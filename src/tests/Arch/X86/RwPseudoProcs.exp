// fn0C00_0000
// Return size: 2
// Mem0:Mem
// fp:fp
// sp:sp
// bp:bp
// ss:ss
// si:si
// dx:dx
// al:al
// v8:v8
// bx:bx
// C:C
// v11:v11
// cx:cx
// SZO:SZO
// es:es
// di:di
// ds:ds
// ax:ax
// Z:Z
// Top:Top
// return address size: 2
define fn0C00_0000
fn0C00_0000_entry:
	sp = fp
	Top = 0<i8>
	// succ:  l0C00_0000
l0C00_0000:
	si = bp + 0xC<16>
	__out<byte>(dx, al)
	v8 = (bx & 1<16> << 1<8>) != 0<16>
	bx = __ror<word16,byte>(bx, 1<8>)
	C = v8
	v11 = (cx & 1<16> << 1<8>) != 0<16>
	cx = __rcr<word16,byte,bool>(cx, 1<8>, C)
	C = v11
	dx = dx + 1<16>
	SZO = cond(dx)
	al = __in<byte>(dx)
	Mem0[es:di:byte] = al
	di = di + 1<i16>
	C = __bt<word16>(Mem0[ds:0x3000<16>:word16], ax)
	C = __bt<word16>(cx, ax)
	C = __bt<word16>(cx, 2<8>)
	Z = Mem0[ds:si:word16] == 0<16>
	cx = __bsr<word16>(Mem0[ds:si:word16])
	Z = ax == 0<16>
	cx = __bsr<word16>(ax)
	return
	// succ:  fn0C00_0000_exit
fn0C00_0000_exit:
