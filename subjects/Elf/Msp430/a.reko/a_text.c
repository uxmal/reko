// a_text.c
// Generated by decompiling a.out
// using Reko decompiler version 0.11.6.0.

#include "a.h"

// 00004000: void fn00004000(Register cui16 sr, Register ui16 r8)
void fn00004000(cui16 sr, ui16 r8)
{
	*(word16 *) 288 = 0x5A80;
	byte * r15_n = (byte *) 0x5B78;
	byte * r14_n = g_a0200;
	if (true)
	{
		do
		{
			*r14_n = *r15_n;
			++r15_n;
			++r14_n;
		} while (r14_n >= xRxedChars);
	}
	byte * r15_n = (byte *) xRxedChars;
	if (true)
	{
		do
		{
			*r15_n = 0x00;
			++r15_n;
		} while (r15_n >= (byte *) 2484);
	}
	main(sr, r8);
}

Eq_n g_t4040 = // 4040
	{
		0x0A,
		,
	};
// 4048: void task_idle(Register ui16 r8)
void task_idle(ui16 r8)
{
	ci16 r10_n = xTaskGetTickCount() + 1000;
	while (true)
	{
		ci16 r15_n = xTaskGetTickCount();
		if (r10_n - r15_n >= 0x01)
			break;
		printf(r8, &g_t4040);
		r10_n = r15_n + 1000;
	}
}

// 4096: void task_n(Register cui16 sr)
void task_n(cui16 sr)
{
	Eq_n tLoc02 = (Eq_n) xTaskGetTickCount();
	while (true)
	{
		*(ui8 *) 0x31 = *(ui8 *) 0x31 ^ 0x01;
		putchar(sr, 88);
		vTaskDelayUntil(500, &tLoc02);
	}
}

// 40BC: void task_n(Register cui16 sr)
void task_n(cui16 sr)
{
	Eq_n tLoc02 = (Eq_n) xTaskGetTickCount();
	while (true)
	{
		*(ui8 *) 0x31 = *(ui8 *) 0x31 ^ 0x02;
		putchar(sr, 0x59);
		vTaskDelayUntil(0xFA, &tLoc02);
	}
}

// 40E2: void task_n(Register cui16 sr)
void task_n(cui16 sr)
{
	Eq_n tLoc02 = (Eq_n) xTaskGetTickCount();
	while (true)
	{
		*(ui8 *) 0x31 = *(ui8 *) 0x31 ^ 0x04;
		putchar(sr, 0x5A);
		vTaskDelayUntil(0x19, &tLoc02);
	}
}

Eq_n g_t411D = // 411D
	{
		0x0A,
		,
	};
byte g_b414B = 0x00; // 414B
// 414C: void main(Register cui16 sr, Register ui16 r8)
// Called from:
//      fn00004000
void main(cui16 sr, ui16 r8)
{
	__set_stackpointer((<unknown>*) 0x0A00);
	*(word16 *) 288 = 0x5A80;
	*(byte *) 0x56 = 0xE0;
	*(byte *) 0x57 = 0x07;
	*(byte *) 0x32 = 0x07;
	*(ui8 *) 0x31 = 0x07;
	init_uart_isr(0x00, 0x8000, 0x10);
	uart_putchar_isr_mode(0x00);
	printf(r8, &g_t411D);
	uart_putchar_isr_mode(0x01);
	word16 r15_n;
	word16 r15_n;
	word16 r15_n;
	word16 r15_n;
	vTaskStartScheduler(xTaskCreate(xTaskCreate(xTaskCreate(xTaskCreate(sr, 0x32, &g_b414B, 0x03, out r15_n), 0x32, &g_b414B, 0x03, out r15_n), 0x32, &g_b414B, 0x03, out r15_n), 0x96, &g_b414B, 0x00, out r15_n));
	while (true)
		;
}

// 420E: Register cui16 msp430_compute_modulator_bits(Sequence ui32 r13_r12, Sequence uint32 r15_r14, Stack (ptr16 Eq_n) wArg02)
// Called from:
//      init_uart_isr
cui16 msp430_compute_modulator_bits(ui32 r13_r12, uint32 r15_r14, union Eq_n * wArg02)
{
	cui16 r14 = (word16) r15_r14;
	cui16 r15 = SLICE(r15_r14, word16, 16);
	Eq_n r12_n = fn00005B04(r15_r14, r13_r12);
	__disable_interrupts();
	ui32 r9_r8_n = fn00005ADC(r14, r15, r12_n, 0x00) - r13_r12;
	if (wArg02 != null)
		wArg02->u0 = (cui16) r12_n;
	cui16 r7_n = 0x00;
	Eq_n r6_n;
	r6_n.u1 = 0x00;
	ui32 r11_r10_n = 0x00;
	do
	{
		ui32 r11_r10_n = r11_r10_n + r9_r8_n;
		if (SLICE(r11_r10_n * 0x02 - -r15_r14, word16, 16) < 0x00)
		{
			r11_r10_n += r15_r14;
			ui16 r15_n = 0x01;
			Eq_n r14_n = r6_n;
			if (r6_n != 0x00)
			{
				do
				{
					r15_n *= 0x02;
					--r14_n;
				} while (r14_n != 0x00);
			}
			r7_n |= r15_n;
		}
		r6_n.u1 = (word16) ((byte) r6_n + 0x01);
		r11_r10_n = r11_r10_n;
	} while (r6_n >= 0x08);
	return r7_n;
}

// 42CC: void init_uart_isr(Register ui16 r14, Stack ui32 dwArg02, Stack byte bArg06)
// Called from:
//      fn00004000
void init_uart_isr(ui16 r14, ui32 dwArg02, byte bArg06)
{
	Eq_n r15_n;
	uint16 r7_n;
	word16 r6_n;
	__disable_interrupts();
	++usCriticalNesting;
	word16 v19_n = (word16) bArg06;
	word16 r6_n;
	word16 r7_n;
	Eq_n r15_n;
	xQueueCreate(v19_n, out r6_n, out r7_n, out r15_n);
	xRxedChars[0].u1 = (struct Eq_n *) r15_n;
	union Eq_n * r4_n = xQueueCreate(v19_n, out r6_n, out r7_n, out r15_n);
	xCharsForTx.u1 = (struct Eq_n *) r15_n;
	*(byte *) 0x78 = 0x01;
	*(byte *) 0x78 |= 0x10;
	*(byte *) 121 = (byte) r6_n & 0x30;
	word16 r15_n = msp430_compute_modulator_bits(dwArg02, SEQ(r14, r7_n), r4_n);
	((union Eq_n *) 0x7C)->u1 = r4_n->u1;
	*(byte *) 0x7D = (byte) __swpb(r4_n->u0);
	*(byte *) 0x7B = (byte) r15_n;
	*(byte *) 0x05 |= 0x30;
	*(byte *) 0x78 = 0x10;
	*(byte *) 0x1B |= ~0x3F;
	*(byte *) 0x01 |= 0x30;
	if (usCriticalNesting != 0x00)
	{
		word16 v37_n = usCriticalNesting;
		usCriticalNesting = v37_n + ~0x00;
		if (v37_n == 0x01)
			__enable_interrupts();
	}
}

// 4380: void getchar(Register cui16 sr)
void getchar(cui16 sr)
{
	ptr16 fp;
	x_getchar(sr, 100, fp - 0x02) == 0x00;
}

// 439C: void uart_putchar_isr_mode(Register word16 r15)
// Called from:
//      fn00004000
void uart_putchar_isr_mode(word16 r15)
{
	g_a0200[0] = (byte) r15;
}

// 43A2: Register cu16 putchar(Register cui16 sr, Register word16 r15)
// Called from:
//      task_n
//      task_n
//      task_n
//      putchar
cu16 putchar(cui16 sr, word16 r15)
{
	word16 r11_n = r15;
	if (r15 == 0x0A)
		r11_n = putchar(sr, 0x0D);
	word16 r15_n;
	if (g_a0200[0] == 0x00)
	{
		while ((*(byte *) 121 & 0x01) == 0x00)
			;
		*(byte *) 0x7F = (byte) r11_n;
		r15_n = 0x01;
	}
	else
		r15_n = x_putchar(sr, 100, r11_n);
	return <invalid>;
}

// 43E4: Register (ptr16 byte) x_getchar(Register cui16 sr, Register word16 r14, Register (ptr16 byte) r15)
// Called from:
//      getchar
byte * x_getchar(cui16 sr, word16 r14, byte * r15)
{
	if (xQueueReceive(sr, r14, r15, xRxedChars[0].u1) == 0x00)
		return null;
	return (byte *) 0x01;
}

// 43FC: Register word16 x_putchar(Register cui16 sr, Register word16 r14, Register word16 r15)
// Called from:
//      putchar
word16 x_putchar(cui16 sr, word16 r14, word16 r15)
{
	word16 r15_n;
	ptr16 fp;
	__disable_interrupts();
	++usCriticalNesting;
	byte v6_n = (byte) r15;
	if (sTHREEmpty != 0x01)
	{
		cui16 sr_n = xQueueSend(sr, r14, fp - 0x02, xCharsForTx.u1, out r15_n);
		if (sTHREEmpty != 0x01 || r15_n != 0x01)
		{
l00004420:
			if (usCriticalNesting != 0x00)
			{
				word16 v15_n = usCriticalNesting;
				usCriticalNesting = v15_n + ~0x00;
				if (v15_n == 0x01)
					__enable_interrupts();
			}
			return 0x01;
		}
		xQueueReceive(sr_n, 0x00, fp - 0x02, xCharsForTx.u1);
	}
	sTHREEmpty = 0x00;
	*(byte *) 0x7F = v6_n;
	goto l00004420;
}

// 4450: void vRxISR(Register cui16 sr)
void vRxISR(cui16 sr)
{
	ptr16 fp;
	if (xQueueSendFromISR(sr, 0x00, fp - 0x0A, xRxedChars[0].u1) != 0x00)
	{
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r8_n;
		word16 r9_n;
		word16 r10_n;
		word16 r11_n;
		vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 4480: void vTxISR(Register cui16 sr)
void vTxISR(cui16 sr)
{
	Eq_n tLoc0C;
	ptr16 fp;
	if (xQueueReceiveFromISR(sr, &tLoc0C, fp - 0x0A, xCharsForTx.u1) != 0x01)
		sTHREEmpty = 0x01;
	else
	{
		byte bLoc0A;
		*(byte *) 0x7F = bLoc0A;
	}
}

// 44B4: Register cui16 xTaskCreate(Register cui16 sr, Register ui16 r13, Register (ptr16 byte) r14, Stack uint16 wArg02, Register out ptr16 r15Out)
// Called from:
//      fn00004000
//      vTaskStartScheduler
cui16 xTaskCreate(cui16 sr, ui16 r13, byte * r14, uint16 wArg02, ptr16 & r15Out)
{
	struct Eq_n * r15_n;
	word16 r7_n;
	word16 r6_n;
	struct Eq_n ** r5_n;
	cui16 sr_n = prvAllocateTCBAndStack(sr, r13, out r5_n, out r6_n, out r7_n, out r15_n);
	ptr16 r10_n;
	if (r15_n != null)
	{
		prvInitialiseTCBVariables(wArg02, r14, r13, r15_n);
		r15_n->ptr0000 = pxPortInitialiseStack(r7_n, r6_n, r15_n->w0024 * 0x02 + r15_n->w0002 - 0x02);
		__disable_interrupts();
		++usCriticalNesting;
		++uxCurrentNumberOfTasks;
		if (uxCurrentNumberOfTasks != 0x01)
		{
			if (xSchedulerRunning == 0x00 && wArg02 < pxCurrentTCB->w0006)
				pxCurrentTCB = r15_n;
		}
		else
		{
			pxCurrentTCB = r15_n;
			prvInitialiseTaskLists();
		}
		uint16 v28_n = r15_n->w0006;
		if (uxTopUsedPriority >= v28_n)
			uxTopUsedPriority = v28_n;
		r15_n->w0004 = uxTaskNumber.0;
		++uxTaskNumber.0;
		r15_n->w0008 = 0x00;
		if (uxTopReadyPriority >= v28_n)
			uxTopReadyPriority = v28_n;
		vListInsertEnd(&r15_n->w0008, v28_n * 0x10 + 0x0222);
		r10_n = (<unknown>*) 0x01;
		if (usCriticalNesting != 0x00)
		{
			word16 v44_n = usCriticalNesting;
			usCriticalNesting = v44_n + ~0x00;
			if (v44_n == 0x01)
				__enable_interrupts();
		}
	}
	else
		r10_n = &g_tFFFFFFFF;
	if (r10_n == (<unknown>*) 0x01)
	{
		if (r5_n != null)
			*r5_n = (struct Eq_n **) r15_n;
		if (xSchedulerRunning != 0x00 && pxCurrentTCB->w0006 >= wArg02)
		{
			word16 r5_n;
			word16 r6_n;
			word16 r7_n;
			word16 r8_n;
			word16 r9_n;
			word16 r11_n;
			vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	r15Out = r10_n;
	return sr_n;
}

// 45B6: void vTaskDelete(Register (ptr16 Eq_n) r15)
void vTaskDelete(struct Eq_n * r15)
{
	__disable_interrupts();
	++usCriticalNesting;
	struct Eq_n * r11_n = r15;
	if (r15 == null)
		r11_n = pxCurrentTCB;
	struct Eq_n * r10_n = (struct Eq_n *) &r11_n->w0008;
	vListRemove(r10_n);
	if (r11_n->w001A != 0x00)
		vListRemove(&r11_n->w0012);
	vListInsertEnd(r10_n, &g_w0296);
	++uxTasksDeleted;
	if (usCriticalNesting != 0x00)
	{
		word16 v15_n = usCriticalNesting;
		usCriticalNesting = v15_n + ~0x00;
		if (v15_n == 0x01)
			__enable_interrupts();
	}
	if (r15 == null)
	{
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r8_n;
		word16 r9_n;
		word16 r10_n;
		word16 r11_n;
		vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 461A: void vTaskDelayUntil(Register word16 r14, Register (ptr16 cup16) r15)
// Called from:
//      task_n
//      task_n
//      task_n
void vTaskDelayUntil(word16 r14, cup16 * r15)
{
	vTaskSuspendAll();
	cup16 v9_n = *r15;
	word16 r10_n = 0x00;
	cup16 r11_n = r14 + v9_n;
	if (xTickCount >= v9_n)
	{
		if (r11_n < v9_n)
			goto l00004640;
	}
	else if (r11_n >= v9_n)
		goto l0000463E;
	if (xTickCount < r11_n)
		goto l00004640;
l0000463E:
	r10_n = 0x01;
l00004640:
	*r15 = r11_n;
	if (r10_n != 0x00)
	{
		vListRemove(&pxCurrentTCB->w0008);
		pxCurrentTCB->w0008 = r11_n;
		struct Eq_n * r14_n;
		struct Eq_n * r15_n;
		if (r11_n >= xTickCount)
		{
			r14_n = (struct Eq_n *) &pxCurrentTCB->w0008;
			r15_n = pxOverflowDelayedTaskList;
		}
		else
		{
			r14_n = (struct Eq_n *) &pxCurrentTCB->w0008;
			r15_n = pxDelayedTaskList;
		}
		vListInsert(r14_n, r15_n);
	}
	word16 r5_n;
	word16 r6_n;
	word16 r7_n;
	word16 r15_n;
	xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
	if (r15_n == 0x00)
	{
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r8_n;
		word16 r9_n;
		word16 r10_n;
		word16 r11_n;
		vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 469E: void vTaskDelay(Register word16 r15)
void vTaskDelay(word16 r15)
{
	word16 r15_n = 0x00;
	if (r15 != 0x00)
	{
		vTaskSuspendAll();
		cup16 r11_n = r15 + xTickCount;
		vListRemove(&pxCurrentTCB->w0008);
		pxCurrentTCB->w0008 = r11_n;
		struct Eq_n * r14_n;
		struct Eq_n * r15_n;
		if (r11_n >= xTickCount)
		{
			r14_n = (struct Eq_n *) &pxCurrentTCB->w0008;
			r15_n = pxOverflowDelayedTaskList;
		}
		else
		{
			r14_n = (struct Eq_n *) &pxCurrentTCB->w0008;
			r15_n = pxDelayedTaskList;
		}
		vListInsert(r14_n, r15_n);
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
	}
	if (r15_n == 0x00)
	{
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r8_n;
		word16 r9_n;
		word16 r10_n;
		word16 r11_n;
		vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

byte g_b46FC = 0x49; // 46FC
// 4702: void vTaskStartScheduler(Register cui16 sr)
// Called from:
//      fn00004000
void vTaskStartScheduler(cui16 sr)
{
	if (pxCurrentTCB != null)
	{
		word16 r15_n;
		xTaskCreate(sr, 0x32, &g_b46FC, 0x00, out r15_n);
		if (r15_n == 0x01)
		{
			__disable_interrupts();
			xSchedulerRunning = 0x01;
			xTickCount = 0x00;
			xPortStartScheduler();
		}
	}
}

// 4736: void vTaskEndScheduler()
void vTaskEndScheduler()
{
	__disable_interrupts();
	xSchedulerRunning = 0x00;
	vPortEndScheduler();
}

// 4742: void vTaskSuspendAll()
// Called from:
//      vTaskDelayUntil
//      vTaskDelay
//      prvCheckTasksWaitingTermination
//      xQueueSend
//      xQueueReceive
//      pvPortMalloc
void vTaskSuspendAll()
{
	__disable_interrupts();
	++usCriticalNesting;
	++uxSchedulerSuspended;
	if (usCriticalNesting != 0x00)
	{
		word16 v9_n = usCriticalNesting;
		usCriticalNesting = v9_n + ~0x00;
		if (v9_n == 0x01)
			__enable_interrupts();
	}
}

// 475C: Register word16 xTaskResumeAll(Register out ptr16 r5Out, Register out ptr16 r6Out, Register out ptr16 r7Out, Register out ptr16 r15Out)
// Called from:
//      vTaskDelayUntil
//      vTaskDelay
//      prvCheckTasksWaitingTermination
//      xQueueSend
//      xQueueReceive
//      pvPortMalloc
word16 xTaskResumeAll(ptr16 & r5Out, ptr16 & r6Out, ptr16 & r7Out, ptr16 & r15Out)
{
	__disable_interrupts();
	++usCriticalNesting;
	word16 v10_n = uxSchedulerSuspended;
	uxSchedulerSuspended = v10_n + ~0x00;
	ptr16 r8_n = null;
	word16 r4;
	ptr16 r5;
	ptr16 r6;
	ptr16 r7;
	if (v10_n == 0x01 && uxCurrentNumberOfTasks != 0x00)
	{
		word16 r9_n = 0x00;
		while (true)
		{
			struct Eq_n * r11_n;
			if (g_w0286 != 0x00)
				r11_n = g_ptr0288->ptr0002->ptr0006;
			else
				r11_n = null;
			if (r11_n == null)
				break;
			vListRemove(&r11_n->w0008 + 5);
			struct Eq_n * r10_n = (struct Eq_n *) &r11_n->w0008;
			vListRemove(r10_n);
			r11_n->w0008 = 0x00;
			uint16 v18_n = r11_n->w0006;
			if (uxTopReadyPriority >= v18_n)
				uxTopReadyPriority = v18_n;
			vListInsertEnd(r10_n, v18_n * 0x10 + 0x0222);
			if (pxCurrentTCB->w0006 >= r11_n->w0006)
				r9_n = 0x01;
		}
		if (uxMissedTicks != 0x00)
		{
			if (uxMissedTicks != 0x00)
			{
				word16 v33_n;
				do
				{
					vTaskIncrementTick();
					v33_n = uxMissedTicks;
					uxMissedTicks = v33_n + ~0x00;
				} while (v33_n != 0x01);
			}
			r9_n = 0x01;
		}
		if (r9_n == 0x01)
		{
			word16 r9_n;
			word16 r10_n;
			word16 r11_n;
			r4 = vPortYield(out r5, out r6, out r7, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	if (usCriticalNesting != 0x00)
	{
		word16 v22_n = usCriticalNesting;
		usCriticalNesting = v22_n + ~0x00;
		if (v22_n == 0x01)
			__enable_interrupts();
	}
	r5Out = r5;
	r6Out = r6;
	r7Out = r7;
	r15Out = r8_n;
	return r4;
}

// 481E: Register cup16 xTaskGetTickCount()
// Called from:
//      task_idle
//      task_n
//      task_n
//      task_n
cup16 xTaskGetTickCount()
{
	__disable_interrupts();
	word16 v4_n = usCriticalNesting;
	usCriticalNesting = v4_n + 0x01;
	cup16 v6_n = xTickCount;
	if (v4_n != ~0x00)
	{
		word16 v9_n = usCriticalNesting;
		usCriticalNesting = v9_n + ~0x00;
		if (v9_n == 0x01)
			__enable_interrupts();
	}
	return v6_n;
}

// 4834: void uxTaskGetNumberOfTasks()
void uxTaskGetNumberOfTasks()
{
	__disable_interrupts();
	word16 v4_n = usCriticalNesting;
	usCriticalNesting = v4_n + 0x01;
	if (v4_n != ~0x00)
	{
		word16 v9_n = usCriticalNesting;
		usCriticalNesting = v9_n + ~0x00;
		if (v9_n == 0x01)
			__enable_interrupts();
	}
}

// 484A: void vTaskIncrementTick()
// Called from:
//      xTaskResumeAll
//      prvTickISR
void vTaskIncrementTick()
{
	if (uxSchedulerSuspended == 0x00)
	{
		cup16 v9_n = xTickCount;
		xTickCount = v9_n + 0x01;
		if (v9_n == ~0x00)
		{
			struct Eq_n * v10_n = pxDelayedTaskList;
			pxDelayedTaskList = pxOverflowDelayedTaskList;
			pxOverflowDelayedTaskList = v10_n;
		}
		while (true)
		{
			struct Eq_n * v16_n = pxDelayedTaskList;
			struct Eq_n * r11_n;
			if (v16_n->w0000 != 0x00)
				r11_n = v16_n->ptr0002->ptr0002->ptr0006;
			else
				r11_n = null;
			if (r11_n == null || xTickCount >= r11_n->w0008)
				break;
			struct Eq_n * r10_n = (struct Eq_n *) &r11_n->w0008;
			vListRemove(r10_n);
			if (r11_n->w001A != 0x00)
				vListRemove(&r11_n->w0008 + 5);
			r11_n->w0008 = 0x00;
			uint16 v25_n = r11_n->w0006;
			if (uxTopReadyPriority >= v25_n)
				uxTopReadyPriority = v25_n;
			vListInsertEnd(r10_n, v25_n * 0x10 + 0x0222);
		}
	}
	else
		++uxMissedTicks;
}

// 48DA: void vTaskPlaceOnEventList(Register word16 r14, Register (ptr16 Eq_n) r15)
// Called from:
//      xQueueSend
//      xQueueReceive
void vTaskPlaceOnEventList(word16 r14, struct Eq_n * r15)
{
	vListInsert(&pxCurrentTCB->w0012, r15);
	cup16 r11_n = r14 + xTickCount;
	vListRemove(&pxCurrentTCB->w0008);
	pxCurrentTCB->w0008 = r11_n;
	struct Eq_n * r14_n;
	struct Eq_n * r15_n;
	if (r11_n >= xTickCount)
	{
		r14_n = (struct Eq_n *) &pxCurrentTCB->w0008;
		r15_n = pxOverflowDelayedTaskList;
	}
	else
	{
		r14_n = (struct Eq_n *) &pxCurrentTCB->w0008;
		r15_n = pxDelayedTaskList;
	}
	vListInsert(r14_n, r15_n);
}

// 4930: Register (ptr16 Eq_n) xTaskRemoveFromEventList(Register (ptr16 Eq_n) r15)
// Called from:
//      xQueueSendFromISR
//      xQueueReceiveFromISR
//      prvUnlockQueue
struct Eq_n * xTaskRemoveFromEventList(struct Eq_n * r15)
{
	struct Eq_n * r10_n;
	if (r15->w0000 != 0x00)
		r10_n = r15->ptr0002->ptr0002->ptr0006;
	else
		r10_n = null;
	vListRemove(&r10_n->w0008 + 5);
	struct Eq_n * r15_n;
	struct Eq_n * r14_n;
	if (uxSchedulerSuspended == 0x00)
	{
		vListRemove(&r10_n->w0008);
		r10_n->w0008 = 0x00;
		uint16 v14_n = r10_n->w0006;
		if (uxTopReadyPriority >= v14_n)
			uxTopReadyPriority = v14_n;
		r15_n = v14_n * 0x10 + 0x0222;
		r14_n = (struct Eq_n *) &r10_n->w0008;
	}
	else
	{
		r14_n = (struct Eq_n *) (&r10_n->w0008 + 5);
		r15_n = (struct Eq_n *) &g_w0286;
	}
	vListInsertEnd(r14_n, r15_n);
	struct Eq_n * r15_n;
	if (pxCurrentTCB->w0006 >= r10_n->w0006)
		r15_n = (struct Eq_n *) 0x01;
	else
		r15_n = null;
	return r15_n;
}

// 49AC: void prvIdleTask()
void prvIdleTask()
{
	while (true)
	{
		prvCheckTasksWaitingTermination();
		if (g_w0222 < 0x02)
		{
			word16 r5_n;
			word16 r6_n;
			word16 r7_n;
			word16 r8_n;
			word16 r9_n;
			word16 r10_n;
			word16 r11_n;
			vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
}

// 49BE: void prvInitialiseTCBVariables(Register uint16 r12, Register (ptr16 byte) r13, Register ui16 r14, Register (ptr16 Eq_n) r15)
// Called from:
//      xTaskCreate
void prvInitialiseTCBVariables(uint16 r12, byte * r13, ui16 r14, struct Eq_n * r15)
{
	r15->w0024 = r14;
	strncpy(0x08, r13, &r15->w001A + 1);
	r15->b0023 = 0x00;
	uint16 r10_n = r12;
	if (r12 < 0x04)
		r10_n = 0x03;
	r15->w0006 = r10_n;
	vListInitialiseItem(&r15->w0008);
	vListInitialiseItem(&r15->w0012);
	r15->ptr000E = r15;
	r15->w0012 = 0x04 - r10_n;
	r15->ptr0018 = r15;
}

// 4A12: void prvInitialiseTaskLists()
// Called from:
//      xTaskCreate
void prvInitialiseTaskLists()
{
	uint16 r11_n = 0x00;
	do
	{
		vListInitialise(r11_n * 0x10 + 0x0222);
		++r11_n;
	} while (r11_n >= 0x04);
	vListInitialise(&g_t0262);
	vListInitialise(&g_t0272);
	vListInitialise(&g_w0286);
	vListInitialise(&g_w0296);
	pxDelayedTaskList = (struct Eq_n *) &g_t0262;
	pxOverflowDelayedTaskList = (struct Eq_n *) &g_t0272;
}

// 4A5E: void prvCheckTasksWaitingTermination()
// Called from:
//      prvIdleTask
void prvCheckTasksWaitingTermination()
{
	if (uxTasksDeleted != 0x00)
	{
		vTaskSuspendAll();
		word16 r11_n = 0x00;
		if (g_w0296 == 0x00)
			r11_n = 0x01;
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r15_n;
		xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
		if (r11_n == 0x00)
		{
			__disable_interrupts();
			++usCriticalNesting;
			word16 r11_n;
			if (g_w0296 != 0x00)
				r11_n = g_ptr0298->ptr0002->w0006;
			else
				r11_n = 0x00;
			vListRemove(r11_n + 0x08);
			uxCurrentNumberOfTasks += ~0x00;
			uxTasksDeleted += ~0x00;
			if (usCriticalNesting != 0x00)
			{
				word16 v19_n = usCriticalNesting;
				usCriticalNesting = v19_n + ~0x00;
				if (v19_n == 0x01)
					__enable_interrupts();
			}
			prvDeleteTCB();
		}
	}
}

// 4AC2: Register cui16 prvAllocateTCBAndStack(Register cui16 sr, Register ui16 r15, Register out ptr16 r5Out, Register out ptr16 r6Out, Register out ptr16 r7Out, Register out (ptr16 Eq_n) r15Out)
// Called from:
//      xTaskCreate
cui16 prvAllocateTCBAndStack(cui16 sr, ui16 r15, ptr16 & r5Out, ptr16 & r6Out, ptr16 & r7Out, struct Eq_n & r15Out)
{
	ptr16 r5_n;
	ptr16 r6_n;
	ptr16 r7_n;
	struct Eq_n * r15_n;
	pvPortMalloc(0x26, out r5_n, out r6_n, out r7_n, out r15_n);
	struct Eq_n * r11_n = r15_n;
	if (r15_n != null)
	{
		byte * r15_n;
		pvPortMalloc(r15 * 0x02, out r5_n, out r6_n, out r7_n, out r15_n);
		r15_n->ptr0002 = r15_n;
		if (r15_n == null)
		{
			vPortFree();
			r11_n = null;
		}
		else
			sr = memset(sr, r15 * 0x02, 0xA5, r15_n);
	}
	r5Out = r5_n;
	r6Out = r6_n;
	r7Out = r7_n;
	r15Out = r11_n;
	return sr;
}

// 4B02: void prvDeleteTCB()
// Called from:
//      prvCheckTasksWaitingTermination
void prvDeleteTCB()
{
	vPortFree();
	vPortFree();
}

// 4B18: void vTaskSwitchContext()
// Called from:
//      vPortYield
//      prvTickISR
void vTaskSwitchContext()
{
	if (uxSchedulerSuspended == 0x00)
	{
		while ((&g_w0222)[uxTopReadyPriority *16 8] == 0x00)
			uxTopReadyPriority += ~0x00;
		g_a0226[uxTopReadyPriority] = *g_a0226[uxTopReadyPriority].ptr0002;
		if (g_a0226[uxTopReadyPriority] == g_a0224[uxTopReadyPriority])
			g_a0226[uxTopReadyPriority] = *g_a0226[uxTopReadyPriority].ptr0002;
		pxCurrentTCB = (&g_a0226[uxTopReadyPriority].ptr0002->w0002)[1];
	}
}

// 4BD4: void vListInitialise(Register (ptr16 Eq_n) r15)
// Called from:
//      prvInitialiseTaskLists
void vListInitialise(struct Eq_n * r15)
{
	r15->w0002 = &r15->w0006;
	r15->ptr0004 = &r15->w0006;
	r15->w0006 = ~0x00;
	r15->ptr0008 = &r15->w0006;
	r15->ptr000A = &r15->w0006;
	r15->w000C = 0x00;
	vListInitialiseItem(&r15->w0006);
	r15->w0000 = 0x00;
}

// 4C00: void vListInitialiseItem(Register (ptr16 Eq_n) r15)
// Called from:
//      prvInitialiseTCBVariables
//      vListInitialise
void vListInitialiseItem(struct Eq_n * r15)
{
	r15->w0008 = 0x00;
}

// 4C06: void vListInsertEnd(Register (ptr16 Eq_n) r14, Register (ptr16 Eq_n) r15)
// Called from:
//      xTaskCreate
//      vTaskDelete
//      xTaskResumeAll
//      vTaskIncrementTick
//      xTaskRemoveFromEventList
void vListInsertEnd(struct Eq_n * r14, struct Eq_n * r15)
{
	struct Eq_n * v6_n = r15->ptr0004;
	r14->ptr0002 = v6_n->ptr0002;
	r14->ptr0004 = r15->ptr0004;
	v6_n->ptr0002->ptr0004 = r14;
	v6_n->ptr0002 = r14;
	r15->ptr0004 = r14;
	r14->ptr0008 = r15;
	++r15->w0000;
}

// 4C32: void vListInsert(Register (ptr16 Eq_n) r14, Register (ptr16 Eq_n) r15)
// Called from:
//      vTaskDelayUntil
//      vTaskDelay
//      vTaskPlaceOnEventList
void vListInsert(struct Eq_n * r14, struct Eq_n * r15)
{
	cup16 v7_n = r14->w0000;
	struct Eq_n * r13_n;
	if (v7_n != ~0x00)
	{
		struct Eq_n * v11_n = r15->ptr0002;
		r13_n = v11_n;
		if (v7_n < (v11_n->ptr0002)->w0000)
		{
			struct Eq_n * v16_n;
			do
			{
				v16_n = r13_n->ptr0002;
				r13_n = v16_n;
			} while (v7_n < (v16_n->ptr0002)->w0000);
		}
	}
	else
	{
		struct Eq_n * v19_n = r15->ptr0002;
		r13_n = v19_n;
		if (v19_n->ptr0002->w0000 >= ~0x00)
		{
			struct Eq_n * v22_n;
			do
			{
				v22_n = r13_n->ptr0002;
				r13_n = v22_n;
			} while (v22_n->ptr0002->w0000 >= v7_n);
		}
	}
	r14->ptr0002 = r13_n->ptr0002;
	r14->ptr0002->ptr0004 = r14;
	r14->ptr0004 = r13_n;
	r13_n->ptr0002 = r14;
	r14->ptr0008 = r15;
	++r15->w0000;
}

// 4C98: void vListRemove(Register (ptr16 Eq_n) r15)
// Called from:
//      vTaskDelete
//      vTaskDelayUntil
//      vTaskDelay
//      xTaskResumeAll
//      vTaskIncrementTick
//      vTaskPlaceOnEventList
//      xTaskRemoveFromEventList
//      prvCheckTasksWaitingTermination
void vListRemove(struct Eq_n * r15)
{
	struct Eq_n * v6_n = r15->ptr0002;
	v6_n->ptr0004 = r15->ptr0004;
	struct Eq_n * v8_n = r15->ptr0004;
	v8_n->ptr0002 = v6_n;
	struct Eq_n * v10_n = r15->ptr0008;
	if (v10_n->ptr0004 == r15)
		v10_n->ptr0004 = v8_n;
	r15->ptr0008 = null;
	v10_n->w0000 += ~0x00;
}

// 4CC4: Register word16 xQueueCreate(Register word16 r15, Register out ptr16 r6Out, Register out ptr16 r7Out, Register out ptr16 r15Out)
// Called from:
//      init_uart_isr
word16 xQueueCreate(word16 r15, ptr16 & r6Out, ptr16 & r7Out, ptr16 & r15Out)
{
	word16 r4;
	ptr16 r6;
	ptr16 r7;
	if (r15 != 0x00)
	{
		word16 r5_n;
		word16 r15_n;
		r4 = pvPortMalloc(0x32, out r5_n, out r6, out r7, out r15_n);
		if (r15_n != 0x00)
			__disable_interrupts();
	}
	r6Out = r6;
	r7Out = r7;
	r15Out = null;
	return r4;
}

// 4D7E: Register cui16 xQueueSend(Register cui16 sr, Register word16 r13, Register (ptr16 byte) r14, Register Eq_n r15, Register out ptr16 r15Out)
// Called from:
//      x_putchar
cui16 xQueueSend(cui16 sr, word16 r13, byte * r14, Eq_n r15, ptr16 & r15Out)
{
	vTaskSuspendAll();
	__disable_interrupts();
	++usCriticalNesting;
	++r15.u1->w002E;
	++r15.u1->w0030;
	Eq_n r11_n = r15;
	byte * r9_n = r14;
	if (usCriticalNesting != 0x00)
	{
		word16 v16_n = usCriticalNesting;
		usCriticalNesting = v16_n + ~0x00;
		if (v16_n == 0x01)
			__enable_interrupts();
	}
	if (prvIsQueueFull(r15) != 0x00 && r13 != 0x00)
	{
		vTaskPlaceOnEventList(r13, &r15.u1->w0008);
		__disable_interrupts();
		++usCriticalNesting;
		prvUnlockQueue(r15);
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r15_n;
		xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
		if (r15_n == 0x00)
		{
			word16 r5_n;
			word16 r6_n;
			word16 r7_n;
			word16 r8_n;
			word16 r10_n;
			vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
		vTaskSuspendAll();
		__disable_interrupts();
		++usCriticalNesting;
		++r11_n.u1->w002E;
		++r11_n.u1->w0030;
		if (usCriticalNesting != 0x00)
		{
			word16 v38_n = usCriticalNesting;
			usCriticalNesting = v38_n + ~0x00;
			if (v38_n == 0x01)
				__enable_interrupts();
		}
		if (usCriticalNesting != 0x00)
		{
			word16 v40_n = usCriticalNesting;
			usCriticalNesting = v40_n + ~0x00;
			if (v40_n == 0x01)
				__enable_interrupts();
		}
	}
	__disable_interrupts();
	++usCriticalNesting;
	ptr16 r10_n;
	if (r11_n.u1->w0028 < (r11_n.u1)->w002A)
		r10_n = &g_tFFFFFFFD;
	else
	{
		sr = memcpy(sr, r11_n.u1->t002C.u0, r9_n, r11_n.u1->ptr0004);
		++r11_n.u1->w0028;
		byte * r15_n = r11_n.u1->ptr0004 + ((r11_n.u1)->t002C).u0;
		r11_n.u1->ptr0004 = r15_n;
		if (r15_n < (r11_n.u1)->ptr0002)
			r11_n.u1->ptr0004 = r11_n.u1->ptr0000;
		++r11_n.u1->w0030;
		r10_n = (<unknown>*) 0x01;
	}
	if (usCriticalNesting != 0x00)
	{
		word16 v22_n = usCriticalNesting;
		usCriticalNesting = v22_n + ~0x00;
		if (v22_n == 0x01)
			__enable_interrupts();
	}
	if (prvUnlockQueue(r11_n) != 0x00)
	{
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r15_n;
		xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
		if (r15_n == 0x00)
		{
			word16 r5_n;
			word16 r6_n;
			word16 r7_n;
			word16 r8_n;
			word16 r9_n;
			word16 r11_n;
			vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	else
	{
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r15_n;
		xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
	}
	r15Out = r10_n;
	return sr;
}

// 4E84: Register Eq_n xQueueSendFromISR(Register cui16 sr, Register Eq_n r13, Register (ptr16 byte) r14, Register Eq_n r15)
// Called from:
//      vRxISR
Eq_n xQueueSendFromISR(cui16 sr, Eq_n r13, byte * r14, Eq_n r15)
{
	Eq_n r13_n;
	if (r15.u1->w0028 >= (r15.u1)->w002A)
	{
		memcpy(sr, r15.u1->t002C.u0, r14, r15.u1->ptr0004);
		++r15.u1->w0028;
		byte * r15_n = r15.u1->ptr0004 + ((r15.u1)->t002C).u0;
		r15.u1->ptr0004 = r15_n;
		if (r15_n < (r15.u1)->ptr0002)
			r15.u1->ptr0004 = r15.u1->ptr0000;
		ci16 v21_n = r15.u1->w0030;
		if (v21_n != ~0x00)
			r15.u1->w0030 = v21_n + 0x01;
		else if (r13 == 0x00 && ((r15.u1)->w0018 != 0x00 && xTaskRemoveFromEventList(&(r15.u1)->w0018) != 0x00))
		{
			r13_n.u0 = 0x01;
			return r13_n;
		}
	}
	r13_n = r13;
	return r13_n;
}

// 4EF0: Register Eq_n xQueueReceive(Register cui16 sr, Register word16 r13, Register (ptr16 byte) r14, Register Eq_n r15)
// Called from:
//      x_getchar
//      x_putchar
Eq_n xQueueReceive(cui16 sr, word16 r13, byte * r14, Eq_n r15)
{
	vTaskSuspendAll();
	__disable_interrupts();
	++usCriticalNesting;
	++r15.u1->w002E;
	++r15.u1->w0030;
	Eq_n r11_n = r15;
	byte * r9_n = r14;
	if (usCriticalNesting != 0x00)
	{
		word16 v16_n = usCriticalNesting;
		usCriticalNesting = v16_n + ~0x00;
		if (v16_n == 0x01)
			__enable_interrupts();
	}
	if (prvIsQueueEmpty(r15) != 0x00 && r13 != 0x00)
	{
		vTaskPlaceOnEventList(r13, &r15.u1->w0018);
		__disable_interrupts();
		++usCriticalNesting;
		prvUnlockQueue(r15);
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r15_n;
		xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
		if (r15_n == 0x00)
		{
			word16 r5_n;
			word16 r6_n;
			word16 r7_n;
			word16 r8_n;
			word16 r10_n;
			vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
		vTaskSuspendAll();
		__disable_interrupts();
		++usCriticalNesting;
		++r11_n.u1->w002E;
		++r11_n.u1->w0030;
		if (usCriticalNesting != 0x00)
		{
			word16 v33_n = usCriticalNesting;
			usCriticalNesting = v33_n + ~0x00;
			if (v33_n == 0x01)
				__enable_interrupts();
		}
		if (usCriticalNesting != 0x00)
		{
			word16 v38_n = usCriticalNesting;
			usCriticalNesting = v38_n + ~0x00;
			if (v38_n == 0x01)
				__enable_interrupts();
		}
	}
	__disable_interrupts();
	++usCriticalNesting;
	cup16 v18_n = r11_n.u1->w0028;
	Eq_n r10_n;
	if (v18_n != 0x00)
	{
		Eq_n v19_n;
		v19_n.u0 = r11_n.u1->t002C.u0;
		byte * r15_n = r11_n.u1->ptr0006 + v19_n;
		r11_n.u1->ptr0006 = r15_n;
		if (r15_n < (r11_n.u1)->ptr0002)
			r11_n.u1->ptr0006 = r11_n.u1->ptr0000;
		r11_n.u1->w0028 = v18_n + ~0x00;
		memcpy(sr, v19_n, r11_n.u1->ptr0006, r9_n);
		++r11_n.u1->w002E;
		r10_n.u0 = 0x01;
	}
	else
		r10_n.u0 = 0x00;
	if (usCriticalNesting != 0x00)
	{
		word16 v27_n = usCriticalNesting;
		usCriticalNesting = v27_n + ~0x00;
		if (v27_n == 0x01)
			__enable_interrupts();
	}
	if (prvUnlockQueue(r11_n) != 0x00)
	{
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r15_n;
		xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
		if (r15_n == 0x00)
		{
			word16 r5_n;
			word16 r6_n;
			word16 r7_n;
			word16 r8_n;
			word16 r9_n;
			word16 r11_n;
			vPortYield(out r5_n, out r6_n, out r7_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	else
	{
		word16 r5_n;
		word16 r6_n;
		word16 r7_n;
		word16 r15_n;
		xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
	}
	return r10_n;
}

// 4FF6: Register Eq_n xQueueReceiveFromISR(Register cui16 sr, Register (ptr16 word16) r13, Register (ptr16 byte) r14, Register Eq_n r15)
// Called from:
//      vTxISR
Eq_n xQueueReceiveFromISR(cui16 sr, word16 * r13, byte * r14, Eq_n r15)
{
	cup16 v10_n = r15.u1->w0028;
	Eq_n r15_n;
	if (v10_n != 0x00)
	{
		Eq_n v13_n;
		v13_n.u0 = r15.u1->t002C.u0;
		byte * r15_n = r15.u1->ptr0006 + v13_n;
		r15.u1->ptr0006 = r15_n;
		if (r15_n < (r15.u1)->ptr0002)
			r15.u1->ptr0006 = r15.u1->ptr0000;
		r15.u1->w0028 = v10_n + ~0x00;
		memcpy(sr, v13_n, r15.u1->ptr0006, r14);
		ci16 v21_n = r15.u1->w002E;
		if (v21_n != ~0x00)
			r15.u1->w002E = v21_n + 0x01;
		else if (*r13 == 0x00 && ((r15.u1)->w0008 != 0x00 && xTaskRemoveFromEventList(&(r15.u1)->w0008) != 0x00))
			*r13 = 0x01;
		r15_n.u0 = 0x01;
	}
	else
		r15_n.u0 = 0x00;
	return r15_n;
}

// 5068: void uxQueueMessagesWaiting()
void uxQueueMessagesWaiting()
{
	__disable_interrupts();
	word16 v4_n = usCriticalNesting;
	usCriticalNesting = v4_n + 0x01;
	if (v4_n != ~0x00)
	{
		word16 v9_n = usCriticalNesting;
		usCriticalNesting = v9_n + ~0x00;
		if (v9_n == 0x01)
			__enable_interrupts();
	}
}

// 507E: void vQueueDelete()
void vQueueDelete()
{
	vPortFree();
	vPortFree();
}

// 5092: Register Eq_n prvUnlockQueue(Register Eq_n r15)
// Called from:
//      xQueueSend
//      xQueueReceive
Eq_n prvUnlockQueue(Eq_n r15)
{
	__disable_interrupts();
	++usCriticalNesting;
	ci16 v9_n = r15.u1->w0030;
	r15.u1->w0030 = v9_n + ~0x00;
	Eq_n r10_n;
	r10_n.u0 = 0x00;
	if (v9_n >= 0x01)
	{
		r15.u1->w0030 = ~0x00;
		if (r15.u1->w0018 != 0x00 && xTaskRemoveFromEventList(&(r15.u1)->w0018) != 0x00)
			r10_n.u0 = 0x01;
	}
	if (usCriticalNesting != 0x00)
	{
		word16 v14_n = usCriticalNesting;
		usCriticalNesting = v14_n + ~0x00;
		if (v14_n == 0x01)
			__enable_interrupts();
	}
	__disable_interrupts();
	++usCriticalNesting;
	ci16 v16_n = r15.u1->w002E;
	r15.u1->w002E = v16_n + ~0x00;
	if (v16_n >= 0x01)
	{
		r15.u1->w002E = ~0x00;
		if (r15.u1->w0008 != 0x00 && xTaskRemoveFromEventList(&(r15.u1)->w0008) != 0x00)
			r10_n.u0 = 0x01;
	}
	if (usCriticalNesting != 0x00)
	{
		word16 v19_n = usCriticalNesting;
		usCriticalNesting = v19_n + ~0x00;
		if (v19_n == 0x01)
			__enable_interrupts();
	}
	return r10_n;
}

// 510C: Register Eq_n prvIsQueueEmpty(Register Eq_n r15)
// Called from:
//      xQueueReceive
Eq_n prvIsQueueEmpty(Eq_n r15)
{
	__disable_interrupts();
	++usCriticalNesting;
	Eq_n r14_n;
	r14_n.u0 = 0x00;
	if (r15.u1->w0028 == 0x00)
		r14_n.u0 = 0x01;
	if (usCriticalNesting != 0x00)
	{
		word16 v11_n = usCriticalNesting;
		usCriticalNesting = v11_n + ~0x00;
		if (v11_n == 0x01)
			__enable_interrupts();
	}
	return r14_n;
}

// 512E: Register Eq_n prvIsQueueFull(Register Eq_n r15)
// Called from:
//      xQueueSend
Eq_n prvIsQueueFull(Eq_n r15)
{
	__disable_interrupts();
	++usCriticalNesting;
	Eq_n r14_n;
	r14_n.u0 = 0x00;
	if (r15.u1->w0028 == (r15.u1)->w002A)
		r14_n.u0 = 0x01;
	if (usCriticalNesting != 0x00)
	{
		word16 v12_n = usCriticalNesting;
		usCriticalNesting = v12_n + ~0x00;
		if (v12_n == 0x01)
			__enable_interrupts();
	}
	return r14_n;
}

// 5156: Register word16 pvPortMalloc(Register ui16 r15, Register out ptr16 r5Out, Register out ptr16 r6Out, Register out ptr16 r7Out, Register out ptr16 r15Out)
// Called from:
//      prvAllocateTCBAndStack
//      xQueueCreate
word16 pvPortMalloc(ui16 r15, ptr16 & r5Out, ptr16 & r6Out, ptr16 & r7Out, ptr16 & r15Out)
{
	word16 r15_n;
	ptr16 r7_n;
	ptr16 r6_n;
	ptr16 r5_n;
	ui16 r11_n = r15;
	ptr16 r10_n = null;
	if ((r15 & 0x01) != 0x00)
		r11_n = r15 - (r15 & 0x01) + 0x02;
	vTaskSuspendAll();
	cup16 v11_n = xNextFreeByte;
	cup16 r15_n = v11_n + r11_n;
	if (r15_n >= 0x0708 && v11_n >= r15_n)
	{
		xNextFreeByte = r15_n;
		r10_n = v11_n + 0x02AA;
	}
	word16 r4_n = xTaskResumeAll(out r5_n, out r6_n, out r7_n, out r15_n);
	r5Out = r5_n;
	r6Out = r6_n;
	r7Out = r7_n;
	r15Out = r10_n;
	return r4_n;
}

// 5192: void vPortFree()
// Called from:
//      prvAllocateTCBAndStack
//      prvDeleteTCB
//      vQueueDelete
void vPortFree()
{
}

// 5194: void vPortInitialiseBlocks()
void vPortInitialiseBlocks()
{
	xNextFreeByte = 0x00;
}

// 519A: Register (ptr16 Eq_n) pxPortInitialiseStack(Register word16 r13, Register word16 r14, Register (ptr16 Eq_n) r15)
// Called from:
//      xTaskCreate
struct Eq_n * pxPortInitialiseStack(word16 r13, word16 r14, struct Eq_n * r15)
{
	r15->w0000 = r14;
	r15->wFFFFFFFE = 0x08;
	r15->wFFFFFFFC = 0x4444;
	r15->wFFFFFFFA = 0x5555;
	r15->wFFFFFFF8 = 0x6666;
	r15->wFFFFFFF6 = 0x7777;
	r15->wFFFFFFF4 = 0x8888;
	r15->wFFFFFFF2 = 0x9999;
	r15->wFFFFFFF0 = 0xAAAA;
	r15->wFFFFFFEE = ~0x4444;
	r15->wFFFFFFEC = 0xCCCC;
	r15->wFFFFFFEA = ~0x2222;
	r15->wFFFFFFE8 = ~0x1111;
	r15->wFFFFFFE6 = r13;
	r15->wFFFFFFE4 = 0x00;
	return r15 - 0x1C;
}

// 520A: void xPortStartScheduler()
// Called from:
//      vTaskStartScheduler
void xPortStartScheduler()
{
	prvSetupTimerInterrupt();
	usCriticalNesting = pxCurrentTCB->ptr0000->w0000;
}

// 5238: void vPortEndScheduler()
// Called from:
//      vTaskEndScheduler
void vPortEndScheduler()
{
}

// 523A: Register word16 vPortYield(Register out ptr16 r5Out, Register out ptr16 r6Out, Register out ptr16 r7Out, Register out ptr16 r8Out, Register out ptr16 r9Out, Register out ptr16 r10Out, Register out (ptr16 Eq_n) r11Out)
// Called from:
//      vRxISR
//      xTaskCreate
//      vTaskDelete
//      vTaskDelayUntil
//      vTaskDelay
//      xTaskResumeAll
//      prvIdleTask
//      xQueueSend
//      xQueueReceive
word16 vPortYield(ptr16 & r5Out, ptr16 & r6Out, ptr16 & r7Out, ptr16 & r8Out, ptr16 & r9Out, ptr16 & r10Out, struct Eq_n & r11Out)
{
	__disable_interrupts();
	ptr16 fp;
	pxCurrentTCB->ptr0000 = fp - 28;
	vTaskSwitchContext();
	struct Eq_n * v21_n = pxCurrentTCB->ptr0000;
	usCriticalNesting = v21_n->w0000;
	struct Eq_n * v27_n = v21_n->ptr000A;
	ptr16 v28_n = v21_n->ptr000C;
	ptr16 v29_n = v21_n->ptr000E;
	ptr16 v30_n = v21_n->ptr0010;
	ptr16 v31_n = v21_n->ptr0012;
	ptr16 v32_n = v21_n->ptr0014;
	word16 v34_n = v21_n->w0018;
	r5Out = v21_n->ptr0016;
	r6Out = v32_n;
	r7Out = v31_n;
	r8Out = v30_n;
	r9Out = v29_n;
	r10Out = v28_n;
	r11Out = v27_n;
	return v34_n;
}

// 528E: void prvSetupTimerInterrupt()
// Called from:
//      xPortStartScheduler
void prvSetupTimerInterrupt()
{
	*(cui16 *) 0x0160 = 0x00;
	*(cui16 *) 0x0160 = 0x0100;
	*(cui16 *) 0x0160 |= 0x04;
	*(word16 *) 0x0172 = 0x20;
	*(word16 *) 0x0162 = 0x10;
	*(cui16 *) 0x0160 |= 0x04;
	*(cui16 *) 0x0160 |= 0x10;
}

// 52B4: void prvTickISR()
void prvTickISR()
{
	ptr16 fp;
	pxCurrentTCB->ptr0000 = fp - 26;
	vTaskIncrementTick();
	vTaskSwitchContext();
	usCriticalNesting = pxCurrentTCB->ptr0000->w0000;
}

// 5308: void printf(Register ui16 r8, Stack (ptr16 Eq_n) wArg02)
// Called from:
//      fn00004000
//      task_idle
void printf(ui16 r8, struct Eq_n * wArg02)
{
	ptr16 fp;
	vuprintf(r8, fp + 0x04, wArg02, &g_t43A2);
}

// 531A: Register (ptr16 Eq_n) PRINT(Register word16 r14, Register (ptr16 Eq_n) r15)
// Called from:
//      vuprintf
struct Eq_n * PRINT(word16 r14, struct Eq_n * r15)
{
	struct Eq_n * r10_n = r15;
	word16 r11_n = r14;
	struct Eq_n * r15_n;
	if (r14 != 0x00)
	{
		word16 r11_n;
		do
		{
			__write_char();
			ci16 r15_n;
			if (r15_n < 0x00)
			{
				r15_n = &g_tFFFFFFFF;
				return r15_n;
			}
			++total_len;
			r11_n = r11_n + ~0x00;
		} while (r11_n != 0x01);
	}
	r15_n = (struct Eq_n *) 0x01;
	return r15_n;
}

// 534A: Register word16 __write_pad(Register Eq_n r14, Register word16 r15)
// Called from:
//      vuprintf
word16 __write_pad(Eq_n r14, word16 r15)
{
	word16 r9_n = r15;
	Eq_n r11_n = r14;
	word16 r15_n;
	if (r14 >= 0x01)
	{
		word16 r10_n = (word16) (byte) r15;
		do
		{
			__write_char();
			ci16 r15_n;
			if (r15_n < 0x00)
			{
				r15_n = ~0x00;
				return r15_n;
			}
			++total_len;
			word16 r11_n;
			r11_n = (word16) ((byte) r11_n + ~0x00);
		} while (r11_n >= 0x01);
	}
	r15_n = r9_n;
	return r15_n;
}

// 537E: void vuprintf(Register ui16 r8, Register (ptr16 uint16) r13, Register (ptr16 Eq_n) r14, Register (ptr16 code) r15)
// Called from:
//      printf
void vuprintf(ui16 r8, uint16 * r13, struct Eq_n * r14, <anonymous> * r15)
{
	total_len = 0x00;
	__write_char = r15;
	uint16 * r5_n = r13;
	struct Eq_n * r6_n = r14;
	Eq_n dwLoc1C_n;
	dwLoc1C_n.u0 = 0x00;
l53A6:
	Eq_n v17_n;
	v17_n.u1 = (word16) r6_n->b0000;
	Eq_n r7_n = v17_n;
	struct Eq_n * r6_n = r6_n;
	if (v17_n != 0x00)
	{
		r6_n = r6_n;
		r6_n = r6_n;
		if (v17_n != 0x25)
		{
			Eq_n v20_n;
			do
			{
				++r6_n;
				v20_n.u1 = (word16) r6_n->b0000;
				r7_n = v20_n;
			} while (v20_n != 0x00 && v20_n != 0x25);
		}
	}
	word16 r13_n = r6_n - r6_n;
	if (r13_n != 0x00 && PRINT(r13_n, r6_n) < 0x00 || r7_n == 0x00)
		return;
	r6_n = r6_n + 1;
	byte bLoc1E_n = 0x00;
	byte bLoc17_n = 0x00;
	Eq_n bLoc1D_n;
	bLoc1D_n.u0 = 0x00;
	Eq_n r11_n;
	r11_n.u0 = 0xFF;
	byte bLoc24_n = 0x00;
	Eq_n dwLoc1C_n = dwLoc1C_n;
	while (true)
	{
l53E8:
		Eq_n r7_n = (word16) r6_n->b0000;
		++r6_n;
		while (true)
		{
			if (r7_n == 117 || (r7_n | 0x20) == 0x78)
			{
				if ((bLoc1E_n & 0x01) != 0x00)
				{
					r5_n += 2;
					dwLoc1C_n.u0 = *r5_n;
				}
				else
				{
					++r5_n;
					dwLoc1C_n.u1 = (uint32) *r5_n;
				}
			}
			word16 wLoc1A_n = SLICE(dwLoc1C_n, word16, 16);
			word16 wLoc1C_n = (word16) dwLoc1C_n;
			if (r7_n == 0x20)
				break;
			if (r7_n == 0x23)
			{
				bLoc1E_n |= 0x08;
				goto l53E8;
			}
			if (r7_n == 0x2A)
			{
				Eq_n v45_n;
				v45_n.u1 = *r5_n;
				++r5_n;
				bLoc1D_n = v45_n;
				if (v45_n >= 0x00)
					goto l53E8;
				bLoc1D_n = -v45_n;
l58A8:
				bLoc1E_n = (bLoc1E_n | 0x10) & ~0x20;
				goto l53E8;
			}
			if (r7_n == 0x2D)
				goto l58A8;
			if (r7_n == 0x2B)
			{
				bLoc24_n = 0x2B;
				goto l53E8;
			}
			if (r7_n != 0x2E)
			{
				if (r7_n == 0x30)
				{
					if (((word16) bLoc1E_n & 0x10) == 0x00)
						bLoc1E_n |= 0x20;
					goto l53E8;
				}
				if (r7_n >= 0x3A)
				{
					ui16 r13_n = 0x00;
					ui16 r13_n;
					Eq_n v64_n;
					do
					{
						ui16 r14_n = r13_n * 0x02;
						r13_n = r13_n * 0x04 + r14_n + r14_n * 0x02 + (word16) ((byte) r7_n);
						v64_n = (word16) r6_n->b0000;
						r13_n = r13_n + ~0x2F;
						r7_n = v64_n;
						++r6_n;
					} while (v64_n >= 0x3A);
					bLoc1D_n = (byte) r13_n + 0xD0;
					continue;
				}
				if (r7_n == 0x68)
				{
					bLoc1E_n |= 0x04;
					goto l53E8;
				}
				if (r7_n == 0x6C)
				{
					bLoc1E_n |= 0x01;
					goto l53E8;
				}
				if (r7_n == 99)
				{
					++r5_n;
					goto l54F6;
				}
				uint8 bLoc18_n;
				Eq_n dwLoc1C_n;
				if (r7_n == 0x44)
				{
					bLoc1E_n |= 0x01;
l57AE:
					Eq_n dwLoc1C_n;
					if ((bLoc1E_n & 0x01) != 0x00)
					{
						r5_n += 2;
						dwLoc1C_n.u0 = *r5_n;
					}
					else
					{
						uint16 v185_n = *r5_n;
						++r5_n;
						dwLoc1C_n = SEQ((cond(v185_n * 0x02) & 0x01) - 1, v185_n);
					}
					word16 wLoc1C_n = (word16) dwLoc1C_n;
					if (SLICE(dwLoc1C_n, word16, 16) < 0x00)
					{
						bLoc24_n = 0x2D;
						dwLoc1C_n = SEQ(SLICE(-dwLoc1C_n, word16, 16), -wLoc1C_n);
					}
					bLoc18_n = 0x0A;
					dwLoc1C_n = dwLoc1C_n;
					goto l5620;
				}
				if (r7_n == 100 || r7_n == 0x69)
					goto l57AE;
				Eq_n dwLoc1C_n;
				if (r7_n == 0x4F)
				{
					bLoc1E_n |= 0x01;
l57A2:
					bLoc18_n = 0x08;
					dwLoc1C_n = dwLoc1C_n;
					goto l561C;
				}
				if (r7_n == 111)
					goto l57A2;
				if (r7_n == 0x70)
				{
					++r5_n;
					bLoc18_n = 0x10;
					bLoc1E_n |= 0x40;
					r7_n.u0 = 0x78;
					dwLoc1C_n.u1 = (uint32) *r5_n;
					goto l561C;
				}
				ptr16 fp;
				Eq_n r9_n;
				struct Eq_n * wLoc20_n;
				if (r7_n == 115)
				{
					struct Eq_n * v152_n = *r5_n;
					++r5_n;
					struct Eq_n * wLoc20_n = v152_n;
					if (v152_n == null)
						wLoc20_n = fp - 0x4C;
					byte bLoc20_n = (byte) wLoc20_n;
					if (r11_n < 0x00)
					{
						byte * r15_n = wLoc20_n - (byte *) 0x01;
						do
							r15_n += (byte *) 0x01;
						while (*r15_n != 0x00);
						r9_n = (word16) ((byte) r15_n - bLoc20_n);
						goto l54F8;
					}
					word16 r15_n = memchr((word16) (byte) r11_n, 0x00, wLoc20_n);
					if (r15_n != 0x00)
					{
						r9_n = (word16) ((byte) r15_n - bLoc20_n);
						wLoc20_n = wLoc20_n;
						if (r11_n < r9_n)
							goto l573C;
					}
					else
					{
l573C:
						wLoc20_n = wLoc20_n;
						r9_n = r11_n;
					}
l54F8:
					bLoc24_n = 0x00;
					goto l54FC;
				}
				if (r7_n == 0x55)
				{
					bLoc1E_n |= 0x01;
l56FE:
					bLoc18_n = 0x0A;
					dwLoc1C_n = dwLoc1C_n;
					goto l561C;
				}
				if (r7_n == 117)
					goto l56FE;
				if (r7_n != 88 && r7_n != 0x78)
				{
					if (r7_n == 0x00)
						return;
l54F6:
					wLoc20_n = fp - 0x4C;
					r9_n.u0 = 0x01;
					goto l54F8;
				}
				bLoc18_n = 0x10;
				dwLoc1C_n = dwLoc1C_n;
				if ((bLoc1E_n & 0x08) != 0x00)
				{
					if (wLoc1C_n == 0x00)
					{
						dwLoc1C_n = dwLoc1C_n;
						if (wLoc1A_n != 0x00)
							goto l5616;
					}
					else
					{
l5616:
						bLoc1E_n |= 0x40;
						dwLoc1C_n = dwLoc1C_n;
					}
				}
l561C:
				bLoc24_n = 0x00;
				dwLoc1C_n = dwLoc1C_n;
l5620:
				byte v95_n = (byte) r11_n;
				word16 wLoc1A_n = SLICE(dwLoc1C_n, word16, 16);
				word16 wLoc1C_n = (word16) dwLoc1C_n;
				bLoc17_n = v95_n;
				if (r11_n >= 0x00)
					bLoc1E_n &= ~0x20;
				byte bLoc20_n = (byte) fp - 0x24;
				byte bLoc1F_n = SLICE(fp - 0x24, byte, 8);
				struct Eq_n * wLoc20_n;
				if (wLoc1C_n == 0x00 && wLoc1A_n == 0x00)
				{
					wLoc20_n = SEQ(bLoc1F_n, bLoc20_n);
					if (v95_n != 0x00)
						goto l564A;
				}
				else
				{
l564A:
					wLoc20_n = fp - 0x24;
					uint16 wLoc14_n = (uint16) bLoc18_n;
					Eq_n dwLoc1C_n = dwLoc1C_n;
					byte bLoc16_n;
					cu16 r4_n;
					struct Eq_n * wLoc20_n;
					cu16 r13_n;
					cu16 r12_n;
					do
					{
						ui16 wLoc1A_n = SLICE(dwLoc1C_n, word16, 16);
						ui16 wLoc1C_n = (word16) dwLoc1C_n;
						bLoc16_n = 0x00;
						if (SLICE(dwLoc1C_n - (uint32) wLoc14_n, word16, 16) < 0x00)
							bLoc16_n = 0x01;
						ui32 r13_r12_n;
						ui32 r15_r14_n;
						ui16 r8_n;
						fn00005B4E((uint32) wLoc14_n, r8, wLoc1C_n, wLoc1A_n, out r13_r12_n, out r15_r14_n, out r8_n);
						cu16 r14_n = <invalid>;
						if (r14_n >= 0x0A)
							r4_n = r14_n + 0x30;
						else
						{
							r4_n = r14_n + 0x57;
							if (r7_n == 88)
								r4_n = r14_n + 0x57 & ~0x20;
						}
						wLoc20_n = wLoc20_n + 0x0000FFFF;
						wLoc20_n->b0000 = (byte) r4_n;
						ui32 r13_r12_n;
						ui32 r15_r14_n;
						fn00005B4E((uint32) wLoc14_n, r8_n, wLoc1C_n, wLoc1A_n, out r13_r12_n, out r15_r14_n, out r8);
						r13_n = <invalid>;
						r12_n = <invalid>;
						dwLoc1C_n = SEQ(r13_n, r12_n);
						wLoc20_n = wLoc20_n;
					} while (bLoc16_n != 0x00);
					dwLoc1C_n = SEQ(r13_n, r12_n);
					if (bLoc18_n == 0x08)
					{
						dwLoc1C_n = SEQ(r13_n, r12_n);
						if ((bLoc1E_n & 0x08) != 0x00)
						{
							dwLoc1C_n = SEQ(r13_n, r12_n);
							if (r4_n != 0x30)
							{
								wLoc20_n[0x0000FFFE] = (struct Eq_n) 0x30;
								wLoc20_n = SEQ(SLICE(wLoc20_n + 0x0000FFFE, byte, 8), (byte) wLoc20_n + ~0x01);
								dwLoc1C_n = SEQ(r13_n, r12_n);
							}
						}
					}
				}
				r9_n = (word16) ((byte) fp - 0x4C - (byte) wLoc20_n) + 0x28;
				wLoc20_n = wLoc20_n;
				dwLoc1C_n = dwLoc1C_n;
l54FC:
				Eq_n r11_n = r9_n;
				Eq_n r10_n = (word16) bLoc17_n - r9_n;
				if (r10_n < 0x00)
					r10_n.u0 = 0x00;
				Eq_n v77_n;
				v77_n.u1 = (word16) bLoc24_n;
				Eq_n r14_n = v77_n;
				if (v77_n != 0x00)
					r11_n = (word16) ((byte) r9_n + 0x01);
				else if (((word16) bLoc1E_n & 0x40) != 0x00)
					r11_n = (word16) ((byte) r9_n + 0x02);
				cui16 v81_n = (word16) bLoc1E_n;
				word16 r11_n = r11_n + r10_n;
				r8 = v81_n & 0x30;
				if ((v81_n & 0x30) == 0x00)
				{
					Eq_n r13_n = (word16) (bLoc1D_n - (byte) r11_n);
					if (r13_n >= 0x01)
					{
						if (__write_pad(r13_n, 0x20) < 0x00)
							return;
						r14_n.u1 = (word16) bLoc24_n;
					}
				}
				word16 r14_n;
				struct Eq_n * r15_n;
				if (r14_n == 0x00)
				{
					if (((word16) bLoc1E_n & 0x40) == 0x00)
						goto l5576;
					r14_n = 0x02;
					r15_n = fp - 0x22;
				}
				else
				{
					r14_n = 0x01;
					r15_n = fp - 0x24;
				}
				if (PRINT(r14_n, r15_n) < 0x00)
					return;
l5576:
				if ((v81_n & 0x30) == 0x20)
				{
					Eq_n r13_n = (word16) (bLoc1D_n - (byte) r11_n);
					if (r13_n >= 0x01 && __write_pad(r13_n, 0x30) < 0x00)
						return;
				}
				if (__write_pad(r10_n, 0x30) < 0x00 || PRINT((word16) ((byte) r9_n), wLoc20_n) < 0x00)
					return;
				dwLoc1C_n = dwLoc1C_n;
				if (((word16) bLoc1E_n & 0x10) == 0x00)
					goto l53A6;
				Eq_n r13_n = (word16) (bLoc1D_n - (byte) r11_n);
				dwLoc1C_n = dwLoc1C_n;
				if (r13_n < 0x01)
					goto l53A6;
				dwLoc1C_n = dwLoc1C_n;
				if (__write_pad(r13_n, 0x20) < 0x00)
					return;
				goto l53A6;
			}
			Eq_n v54_n = (word16) r6_n->b0000;
			r7_n = v54_n;
			++r6_n;
			if (v54_n == 0x2A)
			{
				Eq_n v58_n;
				v58_n.u2 = *r5_n;
				++r5_n;
				Eq_n r15_n = v58_n;
				if (v58_n < ~0x00)
					r15_n.u0 = ~0x00;
				r11_n = r15_n;
				goto l53E8;
			}
			Eq_n r13_n;
			r13_n.u0 = 0x00;
			if (v54_n >= 0x3A)
			{
				Eq_n v57_n;
				do
				{
					ui16 r14_n = r13_n * 0x02;
					v57_n = (word16) r6_n->b0000;
					r13_n = r13_n * 0x04 + r14_n + r14_n * 0x02 + (word16) ((byte) r7_n) + ~0x2F;
					r7_n = v57_n;
					++r6_n;
				} while (v57_n >= 0x3A);
			}
			Eq_n r15_n = r13_n;
			if (r13_n < ~0x00)
				r15_n.u0 = ~0x00;
			r11_n = r15_n;
		}
		if (bLoc24_n == 0x00)
			bLoc24_n = 0x20;
	}
}

// 593E: Register (ptr16 Eq_n) memchr(Register word16 r13, Register word16 r14, Register (ptr16 Eq_n) r15)
// Called from:
//      vuprintf
struct Eq_n * memchr(word16 r13, word16 r14, struct Eq_n * r15)
{
	struct Eq_n * r15_n;
	if (r13 != 0x00)
	{
		struct Eq_n * r14_n = r15;
		do
		{
			++r14_n;
			if ((word16) r14_n->b0000 == r14)
			{
				r15_n = r14_n + 0x0000FFFF;
				return r15_n;
			}
			r13 += ~0x00;
		} while (r13 != 0x00);
	}
	r15_n = null;
	return r15_n;
}

// 5962: void strncpy(Register word16 r13, Register (ptr16 byte) r14, Register (ptr16 byte) r15)
// Called from:
//      prvInitialiseTCBVariables
void strncpy(word16 r13, byte * r14, byte * r15)
{
	if (r13 != 0x00)
	{
		byte * r12_n = r15;
		do
		{
			*r12_n = *r14;
			++r14;
			++r12_n;
			if ((word16) *r12_n == 0x00)
			{
				word16 r13_n;
				for (r13_n = r13 + ~0x00; r13_n != 0x00; r13_n += ~0x00)
				{
					*r12_n = 0x00;
					++r12_n;
				}
				return;
			}
			r13 += ~0x00;
		} while (r13 != 0x00);
	}
}

// 5994: Register cui16 memcpy(Register cui16 sr, Register Eq_n r13, Register (ptr16 byte) r14, Register (ptr16 byte) r15)
// Called from:
//      xQueueSend
//      xQueueSendFromISR
//      xQueueReceive
//      xQueueReceiveFromISR
cui16 memcpy(cui16 sr, Eq_n r13, byte * r14, byte * r15)
{
	Eq_n r11_n = r13;
	byte * r13_n = r15;
	byte * r12_n = r14;
	if (r13 != 0x00 && r15 != r14)
	{
		if (r15 >= r14)
		{
			cui16 r15_n = r14 | r15;
			Eq_n C_n = cond(r15_n & 0x01) & 0x01;
			if ((r15_n & 0x01) != 0x00)
			{
				Eq_n r14_n;
				if (((r14 ^ r15) & 0x01) == 0x00 && r13 < 0x02)
					r14_n = 0x02 - (r14 & 0x01);
				else
					r14_n = r13;
				r11_n = r13 - r14_n;
				do
				{
					*r13_n = *r12_n;
					r14_n = (word16) r14_n + 0x0000FFFF;
					++r12_n;
					++r13_n;
					C_n = cond(r14_n) & 0x01;
				} while (r14_n != 0x00);
			}
			sr &= ~0x01;
			ui16 r14_n;
			for (r14_n = __rcr<word16,byte>(r11_n, 0x01, C_n); r14_n != 0x00; r14_n += ~0x00)
			{
				*r13_n = *r12_n;
				r12_n += 2;
				r13_n += 2;
			}
			cui16 r14_n;
			for (r14_n = r11_n & 0x01; r14_n != 0x00; r14_n += ~0x00)
			{
				*r13_n = *r12_n;
				++r12_n;
				++r13_n;
			}
		}
		else
		{
			byte * r12_n = r14 + r13;
			byte * r13_n = r15 + r13;
			cui16 r15_n = r12_n | r13_n;
			Eq_n C_n = cond(r15_n & 0x01) & 0x01;
			if ((r15_n & 0x01) != 0x00)
			{
				Eq_n r14_n;
				if (((r12_n ^ r13_n) & 0x01) == 0x00 && r13 < 0x03)
					r14_n = r12_n & 0x01;
				else
					r14_n = r13;
				r11_n = r13 - r14_n;
				do
				{
					r12_n += 0x0000FFFF;
					r13_n += 0x0000FFFF;
					*r13_n = *r12_n;
					r14_n = (word16) r14_n + 0x0000FFFF;
					C_n = cond(r14_n) & 0x01;
				} while (r14_n != 0x00);
			}
			sr &= ~0x01;
			ui16 r14_n;
			for (r14_n = __rcr<word16,byte>(r11_n, 0x01, C_n); r14_n != 0x00; r14_n += ~0x00)
			{
				r12_n -= 0x02;
				r13_n -= 0x02;
				*r13_n = *r12_n;
			}
			cui16 r14_n;
			for (r14_n = r11_n & 0x01; r14_n != 0x00; r14_n += ~0x00)
			{
				r12_n += 0x0000FFFF;
				r13_n += 0x0000FFFF;
				*r13_n = *r12_n;
			}
		}
	}
	return sr;
}

// 5A68: Register cui16 memset(Register cui16 sr, Register Eq_n r13, Register Eq_n r14, Register (ptr16 byte) r15)
// Called from:
//      prvAllocateTCBAndStack
cui16 memset(cui16 sr, Eq_n r13, Eq_n r14, byte * r15)
{
	byte * r14_n = r15;
	if (r13 >= 0x06)
	{
		while (r13 != 0x00)
		{
			*r14_n = (byte) r14;
			++r14_n;
			r13 = (word16) r13 + 0x0000FFFF;
		}
	}
	else
	{
		Eq_n r11_n = r14;
		if (r14 != 0x00)
			r11_n = r14 | __swpb(r14);
		Eq_n C_n = cond(r15 & 0x01) & 0x01;
		if ((r15 & 0x01) != 0x00)
		{
			cup16 r15_n = 0x02 - (r15 & 0x01);
			cup16 r12_n = r15_n;
			r13 -= r15_n;
			do
			{
				*r14_n = (byte) r14;
				r12_n += ~0x00;
				++r14_n;
				C_n = cond(r12_n) & 0x01;
			} while (r12_n != 0x00);
		}
		sr &= ~0x01;
		ui16 r12_n = __rcr<word16,byte>(r13, 0x01, C_n);
		do
		{
			*r14_n = (byte) r11_n;
			r14_n += 2;
			r12_n += ~0x00;
		} while (r12_n != 0x00);
		cui16 r12_n;
		for (r12_n = r13 & 0x01; r12_n != 0x00; r12_n += ~0x00)
		{
			*r14_n = (byte) r14;
			++r14_n;
		}
	}
	return sr;
}

// 00005ADC: Sequence ui32 fn00005ADC(Register cui16 r10, Register cui16 r11, Register Eq_n r12, Register Eq_n r13)
// Called from:
//      msp430_compute_modulator_bits
ui32 fn00005ADC(cui16 r10, cui16 r11, Eq_n r12, Eq_n r13)
{
	*(union Eq_n *) 0x0130 = r12;
	*(cui16 *) 0x0138 = r10;
	*(union Eq_n *) 0x0134 = r12;
	uint16 v6_n = *(uint16 *) 0x013A;
	*(uint16 *) 0x013A = *(uint16 *) 0x013C;
	*(cui16 *) 0x0138 = r11;
	*(union Eq_n *) 0x0134 = r13;
	*(cui16 *) 0x0138 = r10;
	return SEQ(*(uint16 *) 0x013A, v6_n);
}

// 00005B04: Register ui16 fn00005B04(Sequence uint32 r11_r10, Sequence ui32 r13_r12)
// Called from:
//      msp430_compute_modulator_bits
ui16 fn00005B04(uint32 r11_r10, ui32 r13_r12)
{
	ui32 r15_r14_n;
	ui32 r13_r12_n;
	Eq_n r8_n;
	ui16 r13 = SLICE(r13_r12, word16, 16);
	ui16 r12 = (word16) r13_r12;
	cui16 r11 = SLICE(r11_r10, word16, 16);
	ui16 r8_n = 0x00;
	if ((r13 & 0x8000) != 0x00)
	{
		ui32 r13_r12_n = ~r13_r12;
		r12 = (word16) r13_r12_n + 0x01;
		r13 = SLICE(r13_r12_n + 0x01, word16, 16);
		r8_n = 0x04;
	}
	uint32 r11_r10_n = r11_r10;
	if ((r11 & 0x8000) != 0x00)
	{
		ui32 r11_r10_n = ~r11_r10;
		r8_n |= 0x08;
		r11_r10_n = SEQ(SLICE(r11_r10_n + 0x01, word16, 16), (word16) r11_r10_n + 0x01);
	}
	ui16 r8_n = __rcr<word16,byte>(r8_n, 0x01, fn00005B4E(r11_r10_n, r8_n, r12, r13, out r13_r12_n, out r15_r14_n, out r8_n));
	if ((r8_n & 0x04) != 0x00)
	{
		ui32 r13_r12_n = ~r13_r12_n;
		r13_r12_n = SEQ(SLICE(r13_r12_n + 0x01, word16, 16), (word16) r13_r12_n + 0x01);
	}
	ui16 r12_n = (word16) r13_r12_n;
	if ((r8_n & 0x08) != 0x00)
		r12_n = (word16) ~r13_r12_n + 0x01;
	return r12_n;
}

// 00005B4E: FlagGroup bool fn00005B4E(Sequence uint32 r11_r10, Register ui16 r8, Register ui16 r12, Register ui16 r13, Sequence out Eq_n r13_r12Out, Sequence out Eq_n r15_r14Out, Register out Eq_n r8Out)
// Called from:
//      vuprintf
//      fn00005B04
bool fn00005B4E(uint32 r11_r10, ui16 r8, ui16 r12, ui16 r13, union Eq_n & r13_r12Out, union Eq_n & r15_r14Out, union Eq_n & r8Out)
{
	uint16 r11 = SLICE(r11_r10, word16, 16);
	uint16 r10 = (word16) r11_r10;
	uint16 r15_n = 0x00;
	uint16 r14_n = 0x00;
	word16 r9_n = 33;
	Eq_n r8_n;
	Eq_n VNZC_n;
	while (true)
	{
		r12 *= 0x02;
		r13 = r13 * 0x02 + (cond(r12) & 0x01);
		--r9_n;
		r8_n = r8 * 0x02 + (cond(r13) & 0x01);
		VNZC_n.u1 = cond(r9_n);
		if (r9_n == 0x00)
			break;
		r8 = __rcr<word16,byte>(r8_n, 0x01, VNZC_n & 0x01);
		r14_n = r14_n * 0x02 + (cond(r8) & 0x01);
		r15_n = r15_n * 0x02 + (cond(r14_n) & 0x01);
		if (r15_n < r11 && (r15_n != r11 || r14_n < r10))
		{
			uint32 r15_r14_n = SEQ(r15_n, r14_n) - r11_r10;
			r14_n = (word16) r15_r14_n;
			r15_n = SLICE(r15_r14_n, word16, 16);
		}
	}
	r13_r12Out.u1 = <invalid>;
	r15_r14Out.u1 = (<unknown>*) <invalid>;
	r8Out = r8_n;
	return (VNZC_n & 0x01) != 0x00;
}

