// a_text.c
// Generated by decompiling a.out
// using Reko decompiler version 0.11.1.0.

#include "a.h"

// 00004000: void fn00004000(Register ui20 sr, Register Eq_n r8)
void fn00004000(ui20 sr, Eq_n r8)
{
	*(word16 *) 288 = 0x5A80;
	byte * r15_n = (byte *) 0x5B78;
	byte * r14_n = g_a0200;
	byte * r13_n = xRxedChars;
	if (r13_n != r14_n)
	{
		do
		{
			*r14_n = *r15_n;
			++r15_n;
			++r14_n;
		} while (r14_n >= r13_n);
	}
	byte * r15_n = xRxedChars;
	byte * r13_n = (byte *) 2484;
	if (r13_n != r15_n)
	{
		do
		{
			*r15_n = 0x00;
			++r15_n;
		} while (r15_n >= r13_n);
	}
	main(sr, r8);
}

// 4048: void task_idle(Register ui20 sr, Register Eq_n r8)
void task_idle(ui20 sr, Eq_n r8)
{
	word20 r15_n;
	ui20 sr_n = xTaskGetTickCount(sr, out r15_n);
	Eq_n r10_n = r15_n + 1000;
	while (true)
	{
		Eq_n r15_n;
		sr_n = xTaskGetTickCount(sr_n, out r15_n);
		if (r10_n - r15_n >= 0x01)
			break;
		printf(r8);
		r10_n.u1 = (word20) r15_n + 1000;
	}
}

// 4096: void task_n(Register ui20 sr)
void task_n(ui20 sr)
{
	word16 fp;
	Eq_n tLoc02;
	Eq_n r15_n;
	ui20 sr_n = xTaskGetTickCount(sr, out r15_n);
	tLoc02 = r15_n;
	while (true)
	{
		*(union Eq_n *) 0x31 = *(union Eq_n *) 0x31 ^ 0x01;
		word20 r11_n;
		sr_n = vTaskDelayUntil(putchar(sr_n, 88, out r11_n), 500, fp - 0x02);
	}
}

// 40BC: void task_n(Register ui20 sr)
void task_n(ui20 sr)
{
	word16 fp;
	Eq_n tLoc02;
	Eq_n r15_n;
	ui20 sr_n = xTaskGetTickCount(sr, out r15_n);
	tLoc02 = r15_n;
	while (true)
	{
		*(union Eq_n *) 0x31 = *(union Eq_n *) 0x31 ^ 0x02;
		word20 r11_n;
		sr_n = vTaskDelayUntil(putchar(sr_n, 0x59, out r11_n), 0xFA, fp - 0x02);
	}
}

// 40E2: void task_n(Register ui20 sr)
void task_n(ui20 sr)
{
	word16 fp;
	Eq_n tLoc02;
	Eq_n r15_n;
	ui20 sr_n = xTaskGetTickCount(sr, out r15_n);
	tLoc02 = r15_n;
	while (true)
	{
		*(union Eq_n *) 0x31 = *(union Eq_n *) 0x31 ^ 0x04;
		word20 r11_n;
		sr_n = vTaskDelayUntil(putchar(sr_n, 0x5A, out r11_n), 0x19, fp - 0x02);
	}
}

// 414C: void main(Register ui20 sr, Register Eq_n r8)
// Called from:
//      fn00004000
void main(ui20 sr, Eq_n r8)
{
	__set_stackpointer(0x0A00);
	*(word16 *) 288 = 0x5A80;
	((union Eq_n *) 0x56)->u1 = ~0x1F;
	((union Eq_n *) 0x57)->u1 = 0x07;
	((union Eq_n *) 0x32)->u1 = 0x07;
	((union Eq_n *) 0x31)->u1 = 0x07;
	ui20 sr_n = init_uart_isr(9600, sr, 0x10);
	uart_putchar_isr_mode(0x00);
	printf(r8);
	uart_putchar_isr_mode(0x01);
	word20 r15_n;
	word20 r15_n;
	word20 r15_n;
	word20 r15_n;
	vTaskStartScheduler(xTaskCreate(xTaskCreate(xTaskCreate(xTaskCreate(sr_n, 0x00, 0x32, 0x414B, 0x4096, out r15_n), 0x00, 0x32, 0x414B, 0x40BC, out r15_n), 0x00, 0x32, 0x414B, 16610, out r15_n), 0x00, 0x96, 0x414B, 0x4048, out r15_n));
	while (true)
		;
}

// 420E: Register Eq_n msp430_compute_modulator_bits(Sequence ui40 r13_r12, Sequence Eq_n r15_r14)
// Called from:
//      init_uart_isr
Eq_n msp430_compute_modulator_bits(ui40 r13_r12, Eq_n r15_r14)
{
	struct Eq_n * fp;
	Eq_n r14 = (word20) r15_r14;
	Eq_n r15 = SLICE(r15_r14, word20, 20);
	union Eq_n * v16_n = fp->ptr0002;
	Eq_n r12_n = fn00005B04(r15_r14, r13_r12);
	Eq_n r9_r8_n = fn00005ADC(r14, r15, r12_n, 0x00) - r13_r12;
	if (v16_n != null)
		*v16_n = (union Eq_n *) r12_n;
	Eq_n r7_n = 0x00;
	Eq_n r6_n = 0x00;
	Eq_n r11_r10_n = 0x00;
	do
	{
		ui40 r11_r10_n = r11_r10_n + r9_r8_n;
		if (SLICE(r11_r10_n * 0x02 - ((r15_r14 ^ ~0x00) + 0x01), word20, 20) < 0x00)
		{
			r11_r10_n += r15_r14;
			Eq_n r15_n = 0x01;
			Eq_n r14_n = r6_n;
			if (r6_n != 0x00)
			{
				do
				{
					r15_n *= 0x02;
					--r14_n;
				} while (r14_n != 0x00);
			}
			r7_n |= r15_n;
		}
		r6_n = (word24) r6_n + 1;
		r11_r10_n = r11_r10_n;
	} while (r6_n >= 0x08);
	return r7_n;
}

// 42CC: Register ui20 init_uart_isr(Sequence Eq_n r14_r13, Register ui20 sr, Register Eq_n r15)
// Called from:
//      fn00004000
ui20 init_uart_isr(Eq_n r14_r13, ui20 sr, Eq_n r15)
{
	Eq_n wLoc10;
	struct Eq_n * fp;
	byte bLoc10 = (byte) wLoc10;
	uint16 v15_n = fp->w0002;
	ui16 v16_n = fp->w0004;
	Eq_n v17_n = fp->t0006;
	++usCriticalNesting;
	Eq_n r15_n;
	ui20 sr_n = xQueueCreate(sr & ~0x08, v17_n, out r15_n);
	xRxedChars[0] = r15_n;
	Eq_n r15_n;
	ui20 sr_n = xQueueCreate(sr_n, v17_n, out r15_n);
	xCharsForTx = r15_n;
	((union Eq_n *) 0x78)->u0 = 0x01;
	*(union Eq_n *) 0x78 |= 0x10;
	*(union Eq_n *) 121 = r15 & 0x30;
	Eq_n r15_n = msp430_compute_modulator_bits(SEQ(v16_n, v15_n), r14_r13);
	*(byte *) 0x7C = bLoc10;
	*(union Eq_n *) 0x7D = __swpb(wLoc10) & ~0x00;
	*(union Eq_n *) 0x7B = r15_n;
	*(byte *) 0x05 |= 0x30;
	((union Eq_n *) 0x78)->u1 = 0x10;
	*(byte *) 0x1B |= ~0x3F;
	*(byte *) 0x01 |= 0x30;
	if (usCriticalNesting != 0x00)
	{
		word16 v30_n = usCriticalNesting;
		usCriticalNesting = v30_n + ~0x00;
		if (v30_n == ~0x00)
			sr_n |= 0x08;
	}
	return sr_n;
}

// 4380: void getchar(Register ui20 sr)
void getchar(ui20 sr)
{
	word16 fp;
	x_getchar(sr, 100, fp - 0x02) == 0x00;
}

// 439C: void uart_putchar_isr_mode(Register Eq_n r15)
// Called from:
//      fn00004000
void uart_putchar_isr_mode(Eq_n r15)
{
	g_a0200[0] = r15;
}

// 43A2: Register ui20 putchar(Register ui20 sr, Register Eq_n r15, Register out Eq_n r11Out)
// Called from:
//      task_n
//      task_n
//      task_n
//      putchar
ui20 putchar(ui20 sr, Eq_n r15, union Eq_n & r11Out)
{
	Eq_n r11_n = r15;
	if (r15 == 0x0A)
		putchar(sr, 0x0D, out r11_n);
	Eq_n r15_n;
	if (g_a0200[0] == 0x00)
	{
		do
			;
		while ((*(union Eq_n *) 121 & 0x01) == 0x00);
		*(union Eq_n *) 0x7F = r11_n;
		r15_n.u1 = 0x01;
	}
	else
		sr = x_putchar(sr, 100, r11_n, out r15_n);
	r11Out.u1 = <invalid>;
	return sr;
}

// 43E4: Register Eq_n x_getchar(Register ui20 sr, Register Eq_n r14, Register Eq_n r15)
// Called from:
//      getchar
Eq_n x_getchar(ui20 sr, Eq_n r14, Eq_n r15)
{
	word20 r15_n;
	xQueueReceive(sr, r14, r15, xRxedChars[0], out r15_n);
	if (r15_n == 0x00)
		return 0x00;
	return 0x01;
}

// 43FC: Register ui20 x_putchar(Register ui20 sr, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      putchar
ui20 x_putchar(ui20 sr, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	word16 fp;
	++usCriticalNesting;
	ui20 sr_n = sr & ~0x08;
	if (sTHREEmpty != 0x01)
	{
		Eq_n r15_n;
		sr_n = xQueueSend(sr & ~0x08, r14, fp - 0x02, xCharsForTx, out r15_n);
		if (sTHREEmpty != 0x01 || r15_n != 0x01)
		{
l00004420:
			if (usCriticalNesting != 0x00)
			{
				word16 v14_n = usCriticalNesting;
				usCriticalNesting = v14_n + ~0x00;
				if (v14_n == ~0x00)
					sr_n |= 0x08;
			}
			r15Out.u0 = 0x01;
			return sr_n;
		}
		word20 r15_n;
		sr_n = xQueueReceive(sr_n, 0x00, fp - 0x02, xCharsForTx, out r15_n);
	}
	sTHREEmpty = 0x00;
	*(union Eq_n *) 0x7F = r15;
	goto l00004420;
}

// 4450: void vRxISR(Register ui20 sr)
void vRxISR(ui20 sr)
{
	word16 fp;
	word20 r15_n;
	ui20 sr_n = xQueueSendFromISR(sr, 0x00, fp - 0x0A, xRxedChars[0], out r15_n);
	if (r15_n != 0x00)
	{
		word20 r11_n;
		word20 r10_n;
		word20 r9_n;
		word20 r8_n;
		vPortYield(sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 4480: void vTxISR(Register ui20 sr)
void vTxISR(ui20 sr)
{
	word16 fp;
	Eq_n bLoc0A;
	if (xQueueReceiveFromISR(sr, fp - 0x0C, fp - 0x0A, xCharsForTx) != 0x01)
		sTHREEmpty = 0x01;
	else
		*(union Eq_n *) 0x7F = bLoc0A;
}

// 44B4: Register ui20 xTaskCreate(Register ui20 sr, Register Eq_n r12, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      fn00004000
//      vTaskStartScheduler
ui20 xTaskCreate(ui20 sr, Eq_n r12, Eq_n r13, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	struct Eq_n * fp;
	Eq_n r10_n;
	Eq_n v15_n = fp->t0002;
	struct Eq_n ** v16_n = fp->ptr0004;
	struct Eq_n * r15_n;
	ui20 sr_n = prvAllocateTCBAndStack(sr, r13, out r15_n);
	if (r15_n != null)
	{
		prvInitialiseTCBVariables(v15_n, r14, r13, r15_n);
		r15_n->ptr0000 = (struct Eq_n *) pxPortInitialiseStack(r12, r15, *((char *) &r15_n->ptr0000 + 2) + ((&r15_n->w001A)[5] *20 0x02) /20 28 - 0x02);
		++usCriticalNesting;
		++uxCurrentNumberOfTasks;
		sr_n &= ~0x08;
		if (uxCurrentNumberOfTasks != 0x01)
		{
			if (xSchedulerRunning == 0x00 && v15_n < pxCurrentTCB->t0006)
				pxCurrentTCB = r15_n;
		}
		else
		{
			pxCurrentTCB = r15_n;
			prvInitialiseTaskLists();
		}
		Eq_n v28_n = r15_n->t0006;
		if (uxTopUsedPriority >= v28_n)
			uxTopUsedPriority = v28_n;
		*((char *) &r15_n->ptr0000 + 4) = (struct Eq_n *) uxTaskNumber.0;
		++uxTaskNumber.0;
		r15_n->t0008 = 0x00;
		if (uxTopReadyPriority >= v28_n)
			uxTopReadyPriority = v28_n;
		vListInsertEnd(&r15_n->t0008, v28_n *20 0x10 + 0x0222);
		r10_n.u0 = 0x01;
		if (usCriticalNesting != 0x00)
		{
			word16 v44_n = usCriticalNesting;
			usCriticalNesting = v44_n + ~0x00;
			if (v44_n == ~0x00)
				sr_n = sr_n & ~0x08 | 0x08;
		}
	}
	else
		r10_n.u0 = ~0x00;
	if (r10_n == 0x01)
	{
		if (v16_n != null)
			*v16_n = (struct Eq_n **) r15_n;
		if (xSchedulerRunning != 0x00 && pxCurrentTCB->t0006 >= v15_n)
		{
			word20 r9_n;
			word20 r11_n;
			word20 r8_n;
			sr_n = vPortYield(sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	r15Out = r10_n;
	return sr_n;
}

// 45B6: void vTaskDelete(Register ui20 sr, Register (ptr20 Eq_n) r15)
void vTaskDelete(ui20 sr, struct Eq_n * r15)
{
	++usCriticalNesting;
	ui20 sr_n = sr & ~0x08;
	struct Eq_n * r11_n = r15;
	if (r15 == null)
		r11_n = pxCurrentTCB;
	Eq_n r10_n = &r11_n->t0008;
	vListRemove(r10_n);
	if (r11_n->w001A != 0x00)
		vListRemove((char *) &r11_n->t0008 + 0x0A);
	vListInsertEnd(r10_n, 662);
	++uxTasksDeleted;
	if (usCriticalNesting != 0x00)
	{
		word16 v15_n = usCriticalNesting;
		usCriticalNesting = v15_n + ~0x00;
		if (v15_n == ~0x00)
			sr_n = sr & ~0x08 | 0x08;
	}
	if (r15 == null)
	{
		word20 r9_n;
		word20 r10_n;
		word20 r11_n;
		word20 r8_n;
		vPortYield(sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 461A: Register ui20 vTaskDelayUntil(Register ui20 sr, Register Eq_n r14, Register Eq_n r15)
// Called from:
//      task_n
//      task_n
//      task_n
ui20 vTaskDelayUntil(ui20 sr, Eq_n r14, Eq_n r15)
{
	ui20 sr_n = vTaskSuspendAll(sr);
	Eq_n v8_n = *r15;
	Eq_n r10_n = 0x00;
	word20 r11_n = r14 + v8_n;
	if (xTickCount >= v8_n)
	{
		if (r11_n < v8_n)
			goto l00004640;
	}
	else if (r11_n >= v8_n)
		goto l0000463E;
	if (xTickCount < r11_n)
		goto l00004640;
l0000463E:
	r10_n.u1 = 0x01;
l00004640:
	*r15 = r11_n;
	if (r10_n != 0x00)
	{
		struct Eq_n * r14_n;
		Eq_n r15_n;
		vListRemove(&pxCurrentTCB->t0008);
		pxCurrentTCB->t0008 = r11_n;
		if (r11_n >= xTickCount)
		{
			r14_n = (struct Eq_n *) &pxCurrentTCB->t0008;
			r15_n = pxOverflowDelayedTaskList;
		}
		else
		{
			r14_n = (struct Eq_n *) &pxCurrentTCB->t0008;
			r15_n = pxDelayedTaskList;
		}
		vListInsert(r14_n, r15_n);
	}
	word20 r15_n;
	ui20 sr_n = xTaskResumeAll(sr_n, out r15_n);
	if (r15_n == 0x00)
	{
		word20 r10_n;
		word20 r8_n;
		word20 r11_n;
		word20 r9_n;
		sr_n = vPortYield(sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
	return sr_n;
}

// 469E: void vTaskDelay(Register ui20 sr, Register word20 r15)
void vTaskDelay(ui20 sr, word20 r15)
{
	Eq_n r15_n = 0x00;
	if (r15 != 0x00)
	{
		struct Eq_n * r14_n;
		Eq_n r15_n;
		ui20 sr_n = vTaskSuspendAll(sr);
		Eq_n r11_n = (word24) xTickCount + r15;
		vListRemove(&pxCurrentTCB->t0008);
		pxCurrentTCB->t0008 = r11_n;
		if (r11_n >= xTickCount)
		{
			r14_n = (struct Eq_n *) &pxCurrentTCB->t0008;
			r15_n = pxOverflowDelayedTaskList;
		}
		else
		{
			r14_n = (struct Eq_n *) &pxCurrentTCB->t0008;
			r15_n = pxDelayedTaskList;
		}
		vListInsert(r14_n, r15_n);
		sr = xTaskResumeAll(sr_n, out r15_n);
	}
	if (r15_n == 0x00)
	{
		word20 r10_n;
		word20 r11_n;
		word20 r8_n;
		word20 r9_n;
		vPortYield(sr, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 4702: void vTaskStartScheduler(Register ui20 sr)
// Called from:
//      fn00004000
void vTaskStartScheduler(ui20 sr)
{
	if (pxCurrentTCB != null)
	{
		Eq_n r15_n;
		xTaskCreate(sr, 0x00, 0x32, 18172, 18860, out r15_n);
		if (r15_n == 0x01)
		{
			xSchedulerRunning = 0x01;
			xTickCount.u0 = 0x00;
			xPortStartScheduler();
		}
	}
}

// 4736: void vTaskEndScheduler()
void vTaskEndScheduler()
{
	xSchedulerRunning = 0x00;
	vPortEndScheduler();
}

// 4742: Register ui20 vTaskSuspendAll(Register ui20 sr)
// Called from:
//      vTaskDelayUntil
//      vTaskDelay
//      prvCheckTasksWaitingTermination
//      xQueueSend
//      xQueueReceive
//      pvPortMalloc
ui20 vTaskSuspendAll(ui20 sr)
{
	++usCriticalNesting;
	++uxSchedulerSuspended;
	ui20 sr_n = sr & ~0x08;
	if (usCriticalNesting != 0x00)
	{
		word16 v9_n = usCriticalNesting;
		usCriticalNesting = v9_n + ~0x00;
		if (v9_n == ~0x00)
			sr_n = sr & ~0x08 | 0x08;
	}
	return sr_n;
}

// 475C: Register ui20 xTaskResumeAll(Register ui20 sr, Register out Eq_n r15Out)
// Called from:
//      vTaskDelayUntil
//      vTaskDelay
//      prvCheckTasksWaitingTermination
//      xQueueSend
//      xQueueReceive
//      pvPortMalloc
ui20 xTaskResumeAll(ui20 sr, union Eq_n & r15Out)
{
	++usCriticalNesting;
	word16 v10_n = uxSchedulerSuspended;
	uxSchedulerSuspended = v10_n + ~0x00;
	Eq_n r8_n = 0x00;
	ui20 sr_n = sr & ~0x08;
	if (v10_n == ~0x00 && uxCurrentNumberOfTasks != 0x00)
	{
		Eq_n r9_n = 0x00;
		while (true)
		{
			Eq_n r11_n;
			if (g_w0286 != 0x00)
				r11_n = g_ptr0288->ptr0002->t0006;
			else
				r11_n.u0 = 0x00;
			if (r11_n == 0x00)
				break;
			vListRemove((word16) r11_n.u0 + 18);
			Eq_n r10_n = (word16) r11_n.u0 + 8;
			vListRemove(r10_n);
			*((word16) r11_n.u0 + 8) = 0x00;
			Eq_n v18_n = *((word16) r11_n.u0 + 6);
			if (uxTopReadyPriority >= v18_n)
				uxTopReadyPriority = v18_n;
			vListInsertEnd(r10_n, v18_n *20 0x10 + 0x0222);
			if (pxCurrentTCB->t0006 >= *((word16) r11_n.u0 + 6))
				r9_n.u1 = 0x01;
		}
		if (uxMissedTicks != 0x00)
		{
			if (uxMissedTicks != 0x00)
			{
				do
				{
					vTaskIncrementTick();
					word16 v33_n = uxMissedTicks;
					uxMissedTicks = v33_n + ~0x00;
				} while (v33_n != ~0x00);
			}
			r9_n.u1 = 0x01;
		}
		if (r9_n == 0x01)
		{
			word20 r10_n;
			word20 r9_n;
			word20 r11_n;
			sr_n = vPortYield(sr & ~0x08, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	if (usCriticalNesting != 0x00)
	{
		word16 v22_n = usCriticalNesting;
		usCriticalNesting = v22_n + ~0x00;
		if (v22_n == ~0x00)
			sr_n |= 0x08;
	}
	r15Out = r8_n;
	return sr_n;
}

// 481E: Register ui20 xTaskGetTickCount(Register ui20 sr, Register out Eq_n r15Out)
// Called from:
//      task_idle
//      task_n
//      task_n
//      task_n
ui20 xTaskGetTickCount(ui20 sr, union Eq_n & r15Out)
{
	word16 v4_n = usCriticalNesting;
	usCriticalNesting = v4_n + 0x01;
	ui20 sr_n = sr & ~0x08;
	Eq_n r15_n = xTickCount;
	if (v4_n != 0x01)
	{
		word16 v9_n = usCriticalNesting;
		usCriticalNesting = v9_n + ~0x00;
		if (v9_n == ~0x00)
			sr_n = sr & ~0x08 | 0x08;
	}
	r15Out = r15_n;
	return sr_n;
}

// 4834: void uxTaskGetNumberOfTasks()
void uxTaskGetNumberOfTasks()
{
	word16 v4_n = usCriticalNesting;
	usCriticalNesting = v4_n + 0x01;
	if (v4_n != 0x01)
	{
		word16 v9_n = usCriticalNesting;
		usCriticalNesting = v9_n + ~0x00;
	}
}

// 484A: void vTaskIncrementTick()
// Called from:
//      xTaskResumeAll
//      prvTickISR
void vTaskIncrementTick()
{
	if (uxSchedulerSuspended == 0x00)
	{
		Eq_n v8_n = xTickCount;
		xTickCount = (word24) v8_n + 1;
		if (v8_n == 0x01)
		{
			Eq_n v9_n = pxDelayedTaskList;
			pxDelayedTaskList = pxOverflowDelayedTaskList;
			pxOverflowDelayedTaskList = v9_n;
		}
		while (true)
		{
			Eq_n r11_n;
			Eq_n v15_n = pxDelayedTaskList;
			if (*v15_n != 0x00)
				r11_n = *((word24) *((word24) *((word24) v15_n + 2) + 2) + 6);
			else
				r11_n.u0 = 0x00;
			if (r11_n == 0x00 || xTickCount >= *((word24) r11_n + 8))
				break;
			Eq_n r10_n = (word24) r11_n + 8;
			vListRemove(r10_n);
			if (*((word24) r11_n + 26) != 0x00)
				vListRemove((word24) r11_n + 18);
			*((word24) r11_n + 8) = 0x00;
			Eq_n v24_n = *((word24) r11_n + 6);
			if (uxTopReadyPriority >= v24_n)
				uxTopReadyPriority = v24_n;
			vListInsertEnd(r10_n, v24_n *20 0x10 + 0x0222);
		}
	}
	else
		++uxMissedTicks;
}

// 48DA: void vTaskPlaceOnEventList(Register Eq_n r14, Register Eq_n r15)
// Called from:
//      xQueueSend
//      xQueueReceive
void vTaskPlaceOnEventList(Eq_n r14, Eq_n r15)
{
	struct Eq_n * r14_n;
	Eq_n r15_n;
	vListInsert((char *) &pxCurrentTCB->t0008 + 0x0A, r15);
	word20 r11_n = r14 + Mem5[0x0208<p16>:word16];
	vListRemove(&pxCurrentTCB->t0008);
	pxCurrentTCB->t0008 = r11_n;
	if (r11_n >= xTickCount)
	{
		r14_n = (struct Eq_n *) &pxCurrentTCB->t0008;
		r15_n = pxOverflowDelayedTaskList;
	}
	else
	{
		r14_n = (struct Eq_n *) &pxCurrentTCB->t0008;
		r15_n = pxDelayedTaskList;
	}
	vListInsert(r14_n, r15_n);
}

// 4930: Register Eq_n xTaskRemoveFromEventList(Register Eq_n r15)
// Called from:
//      xQueueSendFromISR
//      xQueueReceiveFromISR
//      prvUnlockQueue
Eq_n xTaskRemoveFromEventList(Eq_n r15)
{
	Eq_n r10_n;
	if (*r15 != 0x00)
		r10_n = *((word24) *((word24) *((word24) r15 + 2) + 2) + 6);
	else
		r10_n.u0 = 0x00;
	Eq_n r14_n;
	Eq_n r15_n;
	vListRemove((word24) r10_n + 18);
	if (uxSchedulerSuspended == 0x00)
	{
		vListRemove((word24) r10_n + 8);
		*((word24) r10_n + 8) = 0x00;
		Eq_n v13_n = *((word24) r10_n + 6);
		if (uxTopReadyPriority >= v13_n)
			uxTopReadyPriority = v13_n;
		r15_n = v13_n *20 0x10 + 0x0222;
		r14_n = (word24) r10_n + 8;
	}
	else
	{
		r14_n = (word24) r10_n + 18;
		r15_n.u0 = 646;
	}
	Eq_n r15_n;
	vListInsertEnd(r14_n, r15_n);
	if (pxCurrentTCB->t0006 >= *((word24) r10_n + 6))
		r15_n.u0 = 0x01;
	else
		r15_n.u0 = 0x00;
	return r15_n;
}

// 49AC: void prvIdleTask(Register ui20 sr)
void prvIdleTask(ui20 sr)
{
	while (true)
	{
		sr = prvCheckTasksWaitingTermination(sr);
		if (g_w0222 < 0x02)
		{
			word20 r8_n;
			word20 r9_n;
			word20 r10_n;
			word20 r11_n;
			sr = vPortYield(sr, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
}

// 49BE: void prvInitialiseTCBVariables(Register Eq_n r12, Register Eq_n r13, Register Eq_n r14, Register (ptr20 Eq_n) r15)
// Called from:
//      xTaskCreate
void prvInitialiseTCBVariables(Eq_n r12, Eq_n r13, Eq_n r14, struct Eq_n * r15)
{
	(&r15->w001A)[5] = (word16) r14;
	strncpy(0x08, r13, &r15->w001A + 1);
	*((char *) &r15->w001A + 9) = (struct Eq_n *) 0x00;
	Eq_n r10_n = r12;
	if (r12 < 0x04)
		r10_n.u0 = 0x03;
	r15->t0006 = r10_n;
	vListInitialiseItem(&r15->t0008);
	vListInitialiseItem((char *) &r15->t0008 + 0x0A);
	*((char *) &r15->t0008 + 6) = r15;
	*((char *) &r15->t0008 + 0x0A) = (struct Eq_n *) (0x04 - r10_n);
	*((char *) &r15->t0008 + 16) = r15;
}

// 4A12: void prvInitialiseTaskLists()
// Called from:
//      xTaskCreate
void prvInitialiseTaskLists()
{
	Eq_n r11_n = 0x00;
	do
	{
		vListInitialise(r11_n *20 0x10 + 0x0222);
		r11_n = (word24) r11_n + 1;
	} while (r11_n >= 0x04);
	vListInitialise(0x0262);
	vListInitialise(0x0272);
	vListInitialise(646);
	vListInitialise(662);
	pxDelayedTaskList.u0 = 0x0262;
	pxOverflowDelayedTaskList.u0 = 0x0272;
}

// 4A5E: Register ui20 prvCheckTasksWaitingTermination(Register ui20 sr)
// Called from:
//      prvIdleTask
ui20 prvCheckTasksWaitingTermination(ui20 sr)
{
	if (uxTasksDeleted != 0x00)
	{
		ui20 sr_n = vTaskSuspendAll(sr);
		Eq_n r11_n = 0x00;
		if (g_w0296 == 0x00)
			r11_n.u1 = 0x01;
		word20 r15_n;
		sr = xTaskResumeAll(sr_n, out r15_n);
		if (r11_n == 0x00)
		{
			Eq_n r11_n;
			++usCriticalNesting;
			sr &= ~0x08;
			if (g_w0296 != 0x00)
				r11_n = g_ptr0298->ptr0002->t0006;
			else
				r11_n.u1 = 0x00;
			vListRemove((word16) r11_n.u1 + 8);
			uxCurrentNumberOfTasks += ~0x00;
			uxTasksDeleted += ~0x00;
			if (usCriticalNesting != 0x00)
			{
				word16 v19_n = usCriticalNesting;
				usCriticalNesting = v19_n + ~0x00;
				if (v19_n == ~0x00)
					sr = sr & ~0x08 | 0x08;
			}
			prvDeleteTCB();
		}
	}
	return sr;
}

// 4AC2: Register ui20 prvAllocateTCBAndStack(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      xTaskCreate
ui20 prvAllocateTCBAndStack(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	Eq_n r15_n;
	ui20 sr_n = pvPortMalloc(sr, 0x26, out r15_n);
	Eq_n r11_n = r15_n;
	if (r15_n != 0x00)
	{
		Eq_n r15_n;
		sr_n = pvPortMalloc(sr_n, r15 *20 0x02, out r15_n);
		*((word24) r15_n + 2) = r15_n;
		if (r15_n == 0x00)
		{
			vPortFree();
			r11_n.u0 = 0x00;
		}
		else
			sr_n = memset(sr_n, r15 *20 0x02, 0xA5, r15_n);
	}
	r15Out = r11_n;
	return sr_n;
}

// 4B02: void prvDeleteTCB()
// Called from:
//      prvCheckTasksWaitingTermination
void prvDeleteTCB()
{
	vPortFree();
	vPortFree();
}

// 4B18: void vTaskSwitchContext()
// Called from:
//      vPortYield
//      prvTickISR
void vTaskSwitchContext()
{
	if (uxSchedulerSuspended == 0x00)
	{
		while ((&g_w0222)[uxTopReadyPriority *16 0x10] == 0x00)
			uxTopReadyPriority = (word24) uxTopReadyPriority + 0x0000FFFF;
		Eq_n r13_n = 0x0222;
		(word24) r13_n + uxTopReadyPriority *20 0x10 + 4 = (ui20) ((word24) r13_n + uxTopReadyPriority *20 0x10 + 4 + 2);
		if ((word24) r13_n + uxTopReadyPriority *20 0x10 + 4 == ((word24) r13_n + uxTopReadyPriority *20 0x10) + 2)
			g_a0226[uxTopReadyPriority] = (struct Eq_n) g_a0226[uxTopReadyPriority].ptr0000->w0002;
		pxCurrentTCB = (struct Eq_n *) (&g_a0226[uxTopReadyPriority].ptr0000->w0002)[2];
	}
}

// 4BD4: void vListInitialise(Register Eq_n r15)
// Called from:
//      prvInitialiseTaskLists
void vListInitialise(Eq_n r15)
{
	*((word24) r15 + 2) = (word24) r15 + 6;
	*((word24) r15 + 4) = (word24) r15 + 6;
	((word24) r15 + 6)->u0 = ~0x00;
	*((word24) r15 + 8) = (word24) r15 + 6;
	*((word24) r15 + 0x0A) = (word24) r15 + 6;
	((word24) r15 + 0x0C)->u0 = 0x00;
	vListInitialiseItem((word24) r15 + 6);
	r15->u0 = 0x00;
}

// 4C00: void vListInitialiseItem(Register (ptr20 Eq_n) r15)
// Called from:
//      prvInitialiseTCBVariables
//      vListInitialise
void vListInitialiseItem(struct Eq_n * r15)
{
	r15->w0008 = 0x00;
}

// 4C06: void vListInsertEnd(Register Eq_n r14, Register Eq_n r15)
// Called from:
//      xTaskCreate
//      vTaskDelete
//      xTaskResumeAll
//      vTaskIncrementTick
//      xTaskRemoveFromEventList
void vListInsertEnd(Eq_n r14, Eq_n r15)
{
	Eq_n v5_n = *((word24) r15 + 4);
	*((word24) r14 + 2) = *((word24) v5_n + 2);
	*((word24) r14 + 4) = *((word24) r15 + 4);
	*((word24) *((word24) v5_n + 2) + 4) = r14;
	*((word24) v5_n + 2) = r14;
	*((word24) r15 + 4) = r14;
	*((word24) r14 + 8) = r15;
	*r15 = (word24) *r15 + 1;
}

// 4C32: void vListInsert(Register (ptr20 Eq_n) r14, Register Eq_n r15)
// Called from:
//      vTaskDelayUntil
//      vTaskDelay
//      vTaskPlaceOnEventList
void vListInsert(struct Eq_n * r14, Eq_n r15)
{
	struct Eq_n * r13_n;
	cup16 v6_n = r14->w0000;
	if (v6_n != ~0x00)
	{
		struct Eq_n * v10_n = *((word24) r15 + 2);
		r13_n = v10_n;
		if (v6_n < *v10_n->t0002)
		{
			do
			{
				struct Eq_n * v15_n = r13_n->t0002;
				r13_n = v15_n;
			} while (v6_n < *v15_n->t0002);
		}
	}
	else
	{
		struct Eq_n * v18_n = *((word24) r15 + 2);
		r13_n = v18_n;
		if (*v18_n->t0002 >= ~0x00)
		{
			do
			{
				struct Eq_n * v21_n = r13_n->t0002;
				r13_n = v21_n;
			} while (*v21_n->t0002 >= v6_n);
		}
	}
	r14->t0002 = r13_n->t0002;
	*((word24) r14->t0002 + 4) = r14;
	r14->ptr0004 = r13_n;
	r13_n->t0002 = r14;
	r14->t0008 = r15;
	*r15 = (word24) *r15 + 1;
}

// 4C98: void vListRemove(Register Eq_n r15)
// Called from:
//      vTaskDelete
//      vTaskDelayUntil
//      vTaskDelay
//      xTaskResumeAll
//      vTaskIncrementTick
//      vTaskPlaceOnEventList
//      xTaskRemoveFromEventList
//      prvCheckTasksWaitingTermination
void vListRemove(Eq_n r15)
{
	Eq_n v5_n = *((word24) r15 + 2);
	*((word24) v5_n + 4) = *((word24) r15 + 4);
	Eq_n v7_n = *((word24) r15 + 4);
	*((word24) v7_n + 2) = v5_n;
	Eq_n v9_n = *((word24) r15 + 8);
	if (*((word24) v9_n + 4) == r15)
		*((word24) v9_n + 4) = v7_n;
	*((word24) r15 + 8) = 0x00;
	*v9_n = (word24) *v9_n + 0x0000FFFF;
}

// 4CC4: Register ui20 xQueueCreate(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      init_uart_isr
ui20 xQueueCreate(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	if (r15 != 0x00)
	{
		word20 r15_n;
		sr = pvPortMalloc(sr, 0x32, out r15_n);
		if (r15_n != 0x00)
			;
	}
	Eq_n r15_n = 0x00;
	r15Out = r15_n;
	return sr;
}

// 4D7E: Register ui20 xQueueSend(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      x_putchar
ui20 xQueueSend(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	ui20 sr_n = vTaskSuspendAll(sr);
	++usCriticalNesting;
	*((word24) r15 + 46) = (word24) *((word24) r15 + 46) + 1;
	*((word24) r15 + 48) = (word24) *((word24) r15 + 48) + 1;
	Eq_n r11_n = r15;
	Eq_n r9_n = r14;
	ui20 sr_n = sr_n & ~0x08;
	if (usCriticalNesting != 0x00)
	{
		word16 v16_n = usCriticalNesting;
		usCriticalNesting = v16_n + ~0x00;
		if (v16_n == ~0x00)
			sr_n = sr_n & ~0x08 | 0x08;
	}
	word20 r15_n;
	ui20 sr_n = prvIsQueueFull(sr_n, r15, out r15_n);
	if (r15_n != 0x00 && r13 != 0x00)
	{
		vTaskPlaceOnEventList(r13, (word24) r15 + 8);
		++usCriticalNesting;
		word20 r15_n;
		word20 r15_n;
		ui20 sr_n = xTaskResumeAll(prvUnlockQueue(sr_n & ~0x08, r15, out r15_n), out r15_n);
		if (r15_n == 0x00)
		{
			word20 r10_n;
			word20 r8_n;
			sr_n = vPortYield(sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
		ui20 sr_n = vTaskSuspendAll(sr_n);
		++usCriticalNesting;
		*((word24) r11_n + 46) = (word24) *((word24) r11_n + 46) + 1;
		*((word24) r11_n + 48) = (word24) *((word24) r11_n + 48) + 1;
		sr_n = sr_n & ~0x08;
		if (usCriticalNesting != 0x00)
		{
			word16 v38_n = usCriticalNesting;
			usCriticalNesting = v38_n + ~0x00;
			if (v38_n == ~0x00)
				sr_n = sr_n & ~0x08 | 0x08;
		}
		if (usCriticalNesting != 0x00)
		{
			word16 v40_n = usCriticalNesting;
			usCriticalNesting = v40_n + ~0x00;
			if (v40_n == ~0x00)
				sr_n |= 0x08;
		}
	}
	Eq_n r10_n;
	++usCriticalNesting;
	ui20 sr_n = sr_n & ~0x08;
	if (*((word24) r11_n + 40) < *((word24) r11_n + 42))
		r10_n.u0 = ~0x02;
	else
	{
		sr_n = memcpy(sr_n, *((word24) r11_n + 44), r9_n, *((word24) r11_n + 4));
		*((word24) r11_n + 40) = (word24) *((word24) r11_n + 40) + 1;
		word20 r15_n = Mem178[r11_n + 4:word16] + Mem178[r11_n + 44:word16];
		*((word24) r11_n + 4) = r15_n;
		if (r15_n < *((word24) r11_n + 2))
			*((word24) r11_n + 4) = *r11_n;
		*((word24) r11_n + 48) = (word24) *((word24) r11_n + 48) + 1;
		r10_n.u0 = 0x01;
	}
	if (usCriticalNesting != 0x00)
	{
		word16 v22_n = usCriticalNesting;
		usCriticalNesting = v22_n + ~0x00;
		if (v22_n == ~0x00)
			sr_n |= 0x08;
	}
	ui20 sr_n;
	word20 r15_n;
	ui20 sr_n = prvUnlockQueue(sr_n, r11_n, out r15_n);
	if (r15_n != 0x00)
	{
		word20 r15_n;
		sr_n = xTaskResumeAll(sr_n, out r15_n);
		if (r15_n == 0x00)
		{
			word20 r11_n;
			word20 r8_n;
			word20 r9_n;
			sr_n = vPortYield(sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	else
	{
		word20 r15_n;
		sr_n = xTaskResumeAll(sr_n, out r15_n);
	}
	r15Out = r10_n;
	return sr_n;
}

// 4E84: Register ui20 xQueueSendFromISR(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      vRxISR
ui20 xQueueSendFromISR(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	Eq_n r13_n;
	if (*((word24) r15 + 40) >= *((word24) r15 + 42))
	{
		sr = memcpy(sr, *((word24) r15 + 44), r14, *((word24) r15 + 4));
		*((word24) r15 + 40) = (word24) *((word24) r15 + 40) + 1;
		word20 r15_n = Mem33[r15 + 4:word16] + Mem33[r15 + 44:word16];
		*((word24) r15 + 4) = r15_n;
		if (r15_n < *((word24) r15 + 2))
			*((word24) r15 + 4) = *r15;
		ci16 v20_n = *((word24) r15 + 48);
		if (v20_n != ~0x00)
			*((word24) r15 + 48) = v20_n + 0x01;
		else if (r13 == 0x00 && (*((word24) r15 + 24) != 0x00 && xTaskRemoveFromEventList((word24) r15 + 24) != 0x00))
		{
			r13_n.u0 = 0x01;
l4EE8:
			r15Out = r13_n;
			return sr;
		}
	}
	r13_n = r13;
	goto l4EE8;
}

// 4EF0: Register ui20 xQueueReceive(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      x_getchar
//      x_putchar
ui20 xQueueReceive(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	ui20 sr_n = vTaskSuspendAll(sr);
	++usCriticalNesting;
	*((word24) r15 + 46) = (word24) *((word24) r15 + 46) + 1;
	*((word24) r15 + 48) = (word24) *((word24) r15 + 48) + 1;
	Eq_n r11_n = r15;
	Eq_n r9_n = r14;
	ui20 sr_n = sr_n & ~0x08;
	if (usCriticalNesting != 0x00)
	{
		word16 v16_n = usCriticalNesting;
		usCriticalNesting = v16_n + ~0x00;
		if (v16_n == ~0x00)
			sr_n = sr_n & ~0x08 | 0x08;
	}
	word20 r15_n;
	ui20 sr_n = prvIsQueueEmpty(sr_n, r15, out r15_n);
	if (r15_n != 0x00 && r13 != 0x00)
	{
		vTaskPlaceOnEventList(r13, (word24) r15 + 24);
		++usCriticalNesting;
		word20 r15_n;
		word20 r15_n;
		ui20 sr_n = xTaskResumeAll(prvUnlockQueue(sr_n & ~0x08, r15, out r15_n), out r15_n);
		if (r15_n == 0x00)
		{
			word20 r10_n;
			word20 r8_n;
			sr_n = vPortYield(sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
		ui20 sr_n = vTaskSuspendAll(sr_n);
		++usCriticalNesting;
		*((word24) r11_n + 46) = (word24) *((word24) r11_n + 46) + 1;
		*((word24) r11_n + 48) = (word24) *((word24) r11_n + 48) + 1;
		sr_n = sr_n & ~0x08;
		if (usCriticalNesting != 0x00)
		{
			word16 v33_n = usCriticalNesting;
			usCriticalNesting = v33_n + ~0x00;
			if (v33_n == ~0x00)
				sr_n = sr_n & ~0x08 | 0x08;
		}
		if (usCriticalNesting != 0x00)
		{
			word16 v38_n = usCriticalNesting;
			usCriticalNesting = v38_n + ~0x00;
			if (v38_n == ~0x00)
				sr_n |= 0x08;
		}
	}
	Eq_n r10_n;
	++usCriticalNesting;
	ui20 sr_n = sr_n & ~0x08;
	cup16 v18_n = *((word24) r11_n + 40);
	if (v18_n != 0x00)
	{
		Eq_n v19_n = *((word24) r11_n + 44);
		word20 r15_n = Mem152[r11_n + 6:word16] + v19_n;
		*((word24) r11_n + 6) = r15_n;
		if (r15_n < *((word24) r11_n + 2))
			*((word24) r11_n + 6) = *r11_n;
		*((word24) r11_n + 40) = v18_n + ~0x00;
		sr_n = memcpy(sr_n, v19_n, *((word24) r11_n + 6), r9_n);
		*((word24) r11_n + 46) = (word24) *((word24) r11_n + 46) + 1;
		r10_n.u0 = 0x01;
	}
	else
		r10_n.u0 = 0x00;
	if (usCriticalNesting != 0x00)
	{
		word16 v27_n = usCriticalNesting;
		usCriticalNesting = v27_n + ~0x00;
		if (v27_n == ~0x00)
			sr_n |= 0x08;
	}
	ui20 sr_n;
	word20 r15_n;
	ui20 sr_n = prvUnlockQueue(sr_n, r11_n, out r15_n);
	if (r15_n != 0x00)
	{
		word20 r15_n;
		sr_n = xTaskResumeAll(sr_n, out r15_n);
		if (r15_n == 0x00)
		{
			word20 r9_n;
			word20 r11_n;
			word20 r8_n;
			sr_n = vPortYield(sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	else
	{
		word20 r15_n;
		sr_n = xTaskResumeAll(sr_n, out r15_n);
	}
	r15Out = r10_n;
	return sr_n;
}

// 4FF6: Register Eq_n xQueueReceiveFromISR(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
// Called from:
//      vTxISR
Eq_n xQueueReceiveFromISR(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n r15_n;
	cup16 v9_n = *((word24) r15 + 40);
	if (v9_n != 0x00)
	{
		Eq_n v12_n = *((word24) r15 + 44);
		word20 r15_n = Mem8[r15 + 6:word16] + v12_n;
		*((word24) r15 + 6) = r15_n;
		if (r15_n < *((word24) r15 + 2))
			*((word24) r15 + 6) = *r15;
		*((word24) r15 + 40) = v9_n + ~0x00;
		memcpy(sr, v12_n, *((word24) r15 + 6), r14);
		ci16 v20_n = *((word24) r15 + 46);
		if (v20_n != ~0x00)
			*((word24) r15 + 46) = v20_n + 0x01;
		else if (*r13 == 0x00 && (*((word24) r15 + 8) != 0x00 && xTaskRemoveFromEventList((word24) r15 + 8) != 0x00))
			r13->u0 = 0x01;
		r15_n.u1 = 0x01;
	}
	else
		r15_n.u1 = 0x00;
	return r15_n;
}

// 5068: void uxQueueMessagesWaiting()
void uxQueueMessagesWaiting()
{
	word16 v4_n = usCriticalNesting;
	usCriticalNesting = v4_n + 0x01;
	if (v4_n != 0x01)
	{
		word16 v9_n = usCriticalNesting;
		usCriticalNesting = v9_n + ~0x00;
	}
}

// 507E: void vQueueDelete()
void vQueueDelete()
{
	vPortFree();
	vPortFree();
}

// 5092: Register ui20 prvUnlockQueue(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      xQueueSend
//      xQueueReceive
ui20 prvUnlockQueue(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	++usCriticalNesting;
	ci16 v9_n = *((word24) r15 + 48);
	*((word24) r15 + 48) = v9_n + ~0x00;
	Eq_n r10_n = 0x00;
	ui20 sr_n = sr & ~0x08;
	if (v9_n >= ~0x00)
	{
		*((word24) r15 + 48) = ~0x00;
		if (*((word24) r15 + 24) != 0x00 && xTaskRemoveFromEventList((word24) r15 + 24) != 0x00)
			r10_n.u0 = 0x01;
	}
	if (usCriticalNesting != 0x00)
	{
		word16 v14_n = usCriticalNesting;
		usCriticalNesting = v14_n + ~0x00;
		if (v14_n == ~0x00)
			sr_n = sr & ~0x08 | 0x08;
	}
	++usCriticalNesting;
	ci16 v16_n = *((word24) r15 + 46);
	*((word24) r15 + 46) = v16_n + ~0x00;
	ui20 sr_n = sr_n & ~0x08;
	if (v16_n >= ~0x00)
	{
		*((word24) r15 + 46) = ~0x00;
		if (*((word24) r15 + 8) != 0x00 && xTaskRemoveFromEventList((word24) r15 + 8) != 0x00)
			r10_n.u0 = 0x01;
	}
	if (usCriticalNesting != 0x00)
	{
		word16 v19_n = usCriticalNesting;
		usCriticalNesting = v19_n + ~0x00;
		if (v19_n == ~0x00)
			sr_n |= 0x08;
	}
	r15Out = r10_n;
	return sr_n;
}

// 510C: Register ui20 prvIsQueueEmpty(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      xQueueReceive
ui20 prvIsQueueEmpty(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	++usCriticalNesting;
	ui20 sr_n = sr & ~0x08;
	Eq_n r14_n = 0x00;
	if (*((word24) r15 + 40) == 0x00)
		r14_n.u0 = 0x01;
	if (usCriticalNesting != 0x00)
	{
		word16 v11_n = usCriticalNesting;
		usCriticalNesting = v11_n + ~0x00;
		if (v11_n == ~0x00)
			sr_n = sr & ~0x08 | 0x08;
	}
	r15Out = r14_n;
	return sr_n;
}

// 512E: Register ui20 prvIsQueueFull(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      xQueueSend
ui20 prvIsQueueFull(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	++usCriticalNesting;
	ui20 sr_n = sr & ~0x08;
	Eq_n r14_n = 0x00;
	if (*((word24) r15 + 40) == *((word24) r15 + 42))
		r14_n.u0 = 0x01;
	if (usCriticalNesting != 0x00)
	{
		word16 v12_n = usCriticalNesting;
		usCriticalNesting = v12_n + ~0x00;
		if (v12_n == ~0x00)
			sr_n = sr & ~0x08 | 0x08;
	}
	r15Out = r14_n;
	return sr_n;
}

// 5156: Register ui20 pvPortMalloc(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
// Called from:
//      prvAllocateTCBAndStack
//      xQueueCreate
ui20 pvPortMalloc(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	Eq_n r11_n = r15;
	Eq_n r10_n = 0x00;
	if ((r15 & 0x01) != 0x00)
		r11_n = r15 - (r15 & 0x01) + 0x02;
	ui20 sr_n = vTaskSuspendAll(sr);
	Eq_n v10_n = xNextFreeByte;
	word20 r15_n = v10_n + r11_n;
	if (r15_n >= 0x0708 && v10_n >= r15_n)
	{
		xNextFreeByte = r15_n;
		r10_n = (word24) v10_n + 0x02AA;
	}
	word20 r15_n;
	ui20 sr_n = xTaskResumeAll(sr_n, out r15_n);
	r15Out = r10_n;
	return sr_n;
}

// 5192: void vPortFree()
// Called from:
//      prvAllocateTCBAndStack
//      prvDeleteTCB
//      vQueueDelete
void vPortFree()
{
}

// 5194: void vPortInitialiseBlocks()
void vPortInitialiseBlocks()
{
	xNextFreeByte.u0 = 0x00;
}

// 519A: Register (ptr20 Eq_n) pxPortInitialiseStack(Register Eq_n r13, Register Eq_n r14, Register (ptr20 Eq_n) r15)
// Called from:
//      xTaskCreate
struct Eq_n * pxPortInitialiseStack(Eq_n r13, Eq_n r14, struct Eq_n * r15)
{
	r15->t0000 = r14;
	r15->wFFFFFFFE = 0x08;
	r15->wFFFFFFFC = 0x4444;
	r15->wFFFFFFFA = 0x5555;
	r15->wFFFFFFF8 = 0x6666;
	r15->wFFFFFFF6 = 0x7777;
	r15->wFFFFFFF4 = 0x8888;
	r15->wFFFFFFF2 = 0x9999;
	r15->wFFFFFFF0 = 0xAAAA;
	r15->wFFFFFFEE = ~0x4444;
	r15->wFFFFFFEC = 0xCCCC;
	r15->wFFFFFFEA = ~0x2222;
	r15->wFFFFFFE8 = ~0x1111;
	r15->tFFFFFFE6 = r13;
	r15->wFFFFFFE4 = 0x00;
	return r15 - 0x1C;
}

// 520A: void xPortStartScheduler()
// Called from:
//      vTaskStartScheduler
void xPortStartScheduler()
{
	prvSetupTimerInterrupt();
	usCriticalNesting = pxCurrentTCB->ptr0000->w0000;
}

// 5238: void vPortEndScheduler()
// Called from:
//      vTaskEndScheduler
void vPortEndScheduler()
{
}

// 523A: Register ui20 vPortYield(Register ui20 sr, Register out Eq_n r8Out, Register out Eq_n r9Out, Register out Eq_n r10Out, Register out Eq_n r11Out)
// Called from:
//      vRxISR
//      xTaskCreate
//      vTaskDelete
//      vTaskDelayUntil
//      vTaskDelay
//      xTaskResumeAll
//      prvIdleTask
//      xQueueSend
//      xQueueReceive
ui20 vPortYield(ui20 sr, union Eq_n & r8Out, union Eq_n & r9Out, union Eq_n & r10Out, union Eq_n & r11Out)
{
	word16 fp;
	pxCurrentTCB->ptr0000 = fp - 28;
	vTaskSwitchContext();
	struct Eq_n * v20_n = pxCurrentTCB->ptr0000;
	usCriticalNesting = v20_n->w0000;
	Eq_n r11_n = v20_n->t000A;
	Eq_n r10_n = v20_n->t000C;
	Eq_n r9_n = v20_n->t000E;
	r8Out = v20_n->t0010;
	r9Out = r9_n;
	r10Out = r10_n;
	r11Out = r11_n;
	return sr & ~0x08;
}

// 528E: void prvSetupTimerInterrupt()
// Called from:
//      xPortStartScheduler
void prvSetupTimerInterrupt()
{
	*(cui16 *) 0x0160 = 0x00;
	*(cui16 *) 0x0160 = 0x0100;
	*(cui16 *) 0x0160 |= 0x04;
	*(word16 *) 0x0172 = 0x20;
	*(word16 *) 0x0162 = 0x10;
	*(cui16 *) 0x0160 |= 0x04;
	*(cui16 *) 0x0160 |= 0x10;
}

// 52B4: void prvTickISR()
void prvTickISR()
{
	word16 fp;
	pxCurrentTCB->ptr0000 = fp - 26;
	vTaskIncrementTick();
	vTaskSwitchContext();
	usCriticalNesting = pxCurrentTCB->ptr0000->w0000;
}

// 5308: void printf(Register Eq_n r8)
// Called from:
//      fn00004000
//      task_idle
void printf(Eq_n r8)
{
	struct Eq_n * fp;
	vuprintf(r8, (char *) &fp->t0002 + 2, fp->t0002, 17314);
}

// 531A: Register Eq_n PRINT(Register Eq_n r14, Register Eq_n r15)
// Called from:
//      vuprintf
Eq_n PRINT(Eq_n r14, Eq_n r15)
{
	Eq_n r15_n;
	Eq_n r10_n = r15;
	Eq_n r11_n = r14;
	if (r14 != 0x00)
	{
		do
		{
			word20 r11_n;
			int20 r15_n;
			__write_char();
			if (r15_n < 0x00)
			{
				r15_n.u0 = ~0x00;
				return r15_n;
			}
			++total_len;
			r11_n = r11_n + ~0x00;
		} while (r11_n != ~0x00);
	}
	r15_n.u0 = 0x01;
	return r15_n;
}

// 534A: Register Eq_n __write_pad(Register Eq_n r14, Register Eq_n r15)
// Called from:
//      vuprintf
Eq_n __write_pad(Eq_n r14, Eq_n r15)
{
	Eq_n r15_n;
	Eq_n r9_n = r15;
	Eq_n r11_n = r14;
	if (r14 >= 0x01)
	{
		Eq_n r10_n = (int16) (byte) r15;
		do
		{
			Eq_n r11_n;
			int20 r15_n;
			__write_char();
			if (r15_n < 0x00)
			{
				r15_n.u1 = ~0x00;
				return r15_n;
			}
			++total_len;
			r11_n = (word20) r11_n + 0x00FF;
		} while (r11_n >= 0x02);
	}
	r15_n = r9_n;
	return r15_n;
}

// 537E: void vuprintf(Register Eq_n r8, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
// Called from:
//      printf
void vuprintf(Eq_n r8, Eq_n r13, Eq_n r14, Eq_n r15)
{
	word16 fp;
	total_len = 0x00;
	__write_char = r15;
	Eq_n r5_n = r13;
	Eq_n r6_n = r14;
	uint32 dwLoc1C_n = 0x00;
l53A6:
	Eq_n r6_n;
	Eq_n v15_n = *r6_n;
	Eq_n r7_n = v15_n;
	r6_n = r6_n;
	if (v15_n != 0x00)
	{
		r6_n = r6_n;
		r6_n = r6_n;
		if (v15_n != 0x25)
		{
			do
			{
				r6_n = (word20) r6_n + 1;
				Eq_n v17_n = *r6_n;
				r7_n = v17_n;
			} while (v17_n != 0x00 && v17_n != 0x25);
		}
	}
	Eq_n r13_n = r6_n - r6_n;
	if (r13_n != 0x00 && PRINT(r13_n, r6_n) < 0x00 || r7_n == 0x00)
		return;
	r6_n = r6_n + 0x01;
	byte bLoc1E_n = 0x00;
	Eq_n bLoc17_n = 0x00;
	Eq_n bLoc1D_n = 0x00;
	Eq_n r11_n = ~0x00;
	Eq_n bLoc24_n = 0x00;
	uint32 dwLoc1C_n = dwLoc1C_n;
	while (true)
	{
l53E8:
		Eq_n r7_n = *r6_n;
		++r6_n;
		while (true)
		{
			if (r7_n == 117 || (r7_n | 0x20) == 0x78)
			{
				if ((bLoc1E_n & 0x01) != 0x00)
				{
					r5_n += 0x04;
					dwLoc1C_n = (uint32) *r5_n;
				}
				else
				{
					r5_n = (word24) r5_n + 2;
					dwLoc1C_n = (uint32) *r5_n;
				}
			}
			word16 wLoc1A_n = SLICE(dwLoc1C_n, word16, 16);
			word16 wLoc1C_n = (word16) dwLoc1C_n;
			if (r7_n == 0x20)
				break;
			if (r7_n == 0x23)
			{
				bLoc1E_n |= 0x08;
				goto l53E8;
			}
			if (r7_n == 0x2A)
			{
				Eq_n v39_n = *r5_n;
				r5_n += 0x02;
				bLoc1D_n = v39_n;
				if (v39_n >= 0x00)
					goto l53E8;
				bLoc1D_n = -v39_n;
l58A8:
				bLoc1E_n = (bLoc1E_n | 0x10) & ~0x20;
				goto l53E8;
			}
			if (r7_n == 0x2D)
				goto l58A8;
			if (r7_n == 0x2B)
			{
				bLoc24_n.u2 = 0x2B;
				goto l53E8;
			}
			if (r7_n != 0x2E)
			{
				if (r7_n == 0x30)
				{
					if ((bLoc1E_n & 0x10) == 0x00)
						bLoc1E_n |= 0x20;
					goto l53E8;
				}
				if (r7_n >= ~0x39)
				{
					Eq_n r13_n = 0x00;
					do
					{
						ui20 r14_n = r13_n *20 0x02;
						ui20 r13_n = r13_n *20 0x04 + r14_n + r14_n + r14_n + (int16) ((byte) r7_n);
						Eq_n v53_n = *r6_n;
						r13_n = r13_n + ~0x2F;
						r7_n = v53_n;
						++r6_n;
					} while (v53_n >= ~0x39);
					bLoc1D_n = r13_n + ~0x2F;
					continue;
				}
				if (r7_n == 0x68)
				{
					bLoc1E_n |= 0x04;
					goto l53E8;
				}
				if (r7_n == 0x6C)
				{
					bLoc1E_n |= 0x01;
					goto l53E8;
				}
				Eq_n wLoc20_n;
				Eq_n r9_n;
				if (r7_n == 99)
				{
					r5_n += 0x02;
					goto l54F6;
				}
				uint32 dwLoc1C_n;
				Eq_n bLoc18_n;
				if (r7_n == 0x44)
				{
					bLoc1E_n |= 0x01;
l57AE:
					uint32 dwLoc1C_n;
					if ((bLoc1E_n & 0x01) != 0x00)
					{
						r5_n += 0x04;
						dwLoc1C_n = (uint32) *r5_n;
					}
					else
					{
						uint16 v135_n = *r5_n;
						ui32 v140_v138_n = SEQ(v138_n, v135_n) + SEQ(v138_n, v135_n);
						r5_n += 0x02;
						ui16 v138_n = (word16) v140_v138_n;
						dwLoc1C_n = SEQ(~SLICE(v140_v138_n, word16, 16), v135_n);
					}
					word16 wLoc1C_n = (word16) dwLoc1C_n;
					ci16 wLoc1A_n = SLICE(dwLoc1C_n, word16, 16);
					uint32 dwLoc1C_n = dwLoc1C_n;
					if (wLoc1A_n < 0x00)
					{
						uint16 v131_n = ~wLoc1C_n;
						bLoc24_n.u2 = 0x2D;
						dwLoc1C_n = SEQ(SLICE(SEQ(~wLoc1A_n, v131_n) + 0x01, word16, 16), v131_n + 0x01);
					}
					bLoc18_n.u1 = 0x0A;
					dwLoc1C_n = dwLoc1C_n;
					goto l5620;
				}
				if (r7_n == 100 || r7_n == 0x69)
					goto l57AE;
				uint32 dwLoc1C_n;
				if (r7_n == 0x4F)
				{
					bLoc1E_n |= 0x01;
l57A2:
					bLoc18_n.u0 = 0x08;
					dwLoc1C_n = dwLoc1C_n;
					goto l561C;
				}
				if (r7_n == 111)
					goto l57A2;
				if (r7_n == 0x70)
				{
					r5_n += 0x02;
					bLoc18_n.u1 = 0x10;
					bLoc1E_n |= 0x40;
					r7_n.u0 = 0x78;
					dwLoc1C_n = (uint32) *r5_n;
					goto l561C;
				}
				if (r7_n == 115)
				{
					Eq_n v115_n = *r5_n;
					r5_n += 0x02;
					Eq_n wLoc20_n = v115_n;
					if (v115_n == 0x00)
						wLoc20_n = fp - 0x4C;
					Eq_n bLoc20_n = (byte) wLoc20_n;
					if (r11_n < 0x00)
					{
						Eq_n r15_n = wLoc20_n - 0x01;
						do
							++r15_n;
						while (*r15_n != 0x00);
						r9_n = r15_n - bLoc20_n;
						goto l54F8;
					}
					word20 r15_n = memchr((int16) (byte) r11_n, 0x00, wLoc20_n);
					if (r15_n != 0x00)
					{
						r9_n = r15_n - bLoc20_n;
						wLoc20_n = wLoc20_n;
						if (r11_n < r9_n)
							goto l573C;
					}
					else
					{
l573C:
						wLoc20_n = wLoc20_n;
						r9_n = r11_n;
					}
l54F8:
					bLoc24_n.u0 = 0x00;
					goto l54FC;
				}
				if (r7_n == 0x55)
				{
					bLoc1E_n |= 0x01;
l56FE:
					bLoc18_n.u1 = 0x0A;
					dwLoc1C_n = dwLoc1C_n;
					goto l561C;
				}
				if (r7_n == 117)
					goto l56FE;
				if (r7_n != 88 && r7_n != 0x78)
				{
					if (r7_n == 0x00)
						return;
l54F6:
					wLoc20_n = fp - 0x4C;
					r9_n.u1 = 0x01;
					goto l54F8;
				}
				bLoc18_n.u1 = 0x10;
				dwLoc1C_n = dwLoc1C_n;
				if ((bLoc1E_n & 0x08) != 0x00)
				{
					if (wLoc1C_n == 0x00)
					{
						dwLoc1C_n = dwLoc1C_n;
						if (wLoc1A_n != 0x00)
							goto l5616;
					}
					else
					{
l5616:
						bLoc1E_n |= 0x40;
						dwLoc1C_n = dwLoc1C_n;
					}
				}
l561C:
				bLoc24_n.u0 = 0x00;
				dwLoc1C_n = dwLoc1C_n;
l5620:
				word16 wLoc1A_n = SLICE(dwLoc1C_n, word16, 16);
				word16 wLoc1C_n = (word16) dwLoc1C_n;
				bLoc17_n = r11_n;
				if (r11_n >= 0x00)
					bLoc1E_n &= ~0x20;
				Eq_n wLoc20_n = fp - 0x24;
				byte bLoc20_n = (byte) (uipr32) fp - 0x24;
				byte bLoc1F_n = SLICE(fp - 0x24, byte, 8);
				if (wLoc1C_n == 0x00)
				{
					wLoc20_n = (word16) (uipr32) fp - 0x24;
					if (wLoc1A_n != 0x00)
						goto l564A;
					wLoc20_n = SEQ(bLoc1F_n, bLoc20_n);
					if (r11_n != 0x00)
						goto l564A;
				}
				else
				{
l564A:
					uint16 wLoc14_n = (uint16) bLoc18_n;
					uint32 dwLoc1C_n = dwLoc1C_n;
					do
					{
						Eq_n wLoc1A_n = SLICE(dwLoc1C_n, word16, 16);
						Eq_n wLoc1C_n = (word16) dwLoc1C_n;
						byte bLoc16_n = 0x00;
						if (SLICE(dwLoc1C_n - (uint40) wLoc14_n, word20, 20) < 0x00)
							bLoc16_n = 0x01;
						Eq_n r4_n;
						Eq_n r8_n;
						ui40 r15_r14_n;
						ui40 r13_r12_n;
						fn00005B4E((uint40) wLoc14_n, r8, wLoc1C_n, wLoc1A_n, out r13_r12_n, out r15_r14_n, out r8_n);
						Eq_n r14_n = <invalid>;
						if (r14_n >= 0x0A)
							r4_n = (word24) r14_n + 48;
						else
						{
							r4_n = (word24) r14_n + 87;
							if (r7_n == 88)
								r4_n = (word24) r14_n + 87 & ~0x20;
						}
						wLoc20_n = (word16) wLoc20_n + 0x0000FFFF;
						*wLoc20_n = r4_n;
						ui40 r13_r12_n;
						ui40 r15_r14_n;
						fn00005B4E((uint40) wLoc14_n, r8_n, wLoc1C_n, wLoc1A_n, out r13_r12_n, out r15_r14_n, out r8);
						Eq_n r13_n = <invalid>;
						Eq_n r12_n = <invalid>;
						dwLoc1C_n = SEQ(r13_n, r12_n);
						wLoc20_n = wLoc20_n;
					} while (bLoc16_n != 0x00);
					dwLoc1C_n = SEQ(r13_n, r12_n);
					if (bLoc18_n == 0x08)
					{
						dwLoc1C_n = SEQ(r13_n, r12_n);
						if ((bLoc1E_n & 0x08) != 0x00)
						{
							dwLoc1C_n = SEQ(r13_n, r12_n);
							if (r4_n != 0x30)
							{
								*((word16) wLoc20_n + 0x0000FFFE) = 0x30;
								wLoc20_n = SEQ(SLICE((word16) wLoc20_n + 0x0000FFFE, byte, 8), (byte) wLoc20_n + ~0x01);
								dwLoc1C_n = SEQ(r13_n, r12_n);
							}
						}
					}
				}
				r9_n = fp - 0x4C - (byte) wLoc20_n + 0x28;
				wLoc20_n = wLoc20_n;
				dwLoc1C_n = dwLoc1C_n;
l54FC:
				Eq_n r11_n = r9_n;
				Eq_n r10_n = bLoc17_n - r9_n;
				if (r10_n < 0x00)
					r10_n.u0 = 0x00;
				if (bLoc24_n != 0x00)
					r11_n.u1 = (byte) r9_n.u1 + 1;
				else if ((bLoc1E_n & 0x40) != 0x00)
					r11_n.u1 = (byte) r9_n.u1 + 2;
				word20 r11_n = r11_n + r10_n;
				r8 = bLoc1E_n & 0x30;
				if ((bLoc1E_n & 0x30) == 0x00)
				{
					Eq_n r13_n = bLoc1D_n - (byte) r11_n;
					if (r13_n >= 0x01 && __write_pad(r13_n, 0x20) < 0x00)
						return;
				}
				Eq_n r14_n;
				Eq_n r15_n;
				if (bLoc24_n == 0x00)
				{
					if ((bLoc1E_n & 0x40) == 0x00)
						goto l5576;
					r14_n.u0 = 0x02;
					r15_n = fp - 0x22;
				}
				else
				{
					r14_n.u0 = 0x01;
					r15_n = fp - 0x24;
				}
				if (PRINT(r14_n, r15_n) < 0x00)
					return;
l5576:
				if ((bLoc1E_n & 0x30) == 0x20)
				{
					Eq_n r13_n = bLoc1D_n - (byte) r11_n;
					if (r13_n >= 0x01 && __write_pad(r13_n, 0x30) < 0x00)
						return;
				}
				if (__write_pad(r10_n, 0x30) < 0x00 || PRINT((int16) ((byte) r9_n), wLoc20_n) < 0x00)
					return;
				dwLoc1C_n = dwLoc1C_n;
				if ((bLoc1E_n & 0x10) == 0x00)
					goto l53A6;
				Eq_n r13_n = bLoc1D_n - (byte) r11_n;
				dwLoc1C_n = dwLoc1C_n;
				if (r13_n < 0x01)
					goto l53A6;
				dwLoc1C_n = dwLoc1C_n;
				if (__write_pad(r13_n, 0x20) < 0x00)
					return;
				goto l53A6;
			}
			Eq_n v46_n = *r6_n;
			r7_n = v46_n;
			++r6_n;
			if (v46_n == 0x2A)
			{
				Eq_n v49_n = *r5_n;
				r5_n += 0x02;
				Eq_n r15_n = v49_n;
				if (v49_n < ~0x00)
					r15_n.u0 = ~0x00;
				r11_n = r15_n;
				goto l53E8;
			}
			Eq_n r13_n = 0x00;
			if (v46_n >= ~0x39)
			{
				do
				{
					ui20 r14_n = r13_n *20 0x02;
					Eq_n v48_n = *r6_n;
					r13_n = r13_n *20 0x04 + r14_n + r14_n + r14_n + (int16) ((byte) r7_n) + ~0x2F;
					r7_n = v48_n;
					++r6_n;
				} while (v48_n >= ~0x39);
			}
			Eq_n r15_n = r13_n;
			if (r13_n < ~0x00)
				r15_n.u0 = ~0x00;
			r11_n = r15_n;
		}
		if (bLoc24_n == 0x00)
			bLoc24_n.u2 = 0x20;
	}
}

// 593E: Register Eq_n memchr(Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
// Called from:
//      vuprintf
Eq_n memchr(Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n r15_n;
	if (r13 != 0x00)
	{
		Eq_n r14_n = r15;
		do
		{
			r14_n = (word24) r14_n + 1;
			if (*r14_n == r14)
			{
				r15_n = (word24) r14_n + 0x0000FFFF;
				return r15_n;
			}
			r13.u1 = (word20) r13.u1 + 0x0000FFFF;
		} while (r13 != 0x00);
	}
	r15_n.u0 = 0x00;
	return r15_n;
}

// 5962: void strncpy(Register Eq_n r13, Register Eq_n r14, Register (ptr20 byte) r15)
// Called from:
//      prvInitialiseTCBVariables
void strncpy(Eq_n r13, Eq_n r14, byte * r15)
{
	if (r13 != 0x00)
	{
		byte * r12_n = r15;
		do
		{
			*r12_n = (byte) *r14;
			++r14;
			++r12_n;
			if (*r12_n == 0x00)
			{
				word20 r13_n;
				for (r13_n = (word20) r13.u0 + 0x0000FFFF; r13_n != 0x00; r13_n += ~0x00)
				{
					*r12_n = 0x00;
					++r12_n;
				}
				return;
			}
			r13.u0 = (word20) r13.u0 + 0x0000FFFF;
		} while (r13 != 0x00);
	}
}

// 5994: Register ui20 memcpy(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
// Called from:
//      xQueueSend
//      xQueueSendFromISR
//      xQueueReceive
//      xQueueReceiveFromISR
ui20 memcpy(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n r11_n = r13;
	Eq_n r13_n = r15;
	Eq_n r12_n = r14;
	if (r13 != 0x00 && r15 != r14)
	{
		if (r15 >= r14)
		{
			ui20 r15_n = r14 | r15;
			bool C_n = (bool) cond(r15_n & 0x01);
			if ((r15_n & 0x01) != 0x00)
			{
				Eq_n r14_n;
				if (((r14 ^ r15) & 0x01) == 0x00 && r13 < 0x02)
					r14_n = 0x02 - (r14 & 0x01);
				else
					r14_n = r13;
				r11_n = r13 - r14_n;
				do
				{
					*r13_n = *r12_n;
					r14_n = (word24) r14_n + 0x0000FFFF;
					++r12_n;
					++r13_n;
					C_n = (bool) cond(r14_n);
				} while (r14_n != 0x00);
			}
			sr &= ~0x01;
			Eq_n r14_n = __rcr<word20,byte>(r11_n, 0x01, C_n);
			while (r14_n != 0x00)
			{
				*r13_n = *r12_n;
				r12_n += 2;
				r13_n += 0x02;
				r14_n = (word24) r14_n + 0x0000FFFF;
			}
			ui20 r14_n;
			for (r14_n = r11_n & 0x01; r14_n != 0x00; r14_n += ~0x00)
			{
				*r13_n = *r12_n;
				++r12_n;
				++r13_n;
			}
		}
		else
		{
			word20 r12_n = r14 + r13;
			word20 r13_n = r15 + r13;
			ui20 r15_n = r12_n | r13_n;
			bool C_n = (bool) cond(r15_n & 0x01);
			if ((r15_n & 0x01) != 0x00)
			{
				Eq_n r14_n;
				if (((r12_n ^ r13_n) & 0x01) == 0x00 && r13 < 0x03)
					r14_n = r12_n & 0x01;
				else
					r14_n = r13;
				r11_n = r13 - r14_n;
				do
				{
					r12_n = (word20) r12_n + 0x0000FFFF;
					r13_n = (word20) r13_n + 0x0000FFFF;
					*r13_n = *r12_n;
					r14_n = (word24) r14_n + 0x0000FFFF;
					C_n = (bool) cond(r14_n);
				} while (r14_n != 0x00);
			}
			sr &= ~0x01;
			Eq_n r14_n = __rcr<word20,byte>(r11_n, 0x01, C_n);
			while (r14_n != 0x00)
			{
				r12_n -= 0x02;
				r13_n -= 0x02;
				*r13_n = *r12_n;
				r14_n = (word24) r14_n + 0x0000FFFF;
			}
			ui20 r14_n;
			for (r14_n = r11_n & 0x01; r14_n != 0x00; r14_n += ~0x00)
			{
				r12_n += ~0x00;
				r13_n += ~0x00;
				*r13_n = *r12_n;
			}
		}
	}
	return sr;
}

// 5A68: Register ui20 memset(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
// Called from:
//      prvAllocateTCBAndStack
ui20 memset(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n r14_n = r15;
	if (r13 >= 0x06)
	{
		while (r13 != 0x00)
		{
			*r14_n = r14;
			++r14_n;
			r13 = (word24) r13 + 0x0000FFFF;
		}
	}
	else
	{
		Eq_n r11_n = r14;
		if (r14 != 0x00)
			r11_n = r14 | __swpb(r14);
		bool C_n = (bool) cond(r15 & 0x01);
		if ((r15 & 0x01) != 0x00)
		{
			Eq_n r15_n = 0x02 - (r15 & 0x01);
			Eq_n r12_n = r15_n;
			r13 -= r15_n;
			do
			{
				*r14_n = r14;
				r12_n = (word24) r12_n + 0x0000FFFF;
				++r14_n;
				C_n = (bool) cond(r12_n);
			} while (r12_n != 0x00);
		}
		sr &= ~0x01;
		Eq_n r12_n = __rcr<word20,byte>(r13, 0x01, C_n);
		do
		{
			*r14_n = r11_n;
			r14_n += 0x02;
			r12_n = (word24) r12_n + 0x0000FFFF;
		} while (r12_n != 0x00);
		ui20 r12_n;
		for (r12_n = r13 & 0x01; r12_n != 0x00; r12_n += ~0x00)
		{
			*r14_n = r14;
			++r14_n;
		}
	}
	return sr;
}

// 00005ADC: Sequence ui40 fn00005ADC(Register Eq_n r10, Register Eq_n r11, Register Eq_n r12, Register Eq_n r13)
// Called from:
//      msp430_compute_modulator_bits
ui40 fn00005ADC(Eq_n r10, Eq_n r11, Eq_n r12, Eq_n r13)
{
	*(union Eq_n *) 0x0130 = r12;
	*(union Eq_n *) 0x0138 = r10;
	*(union Eq_n *) 0x0134 = r12;
	Eq_n r14_n = *(union Eq_n *) 0x013A;
	*(union Eq_n *) 0x013A = *(union Eq_n *) 0x013C;
	*(union Eq_n *) 0x0138 = r11;
	*(union Eq_n *) 0x0134 = r13;
	*(union Eq_n *) 0x0138 = r10;
	return SEQ(*(union Eq_n *) 0x013A, r14_n);
}

// 00005B04: Register Eq_n fn00005B04(Sequence Eq_n r11_r10, Sequence ui40 r13_r12)
// Called from:
//      msp430_compute_modulator_bits
Eq_n fn00005B04(Eq_n r11_r10, ui40 r13_r12)
{
	Eq_n r13 = SLICE(r13_r12, word20, 20);
	Eq_n r12 = (word20) r13_r12;
	ui20 r11 = SLICE(r11_r10, word20, 20);
	Eq_n r8_n = 0x00;
	if ((r13 & 0x8000) != 0x00)
	{
		r12 = -(word20) r13_r12;
		r13 = SLICE((r13_r12 ^ ~0x00) + 0x01, word20, 20);
		r8_n |= 0x04;
	}
	Eq_n r11_r10_n = r11_r10;
	if ((r11 & 0x8000) != 0x00)
	{
		r8_n |= 0x08;
		r11_r10_n = SEQ(SLICE((r11_r10 ^ ~0x00) + 0x01, word20, 20), -(word20) r11_r10);
	}
	Eq_n r12_n = (word20) r13_r12_n;
	Eq_n r8_n;
	ui40 r15_r14_n;
	ui40 r13_r12_n;
	Eq_n r8_n = __rcr<word20,byte>(r8_n, 0x01, fn00005B4E(r11_r10_n, r8_n, r12, r13, out r13_r12_n, out r15_r14_n, out r8_n));
	if ((r8_n & 0x04) != 0x00)
		r12_n = -(word20) r13_r12_n;
	if ((r8_n & 0x08) != 0x00)
		r12_n = (r12_n ^ ~0x00) + 0x01;
	return r12_n;
}

// 00005B4E: FlagGroup bool fn00005B4E(Sequence Eq_n r11_r10, Register Eq_n r8, Register Eq_n r12, Register Eq_n r13, Sequence out Eq_n r13_r12Out, Sequence out Eq_n r15_r14Out, Register out Eq_n r8Out)
// Called from:
//      vuprintf
//      fn00005B04
bool fn00005B4E(Eq_n r11_r10, Eq_n r8, Eq_n r12, Eq_n r13, union Eq_n & r13_r12Out, union Eq_n & r15_r14Out, union Eq_n & r8Out)
{
	uint20 r11 = SLICE(r11_r10, word20, 20);
	uint20 r10 = (word20) r11_r10;
	uint20 r15_n = 0x00;
	uint20 r14_n = 0x00;
	Eq_n r9_n = 33;
	while (true)
	{
		r12 *= 0x02;
		r13 = r13 *20 0x02 + (word20) (r12 < 0x00);
		--r9_n;
		Eq_n r8_n = r8 *20 0x02 + (word20) (r13 < 0x00);
		bool C_n = (bool) cond(r9_n);
		if (r9_n == 0x00)
			break;
		r8 = __rcr<word20,byte>(r8_n, 0x01, C_n);
		r14_n = r14_n * 0x02 + (word20) (r8 < 0x00);
		r15_n = r15_n * 0x02 + (word20) (r14_n < 0x00);
		if (r15_n < r11 && (r15_n != r11 || r14_n < r10))
		{
			uint40 r15_r14_n = SEQ(r15_n, r14_n) - r11_r10;
			r14_n = (word20) r15_r14_n;
			r15_n = SLICE(r15_r14_n, word20, 20);
		}
	}
	r13_r12Out.u1 = <invalid>;
	r15_r14Out.u1 = <invalid>;
	r8Out = r8_n;
	return C_n;
}

