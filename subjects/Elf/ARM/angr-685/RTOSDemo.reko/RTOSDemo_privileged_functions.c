// RTOSDemo_privileged_functions.c
// Generated by decompiling RTOSDemo.axf
// using Reko decompiler version 0.9.1.0.

#include "RTOSDemo_privileged_functions.h"

// 00000058: void prvUnlockQueue(Register Eq_n r0, Register ptr32 cpsr)
void prvUnlockQueue(Eq_n r0, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	int32 r4_n = (int32) (int8) (word32) *((word32) r0 + 69);
	if (r4_n > 0x00 && *((word32) r0 + 36) != 0x00)
	{
		do
		{
			if (xTaskRemoveFromEventList((word32) r0 + 36) != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
			else
			{
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
		} while (*((word32) r0 + 36) != 0x00);
	}
	((word32) r0 + 69)->u0 = ~0x00;
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	int32 r4_n = (int32) (int8) (word32) *((word32) r0 + 0x0044);
	if (r4_n > 0x00 && *((word32) r0 + 16) != 0x00)
	{
		do
		{
			if (xTaskRemoveFromEventList((word32) r0 + 16) != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
			else
			{
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
		} while (*((word32) r0 + 16) != 0x00);
	}
	((word32) r0 + 0x0044)->u0 = ~0x00;
	vPortExitCritical(cpsr);
}

// 000000EC: FlagGroup bool prvCopyDataToQueue(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r7, Register Eq_n lr, Register out Eq_n r0Out, Register out Eq_n r7Out, Register out Eq_n lrOut)
bool prvCopyDataToQueue(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r7, Eq_n lr, union Eq_n & r0Out, union Eq_n & r7Out, union Eq_n & lrOut)
{
	bool Z_n;
	Eq_n r5_n;
	Eq_n r4_n = r0;
	Eq_n r0_n = *((word32) r0 + 64);
	Eq_n r5_n = *((word32) r0 + 56);
	if (r0_n == 0x00)
	{
		Eq_n r6_n = *r0;
		if (r6_n != 0x00)
		{
			r5_n = (word32) r5_n + 1;
			Z_n = SLICE(cond((word32) r5_n + 1), bool, 2);
		}
		else
		{
			r0_n = xTaskPriorityDisinherit(*((word32) r0 + 4), out lr);
			*((word32) r0 + 4) = r6_n;
			r5_n = (word32) r5_n + 1;
			Z_n = SLICE(cond((word32) r5_n + 1), bool, 2);
		}
	}
	else
	{
		if (r2 == 0x00)
		{
			Eq_n lr_n;
			struct Eq_n * r4_n;
			word32 r5_n;
			Eq_n r6_n;
			Eq_n r7_n;
			memcpy(*((word32) r0 + 8), r1, r0_n, r0, r5_n, r2, r7, lr, out r4_n, out r5_n, out r6_n, out r7_n, out lr_n);
			up32 r2_n = r4_n->dw0004;
			up32 r3_n = r4_n->dw0008 + r4_n->dw0040;
			r4_n->dw0008 = r3_n;
			if (r3_n < r2_n)
			{
				r4_n->dw0038 = r5_n + 0x01;
				r0Out = r6_n;
				r7Out = r7_n;
				lrOut = lr_n;
				return SLICE(cond(r5_n + 0x01), bool, 2);
			}
			else
			{
				r4_n->dw0008 = r4_n->dw0000;
				r4_n->dw0038 = r5_n + 0x01;
				r0Out = r6_n;
				r7Out = r7_n;
				lrOut = lr_n;
				return SLICE(cond(r5_n + 0x01), bool, 2);
			}
		}
		word32 r6_n;
		memcpy(*((word32) r0 + 0x0C), r1, r0_n, r0, r5_n, r2, r7, lr, out r4_n, out r5_n, out r6_n, out r7, out lr);
		Eq_n r3_n = *((word32) r4_n + 0x0C);
		Eq_n r1_n = *r4_n;
		*((word32) r4_n + 0x0C) = r3_n;
		if (r3_n < r1_n)
			*((word32) r4_n + 0x0C) = *((word32) r4_n + 4);
		Z_n = SLICE(cond(r6_n - 0x02), bool, 2);
		if (r6_n != 0x02)
		{
			*((word32) r4_n + 56) = (word32) r5_n + 1;
			r0Out.u0 = 0x00;
			r7Out = r7;
			lrOut = lr;
			return SLICE(cond((word32) r5_n + 1), bool, 2);
		}
		if (r5_n == 0x00)
			r5_n.u0 = 0x01;
		r0_n.u0 = 0x00;
	}
	*((word32) r4_n + 56) = r5_n;
	r0Out = r0_n;
	r7Out = r7;
	lrOut = lr;
	return Z_n;
}

// 0000016C: Register Eq_n prvCopyDataFromQueue(Register Eq_n r0, Register Eq_n r1, Register Eq_n r4, Register Eq_n r5, Register Eq_n r6, Register Eq_n r7, Register Eq_n lr, Register out Eq_n r5Out, Register out Eq_n r6Out, Register out Eq_n r7Out, Register out Eq_n lrOut)
Eq_n prvCopyDataFromQueue(Eq_n r0, Eq_n r1, Eq_n r4, Eq_n r5, Eq_n r6, Eq_n r7, Eq_n lr, union Eq_n & r5Out, union Eq_n & r6Out, union Eq_n & r7Out, union Eq_n & lrOut)
{
	Eq_n r2_n = *((word32) r0 + 64);
	if (r2_n == 0x00)
	{
		r5Out = r5;
		r6Out = r6;
		r7Out = r7;
		lrOut = lr;
		return r4;
	}
	else
	{
		Eq_n r4_n = *((word32) r0 + 4);
		word32 r1_n = Mem10[r0 + 0x0C:word32] + r2_n;
		*((word32) r0 + 0x0C) = r1_n;
		if (r1_n >= r4_n)
			r1_n = *r0;
		*((word32) r0 + 0x0C) = r1_n;
		Eq_n lr_n;
		Eq_n r4_n;
		Eq_n r5_n;
		Eq_n r6_n;
		Eq_n r7_n;
		memcpy(r1, r1_n, r2_n, r4, r5, r6, r7, lr, out r4_n, out r5_n, out r6_n, out r7_n, out lr_n);
		r5Out = r5_n;
		r6Out = r6_n;
		r7Out = r7_n;
		lrOut = lr_n;
		return r4_n;
	}
}

// 00000190: Register Eq_n xQueueGenericSend(Register Eq_n r0, Register Eq_n r1, Register up32 r2, Register Eq_n r3, Register Eq_n lr, Register ptr32 cpsr)
Eq_n xQueueGenericSend(Eq_n r0, Eq_n r1, up32 r2, Eq_n r3, Eq_n lr, ptr32 cpsr)
{
	word32 r5_n = 0x00;
	word32 * r9_n = globals->ptr02A0;
	while (true)
	{
		vPortEnterCritical(cpsr);
		if (*((word32) r0 + 56) < *((word32) r0 + 60) || r3 == 0x02)
			break;
		if (r2 == 0x00)
		{
			vPortExitCritical(cpsr);
			return lr;
		}
		if (r5_n == 0x00)
			vTaskSetTimeOutState(fp - 40);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		vPortEnterCritical(cpsr);
		if ((word32) *((word32) r0 + 0x0044) == 0xFF)
			((word32) r0 + 0x0044)->u0 = 0x00;
		if ((word32) *((word32) r0 + 69) == 0xFF)
			((word32) r0 + 69)->u0 = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 40, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			return lr;
		}
		vPortEnterCritical(cpsr);
		if (*((word32) r0 + 56) != *((word32) r0 + 60))
		{
			vPortExitCritical(cpsr);
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
		}
		else
		{
			vPortExitCritical(cpsr);
			vTaskPlaceOnEventList((word32) r0 + 16, r2);
			prvUnlockQueue(r0, cpsr);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*r9_n = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
		}
		r5_n = 0x01;
	}
	Eq_n lr_n;
	word32 r0_n;
	word32 r7_n;
	prvCopyDataToQueue(r0, r1, r3, r3, lr, out r0_n, out r7_n, out lr_n);
	if (*((word32) r0 + 36) == 0x00)
	{
		if (r0_n == 0x00)
			goto l00000266;
	}
	else if (xTaskRemoveFromEventList((word32) r0 + 36) == 0x00)
		goto l00000266;
	*globals->ptr02A0 = 0x10000000;
	__dsb_sy();
	__isb_sy();
l00000266:
	vPortExitCritical(cpsr);
	return lr_n;
}

// 000002A4: void xQueuePeekFromISR(Register Eq_n r0, Register Eq_n r1, Register Eq_n r7, Register Eq_n lr, Register ptr32 cpsr)
void xQueuePeekFromISR(Eq_n r0, Eq_n r1, Eq_n r7, Eq_n lr, ptr32 cpsr)
{
	Eq_n r5_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (*((word32) r0 + 56) != 0x00)
	{
		Eq_n r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 lr_n;
		prvCopyDataFromQueue(r0, r1, r0, r5_n, *((word32) r0 + 0x0C), r7, lr, out r5_n, out r6_n, out r7_n, out lr_n)->dw000C = r6_n;
		__msr(cpsr, r5_n);
	}
	else
		__msr(cpsr, r5_n);
}

// 000002D8: Register Eq_n xQueueGenericReceive(Register Eq_n r0, Register Eq_n r1, Register up32 r2, Register word32 r3, Register Eq_n lr, Register ptr32 cpsr, Register out Eq_n lrOut)
Eq_n xQueueGenericReceive(Eq_n r0, Eq_n r1, up32 r2, word32 r3, Eq_n lr, ptr32 cpsr, union Eq_n & lrOut)
{
	word32 r5_n = 0x00;
	word32 * r8_n = globals->ptr0424;
	while (true)
	{
		vPortEnterCritical(cpsr);
		Eq_n r6_n = *((word32) r0 + 56);
		if (r6_n != 0x00)
			break;
		if (r2 == 0x00)
		{
l000003A4:
			vPortExitCritical(cpsr);
			lrOut = lr;
			return 0x00;
		}
		if (r5_n == 0x00)
			vTaskSetTimeOutState(fp - 40);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		vPortEnterCritical(cpsr);
		if ((word32) *((word32) r0 + 0x0044) == 0xFF)
			((word32) r0 + 0x0044)->u0 = 0x00;
		if ((word32) *((word32) r0 + 69) == 0xFF)
			((word32) r0 + 69)->u0 = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 40, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			vPortEnterCritical(cpsr);
			if (*((word32) r0 + 56) == 0x00)
				goto l000003A4;
			vPortExitCritical(cpsr);
		}
		else
		{
			vPortEnterCritical(cpsr);
			if (*((word32) r0 + 56) != 0x00)
			{
				vPortExitCritical(cpsr);
				prvUnlockQueue(r0, cpsr);
				xTaskResumeAll(cpsr);
			}
			else
			{
				vPortExitCritical(cpsr);
				if (*r0 == 0x00)
				{
					vPortEnterCritical(cpsr);
					vTaskPriorityInherit(*((word32) r0 + 4));
					vPortExitCritical(cpsr);
				}
				vTaskPlaceOnEventList((word32) r0 + 36, r2);
				prvUnlockQueue(r0, cpsr);
				if (xTaskResumeAll(cpsr) == 0x00)
				{
					*r8_n = 0x10000000;
					__dsb_sy();
					__isb_sy();
				}
			}
		}
		r5_n = 0x01;
	}
	Eq_n lr_n;
	word32 r5_n;
	word32 r6_n;
	word32 r7_n;
	struct Eq_n * r4_n = prvCopyDataFromQueue(r0, r1, r0, *((word32) r0 + 0x0C), r6_n, 0x00, lr, out r5_n, out r6_n, out r7_n, out lr_n);
	if (r3 == 0x00)
	{
		word32 r3_n = r4_n->dw0000;
		r4_n->dw0038 = r6_n - 0x01;
		if (r3_n == 0x00)
			r4_n->dw0004 = pvTaskIncrementMutexHeldCount();
		if (r4_n->dw0010 == 0x00 || xTaskRemoveFromEventList(&r4_n->dw0010) == 0x00)
		{
l000003CC:
			vPortExitCritical(cpsr);
			lrOut = lr_n;
			return 0x01;
		}
	}
	else
	{
		word32 r3_n = r4_n->dw0024;
		r4_n->dw000C = r5_n;
		if (r3_n == 0x00 || xTaskRemoveFromEventList(&r4_n->dw0024) == 0x00)
			goto l000003CC;
	}
	*globals->ptr0424 = 0x10000000;
	__dsb_sy();
	__isb_sy();
	goto l000003CC;
}

// 00000428: void uxQueueMessagesWaiting(Register ptr32 cpsr)
void uxQueueMessagesWaiting(ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	vPortExitCritical(cpsr);
}

// 0000043C: void uxQueueSpacesAvailable(Register ptr32 cpsr)
void uxQueueSpacesAvailable(ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	vPortExitCritical(cpsr);
}

// 00000454: void vQueueDelete()
void vQueueDelete()
{
	vPortFree();
}

// 00000458: void xQueueGenericSendFromISR(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r3, Register Eq_n lr, Register ptr32 cpsr)
void xQueueGenericSendFromISR(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r3, Eq_n lr, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (*((word32) r0 + 56) < *((word32) r0 + 60) || r3 == 0x02)
	{
		int32 r4_n = (int32) (int8) (word32) *((word32) r0 + 69);
		word32 r0_n;
		word32 lr_n;
		word32 * r7_n;
		if (!prvCopyDataToQueue(r0, r1, r3, r2, lr, out r0_n, out r7_n, out lr_n))
			((word32) r0 + 69)->u0 = (byte) (int32) (int8) (r4_n + 0x01);
		else if (*((word32) r0 + 36) != 0x00 && (xTaskRemoveFromEventList((word32) r0 + 36) != 0x00 && r7_n != null))
		{
			*r7_n = 0x01;
			goto l0000047C;
		}
		__msr(cpsr, r6_n);
	}
	else
	{
l0000047C:
		__msr(cpsr, r6_n);
	}
}

// 000004C4: void xQueueGiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 word32) r1, Register ptr32 cpsr)
void xQueueGiveFromISR(struct Eq_n * r0, word32 * r1, ptr32 cpsr)
{
	Eq_n r4_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	up32 r2_n = r0->dw0038;
	if (r2_n >= r0->dw003C)
	{
		__msr(cpsr, r4_n);
		return;
	}
	int32 r3_n = (int32) (int8) (word32) r0->b0045;
	r0->dw0038 = r2_n + 0x01;
	if (r2_n != 0x01)
		r0->b0045 = (byte) (int32) (int8) (r3_n + 0x01);
	else if (r0->dw0024 != 0x00 && (xTaskRemoveFromEventList(&r0->dw0024) != 0x00 && r1 != null))
	{
		*r1 = 0x01;
l000004FA:
		__msr(cpsr, r4_n);
		return;
	}
	goto l000004FA;
}

// 00000524: void xQueueReceiveFromISR(Register Eq_n r0, Register Eq_n r1, Register (ptr32 word32) r2, Register Eq_n lr, Register ptr32 cpsr)
void xQueueReceiveFromISR(Eq_n r0, Eq_n r1, word32 * r2, Eq_n lr, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_n r4_n = *((word32) r0 + 56);
	if (r4_n != 0x00)
	{
		word32 lr_n;
		word32 r5_n;
		struct Eq_n * r7_n;
		struct Eq_n * r4_n = prvCopyDataFromQueue(r0, r1, r4_n, (int32) (int8) (word32) *((word32) r0 + 0x0044), r6_n, r0, lr, out r5_n, out r6_n, out r7_n, out lr_n);
		r7_n->dw0038 = r4_n - &globals->dw0001;
		if (r4_n != &globals->dw0001)
			r7_n->b0044 = (byte) (int32) (int8) (r5_n + 0x01);
		else if (r7_n->dw0010 != 0x00 && (xTaskRemoveFromEventList(&r7_n->dw0010) != 0x00 && r2 != null))
		{
			*r2 = 0x01;
			goto l00000542;
		}
		__msr(cpsr, r6_n);
	}
	else
	{
l00000542:
		__msr(cpsr, r6_n);
	}
}

// 00000594: void xQueueIsQueueEmptyFromISR(Register (ptr32 Eq_n) r0)
void xQueueIsQueueEmptyFromISR(struct Eq_n * r0)
{
	__clz(r0->dw0038);
}

// 000005A0: void xQueueIsQueueFullFromISR(Register (ptr32 Eq_n) r0)
void xQueueIsQueueFullFromISR(struct Eq_n * r0)
{
	__clz(r0->dw003C - r0->dw0038);
}

// 000005B0: void uxQueueMessagesWaitingFromISR()
void uxQueueMessagesWaitingFromISR()
{
}

// 000005B4: void xQueueGetMutexHolder(Register (ptr32 word32) r0, Register ptr32 cpsr)
void xQueueGetMutexHolder(word32 * r0, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	if (*r0 != 0x00)
		vPortExitCritical(cpsr);
	else
		vPortExitCritical(cpsr);
}

// 000005D4: void xQueueTakeMutexRecursive(Register Eq_n r0, Register up32 r1, Register Eq_n lr, Register ptr32 cpsr)
void xQueueTakeMutexRecursive(Eq_n r0, up32 r1, Eq_n lr, ptr32 cpsr)
{
	if (*((word32) r0 + 4) == xTaskGetCurrentTaskHandle())
		*((word32) r0 + 0x0C) = (word32) *((word32) r0 + 0x0C) + 1;
	else
	{
		word32 lr_n;
		if (xQueueGenericReceive(r0, 0x00, r1, 0x00, lr, cpsr, out lr_n) != 0x00)
			*((word32) r0 + 0x0C) = (word32) *((word32) r0 + 0x0C) + 1;
	}
}

// 00000604: void xQueueGiveMutexRecursive(Register Eq_n r0, Register Eq_n lr, Register ptr32 cpsr)
void xQueueGiveMutexRecursive(Eq_n r0, Eq_n lr, ptr32 cpsr)
{
	if (*((word32) r0 + 4) != xTaskGetCurrentTaskHandle())
		return;
	Eq_n r3_n = *((word32) r0 + 0x0C);
	*((word32) r0 + 0x0C) = r3_n - 0x01;
	if (r3_n != 0x01)
		return;
	xQueueGenericSend(r0, r3_n - 0x01, r3_n - 0x01, r3_n - 0x01, lr, cpsr);
}

// 00000630: void xQueueGenericReset(Register (ptr32 Eq_n) r0, Register word32 r1, Register ptr32 cpsr)
void xQueueGenericReset(struct Eq_n * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	ui32 r3_n = r0->dw0040;
	ui32 r2_n = r0->dw003C * r3_n;
	struct Eq_n * r0_n = r0->ptr0000;
	r0->dw0038 = 0x00;
	r0->dw0004 = r0_n + r2_n / 0x0066;
	r0->ptr0044 = &globals->tFFFFFFFF;
	r0->dw000C = r0_n + (r2_n - r3_n) / 0x0066;
	r0->ptr0008 = r0_n;
	r0->b0045 = ~0x00;
	if (r1 != 0x00)
	{
		vListInitialise(&r0->ptr0010);
		vListInitialise(&r0->ptr0024);
		vPortExitCritical(cpsr);
	}
	else if (r0->ptr0010 != null && xTaskRemoveFromEventList(&r0->ptr0010) != 0x00)
	{
		*globals->ptr06A8 = 0x10000000;
		__dsb_sy();
		__isb_sy();
		vPortExitCritical(cpsr);
	}
	else
		vPortExitCritical(cpsr);
}

// 000006AC: void xQueueGenericCreate(Register ui32 r0, Register ui32 r1, Register ptr32 cpsr)
void xQueueGenericCreate(ui32 r0, ui32 r1, ptr32 cpsr)
{
	struct Eq_n * r0_n = pvPortMalloc(r0 * r1 + 0x48, cpsr);
	if (r0_n != null)
	{
		if (r1 != 0x00)
			r0_n->ptr0000 = &r0_n->b0045 + 3;
		else
			r0_n->ptr0000 = r0_n;
		r0_n->dw003C = r0;
		r0_n->dw0040 = r1;
		xQueueGenericReset(r0_n, 0x01, cpsr);
	}
}

// 000006DC: void xQueueCreateMutex(Register Eq_n lr, Register ptr32 cpsr)
void xQueueCreateMutex(Eq_n lr, ptr32 cpsr)
{
	xQueueGenericCreate(0x01, 0x00, cpsr);
	if (0x01 != 0x00)
	{
		globals->dw0005 = 0x00;
		globals->dw0001 = 0x00;
		globals->dw000D = 0x00;
		xQueueGenericSend(0x01, 0x00, 0x00, 0x00, lr, cpsr);
	}
}

// 00000700: void prvInitialiseNewTask(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04, Stack (ptr32 Eq_n) dwArg08, Stack (ptr32 Eq_n) dwArg0C)
void prvInitialiseNewTask(ui32 r0, word32 r1, ui32 r2, word32 r3, int32 dwArg00, struct Eq_n ** dwArg04, struct Eq_n * dwArg08, struct Eq_n * dwArg0C)
{
	byte * r3_n = r1 - 0x01 + 1;
	struct Eq_n * r5_n = dwArg08->ptr0050 + (r2 + 0x3FFFFFFF << 0x02) / 0x0066 & ~0x07;
	byte * r0_n = (char *) &dwArg08->ptr0050 + 4;
	uint32 r2_n = dwArg00 & ~0x80000000;
	do
	{
		*r0_n = (byte) (word32) *r3_n;
		++r3_n;
		++r0_n;
	} while ((word32) *r3_n != 0x00 && r3_n != r1 + 0x02);
	if (r2_n >= 0x01)
		r2_n = 0x01;
	dwArg08->dw004C = r2_n;
	dwArg08->dw0058 = r2_n;
	dwArg08->b0056 = 0x00;
	dwArg08->dw005C = 0x00;
	vListInitialiseItem(&dwArg08->ptr0024);
	vListInitialiseItem(&dwArg08->dw0038);
	dwArg08->dw0038 = 0x02 - r2_n;
	struct Eq_n * r2_n = dwArg08->ptr0050;
	dwArg08->ptr0030 = dwArg08;
	dwArg08->ptr0044 = dwArg08;
	vPortStoreTaskMPUSettings(&dwArg08->dw0004, dwArg0C, r2_n, r2);
	dwArg08->dw0060 = 0x00;
	dwArg08->b0064 = 0x00;
	dwArg08->ptr0000 = pxPortInitialiseStack(r5_n, r0, r3, dwArg00 >> 0x1F);
	if (dwArg04 != null)
		*dwArg04 = (struct Eq_n **) dwArg08;
}

// 00000798: void prvAddNewTaskToReadyList(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void prvAddNewTaskToReadyList(struct Eq_n * r0, ptr32 cpsr)
{
	uint32 r0_n;
	struct Eq_n * r4_n = globals->ptr0854;
	vPortEnterCritical(cpsr);
	++r4_n->dw0000;
	if (r4_n->ptr0004 != null)
	{
		if (r4_n->dw0074 != 0x00)
		{
l000007B4:
			r0_n = r0->dw004C;
			goto l000007BA;
		}
		r0_n = r0->dw004C;
		if (r4_n->ptr0004->dw004C <= r0_n)
			r4_n->ptr0004 = r0;
	}
	else
	{
		r4_n->ptr0004 = r0;
		if (r4_n->dw0000 != 0x01)
			goto l000007B4;
		vListInitialise((char *) &r4_n->ptr0004 + 4);
		vListInitialise((char *) &r4_n->ptr0004 + 24);
		vListInitialise((char *) &r4_n->ptr0004 + 44);
		vListInitialise((char *) &r4_n->ptr0004 + 64);
		vListInitialise((char *) &r4_n->ptr0004 + 84);
		r4_n->ptr006C = (char *) &r4_n->ptr0004 + 44;
		r0_n = r0->dw004C;
		r4_n->ptr0070 = (char *) &r4_n->ptr0004 + 64;
	}
l000007BA:
	word32 r2_n = r4_n->dw0078;
	r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
	r4_n->dw0078 = r2_n + 0x01;
	vListInsertEnd((char *) &r4_n->ptr0004 + 4 + r0_n * 0x14, &r0->ptr0024);
	vPortExitCritical(cpsr);
	if (r4_n->dw0074 != 0x00 && (r4_n->ptr0004)->dw004C < r0->dw004C)
	{
		*globals->ptr0858 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
}

// 0000085C: void prvAddCurrentTaskToDelayedList.isra.0(Register up32 r0)
void prvAddCurrentTaskToDelayedList.isra.0(up32 r0)
{
	struct Eq_n * r4_n = globals->ptr08B0;
	up32 r6_n = r4_n->dw0080;
	if (uxListRemove(&r4_n->ptr0004->dw0024) == 0x00)
		r4_n->dw007C &= ~(0x01 << (r4_n->ptr0004)->dw004C);
	up32 r5_n = r0 + r6_n;
	r4_n->ptr0004->dw0024 = r5_n;
	if (r6_n > r5_n)
	{
		struct Eq_n * r0_n = r4_n->ptr0070;
		struct Eq_n * r1_n = r4_n->ptr0004;
		vListInsert(r0_n, &r1_n->dw0024);
	}
	else
	{
		vListInsert(r4_n->ptr006C, &r4_n->ptr0004->dw0024);
		if (r5_n < r4_n->dw0084)
			r4_n->dw0084 = r5_n;
	}
}

// 000008B4: Register ui32 xTaskCreate(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Register ptr32 cpsr, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04)
ui32 xTaskCreate(ui32 r0, word32 r1, ui32 r2, word32 r3, ptr32 cpsr, int32 dwArg00, struct Eq_n ** dwArg04)
{
	struct Eq_n * r0_n = pvPortMalloc(r2 << 2, cpsr);
	if (r0_n == null)
		return ~0x00;
	ui32 r0_n;
	struct Eq_n * r0_n = pvPortMalloc(0x68, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0050 = r0_n;
		r0_n->b0065 = 0x00;
		prvInitialiseNewTask(r0, r1, r2, r3, dwArg00, dwArg04, r0_n, null);
		prvAddNewTaskToReadyList(r0_n, cpsr);
		r0_n = 0x01;
	}
	else
	{
		vPortFree();
		r0_n = ~0x00;
	}
	return r0_n;
}

// 0000091C: void xTaskCreateRestricted(Register (ptr32 Eq_n) r0, Register (ptr32 (ptr32 Eq_n)) r1, Register ptr32 cpsr)
void xTaskCreateRestricted(struct Eq_n * r0, struct Eq_n ** r1, ptr32 cpsr)
{
	if (r0->ptr0014 == null)
		return;
	struct Eq_n * r0_n = pvPortMalloc(0x68, cpsr);
	if (r0_n != null)
	{
		struct Eq_n * r1_n = r0->ptr0014;
		r0_n->b0065 = 0x01;
		word32 r3_n = r0->dw000C;
		ui32 r2_n = (word32) r0->w0008;
		int32 lr_n = r0->dw0010;
		r0_n->ptr0050 = r1_n;
		prvInitialiseNewTask(r0->dw0000, r0->dw0004, r2_n, r3_n, lr_n, r1, r0_n, (char *) &r0->ptr0014 + 4);
		prvAddNewTaskToReadyList(r0_n, cpsr);
	}
}

// 00000970: void vTaskAllocateMPURegions(Register word32 r0, Register (ptr32 Eq_n) r1)
void vTaskAllocateMPURegions(word32 r0, struct Eq_n * r1)
{
	if (r0 == 0x00)
	{
		word32 r0_n = globals->ptr098C->dw0004;
		vPortStoreTaskMPUSettings(r0_n + 0x04, r1, null, 0x00);
	}
	else
		vPortStoreTaskMPUSettings(r0 + 0x04, r1, null, 0x00);
}

// 00000990: void vTaskStartScheduler(Register ptr32 cpsr)
void vTaskStartScheduler(ptr32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr09E0;
	word32 r0_n = xTaskCreate(globals->dw09E8, globals->dw09E4, 0x3B, 0x00, cpsr, 0x80000000, &r4_n->dw0084 + 1);
	if (r0_n != 0x01)
		return;
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	r4_n->dw0084 = ~0x00;
	r4_n->dw0074 = r0_n;
	r4_n->dw0080 = 0x00;
	xPortStartScheduler(cpsr);
}

// 000009EC: void vTaskEndScheduler(Register ptr32 cpsr)
void vTaskEndScheduler(ptr32 cpsr)
{
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	globals->ptr0A08->dw0074 = 0x00;
	vPortEndScheduler();
}

// 00000A0C: FlagGroup bool vTaskSuspendAll()
bool vTaskSuspendAll()
{
	struct Eq_n * r2_n = globals->ptr0A1C;
	word32 r3_n = r2_n->dw008C;
	r2_n->dw008C = r3_n + 0x01;
	return SLICE(cond(r3_n + 0x01), bool, 1);
}

// 00000A20: void xTaskGetTickCount()
void xTaskGetTickCount()
{
}

// 00000A2C: void xTaskGetTickCountFromISR()
void xTaskGetTickCountFromISR()
{
}

// 00000A38: void uxTaskGetNumberOfTasks()
void uxTaskGetNumberOfTasks()
{
}

// 00000A44: void pcTaskGetName(Register word32 r0)
void pcTaskGetName(word32 r0)
{
	if (r0 == 0x00)
		;
}

// 00000A58: void xTaskGenericNotify(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr)
void xTaskGenericNotify(struct Eq_n * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_n = (uint32) (byte) r4_n;
	if (r2 <= 0x04)
	{
		switch (r2 - 0x01)
		{
		case 0x00:
			r0->dw0060 = r1 | r0->dw0060;
			break;
		case 0x01:
			++r0->dw0060;
			if (r4_n == 0x01)
				goto l00000AA6;
			goto l00000A90;
		case 0x02:
l00000A8A:
			r0->dw0060 = r1;
			break;
		case 0x03:
			if (r4_n != 0x02)
				goto l00000A8A;
			goto l00000A92;
		}
	}
	if (r4_n == 0x01)
	{
l00000AA6:
		struct Eq_n * r5_n = globals->ptr0B04;
		uxListRemove((char *) r0 + 36);
		uint32 r0_n = r0->dw004C;
		r5_n->dw007C = r4_n << r0_n | r5_n->dw007C;
		vListInsertEnd((char *) &r5_n->ptr0004 + 4 + r0_n * 0x14, (char *) r0 + 36);
		if (r0->dw004C > (r5_n->ptr0004)->dw004C)
		{
			*globals->ptr0B08 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return;
		}
	}
l00000A90:
l00000A92:
	vPortExitCritical(cpsr);
}

// 00000B0C: void xTaskGenericNotifyFromISR(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr, Stack (ptr32 word32) dwArg00)
void xTaskGenericNotifyFromISR(struct Eq_n * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr, word32 * dwArg00)
{
	Eq_n r5_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_n = (uint32) (byte) r4_n;
	if (r2 <= 0x04)
	{
		switch (r2 - 0x01)
		{
		case 0x00:
			r0->dw0060 = r1 | r0->dw0060;
			break;
		case 0x01:
			++r0->dw0060;
			if (r4_n == 0x01)
				goto l00000B64;
			goto l00000B4E;
		case 0x02:
l00000B48:
			r0->dw0060 = r1;
			break;
		case 0x03:
			if (r4_n != 0x02)
				goto l00000B48;
			goto l00000B50;
		}
	}
	if (r4_n == 0x01)
	{
l00000B64:
		struct Eq_n * r6_n = globals->ptr0BD0;
		if (r6_n->dw008C != 0x00)
			vListInsertEnd((char *) &r6_n->ptr0004 + 84, (char *) r0 + 56);
		else
		{
			uxListRemove((char *) r0 + 36);
			uint32 r0_n = r0->dw004C;
			r6_n->dw007C = r4_n << r0_n | r6_n->dw007C;
			vListInsertEnd((char *) &r6_n->ptr0004 + 4 + r0_n * 0x14, (char *) r0 + 36);
		}
		if (r0->dw004C > (r6_n->ptr0004)->dw004C)
		{
			if (dwArg00 != null)
			{
				*dwArg00 = 0x01;
				__msr(cpsr, r5_n);
				return;
			}
			r6_n->dw0090 = 0x01;
l00000B50:
			__msr(cpsr, r5_n);
			return;
		}
	}
l00000B4E:
	goto l00000B50;
}

// 00000BD4: void xTaskNotifyWait(Register word32 r0, Register word32 r1, Register (ptr32 ui32) r2, Register up32 r3, Register ptr32 cpsr)
void xTaskNotifyWait(word32 r0, word32 r1, ui32 * r2, up32 r3, ptr32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0C58;
	vPortEnterCritical(cpsr);
	if ((word32) r4_n->ptr0004->b0064 != 0x02)
	{
		struct Eq_n * r1_n = r4_n->ptr0004;
		r1_n->dw0060 &= ~r0;
		r4_n->ptr0004->b0064 = 0x01;
		if (r3 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r3);
			*globals->ptr0C5C = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	if (r2 != null)
		*r2 = r4_n->ptr0004->dw0060;
	if ((word32) r4_n->ptr0004->b0064 != 0x01)
	{
		struct Eq_n * r3_n = r4_n->ptr0004;
		r3_n->dw0060 &= ~r1;
	}
	r4_n->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

// 00000C60: void vTaskNotifyGiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 word32) r1, Register ptr32 cpsr)
void vTaskNotifyGiveFromISR(struct Eq_n * r0, word32 * r1, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	word32 r5_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	++r0->dw0060;
	uint32 r5_n = (uint32) (byte) r5_n;
	if (r5_n == 0x01)
	{
		struct Eq_n * r7_n = globals->ptr0CFC;
		if (r7_n->dw008C != 0x00)
			vListInsertEnd((char *) &r7_n->ptr0004 + 84, (char *) r0 + 56);
		else
		{
			uxListRemove((char *) r0 + 36);
			uint32 r0_n = r0->dw004C;
			r7_n->dw007C = r5_n << r0_n | r7_n->dw007C;
			vListInsertEnd((char *) &r7_n->ptr0004 + 4 + r0_n * 0x14, (char *) r0 + 36);
		}
		if (r0->dw004C > (r7_n->ptr0004)->dw004C)
		{
			if (r1 != null)
			{
				*r1 = 0x01;
				__msr(cpsr, r6_n);
				return;
			}
			r7_n->dw0090 = 0x01;
		}
	}
	__msr(cpsr, r6_n);
}

// 00000D00: void ulTaskNotifyTake(Register word32 r0, Register up32 r1, Register ptr32 cpsr)
void ulTaskNotifyTake(word32 r0, up32 r1, ptr32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0D64;
	vPortEnterCritical(cpsr);
	if (r4_n->ptr0004->dw0060 == 0x00)
	{
		r4_n->ptr0004->b0064 = 0x01;
		if (r1 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r1);
			*globals->ptr0D68 = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	word32 r5_n = r4_n->ptr0004->dw0060;
	if (r5_n != 0x00)
	{
		if (r0 == 0x00)
			r4_n->ptr0004->dw0060 = r5_n - 0x01;
		else
			r4_n->ptr0004->dw0060 = 0x00;
	}
	r4_n->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

// 00000D6C: Register word32 xTaskIncrementTick()
word32 xTaskIncrementTick()
{
	word32 r6_n;
	struct Eq_n * r4_n = globals->ptr0E64;
	if (r4_n->dw008C != 0x00)
	{
		++r4_n->dw0098;
		r6_n = 0x00;
		goto l00000E28;
	}
	up32 r7_n = r4_n->dw0080;
	r4_n->dw0080 = r7_n + 0x01;
	if (r7_n == 0x01)
	{
		struct Eq_n * r3_n = r4_n->ptr006C;
		r4_n->ptr006C = r4_n->ptr0070;
		r4_n->ptr0070 = r3_n;
		++r4_n->dw0094;
		if (r4_n->ptr006C->dw0000 != 0x00)
		{
			r4_n->dw0084 = r4_n->ptr006C->ptr000C->ptr000C->dw0024;
			r6_n = 0x00;
			if (r7_n + 0x01 < r4_n->dw0084)
				goto l00000E14;
l00000DB2:
			r6_n = 0x00;
			word32 r8_n = globals->dw0E68;
			while (r4_n->ptr006C->dw0000 != 0x00)
			{
				struct Eq_n * r5_n = r4_n->ptr006C->ptr000C->ptr000C;
				up32 r3_n = r5_n->dw0024;
				if (r7_n + 0x01 < r3_n)
				{
					r4_n->dw0084 = r3_n;
					goto l00000E14;
				}
				uxListRemove(&r5_n->dw0024);
				if (r5_n->dw0048 != 0x00)
					uxListRemove(&r5_n->dw0024 + 5);
				uint32 r0_n = r5_n->dw004C;
				r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
				vListInsertEnd(r8_n + r0_n * 0x14, &r5_n->dw0024);
				if (r5_n->dw004C >= (r4_n->ptr0004)->dw004C)
					r6_n = 0x01;
			}
			r4_n->dw0084 = ~0x00;
l00000E14:
			if (*((char *) &(r4_n + ((r4_n->ptr0004)->dw004C * 0x14) / 0x009C)->ptr0004 + 4) >= 0x02)
				r6_n = 0x01;
l00000E28:
			if (r4_n->dw0090 != 0x00)
				r6_n = 0x01;
			return r6_n;
		}
		r4_n->dw0084 = ~0x00;
	}
	r6_n = 0x00;
	if (r7_n + 0x01 < r4_n->dw0084)
		goto l00000E14;
	goto l00000DB2;
}

// 00000E6C: Register word32 xTaskResumeAll(Register ptr32 cpsr)
word32 xTaskResumeAll(ptr32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0F40;
	vPortEnterCritical(cpsr);
	--r4_n->ptr008C;
	struct Eq_n * r5_n = r4_n->ptr008C;
	if (r5_n == null && r4_n->dw0000 != 0x00)
	{
		while (r4_n->dw0058 != 0x00)
		{
			r5_n = r4_n->ptr0064->ptr000C;
			uxListRemove((char *) r5_n + 56);
			uxListRemove((char *) r5_n + 36);
			uint32 r0_n = r5_n->dw004C;
			r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
			vListInsertEnd((char *) &r4_n->ptr0004 + 4 + r0_n * 0x14, (char *) r5_n + 36);
			if (r5_n->dw004C >= (r4_n->ptr0004)->dw004C)
				r4_n->dw0090 = 0x01;
		}
		if (r5_n != null)
		{
			if (r4_n->ptr006C->dw0000 == 0x00)
				r4_n->dw0084 = ~0x00;
			else
				r4_n->dw0084 = r4_n->ptr006C->ptr000C->ptr000C->dw0024;
		}
		word32 r5_n = r4_n->dw0098;
		if (r5_n != 0x00)
		{
			do
			{
				if (xTaskIncrementTick() != 0x00)
					r4_n->dw0090 = 0x01;
				--r5_n;
			} while (r5_n != 0x00);
			r4_n->dw0098 = r5_n;
		}
		if (r4_n->dw0090 != 0x00)
		{
			*globals->ptr0F44 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return 0x01;
		}
	}
	vPortExitCritical(cpsr);
	return 0x00;
}

// 00000F48: void vTaskDelay(Register up32 r0, Register ptr32 cpsr)
void vTaskDelay(up32 r0, ptr32 cpsr)
{
	if (r0 != 0x00)
	{
		struct Eq_n * r2_n = globals->ptr0F7C;
		++r2_n->dw008C;
		prvAddCurrentTaskToDelayedList.isra.0(r0);
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
	}
	*globals->ptr0F78 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

// 00000F80: void vTaskDelayUntil(Register (ptr32 up32) r0, Register word32 r1, Register ptr32 cpsr)
void vTaskDelayUntil(up32 * r0, word32 r1, ptr32 cpsr)
{
	struct Eq_n * r2_n = globals->ptr0FD4;
	up32 r3_n = *r0;
	++r2_n->dw008C;
	up32 r2_n = r2_n->dw0080;
	up32 r1_n = r1 + r3_n;
	if (r2_n < r3_n)
	{
		if (r3_n <= r1_n)
			goto l00000F9E;
	}
	else if (r3_n > r1_n)
		goto l00000FC0;
	if (r2_n >= r1_n)
	{
l00000F9E:
		*r0 = r1_n;
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
		goto l00000FA6;
	}
l00000FC0:
	*r0 = r1_n;
	prvAddCurrentTaskToDelayedList.isra.0(r1_n - r2_n);
	if (xTaskResumeAll(cpsr) != 0x00)
		return;
l00000FA6:
	*globals->ptr0FD8 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

// 00000FDC: void vTaskPlaceOnEventList(Register (ptr32 Eq_n) r0, Register up32 r1)
void vTaskPlaceOnEventList(struct Eq_n * r0, up32 r1)
{
	vListInsert(r0, globals->ptr0FF4->dw0004 + 0x38);
	prvAddCurrentTaskToDelayedList.isra.0(r1);
}

// 00000FF8: void vTaskPlaceOnUnorderedEventList(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2)
void vTaskPlaceOnUnorderedEventList(struct Eq_n * r0, ui32 r1, up32 r2)
{
	struct Eq_n * r3_n = globals->ptr1018;
	struct Eq_n * r3_n = r3_n->ptr0004;
	r3_n->ptr0004->dw0038 = r1 | 0x80000000;
	vListInsertEnd(r0, &r3_n->dw0038);
	prvAddCurrentTaskToDelayedList.isra.0(r2);
}

// 0000101C: Register (ptr32 Eq_n) xTaskRemoveFromEventList(Register (ptr32 Eq_n) r0)
struct Eq_n * xTaskRemoveFromEventList(struct Eq_n * r0)
{
	struct Eq_n * r0_n;
	struct Eq_n * r4_n = globals->ptr107C;
	struct Eq_n * r5_n = r0->ptr000C->ptr000C;
	uxListRemove((char *) r5_n + 56);
	if (r4_n->dw008C == 0x00)
	{
		uxListRemove((char *) r5_n + 36);
		uint32 r0_n = r5_n->dw004C;
		r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
		r0_n = (struct Eq_n *) ((char *) &r4_n->ptr0004 + 4 + r0_n * 0x14);
		vListInsertEnd(r0_n, (char *) r5_n + 36);
	}
	else
	{
		vListInsertEnd((char *) &r4_n->ptr0004 + 84, (char *) r5_n + 56);
		r0_n = (struct Eq_n *) ((char *) &r4_n->ptr0004 + 84);
	}
	if (r5_n->dw004C > (r4_n->ptr0004)->dw004C)
		r0_n = &globals->dw0001;
	r4_n->ptr0090 = r0_n;
	return null;
}

// 00001080: void xTaskRemoveFromUnorderedEventList(Register (ptr32 Eq_n) r0, Register ui32 r1)
void xTaskRemoveFromUnorderedEventList(struct Eq_n * r0, ui32 r1)
{
	struct Eq_n * r6_n = r0->ptr000C;
	r0->dw0000 = r1 | 0x80000000;
	uxListRemove(r0);
	struct Eq_n * r4_n = globals->ptr10D4;
	uxListRemove((char *) r6_n + 36);
	uint32 r3_n = r6_n->dw004C;
	r4_n->dw007C = 0x01 << r3_n | r4_n->dw007C;
	vListInsertEnd((char *) &r4_n->ptr0004 + 4 + r3_n * 0x14, (char *) r6_n + 36);
	r6_n->dw004C <= (r4_n->ptr0004)->dw004C;
	r4_n->dw0090 = 0x01;
}

// 000010D8: void vTaskSwitchContext()
void vTaskSwitchContext()
{
	struct Eq_n * r2_n = globals->ptr111C;
	word32 r3_n = r2_n->dw008C;
	if (r3_n != 0x00)
		r2_n->dw0090 = 0x01;
	else
	{
		struct Eq_n * r1_n;
		r2_n->dw0090 = r3_n;
		struct Eq_n * r0_n = r2_n + ((0x1F - (uint32) ((byte) __clz(r2_n->dw007C))) * 0x14) / 0x0094;
		struct Eq_n * r1_n = r0_n->ptr000C->ptr0004;
		r0_n->ptr000C = r1_n;
		r1_n = r1_n;
		if (r1_n == (char *) (&r0_n->ptr000C) + 4)
			r1_n = r1_n->ptr0004;
		word32 r3_n = r1_n->dw000C;
		if (r1_n == (char *) (&r0_n->ptr000C) + 4)
			r0_n->ptr000C = r1_n;
		r2_n->dw0004 = r3_n;
	}
}

// 00001120: Register word32 uxTaskResetEventItemValue()
word32 uxTaskResetEventItemValue()
{
	struct Eq_n * r3_n = globals->ptr1134;
	word32 r0_n = r3_n->ptr0004->dw0038;
	r3_n->ptr0004->dw0038 = 0x02 - (r3_n->ptr0004)->dw004C;
	return r0_n;
}

// 00001138: Register word32 xTaskGetCurrentTaskHandle()
word32 xTaskGetCurrentTaskHandle()
{
	return globals->ptr1140->dw0004;
}

// 00001144: void vTaskSetTimeOutState(Register (ptr32 Eq_n) r0)
void vTaskSetTimeOutState(struct Eq_n * r0)
{
	struct Eq_n * r3_n = globals->ptr1154;
	word32 r3_n = r3_n->dw0080;
	r0->dw0000 = r3_n->dw0094;
	r0->dw0004 = r3_n;
}

// 00001158: Register (ptr32 Eq_n) xTaskCheckForTimeOut(Register (ptr32 Eq_n) r0, Register (ptr32 up32) r1, Register ptr32 cpsr)
struct Eq_n * xTaskCheckForTimeOut(struct Eq_n * r0, up32 * r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	struct Eq_n * r3_n = globals->ptr11A8;
	up32 r5_n = r3_n->dw0080;
	up32 r0_n = r0->dw0004;
	if (r0->dw0000 == r3_n->dw0094 || r5_n < r0_n)
	{
		up32 r2_n = *r1;
		if (r5_n - r0_n < r2_n)
		{
			word32 r1_n = r3_n->dw0094;
			up32 r3_n = r3_n->dw0080;
			*r1 = r2_n - r5_n + r0_n;
			r0->dw0000 = r1_n;
			r0->dw0004 = r3_n;
			vPortExitCritical(cpsr);
			return null;
		}
	}
	vPortExitCritical(cpsr);
	return &globals->dw0001;
}

// 000011AC: void vTaskMissedYield()
void vTaskMissedYield()
{
	globals->ptr11B8->dw0090 = 0x01;
}

// 000011BC: void vTaskPriorityInherit(Register Eq_n r0)
void vTaskPriorityInherit(Eq_n r0)
{
	if (r0 == 0x00)
		return;
	struct Eq_n * r4_n = globals->ptr1248;
	uint32 r3_n = *((word32) r0 + 76);
	if (r3_n >= (r4_n->ptr0004)->dw004C)
		return;
	if (*((word32) r0 + 56) >= 0x00)
		*((word32) r0 + 56) = 0x02 - (r4_n->ptr0004)->dw004C;
	word32 r5_n = globals->dw124C;
	if (*((word32) r0 + 52) == r5_n + r3_n * 0x14)
	{
		if (uxListRemove((word32) r0 + 36) == 0x00)
		{
			uint32 r2_n = *((word32) r0 + 76);
			if (*((char *) &(r4_n + (r2_n * 0x14) / 0x0080)->ptr0004 + 4) == 0x00)
				r4_n->dw007C &= ~(0x01 << r2_n);
		}
		uint32 r2_n = r4_n->ptr0004->dw004C;
		ui32 r3_n = 0x01 << r2_n | r4_n->dw007C;
		*((word32) r0 + 76) = r2_n;
		r4_n->dw007C = r3_n;
		struct Eq_n * r0_n = r5_n + r2_n * 0x14;
		vListInsertEnd(r0_n, (word32) r0 + 36);
	}
	else
		*((word32) r0 + 76) = r4_n->ptr0004->dw004C;
}

// 00001250: Register Eq_n xTaskPriorityDisinherit(Register Eq_n r0, Register out Eq_n lrOut)
Eq_n xTaskPriorityDisinherit(Eq_n r0, union Eq_n & lrOut)
{
	if (r0 == 0x00)
	{
		lrOut = lr;
		return 0x00;
	}
	else
	{
		uint32 r1_n = *((word32) r0 + 76);
		word32 r3_n = *((word32) r0 + 92);
		uint32 r2_n = *((word32) r0 + 88);
		*((word32) r0 + 92) = r3_n - 0x01;
		if (r1_n == r2_n || r3_n != 0x01)
		{
			lrOut = lr;
			return 0x00;
		}
		else
		{
			struct Eq_n * r2_n;
			if (uxListRemove((word32) r0 + 36) == 0x00)
			{
				uint32 r1_n = *((word32) r0 + 76);
				r2_n = globals->ptr12CC;
				if (*((char *) (r2_n + (r1_n * 0x14) / 0x0080) + 8) == 0x00)
					r2_n->t007C &= ~(0x01 << r1_n);
			}
			else
				r2_n = globals->ptr12CC;
			uint32 r3_n = *((word32) r0 + 88);
			Eq_n lr_n = r2_n->t007C;
			word32 r0_n = globals->dw12D0;
			*((word32) r0 + 76) = r3_n;
			*((word32) r0 + 56) = 0x02 - r3_n;
			r2_n->t007C = 0x01 << r3_n | lr_n;
			vListInsertEnd(r0_n + r3_n * 0x14, (word32) r0 + 36);
			lrOut = lr_n;
			return 0x01;
		}
	}
}

// 000012D4: Register (ptr32 Eq_n) pvTaskIncrementMutexHeldCount()
struct Eq_n * pvTaskIncrementMutexHeldCount()
{
	struct Eq_n * r3_n = globals->ptr12E8;
	if (r3_n->ptr0004 != null)
	{
		struct Eq_n * r1_n = r3_n->ptr0004;
		++r1_n->dw005C;
	}
	return r3_n->ptr0004;
}

// 000012F0: void prvRestoreContextOfFirstTask(Register ptr32 cpsr)
void prvRestoreContextOfFirstTask(ptr32 cpsr)
{
	__msr(cpsr, **globals->ptr1724);
	struct Eq_n * r1_n = *globals->ptr1330;
	union Eq_n * r0_n = r1_n->ptr0000;
	struct Eq_n * r2_n = globals->ptr1728;
	word32 r5_n = r1_n->dw0008;
	word32 r6_n = r1_n->dw000C;
	word32 r7_n = r1_n->dw0010;
	word32 r8_n = r1_n->dw0014;
	word32 r9_n = r1_n->dw0018;
	word32 r10_n = r1_n->dw001C;
	word32 fp_n = r1_n->dw0020;
	r2_n->dw0000 = r1_n->dw0004;
	r2_n->dw0004 = r5_n;
	r2_n->dw0008 = r6_n;
	r2_n->dw000C = r7_n;
	r2_n->dw0010 = r8_n;
	r2_n->dw0014 = r9_n;
	r2_n->dw0018 = r10_n;
	r2_n->dw001C = fp_n;
	__msr(cpsr, *r0_n);
	__msr(cpsr, (char *) r0_n + 36);
	__msr(cpsr, 0x00);
}

// 00001334: void prvSVCHandler(Register Eq_n r0, Register ptr32 cpsr)
void prvSVCHandler(Eq_n r0, ptr32 cpsr)
{
	up32 r3_n = (word32) *((word32) *((word32) r0 + 24) - 2);
	if (r3_n == 0x01)
	{
		*globals->ptr1378 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	else if (r3_n < 0x01)
	{
		ui32 * r2_n = globals->ptr1374;
		*r2_n |= 0xBE000000;
		prvRestoreContextOfFirstTask(cpsr);
	}
	else
	{
		if (r3_n != 0x02)
			return;
		__msr(cpsr, __mrs(cpsr) & ~0x01);
	}
}

// 0000137C: Register (ptr32 Eq_n) pxPortInitialiseStack(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 r2, Register int32 r3)
struct Eq_n * pxPortInitialiseStack(struct Eq_n * r0, ui32 r1, word32 r2, int32 r3)
{
	int32 r3_n;
	r3_n = r3;
	if (r3 == 0x01)
		r3_n = 0x02;
	if (r3 != 0x01)
		r3_n = 0x03;
	r0->dwFFFFFFE0 = r2;
	r0->dwFFFFFFF8 = r1 & ~0x01;
	r0->dwFFFFFFFC = 0x01000000;
	r0->dwFFFFFFF4 = 0x00;
	r0->dwFFFFFFBC = r3_n;
	return r0 - 0x44;
}

// 000013B0: void xPortStartScheduler(Register ptr32 cpsr)
void xPortStartScheduler(ptr32 cpsr)
{
	ui32 * r3_n = globals->ptr14E8;
	word32 * r1_n = globals->ptr14EC;
	*r3_n |= 0x00FF0000;
	*r3_n |= 0xFF000000;
	if (*r1_n == 0x0800)
	{
		ui32 r2_n;
		ui32 r0_n = globals->dw14FC;
		uint32 r1_n = globals->dw1500 - r0_n;
		*globals->ptr1504 = r0_n | 0x10;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1508 | r2_n << 0x01;
					goto l0000142C;
				}
			}
			r2_n = globals->dw1538;
		}
		else
			r2_n = globals->dw1548;
l0000142C:
		ui32 r2_n;
		uint32 r1_n = globals->dw150C - r0_n;
		ui32 * r3_n = globals->ptr1504;
		globals->ptr1510->dw0000 = r2_n;
		*r3_n = r0_n | 0x11;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1514 | r2_n << 0x01;
					goto l0000145A;
				}
			}
			r2_n = globals->dw153C;
		}
		else
			r2_n = globals->dw1544;
l0000145A:
		ui32 r0_n;
		ui32 r3_n = globals->dw1518;
		ui32 * r0_n = globals->ptr1504;
		uint32 r1_n = globals->dw151C - r3_n;
		globals->ptr1510->dw0000 = r2_n;
		*r0_n = r3_n | 0x12;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r0_n = globals->dw1520 | r2_n << 0x01;
					goto l0000148A;
				}
			}
			r0_n = globals->dw1540;
		}
		else
			r0_n = globals->dw154C;
l0000148A:
		ui32 * r4_n = globals->ptr1504;
		ui32 r5_n = globals->dw1524;
		uint32 r1_n = globals->dw1528;
		globals->ptr1510->dw0000 = r0_n;
		*r4_n = r5_n;
		ui32 r3_n = 0x05;
		uint32 r2_n = 0x40;
		do
		{
			ui32 r3_n;
			++r3_n;
			r2_n <<= 0x01;
			if (r3_n == 0x1F)
			{
				r3_n = globals->dw1534;
				goto l000014AE;
			}
		} while (r2_n <= r1_n);
		r3_n = globals->dw152C | r3_n << 0x01;
l000014AE:
		struct Eq_n * r2_n = globals->ptr1510;
		ui32 * r1_n = globals->ptr1530;
		r2_n->dw0000 = r3_n;
		*r1_n |= 0x00010000;
		r2_n->dwFFFFFFF4 |= 0x05;
	}
	word32 * r2_n = globals->ptr14F4;
	word32 * r3_n = globals->ptr14F8;
	*globals->ptr14F0 = 19999;
	*r2_n = 0x07;
	*r3_n = 0x00;
	__msr(cpsr, **globals->ptr1724);
	__cps();
	__cps();
	__dsb_sy();
	__isb_sy();
	__syscall(0x00);
}

// 00001550: void vPortEndScheduler()
void vPortEndScheduler()
{
}

// 00001554: void vPortStoreTaskMPUSettings(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 Eq_n) r2, Register ui32 r3)
void vPortStoreTaskMPUSettings(struct Eq_n * r0, struct Eq_n * r1, struct Eq_n * r2, ui32 r3)
{
	if (r1 == null)
	{
		ui32 r2_n;
		ui32 r3_n = globals->dw1668;
		uint32 r1_n = globals->dw166C - r3_n;
		r0->dw0000 = r3_n | 0x14;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r3_n >= r1_n)
				{
					r2_n = globals->dw1660 | r2_n << 0x01;
					goto l00001608;
				}
			}
			r2_n = globals->dw1664;
		}
		else
			r2_n = globals->dw1680;
l00001608:
		ui32 r2_n;
		ui32 r3_n = globals->dw1670;
		uint32 r1_n = globals->dw1674 - r3_n;
		r0->dw0004 = r2_n;
		r0[1] = (struct Eq_n) (r3_n | 0x15);
		if (r1_n > 0x20)
		{
			ui32 r2_n;
			uint32 r3_n = 0x40;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1678 | r2_n << 0x01;
					goto l00001634;
				}
			}
			r2_n = globals->dw167C;
		}
		else
			r2_n = globals->dw1684;
l00001634:
		r0[2] = (struct Eq_n) 22;
		r0->dw000C = r2_n;
		r0->dw0014 = 0x00;
		r0->dw001C = 0x00;
		r0[3] = (struct Eq_n) 0x17;
	}
	else
	{
		if (r3 != 0x00)
		{
			ui32 r4_n;
			r0->dw0000 = r2 | 0x14;
			if (r3 << 2 > 0x20)
			{
				uint32 r2_n = 0x40;
				ui32 r4_n;
				for (r4_n = 0x05; r4_n != 0x1F; ++r4_n)
				{
					r2_n <<= 0x01;
					if (r3 << 2 <= r2_n)
					{
						r4_n = globals->dw1660 | r4_n << 0x01;
						goto l000015D6;
					}
				}
				r4_n = globals->dw1664;
			}
			else
				r4_n = globals->dw1680;
l000015D6:
			r0->dw0004 = r4_n;
		}
		ui32 r5_n;
		for (r5_n = 0x05; r5_n != 0x08; ++r5_n)
		{
			uint32 r4_n = r1->dw0004;
			if (r4_n != 0x00)
			{
				ui32 r3_n;
				r0[1] = (struct Eq_n) (r1->dw0000 | (r5_n | 0x10));
				if (r4_n > 0x20)
				{
					uint32 r2_n = 0x40;
					ui32 r3_n;
					for (r3_n = 0x05; r3_n != 0x1F; ++r3_n)
					{
						r2_n <<= 0x01;
						if (r4_n <= r2_n)
						{
							r3_n = r3_n << 1;
							goto l00001586;
						}
					}
					r3_n = 0x3E;
				}
				else
					r3_n = 0x08;
l00001586:
				r0->dw000C = r3_n | (r1->dw0008 | 0x01);
			}
			else
			{
				r0->dw000C = r4_n;
				r0[1] = (struct Eq_n) (r5_n | 0x10);
			}
			++r1;
			++r0;
		}
	}
}

// 00001688: void xPortPendSVHandler(Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 r9, Register word32 r10, Register word32 fp, Register ptr32 cpsr)
void xPortPendSVHandler(word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 r9, word32 r10, word32 fp, ptr32 cpsr)
{
	Eq_n r0_n = __mrs(cpsr);
	struct Eq_n ** r3_n = globals->ptr16E0;
	struct Eq_n * r2_n = *r3_n;
	*((word32) r0_n - 36) = __mrs(cpsr);
	*((word32) r0_n - 32) = r4;
	*((word32) r0_n - 28) = r5;
	*((word32) r0_n - 24) = r6;
	*((word32) r0_n - 20) = r7;
	*((word32) r0_n - 16) = r8;
	*((word32) r0_n - 0x0C) = r9;
	*((word32) r0_n - 8) = r10;
	*((word32) r0_n - 4) = fp;
	r2_n->ptr0000 = r0_n - 36;
	__msr(cpsr, 191);
	vTaskSwitchContext();
	__msr(cpsr, 0x00);
	struct Eq_n * r1_n = *r3_n;
	union Eq_n * r0_n = r1_n->ptr0000;
	struct Eq_n * r2_n = globals->ptr1728;
	word32 r5_n = r1_n->dw0008;
	word32 r6_n = r1_n->dw000C;
	word32 r7_n = r1_n->dw0010;
	word32 r8_n = r1_n->dw0014;
	word32 r9_n = r1_n->dw0018;
	word32 r10_n = r1_n->dw001C;
	word32 fp_n = r1_n->dw0020;
	r2_n->dw0000 = r1_n->dw0004;
	r2_n->dw0004 = r5_n;
	r2_n->dw0008 = r6_n;
	r2_n->dw000C = r7_n;
	r2_n->dw0010 = r8_n;
	r2_n->dw0014 = r9_n;
	r2_n->dw0018 = r10_n;
	r2_n->dw001C = fp_n;
	__msr(cpsr, *r0_n);
	__msr(cpsr, (char *) r0_n + 36);
}

// 000016E4: void xPortSysTickHandler(Register ptr32 cpsr)
void xPortSysTickHandler(ptr32 cpsr)
{
	Eq_n r4_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (xTaskIncrementTick() != 0x00)
		*globals->ptr1710 = 0x10000000;
	__msr(cpsr, r4_n);
}

// 00001714: void vPortSVCHandler(Register ui32 lr, Register ptr32 cpsr)
void vPortSVCHandler(ui32 lr, ptr32 cpsr)
{
	if ((lr & 0x04) == 0x00)
		__mrs(cpsr);
	Eq_n r0_n = __mrs(cpsr);
	prvSVCHandler(r0_n, cpsr);
}

// 0000172C: Register ui32 pvPortMalloc(Register ui32 r0, Register ptr32 cpsr)
ui32 pvPortMalloc(ui32 r0, ptr32 cpsr)
{
	ui32 r4_n = r0;
	if (r0 << 29 != 0x00)
		r4_n = r0 & ~0x07;
	vTaskSuspendAll();
	struct Eq_n * r3_n = globals->ptr177C;
	word32 r4_n = r4_n + 0x08;
	if (r3_n->dw0000 == 0x00)
		Mem28[r3_n + 0x00:word32] = r3_n + 0x0C & ~0x07;
	up32 r2_n = r3_n->dw05C0;
	up32 r4_n = r4_n + r2_n;
	if (r4_n > 0x05B3 || r2_n >= r4_n)
	{
		xTaskResumeAll(cpsr);
		return 0x00;
	}
	else
	{
		ui32 r1_n = r3_n->dw0000;
		r3_n->dw05C0 = r4_n;
		xTaskResumeAll(cpsr);
		return r1_n + r2_n;
	}
}

// 00001780: void vPortFree()
void vPortFree()
{
}

// 00001784: void vPortInitialiseBlocks()
void vPortInitialiseBlocks()
{
	globals->ptr1790->dw05C0 = 0x00;
}

// 00001794: void xPortGetFreeHeapSize()
void xPortGetFreeHeapSize()
{
}

// 000017A8: void xEventGroupCreate(Register ptr32 cpsr)
void xEventGroupCreate(ptr32 cpsr)
{
	struct Eq_n * r0_n = pvPortMalloc(0x18, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0000 = null;
		vListInitialise(&r0_n->dw0004);
	}
}

// 000017C4: void xEventGroupWaitBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 r2, Register word32 r3, Register ptr32 cpsr, Stack up32 dwArg00)
void xEventGroupWaitBits(ui32 * r0, ui32 r1, word32 r2, word32 r3, ptr32 cpsr, up32 dwArg00)
{
	Eq_n C_n = vTaskSuspendAll();
	ui32 r5_n = r1;
	ui32 r4_n = *r0;
	if (r3 == 0x00)
	{
		r4_n = (word32) C_n + (r4_n + r1);
		if (r4_n != 0x00)
		{
l000017DC:
			if (r2 != 0x00)
				*r0 = r4_n & ~r1;
l000017E8:
			xTaskResumeAll(cpsr);
			return;
		}
	}
	else if ((r1 & ~r4_n) == 0x00)
		goto l000017DC;
	if (dwArg00 == 0x00)
		goto l000017E8;
	ui32 r1_n = 0x01000000;
	if (r3 != 0x00)
		r1_n = 0x05000000;
	vTaskPlaceOnUnorderedEventList(r0 + 1, r1_n | r1, dwArg00);
	if (xTaskResumeAll(cpsr) == 0x00)
	{
		*globals->ptr1870 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	if (uxTaskResetEventItemValue() << 6 < 0x00)
		return;
	bool C_n = vPortEnterCritical(cpsr);
	ui32 r4_n = *r0;
	if (r3 == 0x00)
	{
		r5_n = r1 + r4_n + C_n;
		if (r5_n == 0x00)
			goto l0000185C;
	}
	else if ((r1 & ~r4_n) != 0x00)
		goto l0000185C;
	if (r2 != 0x00)
		*r0 = r4_n & ~r5_n;
l0000185C:
	vPortExitCritical(cpsr);
}

// 00001874: void xEventGroupClearBits(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
void xEventGroupClearBits(ui32 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	*r0 &= ~r1;
	vPortExitCritical(cpsr);
}

// 00001890: void xEventGroupSetBits(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ptr32 cpsr)
void xEventGroupSetBits(struct Eq_n * r0, ui32 r1, ptr32 cpsr)
{
	ui32 r7_n;
	vTaskSuspendAll();
	struct Eq_n * r0_n = r0->ptr0010;
	ui32 r1_n = r0->dw0000 | r1;
	r0->dw0000 = r1_n;
	if (&r0->dw0000 + 3 != r0_n)
	{
		ui32 r7_n = 0x00;
		do
		{
			ui32 r3_n = r0_n->dw0000;
			struct Eq_n * r4_n = r0_n->ptr0004;
			ui32 r2_n = r3_n & ~0xFF000000;
			if ((r3_n & 0x04000000) == 0x00)
			{
				r2_n = r2_n + r1_n + ((r3_n & 0x04000000) < 0x00);
				if (r2_n != 0x00)
				{
l000018B2:
					if (r3_n << 7 < 0x00)
						r7_n |= r2_n;
					xTaskRemoveFromUnorderedEventList(r0_n, r1_n | 0x02000000);
					r1_n = r0->dw0000;
				}
				r0_n = r4_n;
				if (&r0->dw0000 + 3 != r4_n)
					continue;
				break;
			}
			if ((r2_n & ~r1_n) == 0x00)
				goto l000018B2;
			r0_n = r4_n;
		} while (&r0->dw0000 + 3 != r4_n);
		r7_n = ~r7_n;
	}
	else
		r7_n = ~0x00;
	r0->dw0000 = r1_n & r7_n;
	xTaskResumeAll(cpsr);
}

// 000018F8: void xEventGroupSync(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register up32 r3, Register ptr32 cpsr)
void xEventGroupSync(struct Eq_n * r0, ui32 r1, ui32 r2, up32 r3, ptr32 cpsr)
{
	vTaskSuspendAll();
	ui32 r4_n = r0->dw0000 | r1;
	xEventGroupSetBits(r0, r1, cpsr);
	ui32 r6_n = r2;
	if ((r2 & ~r4_n) != 0x00)
	{
		if (r3 != 0x00)
		{
			vTaskPlaceOnUnorderedEventList(&r0->dw0000 + 1, r2 | 0x05000000, r3);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*globals->ptr1984 = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
			if (uxTaskResetEventItemValue() << 6 >= 0x00)
			{
				vPortEnterCritical(cpsr);
				ui32 r4_n = r0->dw0000;
				if ((r2 & ~r4_n) == 0x00)
					r6_n = r4_n & ~r2;
				r0->dw0000 = r6_n;
				vPortExitCritical(cpsr);
			}
			return;
		}
	}
	else
		r0->dw0000 &= ~r2;
	xTaskResumeAll(cpsr);
}

// 00001988: void xEventGroupGetBitsFromISR(Register ptr32 cpsr)
void xEventGroupGetBitsFromISR(ptr32 cpsr)
{
	Eq_n r3_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	__msr(cpsr, r3_n);
}

// 000019A4: void vEventGroupDelete(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void vEventGroupDelete(struct Eq_n * r0, ptr32 cpsr)
{
	vTaskSuspendAll();
	while (r0->dw0004 != 0x00)
		xTaskRemoveFromUnorderedEventList(r0->ptr0010, 0x02000000);
	vPortFree();
	xTaskResumeAll(cpsr);
}

// 000019D0: void vEventGroupSetBitsCallback(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ptr32 cpsr)
void vEventGroupSetBitsCallback(struct Eq_n * r0, ui32 r1, ptr32 cpsr)
{
	xEventGroupSetBits(r0, r1, cpsr);
}

// 000019D4: void vEventGroupClearBitsCallback(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
void vEventGroupClearBitsCallback(ui32 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	*r0 &= ~r1;
	vPortExitCritical(cpsr);
}

