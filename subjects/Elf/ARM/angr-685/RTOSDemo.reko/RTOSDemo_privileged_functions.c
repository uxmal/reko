// RTOSDemo_privileged_functions.c
// Generated by decompiling RTOSDemo.axf
// using Reko decompiler version 0.10.2.0.

#include "RTOSDemo.h"

Eq_n g_t0000 = // 00000000
	{
		&g_t2000022C,
		0x8009,
		&g_t8001,
		0x8005,
		null,
		0x00,
		null,
		0x1715,
		null,
		0x00,
		0x1689,
		0x16E5,
		0x00,
		null,
		0x00,
		0x00,
		null,
		0x00,
		0x4605B570,
		0xFA8CF008,
		0x4045F895,
		100,
		0xB2,
	};
word32 g_dw0001 = 0x09200002; // 00000001
word32 g_dw0005 = 0x01000080; // 00000005
Eq_n g_t0008 = // 00000008
	{
		&g_t8001,
		0x8005,
		null,
		0x00,
		null,
		0x00,
		&g_t1715,
		0x00,
		&g_t1689,
		0x16E5,
		0x00,
		0x00,
		0x00,
		null,
		0x00,
		33033,
		&g_t4605B570,
		0x8C,
		0x4045F895,
		0x2C00B264,
		0x6A6BDD16,
		0xA3,
		177,
	};
word32 g_dw000D = 0x80; // 0000000D
// 00000058: void prvUnlockQueue(Register Eq_n r0, Register ptr32 cpsr)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
void prvUnlockQueue(Eq_n r0, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	int32 r4_n = (int32) *((word32) r0 + 69);
	if (r4_n > 0x00 && *((word32) r0 + 36) != 0x00)
	{
		do
		{
			if (xTaskRemoveFromEventList((word32) r0 + 36) != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_n = (uint32) ((byte) r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
			else
			{
				uint32 r3_n = (uint32) ((byte) r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
		} while (*((word32) r0 + 36) != 0x00);
	}
	*((word32) r0 + 69) = ~0x00;
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	int32 r4_n = (int32) *((word32) r0 + 0x0044);
	if (r4_n > 0x00 && *((word32) r0 + 16) != 0x00)
	{
		do
		{
			if (xTaskRemoveFromEventList((word32) r0 + 16) != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_n = (uint32) ((byte) r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
			else
			{
				uint32 r3_n = (uint32) ((byte) r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
		} while (*((word32) r0 + 16) != 0x00);
	}
	((word32) r0 + 0x0044)->u0 = ~0x00;
	vPortExitCritical(cpsr);
}

// 000000EC: FlagGroup bool prvCopyDataToQueue(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r7, Register Eq_n lr, Register out Eq_n r0Out, Register out Eq_n r7Out, Register out Eq_n lrOut)
// Called from:
//      xQueueGenericSend
//      xQueueGenericSendFromISR
//      xQueueCRSend
//      xQueueCRSendFromISR
bool prvCopyDataToQueue(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r7, Eq_n lr, union Eq_n & r0Out, union Eq_n & r7Out, union Eq_n & lrOut)
{
	bool Z_n;
	Eq_n r5_n;
	Eq_n r4_n = r0;
	Eq_n r0_n = *((word32) r0 + 64);
	Eq_n r5_n = *((word32) r0 + 56);
	if (r0_n == 0x00)
	{
		Eq_n r6_n = *r0;
		if (r6_n != 0x00)
		{
			r5_n = (word32) r5_n + 1;
			Z_n = SLICE(cond((word32) r5_n + 1), bool, 2);
		}
		else
		{
			r0_n = xTaskPriorityDisinherit(*((word32) r0 + 4), out lr);
			*((word32) r0 + 4) = r6_n;
			r5_n = (word32) r5_n + 1;
			Z_n = SLICE(cond((word32) r5_n + 1), bool, 2);
		}
	}
	else
	{
		if (r2 == 0x00)
		{
			Eq_n lr_n;
			struct Eq_n * r4_n;
			word32 r5_n;
			Eq_n r6_n;
			Eq_n r7_n;
			memcpy(*((word32) r0 + 8), r1, r0_n, r0, r5_n, r2, r7, lr, out r4_n, out r5_n, out r6_n, out r7_n, out lr_n);
			up32 r2_n = r4_n->dw0004;
			up32 r3_n = r4_n->dw0008 + r4_n->dw0040;
			r4_n->dw0008 = r3_n;
			if (r3_n < r2_n)
			{
				r4_n->dw0038 = r5_n + 0x01;
				r0Out = r6_n;
				r7Out = r7_n;
				lrOut = lr_n;
				return SLICE(cond(r5_n + 0x01), bool, 2);
			}
			else
			{
				r4_n->dw0008 = r4_n->dw0000;
				r4_n->dw0038 = r5_n + 0x01;
				r0Out = r6_n;
				r7Out = r7_n;
				lrOut = lr_n;
				return SLICE(cond(r5_n + 0x01), bool, 2);
			}
		}
		word32 r6_n;
		memcpy(*((word32) r0 + 0x0C), r1, r0_n, r0, r5_n, r2, r7, lr, out r4_n, out r5_n, out r6_n, out r7, out lr);
		Eq_n r3_n = *((word32) r4_n + 0x0C);
		Eq_n r1_n = *r4_n;
		*((word32) r4_n + 0x0C) = r3_n;
		if (r3_n < r1_n)
			*((word32) r4_n + 0x0C) = *((word32) r4_n + 4);
		Z_n = SLICE(cond(r6_n - 0x02), bool, 2);
		if (r6_n != 0x02)
		{
			*((word32) r4_n + 56) = (word32) r5_n + 1;
			r0Out.u0 = 0x00;
			r7Out = r7;
			lrOut = lr;
			return SLICE(cond((word32) r5_n + 1), bool, 2);
		}
		if (r5_n == 0x00)
			r5_n.u0 = 0x01;
		r0_n.u0 = 0x00;
	}
	*((word32) r4_n + 56) = r5_n;
	r0Out = r0_n;
	r7Out = r7;
	lrOut = lr;
	return Z_n;
}

Eq_n g_t00FF = // 000000FF
	{
		&g_t16BD7063,
		2118517318,
		&g_tA68A0B9,
		~0x5C05A40F,
		&g_t626C2168,
		425763650,
		&g_t7063A560,
		586828784,
		&g_t5268E36C,
		0x2142,
		0xE3428B44,
		0x63D20260,
		0xE2441A68,
		&g_t72E0260,
		0x02,
		1885578528,
		&g_t303501BD,
		99,
		0x01B905BD,
		0xCE200025,
		23617767,
		0xF0,
		117,
	};
// 0000016C: Register Eq_n prvCopyDataFromQueue(Register Eq_n r0, Register Eq_n r1, Register Eq_n r4, Register Eq_n r5, Register Eq_n r6, Register Eq_n r7, Register Eq_n lr, Register out Eq_n r5Out, Register out Eq_n r6Out, Register out Eq_n r7Out, Register out Eq_n lrOut)
// Called from:
//      xQueuePeekFromISR
//      xQueueGenericReceive
//      xQueueReceiveFromISR
Eq_n prvCopyDataFromQueue(Eq_n r0, Eq_n r1, Eq_n r4, Eq_n r5, Eq_n r6, Eq_n r7, Eq_n lr, union Eq_n & r5Out, union Eq_n & r6Out, union Eq_n & r7Out, union Eq_n & lrOut)
{
	Eq_n r2_n = *((word32) r0 + 64);
	if (r2_n == 0x00)
	{
		r5Out = r5;
		r6Out = r6;
		r7Out = r7;
		lrOut = lr;
		return r4;
	}
	else
	{
		Eq_n r4_n = *((word32) r0 + 4);
		word32 r1_n = Mem10[r0 + 0x0C:word32] + r2_n;
		*((word32) r0 + 0x0C) = r1_n;
		if (r1_n >= r4_n)
			r1_n = *r0;
		*((word32) r0 + 0x0C) = r1_n;
		Eq_n lr_n;
		Eq_n r4_n;
		Eq_n r5_n;
		Eq_n r6_n;
		Eq_n r7_n;
		memcpy(r1, r1_n, r2_n, r4, r5, r6, r7, lr, out r4_n, out r5_n, out r6_n, out r7_n, out lr_n);
		r5Out = r5_n;
		r6Out = r6_n;
		r7Out = r7_n;
		lrOut = lr_n;
		return r4_n;
	}
}

// 00000190: Register Eq_n xQueueGenericSend(Register Eq_n r0, Register Eq_n r1, Register up32 r2, Register Eq_n r3, Register Eq_n lr, Register ptr32 cpsr)
// Called from:
//      xQueueGiveMutexRecursive
//      xQueueCreateMutex
//      MPU_xQueueGenericSend
Eq_n xQueueGenericSend(Eq_n r0, Eq_n r1, up32 r2, Eq_n r3, Eq_n lr, ptr32 cpsr)
{
	word32 r5_n = 0x00;
	word32 * r9_n = g_ptr02A0;
	while (true)
	{
		vPortEnterCritical(cpsr);
		if (*((word32) r0 + 56) < *((word32) r0 + 60) || r3 == 0x02)
			break;
		if (r2 == 0x00)
		{
			vPortExitCritical(cpsr);
			return lr;
		}
		if (r5_n == 0x00)
			vTaskSetTimeOutState(fp - 40);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		vPortEnterCritical(cpsr);
		if ((word32) *((word32) r0 + 0x0044) == 0xFF)
			((word32) r0 + 0x0044)->u0 = 0x00;
		if ((word32) *((word32) r0 + 69) == 0xFF)
			*((word32) r0 + 69) = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 40, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			return lr;
		}
		vPortEnterCritical(cpsr);
		if (*((word32) r0 + 56) != *((word32) r0 + 60))
		{
			vPortExitCritical(cpsr);
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
		}
		else
		{
			vPortExitCritical(cpsr);
			vTaskPlaceOnEventList((word32) r0 + 16, r2);
			prvUnlockQueue(r0, cpsr);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*r9_n = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
		}
		r5_n = 0x01;
	}
	Eq_n lr_n;
	word32 r0_n;
	word32 r7_n;
	prvCopyDataToQueue(r0, r1, r3, r3, lr, out r0_n, out r7_n, out lr_n);
	if (*((word32) r0 + 36) == 0x00)
	{
		if (r0_n == 0x00)
			goto l00000266;
	}
	else if (xTaskRemoveFromEventList((word32) r0 + 36) == 0x00)
		goto l00000266;
	*g_ptr02A0 = 0x10000000;
	__dsb_sy();
	__isb_sy();
l00000266:
	vPortExitCritical(cpsr);
	return lr_n;
}

word32 * g_ptr02A0 = &g_dwE000ED04; // 000002A0
// 000002A4: void xQueuePeekFromISR(Register Eq_n r0, Register Eq_n r1, Register Eq_n r7, Register Eq_n lr, Register ptr32 cpsr)
// Called from:
//      MPU_xQueuePeekFromISR
void xQueuePeekFromISR(Eq_n r0, Eq_n r1, Eq_n r7, Eq_n lr, ptr32 cpsr)
{
	Eq_n r5_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (*((word32) r0 + 56) != 0x00)
	{
		Eq_n r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 lr_n;
		prvCopyDataFromQueue(r0, r1, r0, r5_n, *((word32) r0 + 0x0C), r7, lr, out r5_n, out r6_n, out r7_n, out lr_n)->dw000C = r6_n;
		__msr(cpsr, r5_n);
	}
	else
		__msr(cpsr, r5_n);
}

// 000002D8: Register Eq_n xQueueGenericReceive(Register Eq_n r0, Register Eq_n r1, Register up32 r2, Register word32 r3, Register Eq_n lr, Register ptr32 cpsr, Register out Eq_n lrOut)
// Called from:
//      xQueueTakeMutexRecursive
//      MPU_xQueueGenericReceive
Eq_n xQueueGenericReceive(Eq_n r0, Eq_n r1, up32 r2, word32 r3, Eq_n lr, ptr32 cpsr, union Eq_n & lrOut)
{
	word32 r5_n = 0x00;
	word32 * r8_n = g_ptr0424;
	while (true)
	{
		vPortEnterCritical(cpsr);
		Eq_n r6_n = *((word32) r0 + 56);
		if (r6_n != 0x00)
			break;
		if (r2 == 0x00)
		{
l000003A4:
			vPortExitCritical(cpsr);
			lrOut = lr;
			return 0x00;
		}
		if (r5_n == 0x00)
			vTaskSetTimeOutState(fp - 40);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		vPortEnterCritical(cpsr);
		if ((word32) *((word32) r0 + 0x0044) == 0xFF)
			((word32) r0 + 0x0044)->u0 = 0x00;
		if ((word32) *((word32) r0 + 69) == 0xFF)
			*((word32) r0 + 69) = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 40, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			vPortEnterCritical(cpsr);
			if (*((word32) r0 + 56) == 0x00)
				goto l000003A4;
			vPortExitCritical(cpsr);
		}
		else
		{
			vPortEnterCritical(cpsr);
			if (*((word32) r0 + 56) != 0x00)
			{
				vPortExitCritical(cpsr);
				prvUnlockQueue(r0, cpsr);
				xTaskResumeAll(cpsr);
			}
			else
			{
				vPortExitCritical(cpsr);
				if (*r0 == 0x00)
				{
					vPortEnterCritical(cpsr);
					vTaskPriorityInherit(*((word32) r0 + 4));
					vPortExitCritical(cpsr);
				}
				vTaskPlaceOnEventList((word32) r0 + 36, r2);
				prvUnlockQueue(r0, cpsr);
				if (xTaskResumeAll(cpsr) == 0x00)
				{
					*r8_n = 0x10000000;
					__dsb_sy();
					__isb_sy();
				}
			}
		}
		r5_n = 0x01;
	}
	Eq_n lr_n;
	word32 r5_n;
	word32 r6_n;
	word32 r7_n;
	struct Eq_n * r4_n = prvCopyDataFromQueue(r0, r1, r0, *((word32) r0 + 0x0C), r6_n, 0x00, lr, out r5_n, out r6_n, out r7_n, out lr_n);
	if (r3 == 0x00)
	{
		word32 r3_n = r4_n->dw0000;
		r4_n->dw0038 = r6_n - 0x01;
		if (r3_n == 0x00)
			r4_n->dw0004 = pvTaskIncrementMutexHeldCount();
		if (r4_n->dw0010 == 0x00 || xTaskRemoveFromEventList(&r4_n->dw0010) == 0x00)
		{
l000003CC:
			vPortExitCritical(cpsr);
			lrOut = lr_n;
			return 0x01;
		}
	}
	else
	{
		word32 r3_n = r4_n->dw0024;
		r4_n->dw000C = r5_n;
		if (r3_n == 0x00 || xTaskRemoveFromEventList(&r4_n->dw0024) == 0x00)
			goto l000003CC;
	}
	*g_ptr0424 = 0x10000000;
	__dsb_sy();
	__isb_sy();
	goto l000003CC;
}

word32 * g_ptr0424 = &g_dwE000ED04; // 00000424
// 00000428: void uxQueueMessagesWaiting(Register ptr32 cpsr)
// Called from:
//      MPU_uxQueueMessagesWaiting
void uxQueueMessagesWaiting(ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	vPortExitCritical(cpsr);
}

// 0000043C: void uxQueueSpacesAvailable(Register ptr32 cpsr)
// Called from:
//      MPU_uxQueueSpacesAvailable
void uxQueueSpacesAvailable(ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	vPortExitCritical(cpsr);
}

// 00000454: void vQueueDelete()
// Called from:
//      MPU_vQueueDelete
void vQueueDelete()
{
	vPortFree();
}

// 00000458: void xQueueGenericSendFromISR(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r3, Register Eq_n lr, Register ptr32 cpsr)
// Called from:
//      vUART_ISR
void xQueueGenericSendFromISR(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r3, Eq_n lr, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (*((word32) r0 + 56) < *((word32) r0 + 60) || r3 == 0x02)
	{
		int32 r4_n = (int32) *((word32) r0 + 69);
		word32 r0_n;
		word32 * r7_n;
		word32 lr_n;
		if (!prvCopyDataToQueue(r0, r1, r3, r2, lr, out r0_n, out r7_n, out lr_n))
			*((word32) r0 + 69) = (int8) r4_n + 1;
		else if (*((word32) r0 + 36) != 0x00 && (xTaskRemoveFromEventList((word32) r0 + 36) != 0x00 && r7_n != null))
		{
			*r7_n = 0x01;
			goto l0000047C;
		}
		__msr(cpsr, r6_n);
	}
	else
	{
l0000047C:
		__msr(cpsr, r6_n);
	}
}

// 000004C4: void xQueueGiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 word32) r1, Register ptr32 cpsr)
void xQueueGiveFromISR(struct Eq_n * r0, word32 * r1, ptr32 cpsr)
{
	Eq_n r4_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	up32 r2_n = r0->dw0038;
	if (r2_n >= r0->dw003C)
	{
		__msr(cpsr, r4_n);
		return;
	}
	int32 r3_n = (int32) r0->b0045;
	r0->dw0038 = r2_n + 0x01;
	if (r2_n != 0x01)
		r0->b0045 = (int8) r3_n + 1;
	else if (r0->dw0024 != 0x00 && (xTaskRemoveFromEventList(&r0->dw0024) != 0x00 && r1 != null))
	{
		*r1 = 0x01;
l000004FA:
		__msr(cpsr, r4_n);
		return;
	}
	goto l000004FA;
}

// 00000524: void xQueueReceiveFromISR(Register Eq_n r0, Register Eq_n r1, Register (ptr32 word32) r2, Register Eq_n lr, Register ptr32 cpsr)
void xQueueReceiveFromISR(Eq_n r0, Eq_n r1, word32 * r2, Eq_n lr, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_n r4_n = *((word32) r0 + 56);
	if (r4_n != 0x00)
	{
		word32 r5_n;
		struct Eq_n * r7_n;
		word32 lr_n;
		struct Eq_n * r4_n = prvCopyDataFromQueue(r0, r1, r4_n, (int32) *((word32) r0 + 0x0044), r6_n, r0, lr, out r5_n, out r6_n, out r7_n, out lr_n);
		r7_n->dw0038 = r4_n - &g_dw0001;
		if (r4_n != &g_dw0001)
			r7_n->b0044 = (int8) r5_n + 1;
		else if (r7_n->dw0010 != 0x00 && (xTaskRemoveFromEventList(&r7_n->dw0010) != 0x00 && r2 != null))
		{
			*r2 = 0x01;
			goto l00000542;
		}
		__msr(cpsr, r6_n);
	}
	else
	{
l00000542:
		__msr(cpsr, r6_n);
	}
}

// 00000594: void xQueueIsQueueEmptyFromISR()
void xQueueIsQueueEmptyFromISR()
{
}

// 000005A0: void xQueueIsQueueFullFromISR()
void xQueueIsQueueFullFromISR()
{
}

// 000005B0: void uxQueueMessagesWaitingFromISR()
void uxQueueMessagesWaitingFromISR()
{
}

// 000005B4: void xQueueGetMutexHolder(Register (ptr32 word32) r0, Register ptr32 cpsr)
// Called from:
//      MPU_xQueueGetMutexHolder
void xQueueGetMutexHolder(word32 * r0, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	if (*r0 != 0x00)
		vPortExitCritical(cpsr);
	else
		vPortExitCritical(cpsr);
}

// 000005D4: void xQueueTakeMutexRecursive(Register Eq_n r0, Register up32 r1, Register Eq_n lr, Register ptr32 cpsr)
// Called from:
//      MPU_xQueueTakeMutexRecursive
void xQueueTakeMutexRecursive(Eq_n r0, up32 r1, Eq_n lr, ptr32 cpsr)
{
	if (*((word32) r0 + 4) == xTaskGetCurrentTaskHandle())
		*((word32) r0 + 0x0C) = (word32) *((word32) r0 + 0x0C) + 1;
	else
	{
		word32 lr_n;
		if (xQueueGenericReceive(r0, 0x00, r1, 0x00, lr, cpsr, out lr_n) != 0x00)
			*((word32) r0 + 0x0C) = (word32) *((word32) r0 + 0x0C) + 1;
	}
}

// 00000604: void xQueueGiveMutexRecursive(Register Eq_n r0, Register Eq_n lr, Register ptr32 cpsr)
// Called from:
//      MPU_xQueueGiveMutexRecursive
void xQueueGiveMutexRecursive(Eq_n r0, Eq_n lr, ptr32 cpsr)
{
	if (*((word32) r0 + 4) != xTaskGetCurrentTaskHandle())
		return;
	Eq_n r3_n = *((word32) r0 + 0x0C);
	*((word32) r0 + 0x0C) = r3_n - 0x01;
	if (r3_n != 0x01)
		return;
	xQueueGenericSend(r0, r3_n - 0x01, r3_n - 0x01, r3_n - 0x01, lr, cpsr);
}

// 00000630: void xQueueGenericReset(Register (ptr32 Eq_n) r0, Register word32 r1, Register ptr32 cpsr)
// Called from:
//      xQueueGenericCreate
//      MPU_xQueueGenericReset
void xQueueGenericReset(struct Eq_n * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	ui32 r3_n = r0->dw0040;
	ui32 r2_n = r0->dw003C * r3_n;
	struct Eq_n * r0_n = r0->ptr0000;
	r0->dw0038 = 0x00;
	r0->dw0004 = r0_n + r2_n / 0x0066;
	r0->ptr0044 = (struct Eq_n *) &g_tFFFFFFFF;
	r0->dw000C = r0_n + (r2_n - r3_n) / 0x0066;
	r0->ptr0008 = r0_n;
	r0->b0045 = ~0x00;
	if (r1 != 0x00)
	{
		vListInitialise(&r0->ptr0010);
		vListInitialise(&r0->ptr0024);
		vPortExitCritical(cpsr);
	}
	else if (r0->ptr0010 != null && xTaskRemoveFromEventList(&r0->ptr0010) != 0x00)
	{
		*g_ptr06A8 = 0x10000000;
		__dsb_sy();
		__isb_sy();
		vPortExitCritical(cpsr);
	}
	else
		vPortExitCritical(cpsr);
}

word32 * g_ptr06A8 = &g_dwE000ED04; // 000006A8
// 000006AC: void xQueueGenericCreate(Register ui32 r0, Register ui32 r1, Register ptr32 cpsr)
// Called from:
//      xQueueCreateMutex
//      MPU_xQueueGenericCreate
void xQueueGenericCreate(ui32 r0, ui32 r1, ptr32 cpsr)
{
	struct Eq_n * r0_n = pvPortMalloc(r0 * r1 + 0x48, cpsr);
	if (r0_n != null)
	{
		if (r1 != 0x00)
			r0_n->ptr0000 = &r0_n->b0045 + 3;
		else
			r0_n->ptr0000 = r0_n;
		r0_n->dw003C = r0;
		r0_n->dw0040 = r1;
		xQueueGenericReset(r0_n, 0x01, cpsr);
	}
}

// 000006DC: void xQueueCreateMutex(Register Eq_n lr, Register ptr32 cpsr)
// Called from:
//      MPU_xQueueCreateMutex
void xQueueCreateMutex(Eq_n lr, ptr32 cpsr)
{
	xQueueGenericCreate(0x01, 0x00, cpsr);
	if (true)
	{
		g_dw0005 = 0x00;
		g_dw0001 = 0x00;
		g_dw000D = 0x00;
		xQueueGenericSend(0x01, 0x00, 0x00, 0x00, lr, cpsr);
	}
}

// 00000700: void prvInitialiseNewTask(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04, Stack (ptr32 Eq_n) dwArg08, Stack (ptr32 Eq_n) dwArg0C)
// Called from:
//      xTaskCreate
//      xTaskCreateRestricted
void prvInitialiseNewTask(ui32 r0, word32 r1, ui32 r2, word32 r3, int32 dwArg00, struct Eq_n ** dwArg04, struct Eq_n * dwArg08, struct Eq_n * dwArg0C)
{
	ui32 r5_n = dwArg08->ptr0050 + (r2 + 0x3FFFFFFF << 0x02) / 0x0066;
	byte * r3_n = r1 - 0x01 + 1;
	byte * r0_n = (char *) &dwArg08->ptr0050 + 4;
	uint32 r2_n = dwArg00 & 0x7FFFFFFF;
	do
	{
		*r0_n = *r3_n;
		++r3_n;
		++r0_n;
	} while ((word32) *r3_n != 0x00 && r3_n != r1 + 0x02);
	if ((dwArg00 & 0x7FFFFFFF) >= 0x01)
		r2_n = 0x01;
	dwArg08->dw004C = r2_n;
	dwArg08->dw0058 = r2_n;
	dwArg08->b0056 = 0x00;
	dwArg08->dw005C = 0x00;
	vListInitialiseItem(&dwArg08->ptr0024);
	vListInitialiseItem(&dwArg08->dw0038);
	dwArg08->dw0038 = 0x02 - r2_n;
	struct Eq_n * r2_n = dwArg08->ptr0050;
	dwArg08->ptr0030 = dwArg08;
	dwArg08->ptr0044 = dwArg08;
	vPortStoreTaskMPUSettings(&dwArg08->dw0004, dwArg0C, r2_n, r2);
	dwArg08->dw0060 = 0x00;
	dwArg08->b0064 = 0x00;
	dwArg08->ptr0000 = pxPortInitialiseStack(r5_n & ~0x07, r0, r3, dwArg00 >> 0x1F);
	if (dwArg04 != null)
		*dwArg04 = (struct Eq_n **) dwArg08;
}

// 00000798: void prvAddNewTaskToReadyList(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
// Called from:
//      xTaskCreate
//      xTaskCreateRestricted
void prvAddNewTaskToReadyList(struct Eq_n * r0, ptr32 cpsr)
{
	uint32 r0_n;
	struct Eq_n * r4_n = g_ptr0854;
	vPortEnterCritical(cpsr);
	++r4_n->dw0000;
	if (r4_n->ptr0004 != null)
	{
		if (r4_n->dw0074 != 0x00)
		{
l000007B4:
			r0_n = r0->dw004C;
			goto l000007BA;
		}
		r0_n = r0->dw004C;
		if (r4_n->ptr0004->dw004C <= r0_n)
			r4_n->ptr0004 = r0;
	}
	else
	{
		r4_n->ptr0004 = r0;
		if (r4_n->dw0000 != 0x01)
			goto l000007B4;
		vListInitialise((char *) &r4_n->ptr0004 + 4);
		vListInitialise((char *) &r4_n->ptr0004 + 24);
		vListInitialise((char *) &r4_n->ptr0004 + 44);
		vListInitialise((char *) &r4_n->ptr0004 + 64);
		vListInitialise((char *) &r4_n->ptr0004 + 84);
		r4_n->ptr006C = (char *) &r4_n->ptr0004 + 44;
		r0_n = r0->dw004C;
		r4_n->ptr0070 = (char *) &r4_n->ptr0004 + 64;
	}
l000007BA:
	word32 r2_n = r4_n->dw0078;
	r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
	r4_n->dw0078 = r2_n + 0x01;
	vListInsertEnd((char *) &r4_n->ptr0004 + 4 + r0_n * 0x14, &r0->ptr0024);
	vPortExitCritical(cpsr);
	if (r4_n->dw0074 != 0x00 && (r4_n->ptr0004)->dw004C < r0->dw004C)
	{
		*g_ptr0858 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
}

struct Eq_n * g_ptr0854 = &g_t200000C4; // 00000854
word32 * g_ptr0858 = &g_dwE000ED04; // 00000858
// 0000085C: void prvAddCurrentTaskToDelayedList.isra.0(Register up32 r0)
// Called from:
//      xTaskNotifyWait
//      ulTaskNotifyTake
//      vTaskDelay
//      vTaskDelayUntil
//      vTaskPlaceOnEventList
//      vTaskPlaceOnUnorderedEventList
void prvAddCurrentTaskToDelayedList.isra.0(up32 r0)
{
	struct Eq_n * r4_n = g_ptr08B0;
	up32 r6_n = r4_n->dw0080;
	if (uxListRemove(&r4_n->ptr0004->dw0024) == 0x00)
		r4_n->dw007C &= ~(0x01 << (r4_n->ptr0004)->dw004C);
	up32 r5_n = r0 + r6_n;
	r4_n->ptr0004->dw0024 = r5_n;
	if (r6_n > r5_n)
	{
		struct Eq_n * r0_n = r4_n->ptr0070;
		struct Eq_n * r1_n = r4_n->ptr0004;
		vListInsert(r0_n, &r1_n->dw0024);
	}
	else
	{
		vListInsert(r4_n->ptr006C, &r4_n->ptr0004->dw0024);
		if (r5_n < r4_n->dw0084)
			r4_n->dw0084 = r5_n;
	}
}

struct Eq_n * g_ptr08B0 = &g_t200000C4; // 000008B0
// 000008B4: Register ui32 xTaskCreate(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Register ptr32 cpsr, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04)
// Called from:
//      vTaskStartScheduler
//      MPU_xTaskCreate
ui32 xTaskCreate(ui32 r0, word32 r1, ui32 r2, word32 r3, ptr32 cpsr, int32 dwArg00, struct Eq_n ** dwArg04)
{
	struct Eq_n * r0_n = pvPortMalloc(r2 << 2, cpsr);
	if (r0_n == null)
		return ~0x00;
	ui32 r0_n;
	struct Eq_n * r0_n = pvPortMalloc(0x68, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0050 = r0_n;
		r0_n->b0065 = 0x00;
		prvInitialiseNewTask(r0, r1, r2, r3, dwArg00, dwArg04, r0_n, null);
		prvAddNewTaskToReadyList(r0_n, cpsr);
		r0_n = 0x01;
	}
	else
	{
		vPortFree();
		r0_n = ~0x00;
	}
	return r0_n;
}

// 0000091C: void xTaskCreateRestricted(Register (ptr32 Eq_n) r0, Register (ptr32 (ptr32 Eq_n)) r1, Register ptr32 cpsr)
// Called from:
//      MPU_xTaskCreateRestricted
void xTaskCreateRestricted(struct Eq_n * r0, struct Eq_n ** r1, ptr32 cpsr)
{
	if (r0->ptr0014 == null)
		return;
	struct Eq_n * r0_n = pvPortMalloc(0x68, cpsr);
	if (r0_n != null)
	{
		struct Eq_n * r1_n = r0->ptr0014;
		r0_n->b0065 = 0x01;
		word32 r3_n = r0->dw000C;
		ui32 r2_n = (word32) r0->w0008;
		int32 lr_n = r0->dw0010;
		r0_n->ptr0050 = r1_n;
		prvInitialiseNewTask(r0->dw0000, r0->dw0004, r2_n, r3_n, lr_n, r1, r0_n, (char *) &r0->ptr0014 + 4);
		prvAddNewTaskToReadyList(r0_n, cpsr);
	}
}

// 00000970: void vTaskAllocateMPURegions(Register word32 r0, Register (ptr32 Eq_n) r1)
// Called from:
//      MPU_vTaskAllocateMPURegions
void vTaskAllocateMPURegions(word32 r0, struct Eq_n * r1)
{
	if (r0 == 0x00)
	{
		word32 r0_n = g_ptr098C->dw0004;
		vPortStoreTaskMPUSettings(r0_n + 0x04, r1, null, 0x00);
	}
	else
		vPortStoreTaskMPUSettings(r0 + 0x04, r1, null, 0x00);
}

struct Eq_n * g_ptr098C = &g_t200000C4; // 0000098C
// 00000990: void vTaskStartScheduler(Register ptr32 cpsr)
// Called from:
//      ResetISR
void vTaskStartScheduler(ptr32 cpsr)
{
	struct Eq_n * r4_n = g_ptr09E0;
	word32 r0_n = xTaskCreate(g_dw09E8, g_dw09E4, 0x3B, 0x00, cpsr, 0x80000000, &r4_n->dw0084 + 1);
	if (r0_n != 0x01)
		return;
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	r4_n->dw0084 = ~0x00;
	r4_n->dw0074 = r0_n;
	r4_n->dw0080 = 0x00;
	xPortStartScheduler(cpsr);
}

struct Eq_n * g_ptr09E0 = &g_t200000C4; // 000009E0
word32 g_dw09E4 = 0xA27C; // 000009E4
ui32 g_dw09E8 = 34093; // 000009E8
// 000009EC: void vTaskEndScheduler(Register ptr32 cpsr)
void vTaskEndScheduler(ptr32 cpsr)
{
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	g_ptr0A08->dw0074 = 0x00;
	vPortEndScheduler();
}

struct Eq_n * g_ptr0A08 = &g_t200000C4; // 00000A08
// 00000A0C: FlagGroup bool vTaskSuspendAll()
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
//      pvPortMalloc
//      xEventGroupWaitBits
//      xEventGroupSetBits
//      xEventGroupSync
//      vEventGroupDelete
//      MPU_vTaskSuspendAll
bool vTaskSuspendAll()
{
	struct Eq_n * r2_n = g_ptr0A1C;
	word32 r3_n = r2_n->dw008C;
	r2_n->dw008C = r3_n + 0x01;
	return SLICE(cond(r3_n + 0x01), bool, 1);
}

struct Eq_n * g_ptr0A1C = &g_t200000C4; // 00000A1C
// 00000A20: void xTaskGetTickCount()
// Called from:
//      MPU_xTaskGetTickCount
void xTaskGetTickCount()
{
}

// 00000A2C: void xTaskGetTickCountFromISR()
void xTaskGetTickCountFromISR()
{
}

// 00000A38: void uxTaskGetNumberOfTasks()
// Called from:
//      MPU_uxTaskGetNumberOfTasks
void uxTaskGetNumberOfTasks()
{
}

// 00000A44: void pcTaskGetName(Register word32 r0)
// Called from:
//      MPU_pcTaskGetName
void pcTaskGetName(word32 r0)
{
	if (r0 == 0x00)
		;
}

// 00000A58: void xTaskGenericNotify(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr)
// Called from:
//      MPU_xTaskGenericNotify
void xTaskGenericNotify(struct Eq_n * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_n = (uint32) (byte) r4_n;
	if (r2 <= 0x04)
	{
		switch (r2)
		{
		case 0x01:
			r0->dw0060 = r1 | r0->dw0060;
			goto l00000A8C;
		case 0x02:
			++r0->dw0060;
			if (r4_n == 0x01)
				goto l00000AA6;
			goto l00000A90;
		case 0x03:
			break;
		case 0x04:
			if (r4_n == 0x02)
				goto l00000A92;
			break;
		}
		r0->dw0060 = r1;
	}
l00000A8C:
	if (r4_n == 0x01)
	{
l00000AA6:
		struct Eq_n * r5_n = g_ptr0B04;
		uxListRemove((char *) r0 + 36);
		uint32 r0_n = r0->dw004C;
		r5_n->dw007C = r4_n << r0_n | r5_n->dw007C;
		vListInsertEnd((char *) &r5_n->ptr0004 + 4 + r0_n * 0x14, (char *) r0 + 36);
		if (r0->dw004C > (r5_n->ptr0004)->dw004C)
		{
			*g_ptr0B08 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return;
		}
	}
l00000A90:
l00000A92:
	vPortExitCritical(cpsr);
}

struct Eq_n * g_ptr0B04 = &g_t200000C4; // 00000B04
word32 * g_ptr0B08 = &g_dwE000ED04; // 00000B08
// 00000B0C: void xTaskGenericNotifyFromISR(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr, Stack (ptr32 word32) dwArg00)
void xTaskGenericNotifyFromISR(struct Eq_n * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr, word32 * dwArg00)
{
	Eq_n r5_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_n = (uint32) (byte) r4_n;
	if (r2 <= 0x04)
	{
		switch (r2)
		{
		case 0x01:
			r0->dw0060 = r1 | r0->dw0060;
			goto l00000B4A;
		case 0x02:
			++r0->dw0060;
			if (r4_n == 0x01)
				goto l00000B64;
			goto l00000B4E;
		case 0x03:
			break;
		case 0x04:
			if (r4_n == 0x02)
				goto l00000B50;
			break;
		}
		r0->dw0060 = r1;
	}
l00000B4A:
	if (r4_n == 0x01)
	{
l00000B64:
		struct Eq_n * r6_n = g_ptr0BD0;
		if (r6_n->dw008C != 0x00)
			vListInsertEnd((char *) &r6_n->ptr0004 + 84, (char *) r0 + 56);
		else
		{
			uxListRemove((char *) r0 + 36);
			uint32 r0_n = r0->dw004C;
			r6_n->dw007C = r4_n << r0_n | r6_n->dw007C;
			vListInsertEnd((char *) &r6_n->ptr0004 + 4 + r0_n * 0x14, (char *) r0 + 36);
		}
		if (r0->dw004C > (r6_n->ptr0004)->dw004C)
		{
			if (dwArg00 != null)
			{
				*dwArg00 = 0x01;
				__msr(cpsr, r5_n);
				return;
			}
			r6_n->dw0090 = 0x01;
l00000B50:
			__msr(cpsr, r5_n);
			return;
		}
	}
l00000B4E:
	goto l00000B50;
}

struct Eq_n * g_ptr0BD0 = &g_t200000C4; // 00000BD0
// 00000BD4: void xTaskNotifyWait(Register word32 r0, Register word32 r1, Register (ptr32 ui32) r2, Register up32 r3, Register ptr32 cpsr)
// Called from:
//      MPU_xTaskNotifyWait
void xTaskNotifyWait(word32 r0, word32 r1, ui32 * r2, up32 r3, ptr32 cpsr)
{
	struct Eq_n * r4_n = g_ptr0C58;
	vPortEnterCritical(cpsr);
	if ((word32) r4_n->ptr0004->b0064 != 0x02)
	{
		struct Eq_n * r1_n = r4_n->ptr0004;
		r1_n->dw0060 &= ~r0;
		r4_n->ptr0004->b0064 = 0x01;
		if (r3 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r3);
			*g_ptr0C5C = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	if (r2 != null)
		*r2 = r4_n->ptr0004->dw0060;
	if ((word32) r4_n->ptr0004->b0064 != 0x01)
	{
		struct Eq_n * r3_n = r4_n->ptr0004;
		r3_n->dw0060 &= ~r1;
	}
	r4_n->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

struct Eq_n * g_ptr0C58 = &g_t200000C4; // 00000C58
word32 * g_ptr0C5C = &g_dwE000ED04; // 00000C5C
// 00000C60: void vTaskNotifyGiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 word32) r1, Register ptr32 cpsr)
void vTaskNotifyGiveFromISR(struct Eq_n * r0, word32 * r1, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	word32 r5_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	++r0->dw0060;
	uint32 r5_n = (uint32) (byte) r5_n;
	if (r5_n == 0x01)
	{
		struct Eq_n * r7_n = g_ptr0CFC;
		if (r7_n->dw008C != 0x00)
			vListInsertEnd((char *) &r7_n->ptr0004 + 84, (char *) r0 + 56);
		else
		{
			uxListRemove((char *) r0 + 36);
			uint32 r0_n = r0->dw004C;
			r7_n->dw007C = r5_n << r0_n | r7_n->dw007C;
			vListInsertEnd((char *) &r7_n->ptr0004 + 4 + r0_n * 0x14, (char *) r0 + 36);
		}
		if (r0->dw004C > (r7_n->ptr0004)->dw004C)
		{
			if (r1 != null)
			{
				*r1 = 0x01;
				__msr(cpsr, r6_n);
				return;
			}
			r7_n->dw0090 = 0x01;
		}
	}
	__msr(cpsr, r6_n);
}

struct Eq_n * g_ptr0CFC = &g_t200000C4; // 00000CFC
// 00000D00: void ulTaskNotifyTake(Register word32 r0, Register up32 r1, Register ptr32 cpsr)
// Called from:
//      MPU_ulTaskNotifyTake
void ulTaskNotifyTake(word32 r0, up32 r1, ptr32 cpsr)
{
	struct Eq_n * r4_n = g_ptr0D64;
	vPortEnterCritical(cpsr);
	if (r4_n->ptr0004->dw0060 == 0x00)
	{
		r4_n->ptr0004->b0064 = 0x01;
		if (r1 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r1);
			*g_ptr0D68 = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	word32 r5_n = r4_n->ptr0004->dw0060;
	if (r5_n != 0x00)
	{
		if (r0 == 0x00)
			r4_n->ptr0004->dw0060 = r5_n - 0x01;
		else
			r4_n->ptr0004->dw0060 = 0x00;
	}
	r4_n->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

struct Eq_n * g_ptr0D64 = &g_t200000C4; // 00000D64
word32 * g_ptr0D68 = &g_dwE000ED04; // 00000D68
// 00000D6C: Register word32 xTaskIncrementTick()
// Called from:
//      xTaskResumeAll
//      xPortSysTickHandler
word32 xTaskIncrementTick()
{
	word32 r6_n;
	struct Eq_n * r4_n = g_ptr0E64;
	if (r4_n->dw008C != 0x00)
	{
		++r4_n->dw0098;
		r6_n = 0x00;
		goto l00000E28;
	}
	up32 r7_n = r4_n->dw0080;
	r4_n->dw0080 = r7_n + 0x01;
	if (r7_n == 0x01)
	{
		struct Eq_n * r3_n = r4_n->ptr006C;
		r4_n->ptr006C = r4_n->ptr0070;
		r4_n->ptr0070 = r3_n;
		++r4_n->dw0094;
		if (r4_n->ptr006C->dw0000 != 0x00)
		{
			r4_n->dw0084 = r4_n->ptr006C->ptr000C->ptr000C->dw0024;
			r6_n = 0x00;
			if (r7_n + 0x01 < r4_n->dw0084)
				goto l00000E14;
l00000DB2:
			r6_n = 0x00;
			word32 r8_n = g_dw0E68;
			while (r4_n->ptr006C->dw0000 != 0x00)
			{
				struct Eq_n * r5_n = r4_n->ptr006C->ptr000C->ptr000C;
				up32 r3_n = r5_n->dw0024;
				if (r7_n + 0x01 < r3_n)
				{
					r4_n->dw0084 = r3_n;
					goto l00000E14;
				}
				uxListRemove(&r5_n->dw0024);
				if (r5_n->dw0048 != 0x00)
					uxListRemove(&r5_n->dw0024 + 5);
				uint32 r0_n = r5_n->dw004C;
				r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
				vListInsertEnd(r8_n + r0_n * 0x14, &r5_n->dw0024);
				if (r5_n->dw004C >= (r4_n->ptr0004)->dw004C)
					r6_n = 0x01;
			}
			r4_n->dw0084 = ~0x00;
l00000E14:
			if (*((char *) &(r4_n + ((r4_n->ptr0004)->dw004C * 0x14) / 0x009C)->ptr0004 + 4) >= 0x02)
				r6_n = 0x01;
l00000E28:
			if (r4_n->dw0090 != 0x00)
				r6_n = 0x01;
			return r6_n;
		}
		r4_n->dw0084 = ~0x00;
	}
	r6_n = 0x00;
	if (r7_n + 0x01 < r4_n->dw0084)
		goto l00000E14;
	goto l00000DB2;
}

struct Eq_n * g_ptr0E64 = &g_t200000C4; // 00000E64
word32 g_dw0E68 = 0x200000CC; // 00000E68
// 00000E6C: Register word32 xTaskResumeAll(Register ptr32 cpsr)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
//      vTaskDelay
//      vTaskDelayUntil
//      pvPortMalloc
//      xEventGroupWaitBits
//      xEventGroupSetBits
//      xEventGroupSync
//      vEventGroupDelete
//      MPU_xTaskResumeAll
word32 xTaskResumeAll(ptr32 cpsr)
{
	struct Eq_n * r4_n = g_ptr0F40;
	vPortEnterCritical(cpsr);
	--r4_n->ptr008C;
	struct Eq_n * r5_n = r4_n->ptr008C;
	if (r5_n == null && r4_n->dw0000 != 0x00)
	{
		while (r4_n->dw0058 != 0x00)
		{
			r5_n = r4_n->ptr0064->ptr000C;
			uxListRemove((char *) r5_n + 56);
			uxListRemove((char *) r5_n + 36);
			uint32 r0_n = r5_n->dw004C;
			r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
			vListInsertEnd((char *) &r4_n->ptr0004 + 4 + r0_n * 0x14, (char *) r5_n + 36);
			if (r5_n->dw004C >= (r4_n->ptr0004)->dw004C)
				r4_n->dw0090 = 0x01;
		}
		if (r5_n != null)
		{
			if (r4_n->ptr006C->dw0000 == 0x00)
				r4_n->dw0084 = ~0x00;
			else
				r4_n->dw0084 = r4_n->ptr006C->ptr000C->ptr000C->dw0024;
		}
		word32 r5_n = r4_n->dw0098;
		if (r5_n != 0x00)
		{
			do
			{
				if (xTaskIncrementTick() != 0x00)
					r4_n->dw0090 = 0x01;
				--r5_n;
			} while (r5_n != 0x00);
			r4_n->dw0098 = r5_n;
		}
		if (r4_n->dw0090 != 0x00)
		{
			*g_ptr0F44 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return 0x01;
		}
	}
	vPortExitCritical(cpsr);
	return 0x00;
}

struct Eq_n * g_ptr0F40 = &g_t200000C4; // 00000F40
word32 * g_ptr0F44 = &g_dwE000ED04; // 00000F44
// 00000F48: void vTaskDelay(Register up32 r0, Register ptr32 cpsr)
// Called from:
//      MPU_vTaskDelay
void vTaskDelay(up32 r0, ptr32 cpsr)
{
	if (r0 != 0x00)
	{
		struct Eq_n * r2_n = g_ptr0F7C;
		++r2_n->dw008C;
		prvAddCurrentTaskToDelayedList.isra.0(r0);
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
	}
	*g_ptr0F78 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

word32 * g_ptr0F78 = &g_dwE000ED04; // 00000F78
struct Eq_n * g_ptr0F7C = &g_t200000C4; // 00000F7C
// 00000F80: void vTaskDelayUntil(Register (ptr32 up32) r0, Register word32 r1, Register ptr32 cpsr)
// Called from:
//      MPU_vTaskDelayUntil
void vTaskDelayUntil(up32 * r0, word32 r1, ptr32 cpsr)
{
	struct Eq_n * r2_n = g_ptr0FD4;
	up32 r3_n = *r0;
	++r2_n->dw008C;
	up32 r2_n = r2_n->dw0080;
	up32 r1_n = r1 + r3_n;
	if (r2_n < r3_n)
	{
		if (r3_n <= r1_n)
			goto l00000F9E;
	}
	else if (r3_n > r1_n)
		goto l00000FC0;
	if (r2_n >= r1_n)
	{
l00000F9E:
		*r0 = r1_n;
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
		goto l00000FA6;
	}
l00000FC0:
	*r0 = r1_n;
	prvAddCurrentTaskToDelayedList.isra.0(r1_n - r2_n);
	if (xTaskResumeAll(cpsr) != 0x00)
		return;
l00000FA6:
	*g_ptr0FD8 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

struct Eq_n * g_ptr0FD4 = &g_t200000C4; // 00000FD4
word32 * g_ptr0FD8 = &g_dwE000ED04; // 00000FD8
// 00000FDC: void vTaskPlaceOnEventList(Register (ptr32 Eq_n) r0, Register up32 r1)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
void vTaskPlaceOnEventList(struct Eq_n * r0, up32 r1)
{
	vListInsert(r0, g_ptr0FF4->dw0004 + 0x38);
	prvAddCurrentTaskToDelayedList.isra.0(r1);
}

struct Eq_n * g_ptr0FF4 = &g_t200000C4; // 00000FF4
// 00000FF8: void vTaskPlaceOnUnorderedEventList(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2)
// Called from:
//      xEventGroupWaitBits
//      xEventGroupSync
void vTaskPlaceOnUnorderedEventList(struct Eq_n * r0, ui32 r1, up32 r2)
{
	struct Eq_n * r3_n = g_ptr1018;
	struct Eq_n * r3_n = r3_n->ptr0004;
	r3_n->ptr0004->dw0038 = r1 | 0x80000000;
	vListInsertEnd(r0, &r3_n->dw0038);
	prvAddCurrentTaskToDelayedList.isra.0(r2);
}

struct Eq_n * g_ptr1018 = &g_t200000C4; // 00001018
// 0000101C: Register (ptr32 Eq_n) xTaskRemoveFromEventList(Register (ptr32 Eq_n) r0)
// Called from:
//      prvUnlockQueue
//      xQueueGenericSend
//      xQueueGenericReceive
//      xQueueGenericSendFromISR
//      xQueueGiveFromISR
//      xQueueReceiveFromISR
//      xQueueGenericReset
struct Eq_n * xTaskRemoveFromEventList(struct Eq_n * r0)
{
	struct Eq_n * r0_n;
	struct Eq_n * r4_n = g_ptr107C;
	struct Eq_n * r5_n = r0->ptr000C->ptr000C;
	uxListRemove((char *) r5_n + 56);
	if (r4_n->dw008C == 0x00)
	{
		uxListRemove((char *) r5_n + 36);
		uint32 r0_n = r5_n->dw004C;
		r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
		r0_n = (struct Eq_n *) ((char *) &r4_n->ptr0004 + 4 + r0_n * 0x14);
		vListInsertEnd(r0_n, (char *) r5_n + 36);
	}
	else
	{
		vListInsertEnd((char *) &r4_n->ptr0004 + 84, (char *) r5_n + 56);
		r0_n = (struct Eq_n *) ((char *) &r4_n->ptr0004 + 84);
	}
	if (r5_n->dw004C > (r4_n->ptr0004)->dw004C)
		r0_n = (struct Eq_n *) &g_dw0001;
	r4_n->ptr0090 = r0_n;
	return null;
}

struct Eq_n * g_ptr107C = &g_t200000C4; // 0000107C
// 00001080: void xTaskRemoveFromUnorderedEventList(Register (ptr32 Eq_n) r0, Register ui32 r1)
// Called from:
//      xEventGroupSetBits
//      vEventGroupDelete
void xTaskRemoveFromUnorderedEventList(struct Eq_n * r0, ui32 r1)
{
	struct Eq_n * r6_n = r0->ptr000C;
	r0->dw0000 = r1 | 0x80000000;
	uxListRemove(r0);
	struct Eq_n * r4_n = g_ptr10D4;
	uxListRemove((char *) r6_n + 36);
	uint32 r3_n = r6_n->dw004C;
	r4_n->dw007C = 0x01 << r3_n | r4_n->dw007C;
	vListInsertEnd((char *) &r4_n->ptr0004 + 4 + r3_n * 0x14, (char *) r6_n + 36);
	r6_n->dw004C <= (r4_n->ptr0004)->dw004C;
	r4_n->dw0090 = 0x01;
}

struct Eq_n * g_ptr10D4 = &g_t200000C4; // 000010D4
// 000010D8: void vTaskSwitchContext()
// Called from:
//      xPortPendSVHandler
void vTaskSwitchContext()
{
	struct Eq_n * r2_n = g_ptr111C;
	word32 r3_n = r2_n->dw008C;
	if (r3_n != 0x00)
		r2_n->dw0090 = 0x01;
	else
	{
		struct Eq_n * r1_n;
		r2_n->dw0090 = r3_n;
		struct Eq_n * r0_n = r2_n + ((0x1F - (uint32) ((byte) __clz(r2_n->dw007C))) * 0x14) / 0x0094;
		struct Eq_n * r1_n = r0_n->ptr000C->ptr0004;
		r0_n->ptr000C = r1_n;
		r1_n = r1_n;
		if (r1_n == (char *) (&r0_n->ptr000C) + 4)
			r1_n = r1_n->ptr0004;
		word32 r3_n = r1_n->dw000C;
		if (r1_n == (char *) (&r0_n->ptr000C) + 4)
			r0_n->ptr000C = r1_n;
		r2_n->dw0004 = r3_n;
	}
}

struct Eq_n * g_ptr111C = &g_t200000C4; // 0000111C
// 00001120: Register word32 uxTaskResetEventItemValue()
// Called from:
//      xEventGroupWaitBits
//      xEventGroupSync
word32 uxTaskResetEventItemValue()
{
	struct Eq_n * r3_n = g_ptr1134;
	word32 r0_n = r3_n->ptr0004->dw0038;
	r3_n->ptr0004->dw0038 = 0x02 - (r3_n->ptr0004)->dw004C;
	return r0_n;
}

struct Eq_n * g_ptr1134 = &g_t200000C4; // 00001134
// 00001138: Register word32 xTaskGetCurrentTaskHandle()
// Called from:
//      xQueueTakeMutexRecursive
//      xQueueGiveMutexRecursive
word32 xTaskGetCurrentTaskHandle()
{
	return g_ptr1140->dw0004;
}

struct Eq_n * g_ptr1140 = &g_t200000C4; // 00001140
// 00001144: void vTaskSetTimeOutState(Register (ptr32 Eq_n) r0)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
//      MPU_vTaskSetTimeOutState
void vTaskSetTimeOutState(struct Eq_n * r0)
{
	struct Eq_n * r3_n = g_ptr1154;
	word32 r3_n = r3_n->dw0080;
	r0->dw0000 = r3_n->dw0094;
	r0->dw0004 = r3_n;
}

struct Eq_n * g_ptr1154 = &g_t200000C4; // 00001154
// 00001158: Register (ptr32 Eq_n) xTaskCheckForTimeOut(Register (ptr32 Eq_n) r0, Register (ptr32 up32) r1, Register ptr32 cpsr)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
//      MPU_xTaskCheckForTimeOut
struct Eq_n * xTaskCheckForTimeOut(struct Eq_n * r0, up32 * r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	struct Eq_n * r3_n = g_ptr11A8;
	up32 r5_n = r3_n->dw0080;
	up32 r0_n = r0->dw0004;
	if (r0->dw0000 == r3_n->dw0094 || r5_n < r0_n)
	{
		up32 r2_n = *r1;
		if (r5_n - r0_n < r2_n)
		{
			word32 r1_n = r3_n->dw0094;
			up32 r3_n = r3_n->dw0080;
			*r1 = r2_n - r5_n + r0_n;
			r0->dw0000 = r1_n;
			r0->dw0004 = r3_n;
			vPortExitCritical(cpsr);
			return null;
		}
	}
	vPortExitCritical(cpsr);
	return &g_dw0001;
}

struct Eq_n * g_ptr11A8 = &g_t200000C4; // 000011A8
// 000011AC: void vTaskMissedYield()
// Called from:
//      prvUnlockQueue
void vTaskMissedYield()
{
	g_ptr11B8->dw0090 = 0x01;
}

struct Eq_n * g_ptr11B8 = &g_t200000C4; // 000011B8
// 000011BC: void vTaskPriorityInherit(Register Eq_n r0)
// Called from:
//      xQueueGenericReceive
void vTaskPriorityInherit(Eq_n r0)
{
	if (r0 == 0x00)
		return;
	struct Eq_n * r4_n = g_ptr1248;
	uint32 r3_n = *((word32) r0 + 76);
	if (r3_n >= (r4_n->ptr0004)->dw004C)
		return;
	if (*((word32) r0 + 56) >= 0x00)
		*((word32) r0 + 56) = 0x02 - (r4_n->ptr0004)->dw004C;
	word32 r5_n = g_dw124C;
	if (*((word32) r0 + 52) == r5_n + r3_n * 0x14)
	{
		if (uxListRemove((word32) r0 + 36) == 0x00)
		{
			uint32 r2_n = *((word32) r0 + 76);
			if (*((char *) &(r4_n + (r2_n * 0x14) / 0x0080)->ptr0004 + 4) == 0x00)
				r4_n->dw007C &= ~(0x01 << r2_n);
		}
		uint32 r2_n = r4_n->ptr0004->dw004C;
		ui32 r3_n = 0x01 << r2_n | r4_n->dw007C;
		*((word32) r0 + 76) = r2_n;
		r4_n->dw007C = r3_n;
		struct Eq_n * r0_n = r5_n + r2_n * 0x14;
		vListInsertEnd(r0_n, (word32) r0 + 36);
	}
	else
		*((word32) r0 + 76) = r4_n->ptr0004->dw004C;
}

struct Eq_n * g_ptr1248 = &g_t200000C4; // 00001248
word32 g_dw124C = 0x200000CC; // 0000124C
// 00001250: Register Eq_n xTaskPriorityDisinherit(Register Eq_n r0, Register out Eq_n lrOut)
// Called from:
//      prvCopyDataToQueue
Eq_n xTaskPriorityDisinherit(Eq_n r0, union Eq_n & lrOut)
{
	if (r0 == 0x00)
	{
		lrOut = lr;
		return 0x00;
	}
	else
	{
		uint32 r1_n = *((word32) r0 + 76);
		word32 r3_n = *((word32) r0 + 92);
		uint32 r2_n = *((word32) r0 + 88);
		*((word32) r0 + 92) = r3_n - 0x01;
		if (r1_n == r2_n || r3_n != 0x01)
		{
			lrOut = lr;
			return 0x00;
		}
		else
		{
			struct Eq_n * r2_n;
			if (uxListRemove((word32) r0 + 36) == 0x00)
			{
				uint32 r1_n = *((word32) r0 + 76);
				r2_n = g_ptr12CC;
				if (*((char *) (r2_n + (r1_n * 0x14) / 0x0080) + 8) == 0x00)
					r2_n->t007C &= ~(0x01 << r1_n);
			}
			else
				r2_n = g_ptr12CC;
			uint32 r3_n = *((word32) r0 + 88);
			Eq_n lr_n = r2_n->t007C;
			word32 r0_n = g_dw12D0;
			*((word32) r0 + 76) = r3_n;
			*((word32) r0 + 56) = 0x02 - r3_n;
			r2_n->t007C = 0x01 << r3_n | lr_n;
			vListInsertEnd(r0_n + r3_n * 0x14, (word32) r0 + 36);
			lrOut = lr_n;
			return 0x01;
		}
	}
}

struct Eq_n * g_ptr12CC = &g_t200000C4; // 000012CC
word32 g_dw12D0 = 0x200000CC; // 000012D0
// 000012D4: Register (ptr32 Eq_n) pvTaskIncrementMutexHeldCount()
// Called from:
//      xQueueGenericReceive
struct Eq_n * pvTaskIncrementMutexHeldCount()
{
	struct Eq_n * r3_n = g_ptr12E8;
	if (r3_n->ptr0004 != null)
	{
		struct Eq_n * r1_n = r3_n->ptr0004;
		++r1_n->dw005C;
	}
	return r3_n->ptr0004;
}

struct Eq_n * g_ptr12E8 = &g_t200000C4; // 000012E8
// 000012F0: void prvRestoreContextOfFirstTask(Register ptr32 cpsr)
// Called from:
//      prvSVCHandler
void prvRestoreContextOfFirstTask(ptr32 cpsr)
{
	__msr(cpsr, **g_ptr1724);
	struct Eq_n * r1_n = *g_ptr1330;
	union Eq_n * r0_n = r1_n->ptr0000;
	struct Eq_n * r2_n = g_ptr1728;
	word32 r5_n = r1_n->dw0008;
	word32 r6_n = r1_n->dw000C;
	word32 r7_n = r1_n->dw0010;
	word32 r8_n = r1_n->dw0014;
	word32 r9_n = r1_n->dw0018;
	word32 r10_n = r1_n->dw001C;
	word32 fp_n = r1_n->dw0020;
	r2_n->dw0000 = r1_n->dw0004;
	r2_n->dw0004 = r5_n;
	r2_n->dw0008 = r6_n;
	r2_n->dw000C = r7_n;
	r2_n->dw0010 = r8_n;
	r2_n->dw0014 = r9_n;
	r2_n->dw0018 = r10_n;
	r2_n->dw001C = fp_n;
	__msr(cpsr, *r0_n);
	__msr(cpsr, (char *) r0_n + 36);
	__msr(cpsr, 0x00);
}

struct Eq_n ** g_ptr1330 = &g_ptr200000C8; // 00001330
// 00001334: void prvSVCHandler(Register Eq_n r0, Register ptr32 cpsr)
// Called from:
//      vPortSVCHandler
void prvSVCHandler(Eq_n r0, ptr32 cpsr)
{
	up32 r3_n = (word32) *((word32) *((word32) r0 + 24) - 2);
	if (r3_n == 0x01)
	{
		*g_ptr1378 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	else if (r3_n < 0x01)
	{
		ui32 * r2_n = g_ptr1374;
		*r2_n |= 0xBE000000;
		prvRestoreContextOfFirstTask(cpsr);
	}
	else
	{
		if (r3_n != 0x02)
			return;
		__msr(cpsr, __mrs(cpsr) & ~0x01);
	}
}

ui32 * g_ptr1374 = &g_dwE000ED1C; // 00001374
word32 * g_ptr1378 = &g_dwE000ED04; // 00001378
// 0000137C: Register (ptr32 Eq_n) pxPortInitialiseStack(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 r2, Register int32 r3)
// Called from:
//      prvInitialiseNewTask
struct Eq_n * pxPortInitialiseStack(struct Eq_n * r0, ui32 r1, word32 r2, int32 r3)
{
	int32 r3_n;
	r3_n = r3;
	if (r3 == 0x01)
		r3_n = 0x02;
	if (r3 != 0x01)
		r3_n = 0x03;
	r0->dwFFFFFFE0 = r2;
	r0->dwFFFFFFF8 = r1 & ~0x01;
	r0->dwFFFFFFFC = 0x01000000;
	r0->dwFFFFFFF4 = 0x00;
	r0->dwFFFFFFBC = r3_n;
	return r0 - 0x44;
}

// 000013B0: void xPortStartScheduler(Register ptr32 cpsr)
// Called from:
//      vTaskStartScheduler
void xPortStartScheduler(ptr32 cpsr)
{
	ui32 * r3_n = g_ptr14E8;
	word32 * r1_n = g_ptr14EC;
	*r3_n |= 0x00FF0000;
	*r3_n |= 0xFF000000;
	if (*r1_n == 0x0800)
	{
		ui32 r2_n;
		ui32 r0_n = g_dw14FC;
		uint32 r1_n = g_dw1500 - r0_n;
		*g_ptr1504 = r0_n | 0x10;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = g_dw1508 | r2_n << 0x01;
					goto l0000142C;
				}
			}
			r2_n = g_dw1538;
		}
		else
			r2_n = g_dw1548;
l0000142C:
		ui32 r2_n;
		uint32 r1_n = g_dw150C - r0_n;
		ui32 * r3_n = g_ptr1504;
		g_ptr1510->dw0000 = r2_n;
		*r3_n = r0_n | 0x11;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = g_dw1514 | r2_n << 0x01;
					goto l0000145A;
				}
			}
			r2_n = g_dw153C;
		}
		else
			r2_n = g_dw1544;
l0000145A:
		ui32 r0_n;
		ui32 r3_n = g_dw1518;
		ui32 * r0_n = g_ptr1504;
		uint32 r1_n = g_dw151C - r3_n;
		g_ptr1510->dw0000 = r2_n;
		*r0_n = r3_n | 0x12;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r0_n = g_dw1520 | r2_n << 0x01;
					goto l0000148A;
				}
			}
			r0_n = g_dw1540;
		}
		else
			r0_n = g_dw154C;
l0000148A:
		ui32 * r4_n = g_ptr1504;
		ui32 r5_n = g_dw1524;
		uint32 r1_n = g_dw1528;
		g_ptr1510->dw0000 = r0_n;
		*r4_n = r5_n;
		ui32 r3_n = 0x05;
		uint32 r2_n = 0x40;
		do
		{
			ui32 r3_n;
			++r3_n;
			r2_n <<= 0x01;
			if (r3_n == 0x1F)
			{
				r3_n = g_dw1534;
				goto l000014AE;
			}
		} while (r2_n <= r1_n);
		r3_n = g_dw152C | r3_n << 0x01;
l000014AE:
		struct Eq_n * r2_n = g_ptr1510;
		ui32 * r1_n = g_ptr1530;
		r2_n->dw0000 = r3_n;
		*r1_n |= 0x00010000;
		r2_n->dwFFFFFFF4 |= 0x05;
	}
	word32 * r2_n = g_ptr14F4;
	word32 * r3_n = g_ptr14F8;
	*g_ptr14F0 = 19999;
	*r2_n = 0x07;
	*r3_n = 0x00;
	__msr(cpsr, **g_ptr1724);
	__cps();
	__cps();
	__dsb_sy();
	__isb_sy();
	__syscall(0x00);
}

ui32 * g_ptr14E8 = &g_dwE000ED20; // 000014E8
word32 * g_ptr14EC = &g_dwE000ED90; // 000014EC
word32 * g_ptr14F0 = &g_dwE000E014; // 000014F0
word32 * g_ptr14F4 = &g_dwE000E010; // 000014F4
word32 * g_ptr14F8 = &g_dw200000BC; // 000014F8
ui32 g_dw14FC = 0x00; // 000014FC
word32 g_dw1500 = 0x00020000; // 00001500
ui32 * g_ptr1504 = &g_dwE000ED9C; // 00001504
ui32 g_dw1508 = 0x06070001; // 00001508
word32 g_dw150C = 0x8000; // 0000150C
struct Eq_n * g_ptr1510 = &g_tE000EDA0; // 00001510
ui32 g_dw1514 = 0x05070001; // 00001514
ui32 g_dw1518 = 0x20000000; // 00001518
word32 g_dw151C = 0x20000200; // 0000151C
ui32 g_dw1520 = 0x01070001; // 00001520
ui32 g_dw1524 = 0x40000013; // 00001524
uint32 g_dw1528 = 0x1FFFFFFE; // 00001528
ui32 g_dw152C = 0x13000001; // 0000152C
ui32 * g_ptr1530 = &g_dwE000ED24; // 00001530
ui32 g_dw1534 = 0x1300003F; // 00001534
ui32 g_dw1538 = 101122111; // 00001538
ui32 g_dw153C = 0x0507003F; // 0000153C
ui32 g_dw1540 = 0x0107003F; // 00001540
ui32 g_dw1544 = 0x05070009; // 00001544
ui32 g_dw1548 = 0x06070009; // 00001548
ui32 g_dw154C = 0x01070009; // 0000154C
// 00001550: void vPortEndScheduler()
// Called from:
//      vTaskEndScheduler
void vPortEndScheduler()
{
}

// 00001554: void vPortStoreTaskMPUSettings(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 Eq_n) r2, Register ui32 r3)
// Called from:
//      prvInitialiseNewTask
//      vTaskAllocateMPURegions
void vPortStoreTaskMPUSettings(struct Eq_n * r0, struct Eq_n * r1, struct Eq_n * r2, ui32 r3)
{
	if (r1 == null)
	{
		ui32 r2_n;
		ui32 r3_n = g_dw1668;
		uint32 r1_n = g_dw166C - r3_n;
		r0->dw0000 = r3_n | 0x14;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r3_n >= r1_n)
				{
					r2_n = g_dw1660 | r2_n << 0x01;
					goto l00001608;
				}
			}
			r2_n = g_dw1664;
		}
		else
			r2_n = g_dw1680;
l00001608:
		ui32 r2_n;
		ui32 r3_n = g_dw1670;
		uint32 r1_n = g_dw1674 - r3_n;
		r0->dw0004 = r2_n;
		r0[1] = (struct Eq_n) (r3_n | 0x15);
		if (r1_n > 0x20)
		{
			ui32 r2_n;
			uint32 r3_n = 0x40;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = g_dw1678 | r2_n << 0x01;
					goto l00001634;
				}
			}
			r2_n = g_dw167C;
		}
		else
			r2_n = g_dw1684;
l00001634:
		r0[2] = (struct Eq_n) 22;
		r0->dw000C = r2_n;
		r0->dw0014 = 0x00;
		r0->dw001C = 0x00;
		r0[3] = (struct Eq_n) 0x17;
	}
	else
	{
		if (r3 != 0x00)
		{
			ui32 r4_n;
			r0->dw0000 = r2 | 0x14;
			if (r3 << 2 > 0x20)
			{
				uint32 r2_n = 0x40;
				ui32 r4_n;
				for (r4_n = 0x05; r4_n != 0x1F; ++r4_n)
				{
					r2_n <<= 0x01;
					if (r3 << 2 <= r2_n)
					{
						r4_n = g_dw1660 | r4_n << 0x01;
						goto l000015D6;
					}
				}
				r4_n = g_dw1664;
			}
			else
				r4_n = g_dw1680;
l000015D6:
			r0->dw0004 = r4_n;
		}
		ui32 r5_n;
		for (r5_n = 0x05; r5_n != 0x08; ++r5_n)
		{
			uint32 r4_n = r1->dw0004;
			if (r4_n != 0x00)
			{
				ui32 r3_n;
				r0[1] = (struct Eq_n) (r1->dw0000 | (r5_n | 0x10));
				if (r4_n > 0x20)
				{
					uint32 r2_n = 0x40;
					ui32 r3_n;
					for (r3_n = 0x05; r3_n != 0x1F; ++r3_n)
					{
						r2_n <<= 0x01;
						if (r4_n <= r2_n)
						{
							r3_n = r3_n << 1;
							goto l00001586;
						}
					}
					r3_n = 0x3E;
				}
				else
					r3_n = 0x08;
l00001586:
				r0->dw000C = r3_n | (r1->dw0008 | 0x01);
			}
			else
			{
				r0->dw000C = r4_n;
				r0[1] = (struct Eq_n) (r5_n | 0x10);
			}
			++r1;
			++r0;
		}
	}
}

ui32 g_dw1660 = 0x03070001; // 00001660
ui32 g_dw1664 = 0x0307003F; // 00001664
ui32 g_dw1668 = 0x20000000; // 00001668
word32 g_dw166C = 0x20002000; // 0000166C
ui32 g_dw1670 = 0x20000000; // 00001670
word32 g_dw1674 = 0x20000200; // 00001674
ui32 g_dw1678 = 0x01070001; // 00001678
ui32 g_dw167C = 0x0107003F; // 0000167C
ui32 g_dw1680 = 0x03070009; // 00001680
ui32 g_dw1684 = 0x01070009; // 00001684
// 00001688: void xPortPendSVHandler(Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 r9, Register word32 r10, Register word32 fp, Register ptr32 cpsr)
void xPortPendSVHandler(word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 r9, word32 r10, word32 fp, ptr32 cpsr)
{
	Eq_n r0_n = __mrs(cpsr);
	struct Eq_n ** r3_n = g_ptr16E0;
	struct Eq_n * r2_n = *r3_n;
	*((word32) r0_n - 36) = __mrs(cpsr);
	*((word32) r0_n - 32) = r4;
	*((word32) r0_n - 28) = r5;
	*((word32) r0_n - 24) = r6;
	*((word32) r0_n - 20) = r7;
	*((word32) r0_n - 16) = r8;
	*((word32) r0_n - 0x0C) = r9;
	*((word32) r0_n - 8) = r10;
	*((word32) r0_n - 4) = fp;
	r2_n->ptr0000 = r0_n - 36;
	__msr(cpsr, 191);
	vTaskSwitchContext();
	__msr(cpsr, 0x00);
	struct Eq_n * r1_n = *r3_n;
	union Eq_n * r0_n = r1_n->ptr0000;
	struct Eq_n * r2_n = g_ptr1728;
	word32 r5_n = r1_n->dw0008;
	word32 r6_n = r1_n->dw000C;
	word32 r7_n = r1_n->dw0010;
	word32 r8_n = r1_n->dw0014;
	word32 r9_n = r1_n->dw0018;
	word32 r10_n = r1_n->dw001C;
	word32 fp_n = r1_n->dw0020;
	r2_n->dw0000 = r1_n->dw0004;
	r2_n->dw0004 = r5_n;
	r2_n->dw0008 = r6_n;
	r2_n->dw000C = r7_n;
	r2_n->dw0010 = r8_n;
	r2_n->dw0014 = r9_n;
	r2_n->dw0018 = r10_n;
	r2_n->dw001C = fp_n;
	__msr(cpsr, *r0_n);
	__msr(cpsr, (char *) r0_n + 36);
}

Eq_n g_t1689 = // 00001689
	{
		&g_t148009F3,
		4016577099,
		&g_t208114F3,
		0x100FF2E9,
		&g_t8E92D60,
		0x11F38000,
		&g_t11F38000,
		0x08681940,
		&g_t4F10168,
		0x1A01,
		0xA20FF0E8,
		0xB00FF0E8,
		0x830FF8E8,
		&g_t808814F3,
		0x14,
		~0x5040FFB8,
		&g_tAF8000F3,
		0x80,
		0x10200000,
		0x11F3EFB5,
		~0x400FB07B,
		0x03,
		131,
	};
struct Eq_n ** g_ptr16E0 = &g_ptr200000C8; // 000016E0
// 000016E4: void xPortSysTickHandler(Register ptr32 cpsr)
void xPortSysTickHandler(ptr32 cpsr)
{
	Eq_n r4_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (xTaskIncrementTick() != 0x00)
		*g_ptr1710 = 0x10000000;
	__msr(cpsr, r4_n);
}

word32 * g_ptr1710 = &g_dwE000ED04; // 00001710
// 00001714: void vPortSVCHandler(Register ui32 lr, Register ptr32 cpsr)
void vPortSVCHandler(ui32 lr, ptr32 cpsr)
{
	if ((lr & 0x04) == 0x00)
		__mrs(cpsr);
	Eq_n r0_n = __mrs(cpsr);
	prvSVCHandler(r0_n, cpsr);
}

Eq_n g_t1715 = // 00001715
	{
		&g_tC0F04F0,
		0x08F3EFBF,
		&g_t9F3EF80,
		0x08E60780,
		&g_t9CE000ED,
		0x434604B5,
		&g_t67F7FF34,
		1085385320,
		&g_tD351B3F2,
		49400,
		0x09428C44,
		0x0742A2D8,
		3278379474,
		&g_t8C45C0F8,
		0xC0,
		0x104620FB,
		&g_tFF2400BD,
		~0x04,
		62722118,
		0x22020CF1,
		0x1A0207F0,
		0x60,
		227,
	};
union Eq_n ** g_ptr1724 = &g_ptrE000ED08; // 00001724
struct Eq_n * g_ptr1728 = &g_tE000ED9C; // 00001728
// 0000172C: Register ui32 pvPortMalloc(Register ui32 r0, Register ptr32 cpsr)
// Called from:
//      xQueueGenericCreate
//      xTaskCreate
//      xTaskCreateRestricted
//      xEventGroupCreate
//      MPU_pvPortMalloc
//      xCoRoutineCreate
ui32 pvPortMalloc(ui32 r0, ptr32 cpsr)
{
	ui32 r4_n = r0;
	if (r0 << 29 != 0x00)
		r4_n = r0 & ~0x07;
	vTaskSuspendAll();
	struct Eq_n * r3_n = g_ptr177C;
	word32 r4_n = r4_n + 0x08;
	if (r3_n->dw0000 == 0x00)
		Mem28[r3_n + 0x00:word32] = r3_n + 0x0C & ~0x07;
	up32 r2_n = r3_n->dw05C0;
	up32 r4_n = r4_n + r2_n;
	if (r4_n > 0x05B3 || r2_n >= r4_n)
	{
		xTaskResumeAll(cpsr);
		return 0x00;
	}
	else
	{
		ui32 r1_n = r3_n->dw0000;
		r3_n->dw05C0 = r4_n;
		xTaskResumeAll(cpsr);
		return r1_n + r2_n;
	}
}

struct Eq_n * g_ptr177C = &g_t20000230; // 0000177C
// 00001780: void vPortFree()
// Called from:
//      vQueueDelete
//      xTaskCreate
//      vEventGroupDelete
//      MPU_vPortFree
void vPortFree()
{
}

// 00001784: void vPortInitialiseBlocks()
// Called from:
//      MPU_vPortInitialiseBlocks
void vPortInitialiseBlocks()
{
	g_ptr1790->dw05C0 = 0x00;
}

struct Eq_n * g_ptr1790 = &g_t20000230; // 00001790
// 00001794: void xPortGetFreeHeapSize()
// Called from:
//      MPU_xPortGetFreeHeapSize
void xPortGetFreeHeapSize()
{
}

// 000017A8: void xEventGroupCreate(Register ptr32 cpsr)
// Called from:
//      MPU_xEventGroupCreate
void xEventGroupCreate(ptr32 cpsr)
{
	struct Eq_n * r0_n = pvPortMalloc(0x18, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0000 = null;
		vListInitialise(&r0_n->dw0004);
	}
}

// 000017C4: void xEventGroupWaitBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 r2, Register word32 r3, Register ptr32 cpsr, Stack up32 dwArg00)
// Called from:
//      MPU_xEventGroupWaitBits
void xEventGroupWaitBits(ui32 * r0, ui32 r1, word32 r2, word32 r3, ptr32 cpsr, up32 dwArg00)
{
	bool C_n = vTaskSuspendAll();
	ui32 r5_n = r1;
	ui32 r4_n = *r0;
	if (r3 == 0x00)
	{
		r4_n = r4_n + r1 + (word32) C_n;
		if (r4_n != 0x00)
		{
l000017DC:
			if (r2 != 0x00)
				*r0 = r4_n & ~r1;
l000017E8:
			xTaskResumeAll(cpsr);
			return;
		}
	}
	else if ((r1 & ~r4_n) == 0x00)
		goto l000017DC;
	if (dwArg00 == 0x00)
		goto l000017E8;
	ui32 r1_n = 0x01000000;
	if (r3 != 0x00)
		r1_n = 0x05000000;
	vTaskPlaceOnUnorderedEventList(r0 + 1, r1_n | r1, dwArg00);
	if (xTaskResumeAll(cpsr) == 0x00)
	{
		*g_ptr1870 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	if (uxTaskResetEventItemValue() << 6 < 0x00)
		return;
	bool C_n = vPortEnterCritical(cpsr);
	ui32 r4_n = *r0;
	if (r3 == 0x00)
	{
		r5_n = r1 + r4_n + (word32) C_n;
		if (r5_n == 0x00)
			goto l0000185C;
	}
	else if ((r1 & ~r4_n) != 0x00)
		goto l0000185C;
	if (r2 != 0x00)
		*r0 = r4_n & ~r5_n;
l0000185C:
	vPortExitCritical(cpsr);
}

word32 * g_ptr1870 = &g_dwE000ED04; // 00001870
// 00001874: void xEventGroupClearBits(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
// Called from:
//      MPU_xEventGroupClearBits
void xEventGroupClearBits(ui32 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	*r0 &= ~r1;
	vPortExitCritical(cpsr);
}

// 00001890: void xEventGroupSetBits(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ptr32 cpsr)
// Called from:
//      xEventGroupSync
//      vEventGroupSetBitsCallback
//      MPU_xEventGroupSetBits
void xEventGroupSetBits(struct Eq_n * r0, ui32 r1, ptr32 cpsr)
{
	ui32 r7_n;
	vTaskSuspendAll();
	struct Eq_n * r0_n = r0->ptr0010;
	ui32 r1_n = r0->dw0000 | r1;
	r0->dw0000 = r1_n;
	if (&r0->dw0000 + 3 != r0_n)
	{
		ui32 r7_n = 0x00;
		do
		{
			ui32 r3_n = r0_n->dw0000;
			struct Eq_n * r4_n = r0_n->ptr0004;
			ui32 r2_n = r3_n & 0x00FFFFFF;
			if ((r3_n & 0x04000000) == 0x00)
			{
				r2_n = (r3_n & 0x00FFFFFF) + r1_n + (word32) ((r3_n & 0x04000000) < 0x00);
				if (r2_n != 0x00)
				{
l000018B2:
					if (r3_n << 7 < 0x00)
						r7_n |= r2_n;
					xTaskRemoveFromUnorderedEventList(r0_n, r1_n | 0x02000000);
					r1_n = r0->dw0000;
				}
				r0_n = r4_n;
				if (&r0->dw0000 + 3 != r4_n)
					continue;
				break;
			}
			if ((r3_n & 0x00FFFFFF & ~r1_n) == 0x00)
				goto l000018B2;
			r0_n = r4_n;
		} while (&r0->dw0000 + 3 != r4_n);
		r7_n = ~r7_n;
	}
	else
		r7_n = ~0x00;
	r0->dw0000 = r1_n & r7_n;
	xTaskResumeAll(cpsr);
}

// 000018F8: void xEventGroupSync(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register up32 r3, Register ptr32 cpsr)
// Called from:
//      MPU_xEventGroupSync
void xEventGroupSync(struct Eq_n * r0, ui32 r1, ui32 r2, up32 r3, ptr32 cpsr)
{
	vTaskSuspendAll();
	ui32 r4_n = r0->dw0000 | r1;
	xEventGroupSetBits(r0, r1, cpsr);
	ui32 r6_n = r2;
	if ((r2 & ~r4_n) != 0x00)
	{
		if (r3 != 0x00)
		{
			vTaskPlaceOnUnorderedEventList(&r0->dw0000 + 1, r2 | 0x05000000, r3);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*g_ptr1984 = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
			if (uxTaskResetEventItemValue() << 6 >= 0x00)
			{
				vPortEnterCritical(cpsr);
				ui32 r4_n = r0->dw0000;
				if ((r2 & ~r4_n) == 0x00)
					r6_n = r4_n & ~r2;
				r0->dw0000 = r6_n;
				vPortExitCritical(cpsr);
			}
			return;
		}
	}
	else
		r0->dw0000 &= ~r2;
	xTaskResumeAll(cpsr);
}

word32 * g_ptr1984 = &g_dwE000ED04; // 00001984
// 00001988: void xEventGroupGetBitsFromISR(Register ptr32 cpsr)
void xEventGroupGetBitsFromISR(ptr32 cpsr)
{
	Eq_n r3_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	__msr(cpsr, r3_n);
}

// 000019A4: void vEventGroupDelete(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
// Called from:
//      MPU_vEventGroupDelete
void vEventGroupDelete(struct Eq_n * r0, ptr32 cpsr)
{
	vTaskSuspendAll();
	while (r0->dw0004 != 0x00)
		xTaskRemoveFromUnorderedEventList(r0->ptr0010, 0x02000000);
	vPortFree();
	xTaskResumeAll(cpsr);
}

// 000019D0: void vEventGroupSetBitsCallback(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ptr32 cpsr)
void vEventGroupSetBitsCallback(struct Eq_n * r0, ui32 r1, ptr32 cpsr)
{
	xEventGroupSetBits(r0, r1, cpsr);
}

// 000019D4: void vEventGroupClearBitsCallback(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
void vEventGroupClearBitsCallback(ui32 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	*r0 &= ~r1;
	vPortExitCritical(cpsr);
}

