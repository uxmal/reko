// redir_text.c
// Generated by decompiling redir
// using Reko decompiler version 0.11.4.0.

#include "redir.h"

// 00400230: void __start(Stack word32 dwArg00)
void __start(word32 dwArg00)
{
	ptr32 fp;
	word32 r2_n = *(word32 *) 0x100107A0;
	(*(<anonymous> **) 0x100107F8)();
	while (true)
		;
}

// 00400290: void strcpy(Register (ptr32 Eq_n) r28, Register word32 ra)
void strcpy(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	__do_global_dtors_aux();
}

// 004002A0: void printf(Register (ptr32 Eq_n) r28, Register word32 ra)
void printf(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004002B0: void recv(Register (ptr32 Eq_n) r28, Register word32 ra)
void recv(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004002C0: void connect(Register (ptr32 Eq_n) r28, Register word32 ra)
void connect(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004002D0: void strerror(Register (ptr32 Eq_n) r28, Register word32 ra)
void strerror(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	__do_global_dtors_aux();
}

// 004002E0: void __xpg_basename(Register (ptr32 Eq_n) r28, Register word32 ra)
void __xpg_basename(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004002F0: void snprintf(Register (ptr32 Eq_n) r28, Register word32 ra)
void snprintf(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400300: void getpid(Register (ptr32 Eq_n) r28, Register word32 ra)
void getpid(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400310: void fgets(Register (ptr32 Eq_n) r28, Register word32 ra)
void fgets(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400320: void memcpy(Register (ptr32 Eq_n) r28, Register word32 ra)
void memcpy(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400330: void tolower(Register (ptr32 Eq_n) r28, Register word32 ra)
void tolower(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400340: void malloc(Register (ptr32 Eq_n) r28, Register word32 ra)
void malloc(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400350: void vsnprintf(Register (ptr32 Eq_n) r28, Register word32 ra)
void vsnprintf(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	__do_global_dtors_aux();
}

// 00400360: void strtoul(Register (ptr32 Eq_n) r28, Register word32 ra)
void strtoul(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400370: void socket(Register (ptr32 Eq_n) r28, Register word32 ra)
void socket(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400380: void select(Register (ptr32 Eq_n) r28, Register word32 ra)
void select(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400390: void fflush(Register (ptr32 Eq_n) r28, Register word32 ra)
void fflush(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004003A0: void strncasecmp(Register (ptr32 Eq_n) r28, Register word32 ra)
void strncasecmp(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004003B0: void bzero(Register (ptr32 Eq_n) r28, Register word32 ra)
void bzero(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004003C0: void send(Register (ptr32 Eq_n) r28, Register word32 ra)
void send(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004003D0: void accept(Register (ptr32 Eq_n) r28, Register word32 ra)
void accept(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004003E0: void rename(Register (ptr32 Eq_n) r28, Register word32 ra)
void rename(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004003F0: void strrchr(Register (ptr32 Eq_n) r28, Register word32 ra)
void strrchr(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400400: void fprintf(Register (ptr32 Eq_n) r28, Register word32 ra)
void fprintf(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400410: void strcat(Register (ptr32 Eq_n) r28, Register word32 ra)
void strcat(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400420: void bind(Register (ptr32 Eq_n) r28, Register word32 ra)
void bind(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400430: void inet_addr(Register (ptr32 Eq_n) r28, Register word32 ra)
void inet_addr(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400440: void signal(Register (ptr32 Eq_n) r28, Register word32 ra)
void signal(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400450: void read(Register (ptr32 Eq_n) r28, Register word32 ra)
void read(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	r28->ptrFFFF8010();
	__do_global_dtors_aux();
}

// 00400460: void strncmp(Register (ptr32 Eq_n) r28, Register word32 ra)
void strncmp(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400470: void strncpy(Register (ptr32 Eq_n) r28, Register word32 ra)
void strncpy(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400480: void unlink(Register (ptr32 Eq_n) r28, Register word32 ra)
void unlink(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400490: void strcasecmp(Register (ptr32 Eq_n) r28, Register word32 ra)
void strcasecmp(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004004A0: void listen(Register (ptr32 Eq_n) r28, Register word32 ra)
void listen(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004004B0: void fork(Register (ptr32 Eq_n) r28, Register word32 ra)
void fork(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004004C0: void gettimeofday(Register (ptr32 Eq_n) r28, Register word32 ra)
void gettimeofday(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004004D0: void fopen(Register (ptr32 Eq_n) r28, Register word32 ra)
void fopen(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004004E0: void ftell(Register (ptr32 Eq_n) r28, Register word32 ra)
void ftell(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004004F0: void fclose(Register (ptr32 Eq_n) r28, Register word32 ra)
void fclose(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400500: void inet_ntoa(Register (ptr32 Eq_n) r28, Register word32 ra)
void inet_ntoa(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400510: void time(Register (ptr32 Eq_n) r28, Register word32 ra)
void time(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400520: void strcspn(Register (ptr32 Eq_n) r28, Register word32 ra)
void strcspn(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400530: void strsep(Register (ptr32 Eq_n) r28, Register word32 ra)
void strsep(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400540: void getsockopt(Register (ptr32 Eq_n) r28, Register word32 ra)
void getsockopt(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400550: void strftime(Register (ptr32 Eq_n) r28, Register word32 ra)
void strftime(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400560: void __errno_location(Register (ptr32 Eq_n) r28, Register word32 ra)
void __errno_location(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400570: void exit(Register (ptr32 Eq_n) r28, Register word32 ra)
void exit(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400580: void gmtime(Register (ptr32 Eq_n) r28, Register word32 ra)
void gmtime(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400590: void strspn(Register (ptr32 Eq_n) r28, Register word32 ra)
void strspn(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004005A0: void strlen(Register (ptr32 Eq_n) r28, Register word32 ra)
void strlen(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004005B0: void __uClibc_start_main(Register (ptr32 Eq_n) r28, Register word32 ra)
void __uClibc_start_main(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004005C0: void toupper(Register (ptr32 Eq_n) r28, Register word32 ra)
void toupper(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004005D0: void strchr(Register (ptr32 Eq_n) r28, Register word32 ra)
void strchr(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004005E0: void close(Register (ptr32 Eq_n) r28, Register word32 ra)
void close(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 004005F0: void strpbrk(Register (ptr32 Eq_n) r28, Register word32 ra)
void strpbrk(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
}

// 00400600: void free(Register (ptr32 Eq_n) r28, Register word32 ra)
void free(struct Eq_n * r28, word32 ra)
{
	r28->ptrFFFF8010();
	__do_global_dtors_aux();
}

// 00400620: void __do_global_dtors_aux()
// Called from:
//      strcpy
//      strerror
//      vsnprintf
//      read
//      free
void __do_global_dtors_aux()
{
	if (g_ptr10000878->dw0008 == 0x00)
	{
		<anonymous> ** r3_n = g_ptr10000878->ptr0004;
		if (*r3_n != null)
		{
			<anonymous> ** r2_n = (char *) r3_n + 4;
			while (true)
			{
				<anonymous> * r25_n = *r3_n;
				g_ptr10000878->ptr0004 = r2_n;
				word32 r4_n;
				r25_n();
				r3_n = g_ptr10000878->ptr0004;
				if (*r3_n == null)
					break;
				r2_n = (<anonymous> **) ((char *) r3_n + 4);
			}
		}
		if (__deregister_frame_info != null)
			__deregister_frame_info(&g_ptr10000878->dw0824 + 11);
		g_ptr10000878->dw0008 = 1;
	}
}

// 00400704: void fini_dummy()
void fini_dummy()
{
}

// 0040072C: void frame_dummy()
void frame_dummy()
{
	if (__register_frame_info != null)
		__register_frame_info(&g_ptr10000878->dw0824 + 11, (char *) &g_ptr10000878->ptr0854 + 604);
}

// 00400784: void init_dummy()
void init_dummy()
{
}

// 004007B0: void handle_stop(Register word32 r4, Register word32 ra)
void handle_stop(word32 r4, word32 ra)
{
	word32 r5_n;
	word32 r6_n;
	word32 r7_n;
	word32 r25_n;
	print_log(3, 0x00409DD4, out r5_n, out r6_n, out r7_n, out r25_n);
	*g_ptr100008C0 = 1;
}

// 0040083C: void handle_log_rotate(Register word32 r4, Register word32 ra)
void handle_log_rotate(word32 r4, word32 ra)
{
	word32 r5_n;
	word32 r6_n;
	word32 r7_n;
	word32 r25_n;
	print_log(3, 0x00409E04, out r5_n, out r6_n, out r7_n, out r25_n);
	log_rotate(ra);
}

// 004008D0: void main(Register int32 r4, Register (arr Eq_n) r5, Register word32 r16, Register word32 ra)
void main(int32 r4, Eq_n r5[], word32 r16, word32 ra)
{
	struct Eq_n * fp;
	*g_ptr10000A20 = *g_ptr10000914;
	signal(2, handle_stop);
	signal(1, handle_log_rotate);
	properties_load(r5[0].ptr0000, 0x00, ra);
	properties_parse_command_line(r4, r5, r16, ra);
	if (g_ptr10000A40->dw04BC != 0x00)
	{
		if (fork() != 0x00)
			exit(0x00);
		close(0x00);
		close(1);
		close(2);
	}
	struct Eq_n * r2_n = g_ptr10000A40;
	if (r2_n != (struct Eq_n *) 0x0695 && (word32) r2_n->b0695 != 0x00)
	{
		FILE * r2_n = fopen(&r2_n->b0695, "w");
		if (r2_n != null)
		{
			fprintf(r2_n, "%d\n", getpid());
			fclose(r2_n);
		}
	}
	*g_ptr100008F4 = g_ptr10000A40->dw038C;
	g_ptr100008A0->ptr0000 = (union Eq_n *) ((char *) &g_ptr10000A40->dw038C + 0x0011);
	*g_ptr10000A28 = g_ptr10000A40->dw0684 << 0x0A;
	*g_ptr1000090C = (int32) g_ptr10000A40->t05EC;
	open_log("a", ra);
	__xpg_basename(r5[0].ptr0000);
	*g_ptr10000A28 >= 0x00;
	word32 r6_n;
	word32 r5_n;
	word32 r7_n;
	word32 r25_n;
	print_log(3, 4234832, out r5_n, out r6_n, out r7_n, out r25_n);
	word32 r4_n;
	word32 r5_n;
	struct Eq_n * r2_n = clist_new(ra, out r4_n, out r5_n);
	if (r2_n != null)
	{
		Eq_n r2_n = slist_new(ra);
		if (r2_n != 0x00)
		{
			slist_add(r2_n, server_new((char *) &g_ptr10000A40->a0004->t0004 + 5, g_ptr10000A40->dw012C, g_ptr10000A40->dw0554, 0x00, ra));
			slist_add(r2_n, server_new((char *) &g_ptr10000A40->a0004->t0004 + 5, g_ptr10000A40->dw01C4, g_ptr10000A40->dw0554, 1, ra));
			bzero((char *) fp - 328, (size_t) 16);
			Eq_n r7_n = <invalid>;
			Eq_n r6_n = <invalid>;
			Eq_n r5_n = <invalid>;
			Eq_n r4_n = <invalid>;
			inet_addr(r4_n, (char *) &g_ptr10000A40->dw01C4 + 0x0011, r5_n, r6_n, r7_n, 0x02, g_ptr10000A40->w02F6);
			Eq_n dwLoc0150_n = *((char *) r2_n.ptr0000 + 8);
			while (true)
			{
				Eq_n r5_n;
				struct Eq_n * r28_n = (struct Eq_n *) 0x10008860;
				if (dwLoc0150_n == 0x00)
					break;
				if (server_open(dwLoc0150_n, ra, out r5_n) == 0x00)
				{
					exit(-1);
					r5_n = r5_n;
				}
				dwLoc0150_n = *((char *) dwLoc0150_n.ptr0000 + 24);
			}
			while (*r28_n->ptrFFFF8060 == 0x00)
			{
				word32 r2_n;
				r28_n->ptrFFFF80D0();
				Eq_n dwLoc0160_n = 0x00;
				Eq_n dwLoc2C_n = 0x00;
				while ((word32) (dwLoc2C_n < 32) != 0x00)
				{
					fp->aFFFFFED0[dwLoc2C_n] = 0x00;
					dwLoc2C_n = (word32) dwLoc2C_n.u1 + 1;
				}
				Eq_n dwLoc28_n = 0x00;
				while ((word32) (dwLoc28_n < 32) != 0x00)
				{
					fp->aFFFFFF50[dwLoc28_n] = 0x00;
					dwLoc28_n = (word32) dwLoc28_n.u1 + 1;
				}
				Eq_n dwLoc0150_n = *((char *) r2_n.ptr0000 + 8);
				while (dwLoc0150_n != 0x00)
				{
					Eq_n r2_n = *dwLoc0150_n.ptr0000;
					fp->aFFFFFED0[r2_n >> 0x05] |= 1 << (*dwLoc0150_n.ptr0000 & 0x1F);
					if ((word32) (dwLoc0160_n < *dwLoc0150_n.ptr0000) != 0x00)
						dwLoc0160_n = *dwLoc0150_n.ptr0000;
					dwLoc0150_n = *((char *) dwLoc0150_n.ptr0000 + 24);
				}
				Eq_n dwLoc0158_n = r2_n->t0008.ptr0000;
				while (dwLoc0158_n != 0x00)
				{
					if (*dwLoc0158_n.ptr0000 >= 0x00)
					{
						if ((word32) (dwLoc0160_n < *dwLoc0158_n.ptr0000) != 0x00)
							dwLoc0160_n = *dwLoc0158_n.ptr0000;
						if (*((char *) dwLoc0158_n.ptr0000 + 0x0FAC) == 0x00)
						{
							Eq_n r2_n = *dwLoc0158_n.ptr0000;
							fp->aFFFFFED0[r2_n >> 0x05] |= 1 << (*dwLoc0158_n.ptr0000 & 0x1F);
						}
						else
						{
							Eq_n r2_n = *dwLoc0158_n.ptr0000;
							fp->aFFFFFF50[r2_n >> 0x05] |= 1 << (*dwLoc0158_n.ptr0000 & 0x1F);
						}
					}
					if (*((char *) dwLoc0158_n.ptr0000 + 4) >= 0x00)
					{
						if ((word32) (dwLoc0160_n < *((char *) dwLoc0158_n.ptr0000 + 4)) != 0x00)
							dwLoc0160_n = *((char *) dwLoc0158_n.ptr0000 + 4);
						if (*((char *) dwLoc0158_n.ptr0000 + 6028) == 0x00)
						{
							Eq_n r2_n = *((char *) dwLoc0158_n.ptr0000 + 4);
							fp->aFFFFFED0[r2_n >> 0x05] |= 1 << (*((char *) dwLoc0158_n.ptr0000 + 4) & 0x1F);
						}
						else
						{
							Eq_n r2_n = *((char *) dwLoc0158_n.ptr0000 + 4);
							fp->aFFFFFF50[r2_n >> 0x05] |= 1 << (*((char *) dwLoc0158_n.ptr0000 + 4) & 0x1F);
						}
					}
					dwLoc0158_n = *((char *) dwLoc0158_n.ptr0000 + 6072);
				}
				if (select((word32) dwLoc0160_n.u1 + 1, fp->aFFFFFED0, 0x00, 0x00, 0x00) < 0x00)
				{
					r5_n = (Eq_n) <invalid>;
					r28_n = (struct Eq_n *) 0x10008860;
					if (*__errno_location() == 4)
						continue;
					__errno_location();
					strerror(*__errno_location());
					word32 r25_n;
					word32 r6_n;
					word32 r7_n;
					word32 r5_n;
					print_log(0x00, 0x00409EB0, out r5_n, out r6_n, out r7_n, out r25_n);
					exit(-1);
					r5_n = r5_n;
				}
				r28_n = (struct Eq_n *) 0x10008860;
				Eq_n dwLoc0150_n = *((char *) r2_n.ptr0000 + 8);
				while (dwLoc0150_n != 0x00)
				{
					if ((fp->aFFFFFED0[*dwLoc0150_n.ptr0000 >> 0x05] >> (*dwLoc0150_n.ptr0000 & 0x1F) & 0x01) != 0x00)
					{
						Eq_n r2_n;
						r28_n->ptrFFFF80D8();
						r28_n = (struct Eq_n *) 0x10008860;
						if (r2_n != 0x00)
						{
							r28_n = (struct Eq_n *) 0x10008860;
							if (clist_add(r2_n, r2_n, out r5_n) == 0x00)
							{
								word32 r25_n;
								word32 r5_n;
								word32 r6_n;
								word32 r7_n;
								print_log(1, 0x00409ECC, out r5_n, out r6_n, out r7_n, out r25_n);
								r5_n = client_destroy(r2_n, ra);
								r28_n = (struct Eq_n *) 0x10008860;
							}
						}
					}
					dwLoc0150_n = *((char *) dwLoc0150_n.ptr0000 + 24);
				}
				Eq_n dwLoc0158_n = r2_n->t0008.ptr0000;
				while (dwLoc0158_n != 0x00)
				{
					if (dwLoc0158_n != 0x00 && (*dwLoc0158_n.ptr0000 >= 0x00 && ((fp->aFFFFFED0)[*dwLoc0158_n.ptr0000 >> 0x05] >> (*dwLoc0158_n.ptr0000 & 0x1F) & 0x01) != 0x00))
					{
						r28_n->ptrFFFF8108();
						r28_n = (struct Eq_n *) 0x10008860;
						if (*((char *) dwLoc0158_n.ptr0000 + 2008) <= 0x00)
						{
							if (*dwLoc0158_n.ptr0000 >= 0x00)
							{
								close(*dwLoc0158_n.ptr0000);
								*dwLoc0158_n.ptr0000 = (Eq_n) -1;
								r5_n = (Eq_n) <invalid>;
								r28_n = (struct Eq_n *) 0x10008860;
							}
						}
						else
						{
							<anonymous> * r2_n = *((char *) dwLoc0158_n.ptr0000 + 6080);
							r2_n();
							word32 r25_n;
							r5_n = client_send_request(dwLoc0158_n, ra, out r25_n);
							r28_n = (struct Eq_n *) 0x10008860;
						}
					}
					if (dwLoc0158_n != 0x00 && (*((char *) dwLoc0158_n.ptr0000 + 4) >= 0x00 && ((fp->aFFFFFED0)[*((char *) dwLoc0158_n.ptr0000 + 4) >> 0x05] >> (*((char *) dwLoc0158_n.ptr0000 + 4) & 0x1F) & 0x01) != 0x00))
					{
						r28_n->ptrFFFF81F0();
						r28_n = (struct Eq_n *) 0x10008860;
						if (*((char *) dwLoc0158_n.ptr0000 + 6028) <= 0x00)
						{
							if (*((char *) dwLoc0158_n.ptr0000 + 4) >= 0x00)
							{
								close(*((char *) dwLoc0158_n.ptr0000 + 4));
								*((char *) dwLoc0158_n.ptr0000 + 4) = (Eq_n) -1;
								r5_n = (Eq_n) <invalid>;
								r28_n = (struct Eq_n *) 0x10008860;
							}
						}
						else
						{
							<anonymous> * r2_n = *((char *) dwLoc0158_n.ptr0000 + 6084);
							word32 r25_n;
							r2_n();
							r28_n = (struct Eq_n *) 0x10008860;
						}
					}
					if (dwLoc0158_n != 0x00 && (*dwLoc0158_n.ptr0000 >= 0x00 && ((fp->aFFFFFF50)[*dwLoc0158_n.ptr0000 >> 0x05] >> (*dwLoc0158_n.ptr0000 & 0x1F) & 0x01) != 0x00))
					{
						<anonymous> * r2_n = *((char *) dwLoc0158_n.ptr0000 + 6084);
						word32 r25_n;
						r2_n();
						r28_n = (struct Eq_n *) 0x10008860;
					}
					if (dwLoc0158_n != 0x00 && (*((char *) dwLoc0158_n.ptr0000 + 4) >= 0x00 && ((fp->aFFFFFF50)[*((char *) dwLoc0158_n.ptr0000 + 4) >> 0x05] >> (*((char *) dwLoc0158_n.ptr0000 + 4) & 0x1F) & 0x01) != 0x00))
					{
						r28_n->ptrFFFF8150();
						r28_n = (struct Eq_n *) 0x10008860;
					}
					if (dwLoc0158_n != 0x00)
					{
						if ((*((char *) dwLoc0158_n.ptr0000 + 4) >= 0x00 || *dwLoc0158_n.ptr0000 >= 0x00) && ((*((char *) dwLoc0158_n.ptr0000 + 4) >= 0x00 || (*dwLoc0158_n.ptr0000 < 0x00 || *((char *) dwLoc0158_n.ptr0000 + 6028) > 0x00)) && (*dwLoc0158_n.ptr0000 >= 0x00 || (*((char *) dwLoc0158_n.ptr0000 + 4) < 0x00 || *((char *) dwLoc0158_n.ptr0000 + 0x0FAC) > 0x00))))
						{
							int32 r2_n;
							r28_n->ptrFFFF8038();
							r28_n = (struct Eq_n *) 0x10008860;
							if ((word32) (r2_n < 3) != 0x00)
								goto l00401AA4;
						}
						r28_n->ptrFFFF81B4();
						r28_n = (struct Eq_n *) 0x10008860;
						dwLoc0158_n = (Eq_n) 0x00;
						goto l00401AA4;
					}
l00401AA4:
					if (dwLoc0158_n == 0x00)
						break;
					dwLoc0158_n = *((char *) dwLoc0158_n.ptr0000 + 6072);
				}
			}
			r28_n->ptrFFFF8130();
			slist_destroy(r2_n, ra);
			if (r2_n != (struct Eq_n *) 0x0695 && (word32) r2_n->b0695 != 0x00)
				unlink(&r2_n->b0695);
			exit(0x00);
		}
		else
			exit(-1);
	}
	else
		exit(-1);
}

// 00401B70: void client_new(Register (ptr32 Eq_n) r4, Register (ptr32 Eq_n) r5, Register int32 r6, Register int32 r7, Register word32 ra)
// Called from:
//      main
void client_new(struct Eq_n * r4, struct Eq_n * r5, int32 r6, int32 r7, word32 ra)
{
	ptr32 fp;
	Eq_n r2_n = malloc((size_t) 6100);
	if (r2_n == 0x00)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(0x00, 0x00409F00, out r5_n, out r6_n, out r7_n, out r25_n);
	}
	else
	{
		bzero((char *) r2_n.ptr0000 + 6040, (size_t) 16);
		*((char *) r2_n.ptr0000 + 6040) = (Eq_n) 0x02;
		*((char *) r2_n.ptr0000 + 6042) = (Eq_n) r4->w0002;
		*((char *) r2_n.ptr0000 + 6044) = (Eq_n) r4->dw0004;
		*r2_n.ptr0000 = (Eq_n) accept(r6, (char *) r2_n.ptr0000 + 6040, fp + -32);
		*((char *) r2_n.ptr0000 + 6056) = (Eq_n) 0x02;
		*((char *) r2_n.ptr0000 + 0x000017AA) = (Eq_n) r5->w0002;
		*((char *) r2_n.ptr0000 + 6060) = (Eq_n) r5->dw0004;
		*((char *) r2_n.ptr0000 + 6032) = (Eq_n) r7;
		*((char *) r2_n.ptr0000 + 4) = (Eq_n) open_destination((char *) r2_n.ptr0000 + 6056, ra);
		if (*((char *) r2_n.ptr0000 + 4) < 0x00)
		{
			word32 r5_n;
			word32 r6_n;
			word32 r7_n;
			word32 r25_n;
			print_log(1, 0x00409F28, out r5_n, out r6_n, out r7_n, out r25_n);
			close(*r2_n.ptr0000);
			free(r2_n);
		}
		else
		{
			inet_ntoa(*((char *) r2_n.ptr0000 + 6044));
			word32 r5_n;
			word32 r6_n;
			word32 r7_n;
			word32 r25_n;
			print_log(3, 0x00409F60, out r5_n, out r6_n, out r7_n, out r25_n);
			*((char *) r2_n.ptr0000 + 2008) = (Eq_n) 0x00;
			*((char *) r2_n.ptr0000 + 0x0FAC) = (Eq_n) 0x00;
			*((char *) r2_n.ptr0000 + 6028) = (Eq_n) 0x00;
			*((char *) r2_n.ptr0000 + 0x0FB0) = (Eq_n) ((char *) r2_n.ptr0000 + 2012);
			*((char *) r2_n.ptr0000 + 0x00001788) = (Eq_n) ((char *) r2_n.ptr0000 + 4024);
			*((char *) r2_n.ptr0000 + 6036) = (Eq_n) 0x00;
			*((char *) r2_n.ptr0000 + 4020) = (Eq_n) 0x00;
			*((char *) r2_n.ptr0000 + 6076) = (Eq_n) 0x00;
			*((char *) r2_n.ptr0000 + 6072) = (Eq_n) 0x00;
			*((char *) r2_n.ptr0000 + 6088) = (Eq_n) time(null);
			*((char *) r2_n.ptr0000 + 0x000017CC) = (Eq_n) time(null);
			*((char *) r2_n.ptr0000 + 6096) = (Eq_n) time(null);
			if (r7 != 0x00)
			{
				if (r7 == 1)
				{
					*((char *) r2_n.ptr0000 + 6080) = (Eq_n) client_copy_request;
					*((char *) r2_n.ptr0000 + 6084) = (Eq_n) client_parse_reply;
					word32 r6_n;
					word32 r7_n;
					client_prepare_connect(r2_n, ra, out r6_n, out r7_n);
					word32 r25_n;
					client_send_request(r2_n, ra, out r25_n);
				}
			}
			else
			{
				*((char *) r2_n.ptr0000 + 6080) = (Eq_n) client_parse_request;
				*((char *) r2_n.ptr0000 + 6084) = (Eq_n) client_copy_reply;
			}
		}
	}
}

// 00402028: Register word32 client_prepare_connect(Register Eq_n r4, Register word32 ra, Register out ptr32 r6Out, Register out ptr32 r7Out)
// Called from:
//      client_new
word32 client_prepare_connect(Eq_n r4, word32 ra, ptr32 & r6Out, ptr32 & r7Out)
{
	ptr32 fp;
	getsockopt(*r4.ptr0000, 0x00, 80, (char *) r4.ptr0000 + 6040, fp + -24, 0x10008860, 16);
	inet_ntoa(*((char *) r4.ptr0000 + 6044));
	inet_ntoa(*((char *) r4.ptr0000 + 6044));
	Eq_n r2_n = snprintf(fp + -0x0118, (size_t) 0x0100, "CONNECT %s:%d HTTP/1.1\r\nHost: %s:%d\r\n\r\n", 0x00);
	Eq_n dwLoc18_n = r2_n;
	if ((word32) (r2_n < 0x0100) == 0x00)
		dwLoc18_n.u0 = 0x0100;
	ptr32 r7_n;
	word32 r5_n;
	ptr32 r6_n;
	add_to_request(r4, *((char *) r4.ptr0000 + 0x0FB0), fp + -0x0118, dwLoc18_n, ra, out r5_n, out r6_n, out r7_n);
	r6Out = r6_n;
	r7Out = r7_n;
	return r5_n;
}

// 004021A0: void client_copy_request(Register (ptr32 Eq_n) r4)
void client_copy_request(struct Eq_n * r4)
{
	memcpy((char *) &r4->t07D8 + 4, (char *) r4 + 8, r4->t07D8);
	r4->ptr0FB0 = (char *) &r4->t07D8 + 4;
	r4->t0FAC = r4->t07D8;
}

// 00402244: void client_parse_request(Register Eq_n r4, Register word32 ra)
void client_parse_request(Eq_n r4, word32 ra)
{
	ptr32 fp;
	int8 bLoc0810;
	int8 * dwLoc40_n = (char *) r4.ptr0000 + 8;
	int32 r2_n = *((char *) r4.ptr0000 + 2008);
	void * dwLoc28_n = (char *) r4.ptr0000 + 2012;
	Eq_n dwLoc20_n = *((char *) r4.ptr0000 + 4020);
	while (r2_n > 0x00)
	{
		int8 * r2_n = get_a_line(fp + -0x0810, dwLoc40_n, fp + -0x0818);
		int32 dwLoc1C_n = 0x00;
		if ((word32) bLoc0810 == 0x0A || (word32) bLoc0810 == 0x0D)
			dwLoc1C_n = 1;
		int32 r2_n = *((char *) r4.ptr0000 + 6036);
		if (r2_n != 1)
		{
			if ((word32) (r2_n < 2) != 0x00)
			{
				if (r2_n == 0x00)
				{
					if (dwLoc1C_n == 0x00)
					{
						if (*((char *) r4.ptr0000 + 4020) != 0x00)
						{
							word32 r25_n;
							word32 r7_n;
							word32 r6_n;
							word32 r5_n;
							print_log(4, 0x0040A008, out r5_n, out r6_n, out r7_n, out r25_n);
							Eq_n r2_n = *((char *) r4.ptr0000 + 4020);
							dwLoc20_n = r2_n;
							if (request_parse_line(r2_n, fp + -0x0810, ra) == 0x00)
							{
								word32 r5_n;
								word32 r6_n;
								word32 r25_n;
								word32 r7_n;
								print_log(4, 4235324, out r5_n, out r6_n, out r7_n, out r25_n);
								request_destroy(r2_n);
								dwLoc20_n = (Eq_n) 0x00;
							}
						}
						else
							dwLoc20_n = request_new(fp + -0x0810, ra);
						*((char *) r4.ptr0000 + 4020) = dwLoc20_n;
						if (dwLoc20_n != 0x00)
							*((char *) r4.ptr0000 + 6036) = (Eq_n) 1;
						else
						{
							word32 r7_n;
							word32 r25_n;
							word32 r6_n;
							word32 r5_n;
							print_log(3, 0x0040A074, out r5_n, out r6_n, out r7_n, out r25_n);
							word32 r7_n;
							word32 r6_n;
							word32 r5_n;
							add_to_request(r4, dwLoc28_n, fp + -0x0810, 0x00, ra, out r5_n, out r6_n, out r7_n);
							*((char *) r4.ptr0000 + 6036) = (Eq_n) 2;
						}
					}
					else
					{
						word32 r5_n;
						word32 r6_n;
						word32 r7_n;
						add_to_request(r4, dwLoc28_n, fp + -0x0810, 0x00, ra, out r5_n, out r6_n, out r7_n);
					}
				}
			}
			else if (r2_n != 2)
			{
				if (r2_n == 3)
				{
					word32 r7_n;
					word32 r6_n;
					word32 r5_n;
					dwLoc28_n = add_to_request(r4, dwLoc28_n, fp + -0x0810, 0x00, ra, out r5_n, out r6_n, out r7_n);
					*((char *) dwLoc20_n.ptr0000 + 0x0554) = *((char *) dwLoc20_n.ptr0000 + 0x0554);
					if (*((char *) dwLoc20_n.ptr0000 + 0x0554) == 0x00)
						*((char *) r4.ptr0000 + 6036) = (Eq_n) 0x00;
				}
			}
			else
			{
				word32 r6_n;
				word32 r7_n;
				word32 r5_n;
				dwLoc28_n = add_to_request(r4, dwLoc28_n, fp + -0x0810, 0x00, ra, out r5_n, out r6_n, out r7_n);
				if (dwLoc1C_n != 0x00)
				{
					if (dwLoc20_n != 0x00 && *((char *) dwLoc20_n.ptr0000 + 0x0554) == 0x00)
						*((char *) r4.ptr0000 + 6036) = (Eq_n) 0x00;
					else
						*((char *) r4.ptr0000 + 6036) = (Eq_n) 3;
				}
				else if (false && strncasecmp(&g_t409FF4, fp + -0x0810, 0x0A) == 0x00)
					request_get_content_length(dwLoc20_n, fp + -0x0810, ra);
			}
		}
		else
		{
			if (dwLoc1C_n != 0x00)
			{
				word32 r25_n;
				word32 r5_n;
				word32 r6_n;
				word32 r7_n;
				print_log(2, 4235444, out r5_n, out r6_n, out r7_n, out r25_n);
				*((char *) r4.ptr0000 + 6036) = (Eq_n) 0x00;
				return;
			}
			if (false && strncasecmp(fp + -0x0810, "host: ", 6) == 0x00)
			{
				if (dwLoc20_n == 0x00)
				{
					word32 r5_n;
					word32 r6_n;
					word32 r7_n;
					word32 r25_n;
					print_log(2, 0x00409FC4, out r5_n, out r6_n, out r7_n, out r25_n);
				}
				else
				{
					request_get_host(dwLoc20_n, fp + -0x0810, ra);
					request_make_url(dwLoc20_n, ra);
					word32 r5_n;
					word32 r6_n;
					word32 r7_n;
					word32 r5_n;
					word32 r6_n;
					word32 r7_n;
					dwLoc28_n = add_to_request(r4, request_add_lines(dwLoc20_n, r4, add_to_request(r4, dwLoc28_n, (char *) dwLoc20_n.ptr0000 + 532, (uint32) strlen((char *) dwLoc20_n.ptr0000 + 532), ra, out r5_n, out r6_n, out r7_n)), fp + -0x0810, 0x00, ra, out r5_n, out r6_n, out r7_n);
					*((char *) r4.ptr0000 + 6036) = (Eq_n) 2;
				}
			}
			else if (false && strncasecmp(&g_t409FE0, fp + -0x0810, 0x0A) == 0x00)
			{
				request_get_content_length(dwLoc20_n, fp + -0x0810, ra);
				request_save_line(dwLoc20_n, fp + -0x0810, 0x00, ra);
			}
			else
				request_save_line(dwLoc20_n, fp + -0x0810, 0x00, ra);
		}
		dwLoc40_n = r2_n;
	}
}

// 00402A60: Register (ptr32 void) add_to_request(Register Eq_n r4, Register (ptr32 void) r5, Register (ptr32 void) r6, Register Eq_n r7, Register word32 ra, Register out Eq_n r5Out, Register out Eq_n r6Out, Register out Eq_n r7Out)
// Called from:
//      client_prepare_connect
//      client_parse_request
void * add_to_request(Eq_n r4, void * r5, void * r6, Eq_n r7, word32 ra, struct Eq_n & r5Out, struct Eq_n & r6Out, struct Eq_n & r7Out)
{
	Eq_n r7_n;
	Eq_n r6_n;
	void * r2_n;
	Eq_n r5_n;
	if (r5 == null)
	{
		word32 r25_n;
		print_log(1, 0x0040A0E4, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = null;
	}
	else if (r6 != null && r7 > 0x00)
	{
		Mem51[r4 + 0x0FAC:word32] = Mem21[r4 + 0x0FAC:word32] + r7;
		if ((word32) (*((char *) r4.ptr0000 + 0x0FAC) < 2000) != 0x00)
		{
			memcpy(r5, r6, (size_t) r7);
			r7_n = (Eq_n) <invalid>;
			r6_n = (Eq_n) <invalid>;
			r5_n = (Eq_n) <invalid>;
			r2_n = r5 + r7;
		}
		else
		{
			word32 r25_n;
			print_log(1, 0x0040A148, out r5_n, out r6_n, out r7_n, out r25_n);
			*((char *) r4.ptr0000 + 0x0FAC) = (Eq_n) 0x00;
			r2_n = null;
		}
	}
	else
	{
		word32 r25_n;
		print_log(2, 4235556, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = r5;
	}
	r5Out = r5_n;
	r6Out = r6_n;
	r7Out = r7_n;
	return r2_n;
}

// 00402C1C: Register (ptr32 int8) get_a_line(Register (ptr32 byte) r4, Register (ptr32 int8) r5, Register (ptr32 int32) r6)
// Called from:
//      client_parse_request
int8 * get_a_line(byte * r4, int8 * r5, int32 * r6)
{
	byte * dwArg00_n = r4;
	int8 * dwArg04_n = r5;
	while (*r6 > 0x00 && ((word32) (*dwArg04_n) != 0x0A && (word32) (*dwArg04_n) != 0x0D))
	{
		*dwArg00_n = *dwArg04_n;
		*r6 += -1;
		++dwArg04_n;
		++dwArg00_n;
	}
	if (*r6 > 0x00 && ((word32) (*dwArg04_n) == 0x0A || (word32) (*dwArg04_n) == 0x0D))
	{
		*dwArg00_n = *dwArg04_n;
		*r6 += -1;
		++dwArg04_n;
		++dwArg00_n;
	}
	if (*r6 > 0x00 && ((word32) (*dwArg04_n) == 0x0A || (word32) (*dwArg04_n) == 0x0D))
	{
		*dwArg00_n = *dwArg04_n;
		*r6 += -1;
		++dwArg04_n;
		++dwArg00_n;
	}
	*dwArg00_n = 0x00;
	return dwArg04_n;
}

// 00402E44: void client_read_request(Register (ptr32 Eq_n) r4)
void client_read_request(struct Eq_n * r4)
{
	r4->t17CC = time(null);
	Eq_n r7_n = <invalid>;
	Eq_n r6_n = <invalid>;
	Eq_n r5_n = <invalid>;
	Eq_n r4_n = <invalid>;
	r4->dw07D8 = recv(0x00, r4_n, r4->dw0000, r5_n, &r4->dw0000 + 2, r6_n, 1744, r7_n, 0x00004000, 0x10008860);
}

// 00402EF8: Register Eq_n client_send_request(Register Eq_n r4, Register word32 ra, Register out Eq_n r25Out)
// Called from:
//      main
//      client_new
Eq_n client_send_request(Eq_n r4, word32 ra, struct Eq_n & r25Out)
{
	*((char *) r4.ptr0000 + 0x000017CC) = (Eq_n) time(null);
	Eq_n r5_n = <invalid>;
	Eq_n r25_n = <invalid>;
	if (*((char *) r4.ptr0000 + 0x0FAC) > 0x00)
	{
		int32 r2_n = send(*((char *) r4.ptr0000 + 4), *((char *) r4.ptr0000 + 0x0FB0), r4, *((char *) r4.ptr0000 + 0x0FAC), 0x00);
		if (r2_n == *((char *) r4.ptr0000 + 0x0FAC))
		{
			*((char *) r4.ptr0000 + 0x0FAC) = (Eq_n) 0x00;
			*((char *) r4.ptr0000 + 0x0FB0) = (Eq_n) ((char *) r4.ptr0000 + 2012);
		}
		else
		{
			*((char *) r4.ptr0000 + 0x0FB0) = (Eq_n) ((char *) ((char *) r4.ptr0000 + 0x0FB0)->ptr0000 + r2_n);
			*((char *) r4.ptr0000 + 0x0FAC) = (Eq_n) (*((char *) r4.ptr0000 + 0x0FAC) - r2_n);
			word32 r6_n;
			word32 r7_n;
			print_log(4, 0x0040A174, out r5_n, out r6_n, out r7_n, out r25_n);
		}
	}
	r25Out = r25_n;
	return r5_n;
}

// 0040307C: void client_read_reply(Register (ptr32 Eq_n) r4)
void client_read_reply(struct Eq_n * r4)
{
	r4->t17D0 = time(null);
	r4->dw178C = (uint32) read(r4->dw0004, &r4->dw0004 + 1005, (size_t) 1999);
	r4->ptr1788 = &r4->dw0004 + 1005;
}

// 00403140: void client_parse_reply(Register (ptr32 Eq_n) r4, Register word32 ra)
void client_parse_reply(struct Eq_n * r4, word32 ra)
{
	if (r4->dw178C > 0x00 && client_check_reply_http(r4) == 0x00)
		client_copy_reply(r4);
}

// 004031DC: void client_copy_reply(Register (ptr32 Eq_n) r4)
// Called from:
//      client_parse_reply
void client_copy_reply(struct Eq_n * r4)
{
	if (r4->dw178C > 0x00)
	{
		r4->t17D0 = time(null);
		Eq_n r7_n = <invalid>;
		Eq_n r5_n = <invalid>;
		Eq_n r6_n = <invalid>;
		Eq_n r4_n = <invalid>;
		int32 r2_n = send(0x00, r4_n, r4->dw0000, r5_n, r4->ptr1788, r6_n, r4, r4->dw178C, r7_n, 0x00);
		if (r2_n == r4->dw178C)
		{
			r4->ptr1788 = (struct Eq_n *) (&r4->dw0000 + 0x03EE);
			r4->dw178C = 0x00;
		}
		else
		{
			r4->ptr1788 += r2_n;
			r4->dw178C -= r2_n;
		}
	}
}

// 00403318: Register int32 client_check_reply_http(Register (ptr32 Eq_n) r4)
// Called from:
//      client_parse_reply
int32 client_check_reply_http(struct Eq_n * r4)
{
	struct Eq_n * dwLoc18_n = r4->ptr1788;
	int32 dwLoc14_n = r4->dw178C;
	while (dwLoc14_n > 0x00 && ((word32) dwLoc18_n->t0000 == 0x0A || (word32) dwLoc18_n->t0000 == 0x0D))
	{
		++dwLoc18_n;
		dwLoc14_n += -1;
	}
	int32 r2_n;
	if ((word32) (dwLoc14_n < 5) == 0x00 && strncasecmp(dwLoc18_n, "HTTP", 4) == 0x00)
	{
		r4->ptr17C4 = client_copy_reply;
		do
		{
			if (dwLoc14_n <= 0x00)
			{
				r4->ptr1788 = (struct Eq_n *) (&r4->dw0000 + 0x03EE);
				r4->dw178C = 0x00;
				r2_n = 1;
				return r2_n;
			}
			while (dwLoc14_n > 0x00 && ((word32) dwLoc18_n->t0000 != 0x0A && (word32) dwLoc18_n->t0000 != 0x0D))
			{
				dwLoc14_n += -1;
				++dwLoc18_n;
			}
			if ((word32) (dwLoc14_n < 2) != 0x00 || (word32) dwLoc18_n->t0000 != 0x0A && (word32) dwLoc18_n->t0000 != 0x0D || (word32) dwLoc18_n[1] != 0x0A && (word32) dwLoc18_n[1] != 0x0D)
				continue;
			struct Eq_n * dwLoc18_n = dwLoc18_n + 1;
			dwLoc14_n += -2;
			dwLoc18_n = (struct Eq_n *) &dwLoc18_n->b0001;
		} while ((word32) (dwLoc14_n < 2) != 0x00 || (word32) dwLoc18_n->b0001 != 0x0A && (word32) dwLoc18_n->b0001 != 0x0D || (word32) dwLoc18_n->b0002 != 0x0A && (word32) dwLoc18_n->b0002 != 0x0D);
		if (dwLoc14_n > ~0x01)
		{
			r4->ptr1788 = (struct Eq_n *) (&dwLoc18_n->b0002 + 1);
			r4->dw178C = dwLoc14_n + -2;
			r2_n = 0x00;
		}
		else
		{
			r4->ptr1788 = (struct Eq_n *) (&r4->dw0000 + 0x03EE);
			r4->dw178C = 0x00;
			r2_n = 1;
		}
	}
	else
		r2_n = 0x00;
	return r2_n;
}

// 004036BC: void client_close(Register Eq_n r4)
// Called from:
//      client_destroy
//      clist_close_all
void client_close(Eq_n r4)
{
	if (r4 != 0x00)
	{
		if (*r4.ptr0000 >= 0x00)
		{
			close(*r4.ptr0000);
			*r4.ptr0000 = (Eq_n) -1;
		}
		if (*((char *) r4.ptr0000 + 4) >= 0x00)
		{
			close(*((char *) r4.ptr0000 + 4));
			*((char *) r4.ptr0000 + 4) = (Eq_n) -1;
		}
	}
}

// 00403794: Register Eq_n client_destroy(Register Eq_n r4, Register word32 ra)
// Called from:
//      main
//      clist_delete
Eq_n client_destroy(Eq_n r4, word32 ra)
{
	client_close(r4);
	if (*((char *) r4.ptr0000 + 4020) != 0x00)
		request_destroy(*((char *) r4.ptr0000 + 4020));
	free(r4);
	return <invalid>;
}

// 00403840: void client_check_activ(Register (ptr32 Eq_n) r4, Register Eq_n r5, Register word32 ra)
void client_check_activ(struct Eq_n * r4, Eq_n r5, word32 ra)
{
	Eq_n dwArg04_n = r5;
	if (r5 < 0x00)
		dwArg04_n = time(null);
	if ((word32) (*g_ptr1000090C < dwArg04_n - r4->dw17CC) != 0x00)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(3, 0x0040A1B0, out r5_n, out r6_n, out r7_n, out r25_n);
	}
	if ((word32) (*g_ptr1000090C < dwArg04_n - r4->t17D0) != 0x00)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(3, 0x0040A1F4, out r5_n, out r6_n, out r7_n, out r25_n);
	}
}

// 00403A1C: Register Eq_n open_destination(Register (ptr32 Eq_n) r4, Register word32 ra)
// Called from:
//      client_new
Eq_n open_destination(struct sockaddr * r4, word32 ra)
{
	Eq_n r2_n;
	Eq_n r2_n = socket(2, 2, 6);
	if (r2_n < 0x00)
	{
		__errno_location();
		strerror(*__errno_location());
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(1, 0x0040A224, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n.u1 = -1;
	}
	else if (connect(r2_n, r4, 16) < 0x00)
	{
		__errno_location();
		strerror(*__errno_location());
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(1, 0x0040A268, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n.u1 = -1;
	}
	else
		r2_n = r2_n;
	return r2_n;
}

// 00403C00: Register (ptr32 Eq_n) clist_new(Register word32 ra, Register out Eq_n r4Out, Register out Eq_n r5Out)
// Called from:
//      main
struct Eq_n * clist_new(word32 ra, struct Eq_n & r4Out, struct Eq_n & r5Out)
{
	struct Eq_n * r2_n;
	struct Eq_n * r2_n = malloc((size_t) 0x0C);
	Eq_n r5_n = <invalid>;
	Eq_n r4_n = <invalid>;
	if (r2_n == null)
	{
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		r4_n = print_log(0x00, 0x0040A2A0, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = null;
	}
	else
	{
		r2_n->dw0008 = 0x00;
		r2_n->dw0000 = 0x00;
		r2_n->dw0004 = 0x00;
		r2_n = r2_n;
	}
	r4Out = r4_n;
	r5Out = r5_n;
	return r2_n;
}

// 00403CBC: Register int32 clist_add(Register (ptr32 Eq_n) r4, Register Eq_n r5, Register out ptr32 r5Out)
// Called from:
//      main
int32 clist_add(struct Eq_n * r4, Eq_n r5, ptr32 & r5Out)
{
	if (r4->t0008.ptr0000 != 0x00)
	{
		*((char *) r4->t0008.ptr0000 + 6076) = (union Eq_n *) r5;
		*((char *) r5.ptr0000 + 6072) = (Eq_n) r4->t0008.ptr0000;
	}
	*((char *) r5.ptr0000 + 6076) = (Eq_n) 0x00;
	r4->t0008.ptr0000 = (union Eq_n *) r5;
	++r4->dw0000;
	if ((word32) (r4->dw0004 < r4->dw0000) != 0x00)
		r4->dw0004 = r4->dw0000;
	int32 r2_n = r4->dw0000;
	r5Out = <invalid>;
	return r2_n;
}

// 00403DBC: Register Eq_n clist_remove(Register Eq_n r4, Register Eq_n r5)
// Called from:
//      clist_delete
Eq_n clist_remove(Eq_n r4, Eq_n r5)
{
	if (r5 != 0x00)
	{
		if (r5 == *((char *) r4.ptr0000 + 8))
			*((char *) r4.ptr0000 + 8) = *((char *) r5.ptr0000 + 6072);
		else
			*((char *) ((char *) r5.ptr0000 + 6076)->ptr0000 + 6072) = *((char *) r5.ptr0000 + 6072);
		if (*((char *) r5.ptr0000 + 6072) != 0x00)
			*((char *) ((char *) r5.ptr0000 + 6072)->ptr0000 + 6076) = *((char *) r5.ptr0000 + 6076);
		*r4.ptr0000 = (Eq_n) ((word32) *r4.ptr0000 - 1);
	}
	return <invalid>;
}

// 00403EC0: void clist_find_fdin(Register (ptr32 Eq_n) r4, Register word32 r5)
void clist_find_fdin(struct Eq_n * r4, word32 r5)
{
	struct Eq_n * dwLoc10_n = r4->ptr0008;
	while (dwLoc10_n != null && dwLoc10_n->dw0000 != r5)
		dwLoc10_n = dwLoc10_n->ptr17B8;
}

// 00403F5C: void clist_find_fdout(Register (ptr32 Eq_n) r4, Register word32 r5)
void clist_find_fdout(struct Eq_n * r4, word32 r5)
{
	struct Eq_n * dwLoc10_n = r4->ptr0008;
	while (dwLoc10_n != null && dwLoc10_n->dw0004 != r5)
		dwLoc10_n = dwLoc10_n->ptr17B8;
}

// 00403FF8: void clist_delete(Register Eq_n r4, Register Eq_n r5, Register word32 ra)
// Called from:
//      clist_destroy_all
void clist_delete(Eq_n r4, Eq_n r5, word32 ra)
{
	clist_remove(r4, r5);
	client_destroy(r5, ra);
}

// 00404070: void clist_close_all(Register Eq_n r4, Register word32 ra)
// Called from:
//      clist_destroy
void clist_close_all(Eq_n r4, word32 ra)
{
	Eq_n dwLoc18_n = *((char *) r4.ptr0000 + 8);
	while (dwLoc18_n != 0x00)
	{
		client_close(dwLoc18_n);
		dwLoc18_n = *((char *) dwLoc18_n.ptr0000 + 6072);
	}
}

// 00404108: void clist_destroy_all(Register Eq_n r4, Register word32 ra)
// Called from:
//      clist_destroy
void clist_destroy_all(Eq_n r4, word32 ra)
{
	while (*((char *) r4.ptr0000 + 8) != 0x00)
		clist_delete(r4, *((char *) r4.ptr0000 + 8), ra);
}

// 004041B0: void clist_destroy(Register Eq_n r4, Register word32 ra)
void clist_destroy(Eq_n r4, word32 ra)
{
	clist_close_all(r4, ra);
	clist_destroy_all(r4, ra);
	free(r4);
}

// 00404240: Register Eq_n request_new(Register ptr32 r4, Register word32 ra)
// Called from:
//      client_parse_request
Eq_n request_new(ptr32 r4, word32 ra)
{
	Eq_n r2_n;
	Eq_n r2_n = malloc((size_t) 0x055C);
	if (r2_n == 0x00)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(0x00, 0x0040A308, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = (Eq_n) 0x00;
	}
	else
	{
		*r2_n.ptr0000 = (Eq_n) 0x00;
		*((char *) r2_n.ptr0000 + 0x0114) = (Eq_n) 0x00;
		*((char *) r2_n.ptr0000 + 788) = (Eq_n) 0x00;
		*((char *) r2_n.ptr0000 + 532) = (Eq_n) 0x00;
		*((char *) r2_n.ptr0000 + 20) = (Eq_n) 0x00;
		*((char *) r2_n.ptr0000 + 0x0414) = (Eq_n) 0x00;
		*((char *) r2_n.ptr0000 + 0x0558) = (Eq_n) -1;
		*((char *) r2_n.ptr0000 + 0x0554) = (Eq_n) 0x00;
		if (r4 != 0x00 && request_parse_line(r2_n, r4, ra) == 0x00)
			r2_n = (Eq_n) 0x00;
		else
			r2_n = r2_n;
	}
	return r2_n;
}

// 00404378: Register int32 request_parse_line(Register Eq_n r4, Register ptr32 r5, Register word32 ra)
// Called from:
//      client_parse_request
//      request_new
int32 request_parse_line(Eq_n r4, ptr32 r5, word32 ra)
{
	int32 r2_n;
	word32 r5_n;
	get_method(r4, out r5_n);
	if (is_a_method(r4) == 0x00)
		r2_n = 0x00;
	else
	{
		get_uri((char *) r4.ptr0000 + 0x0114);
		get_version((char *) r4.ptr0000 + 788);
		r2_n = 1;
	}
	return r2_n;
}

// 00404458: void request_save_line(Register Eq_n r4, Register (ptr32 void) r5, Register word32 r6, Register word32 ra)
// Called from:
//      client_parse_request
void request_save_line(Eq_n r4, void * r5, word32 r6, word32 ra)
{
	int8 bArg0B_n = (byte) r6;
	if (r4 == 0x00)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(2, 0x0040A398, out r5_n, out r6_n, out r7_n, out r25_n);
	}
	else if ((word32) (*((char *) r4.ptr0000 + 0x0558) < 63) == 0x00)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(2, 0x0040A344, out r5_n, out r6_n, out r7_n, out r25_n);
	}
	else
	{
		*((char *) r4.ptr0000 + 0x0558) = (Eq_n) ((char *) ((char *) r4.ptr0000 + 0x0558)->ptr0000 + 1);
		((char *) r4.ptr0000 + 4)[*((char *) r4.ptr0000 + 0x0558) * 0x04 + 1040] = (char) malloc((size_t) r6);
		if (((char *) r4.ptr0000 + 4)[*((char *) r4.ptr0000 + 0x0558) * 0x04 + 1040] == 0x00)
		{
			word32 r5_n;
			word32 r6_n;
			word32 r7_n;
			word32 r25_n;
			print_log(2, 0x0040A364, out r5_n, out r6_n, out r7_n, out r25_n);
			*((char *) r4.ptr0000 + 0x0558) = (Eq_n) ((word32) *((char *) r4.ptr0000 + 0x0558) - 1);
		}
		else
		{
			Mem64[r4 + 4 + (Mem48[r4 + 0x0558:word32] + 0x0510):byte] = bArg0B_n;
			memcpy(((char *) r4.ptr0000 + 4)[*((char *) r4.ptr0000 + 0x0558) * 0x04 + 1040], r5, (size_t) r6);
		}
	}
}

// 004046C4: void request_make_url(Register Eq_n r4, Register word32 ra)
// Called from:
//      client_parse_request
void request_make_url(Eq_n r4, word32 ra)
{
	if (r4 == 0x00)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(2, 4236228, out r5_n, out r6_n, out r7_n, out r25_n);
	}
	else if (strncasecmp((char *) r4.ptr0000 + 0x0114, "http://", 7) == 0x00)
		snprintf((char *) r4.ptr0000 + 532, (size_t) 0x0100, "%s %s %s\r\n", 0x00);
	else if ((word32) *((char *) r4.ptr0000 + 0x0114) == 47)
		snprintf((char *) r4.ptr0000 + 532, (size_t) 0x0100, "%s http://%s%s %s\r\n", 0x00);
	else
		snprintf((char *) r4.ptr0000 + 532, (size_t) 0x0100, "%s http://%s/%s %s\r\n", 0x00);
}

// 004048DC: Register (ptr32 void) request_add_lines(Register Eq_n r4, Register Eq_n r5, Register (ptr32 void) r6)
// Called from:
//      client_parse_request
void * request_add_lines(Eq_n r4, Eq_n r5, void * r6)
{
	struct Eq_n * r28_n = (struct Eq_n *) 0x10008860;
	void * dwArg08_n = r6;
	int32 dwLoc18_n = 0x00;
	while ((word32) (*((char *) r4.ptr0000 + 0x0558) < dwLoc18_n) == 0x00)
	{
		if (((char *) r4.ptr0000 + 4)[dwLoc18_n * 0x04 + 1040] != 0x00)
		{
			if ((word32) ((char *) ((char *) r5.ptr0000 + 0x0FAC)->ptr0000 + (word32) ((char *) r4.ptr0000 + 4)[dwLoc18_n + 0x0510] < 2000) != 0x00)
			{
				*((char *) r5.ptr0000 + 0x0FAC) = (Eq_n) ((char *) ((char *) r5.ptr0000 + 0x0FAC)->ptr0000 + (word32) ((char *) r4.ptr0000 + 4)[dwLoc18_n + 0x0510]);
				word32 r2_n = (word32) ((char *) r4.ptr0000 + 4)[dwLoc18_n + 0x0510];
				word32 r7_n;
				r28_n->ptrFFFF81E8();
				r28_n = (struct Eq_n *) 0x10008860;
				dwArg08_n = (void *) ((char *) dwArg08_n + (word32) ((char *) r4.ptr0000 + 4)[dwLoc18_n + 0x0510]);
			}
			else
			{
				r28_n->ptrFFFF818C();
				r28_n = (struct Eq_n *) 0x10008860;
			}
		}
		++dwLoc18_n;
	}
	while (*((char *) r4.ptr0000 + 0x0558) >= 0x00)
	{
		int32 r3_n = *((char *) r4.ptr0000 + 0x0558);
		*((char *) r4.ptr0000 + 0x0558) = (Eq_n) (r3_n + -1);
		ptr32 r2_n = (char *) r4.ptr0000 + 4 + ((r3_n << 0x02) + 1040);
		word32 r7_n;
		r28_n->ptrFFFF802C();
		r28_n = (struct Eq_n *) 0x10008860;
	}
	return dwArg08_n;
}

// 00404B34: Register word32 get_method(Register Eq_n r4, Register out Eq_n r5Out)
// Called from:
//      request_parse_line
word32 get_method(Eq_n r4, struct Eq_n & r5Out)
{
	ptr32 fp;
	word32 r5;
	strncpy(r4, strsep(fp + 4, 0x00410000, 0x0040A464, 0x10008860), 0x0100);
	Eq_n r5_n = <invalid>;
	r5Out = r5_n;
	return r5;
}

// 00404BC8: Register word32 get_uri(Register Eq_n r4)
// Called from:
//      request_parse_line
word32 get_uri(Eq_n r4)
{
	ptr32 fp;
	word32 r5;
	strncpy(r4, strsep(fp + 4, 0x00410000, 0x0040A464, 0x10008860), 0x0100);
	return r5;
}

// 00404C5C: void get_version(Register Eq_n r4)
// Called from:
//      request_parse_line
void get_version(Eq_n r4)
{
	ptr32 fp;
	strncpy(r4, strsep(fp + 4, 0x00410000, 0x0040A468, 0x10008860), 0x0100);
}

// 00404CF0: void request_get_host(Register Eq_n r4, Register (ptr32 Eq_n) r5, Register word32 ra)
// Called from:
//      client_parse_request
void request_get_host(Eq_n r4, union Eq_n * r5, word32 ra)
{
	if (r4 == 0x00 || r4 == -20)
	{
		word32 r7_n;
		word32 r6_n;
		word32 r5_n;
		word32 r25_n;
		print_log(2, 0x0040A4F0, out r5_n, out r6_n, out r7_n, out r25_n);
	}
	else
	{
		union Eq_n * r2_n = strpbrk(r5, " \t");
		union Eq_n * dwLoc18_n = r2_n;
		if (r2_n != null)
		{
			while ((word32) (dwLoc18_n < &r5->u0 + 0x0100) != 0x00 && ((word32) (*dwLoc18_n) == 32 || (word32) (*dwLoc18_n) == 9))
				dwLoc18_n = (union Eq_n *) ((char *) dwLoc18_n + 1);
			union Eq_n * r2_n = strpbrk(dwLoc18_n, " \n\r");
			if (r2_n != null)
			{
				if ((word32) (r2_n - dwLoc18_n < 0x0101) != 0x00)
				{
					strncpy((char *) r4.ptr0000 + 20, dwLoc18_n, r2_n - dwLoc18_n);
					((char *) r4.ptr0000 + 4)[r2_n - dwLoc18_n + 16] = (char) 0x00;
				}
				else
				{
					word32 r5_n;
					word32 r6_n;
					word32 r7_n;
					word32 r25_n;
					print_log(2, 0x0040A4D0, out r5_n, out r6_n, out r7_n, out r25_n);
				}
			}
			else
			{
				word32 r5_n;
				word32 r6_n;
				word32 r7_n;
				word32 r25_n;
				print_log(2, 0x0040A4AC, out r5_n, out r6_n, out r7_n, out r25_n);
			}
		}
		else
		{
			word32 r6_n;
			word32 r5_n;
			word32 r25_n;
			word32 r7_n;
			print_log(2, 0x0040A470, out r5_n, out r6_n, out r7_n, out r25_n);
		}
	}
}

// 00404FC0: void request_get_content_length(Register Eq_n r4, Register (ptr32 Eq_n) r5, Register word32 ra)
// Called from:
//      client_parse_request
void request_get_content_length(Eq_n r4, union Eq_n * r5, word32 ra)
{
	ptr32 fp;
	if (r4 == 0x00 || r4 == -20)
	{
		word32 r7_n;
		word32 r6_n;
		word32 r5_n;
		word32 r25_n;
		print_log(2, 4236600, out r5_n, out r6_n, out r7_n, out r25_n);
	}
	else
	{
		union Eq_n * r2_n = strpbrk(r5, " \t");
		union Eq_n * dwLoc18_n = r2_n;
		if (r2_n != null)
		{
			while ((word32) (dwLoc18_n < &r5->u0 + 0x0100) != 0x00 && ((word32) (*dwLoc18_n) == 32 || (word32) (*dwLoc18_n) == 9))
				dwLoc18_n = (union Eq_n *) ((char *) dwLoc18_n + 1);
			union Eq_n * r2_n = strpbrk(dwLoc18_n, " \n\r");
			if (r2_n != null)
			{
				if ((word32) (r2_n - dwLoc18_n < 0x0101) != 0x00)
					*((char *) r4.ptr0000 + 0x0554) = (Eq_n) strtoul(dwLoc18_n, fp + -20, 0x0A);
				else
				{
					word32 r5_n;
					word32 r6_n;
					word32 r7_n;
					word32 r25_n;
					print_log(2, 0x0040A4D0, out r5_n, out r6_n, out r7_n, out r25_n);
				}
			}
			else
			{
				word32 r5_n;
				word32 r6_n;
				word32 r7_n;
				word32 r25_n;
				print_log(2, 0x0040A4AC, out r5_n, out r6_n, out r7_n, out r25_n);
			}
		}
		else
		{
			word32 r6_n;
			word32 r5_n;
			word32 r25_n;
			word32 r7_n;
			print_log(2, 4236644, out r5_n, out r6_n, out r7_n, out r25_n);
		}
	}
}

// 00405264: Register int32 is_a_method(Register Eq_n r4)
// Called from:
//      request_parse_line
int32 is_a_method(Eq_n r4)
{
	ui32 dwLoc18_n = 0x00;
	do
	{
		int32 r2_n;
		if (g_ptr100009C8[dwLoc18_n] == null)
		{
			r2_n = 0x00;
			return r2_n;
		}
		dwLoc18_n = dwLoc18_n + 1;
		dwLoc18_n = dwLoc18_n;
	} while (strncmp(g_ptr100009C8[dwLoc18_n], r4, 20) != 0x00);
	r2_n = 1;
	return r2_n;
}

// 00405328: void request_destroy(Register Eq_n r4)
// Called from:
//      client_parse_request
//      client_destroy
void request_destroy(Eq_n r4)
{
	while (*((char *) r4.ptr0000 + 0x0558) >= 0x00)
	{
		int32 r3_n = *((char *) r4.ptr0000 + 0x0558);
		*((char *) r4.ptr0000 + 0x0558) = (Eq_n) (r3_n + -1);
		free(((char *) r4.ptr0000 + 4)[r3_n * 0x04 + 1040]);
	}
	free(r4);
}

// 004053F0: void properties_parse_int(Register (ptr32 Eq_n) r4, Register word32 r5, Register word32 ra)
void properties_parse_int(union Eq_n * r4, word32 r5, word32 ra)
{
	char * ptrLoc18;
	strtoul(r4, &ptrLoc18, 0x00);
	if ((word32) *ptrLoc18 != 0x00 && ptrLoc18 != r5)
	{
		word32 r25_n;
		word32 r7_n;
		word32 r6_n;
		word32 r5_n;
		print_log(2, 0x0040A590, out r5_n, out r6_n, out r7_n, out r25_n);
	}
}

// 004054D0: void properties_load(Register Eq_n r4, Register Eq_n r5, Register word32 ra)
// Called from:
//      main
void properties_load(Eq_n r4, Eq_n r5, word32 ra)
{
	ptr32 fp;
	Eq_n dwArg04_n = r5;
	int32 dwLoc30_n = 0x00;
	if (r4 == 0x00)
		return;
	if (r5 == 0x00)
	{
		word32 r2_n = malloc(strlen(r4) + SLICE(11, size_t, 0));
		dwArg04_n = r2_n;
		if (r2_n == 0x00)
		{
			word32 r25_n;
			word32 r5_n;
			word32 r6_n;
			word32 r7_n;
			print_log(1, 0x0040A5EC, out r5_n, out r6_n, out r7_n, out r25_n);
			return;
		}
		Eq_n dwLoc48_n;
		strcpy(r2_n, r4);
		dwLoc30_n = 1;
		struct Eq_n * r2_n = strrchr(r2_n, '/');
		if (r2_n != null)
		{
			r2_n->b0001 = 0x00;
			dwLoc48_n = (Eq_n) &r2_n->b0001;
		}
		else
			dwLoc48_n = r2_n;
		strcpy(dwLoc48_n, fp + -64);
	}
	FILE * r2_n = fopen(dwArg04_n, "r");
	if (r2_n == null)
	{
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		word32 r5_n;
		print_log(1, 4236824, out r5_n, out r6_n, out r7_n, out r25_n);
	}
	else
	{
		if (dwLoc30_n != 0x00)
			free(dwArg04_n);
		while (true)
		{
			char * r2_n = fgets(fp + -328, 0x00FF, r2_n);
			if (r2_n == null)
				break;
			char * r2_n = strchr(r2_n, '\n');
			if (r2_n != null)
				*r2_n = 0x00;
			char * r2_n = strchr(r2_n, '#');
			if (r2_n != null)
				*r2_n = 0x00;
			char * r2_n = r2_n + strspn(r2_n, 0x00410000, 0x0040A640);
			if ((word32) *r2_n != 0x00)
			{
				char * r2_n = r2_n + strcspn(r2_n, 0x00410000, 0x0040A644, r2_n);
				char * r2_n = strchr(r2_n, '=');
				if (r2_n == null)
				{
					word32 r7_n;
					word32 r25_n;
					word32 r5_n;
					word32 r6_n;
					print_log(2, 0x0040A648, out r5_n, out r6_n, out r7_n, out r25_n);
				}
				else
				{
					union Eq_n * r2_n = r2_n + 1 + strspn(r2_n + 1, 0x00410000, 0x0040A640, r2_n + 1);
					*((char *) r2_n + strcspn(r2_n, 0x00410000, 0x0040A640, r2_n, r2_n)) = (union Eq_n *) 0x00;
					*r2_n = 0x00;
					int32 dwLoc2C_n = 0x00;
					ui32 dwLoc014C_n = 0x00;
					while ((word32) (g_ptr10000A40 + (dwLoc014C_n * 0x98 + 8) / 0x0696)->a0004[0].t0000 != 32 && dwLoc2C_n == 0x00)
					{
						if (strcasecmp(r2_n, g_ptr10000A40->a0004[dwLoc014C_n].t0000) == 0x00)
						{
							dwLoc2C_n = 1;
							Eq_n r2_n = g_ptr10000A40->a0004[dwLoc014C_n].t0004;
							if (r2_n != 1)
							{
								if ((word32) (r2_n < 1) == 0x00)
								{
									if (r2_n == 2)
										*((char *) &g_ptr10000A40->a0004->t0000 + (dwLoc014C_n * 0x98 + 144)) = (word32) (strchr("1yY", *r2_n) > null);
								}
								else
									strncpy((char *) &g_ptr10000A40->a0004->t0004 + 5 + dwLoc014C_n * 0x98, r2_n, 20);
							}
							else
							{
								word32 r2_n;
								g_t4053F0();
								*((char *) &g_ptr10000A40->a0004->t0000 + (dwLoc014C_n * 0x98 + 144)) = r2_n;
							}
						}
						++dwLoc014C_n;
					}
					if (dwLoc2C_n == 0x00)
					{
						word32 r7_n;
						word32 r25_n;
						word32 r5_n;
						word32 r6_n;
						print_log(1, 0x0040A5C4, out r5_n, out r6_n, out r7_n, out r25_n);
					}
				}
			}
		}
		fclose(r2_n);
	}
}

// 00405CD0: Register (arr Eq_n) properties_parse_command_line(Register int32 r4, Register (arr Eq_n) r5, Register word32 r16, Register word32 ra)
// Called from:
//      main
Eq_n properties_parse_command_line[](int32 r4, Eq_n r5[], word32 r16, word32 ra)
{
	struct Eq_n * r28_n = (struct Eq_n *) 0x10008860;
	int32 dwLoc28_n = 0x00;
	r5_n = r5;
	while (true)
	{
		Eq_n (* r5_n)[];
		if ((word32) (dwLoc28_n < r4) == 0x00)
			break;
		if ((word32) *r5[dwLoc28_n].ptr0000 == 45)
		{
			word32 dwLoc18_n;
			byte bLoc1C_n = *((char *) r5[dwLoc28_n].ptr0000 + 1);
			if ((word32) bLoc1C_n != 0x00 && (word32) (*((char *) (r5)[dwLoc28_n].ptr0000 + 2)) != 0x00)
				dwLoc18_n = (char *) r5[dwLoc28_n].ptr0000 + 2;
			else if ((word32) (dwLoc28_n < r4) != 0x00)
			{
				++dwLoc28_n;
				dwLoc18_n = r5[dwLoc28_n + 1].ptr0000;
			}
			else
				dwLoc18_n = r28_n->dwFFFF8020 + -22928;
			if ((word32) bLoc1C_n == 0x0068)
			{
				r28_n->ptrFFFF823C();
				exit(0x00);
				r28_n = r28_n;
				r5_n = r5_n;
			}
			int32 dwLoc20_n = 0x00;
			ui32 dwLoc24_n = 0x00;
			while ((word32) *((char *) (r28_n->ptrFFFF81E0 + (dwLoc24_n * 0x98 + 8) / 8) + 4) != 32 && dwLoc20_n == 0x00)
			{
				if ((word32) bLoc1C_n != (word32) (*((char *) (r28_n->ptrFFFF81E0 + (dwLoc24_n * 0x98 + 8) / 8) + 4)))
				{
					if (r28_n->ptrFFFF81E0->a0008[dwLoc24_n].t0000 != 2)
						goto l004061C8;
					word32 r2_n = (word32) bLoc1C_n;
					word32 r2_n;
					r28_n->ptrFFFF8064();
					r28_n = (struct Eq_n *) 0x10008860;
					r5_n = r5_n;
					if (r2_n == toupper((word32) (((g_ptr10000A40 + (dwLoc24_n * 0x98 + 8) / 0x0696)->a0004))[0].t0000))
						goto l00406004;
					r5_n = r5_n;
				}
				else
				{
l00406004:
					dwLoc20_n = 1;
					Eq_n r2_n = r28_n->ptrFFFF81E0->a0008[dwLoc24_n].t0000;
					if (r2_n != 1)
					{
						if ((word32) (r2_n < 1) == 0x00)
						{
							if (r2_n == 2)
							{
								((char *) r28_n->ptrFFFF81E0 + 4)[dwLoc24_n * 0x98 + 144] = (char) ((word32) *((char *) *r28_n->ptrFFFF820C + (word32) bLoc1C_n * 0x02) & 0x01 & 0xFFFF);
								dwLoc28_n += -1;
							}
						}
						else
						{
							ui32 r2_n = (char *) &r28_n->ptrFFFF81E0->a0008->t0000 + 5 + dwLoc24_n * 0x98;
							word32 r7_n;
							r28_n->ptrFFFF812C();
							r28_n = (struct Eq_n *) 0x10008860;
						}
					}
					else
					{
						ptr32 r25_n = r28_n->ptrFFFF801C;
						word32 r2_n;
						word32 r6_n;
						word32 r7_n;
						(r25_n + 21488)();
						*((char *) &g_ptr10000A40->a0004->t0000 + (dwLoc24_n * 0x98 + 144)) = r2_n;
						r28_n = (struct Eq_n *) 0x10008860;
					}
				}
l004061C8:
				++dwLoc24_n;
			}
			if (dwLoc20_n == 0x00)
			{
				word32 r2_n = (word32) bLoc1C_n;
				r28_n->ptrFFFF818C();
				r5_n = properties_print_usage(r5[0].ptr0000);
				return r5_n;
			}
		}
		++dwLoc28_n;
	}
	return r5_n;
}

// 0040628C: Register Eq_n properties_print_usage(Register Eq_n r4)
// Called from:
//      properties_parse_command_line
Eq_n properties_print_usage(Eq_n r4)
{
	if (r4 != 0x00 && (word32) (*r4) != 0x00)
		printf("Usage: %s -h ", r4);
	else
		printf("Usage: redir -h ");
	ui32 dwLoc18_n = 0x00;
	while ((word32) (g_ptr10000A40 + (dwLoc18_n * 0x98 + 8) / 0x0696)->a0004[0].t0000 != 32)
	{
		if (g_ptr10000A40->a0004[dwLoc18_n].t0004 == 2)
		{
			word32 dwLoc14_n;
			if (((word32) *((char *) *g_ptr10000A6C + (word32) (((g_ptr10000A40 + (dwLoc18_n * 0x98 + 8) / 0x0696)->a0004))[0].t0000 * 0x02) & 0x01 & 0xFFFF) != 0x00)
				dwLoc14_n = tolower((word32) (g_ptr10000A40 + (dwLoc18_n * 0x98 + 8) / 0x0696)->a0004[0].t0000);
			else
				dwLoc14_n = toupper((word32) (g_ptr10000A40 + (dwLoc18_n * 0x98 + 8) / 0x0696)->a0004[0].t0000);
			printf("-%c|%c ", (g_ptr10000A40 + (dwLoc18_n * 0x98 + 8) / 0x0696)->a0004[0].t0000, (char) dwLoc14_n);
		}
		else
			printf("-%c %s ", (g_ptr10000A40 + (dwLoc18_n * 0x98 + 8) / 0x0696)->a0004[0].t0000, g_ptr10000A40->a0004[dwLoc18_n].t0000);
		++dwLoc18_n;
	}
	printf("\n");
	Eq_n r5_n = <invalid>;
	return r5_n;
}

// 00406610: Register int32 print_log(Register int32 r4, Register ptr32 r5, Register out ptr32 r5Out, Register out ptr32 r6Out, Register out ptr32 r7Out, Register out ptr32 r25Out)
// Called from:
//      handle_stop
//      handle_log_rotate
//      main
//      client_new
//      client_parse_request
//      add_to_request
//      client_send_request
//      client_check_activ
//      open_destination
//      clist_new
//      request_new
//      request_save_line
//      request_make_url
//      request_get_host
//      request_get_content_length
//      properties_parse_int
//      properties_load
//      open_log
//      server_new
//      server_open
//      server_destroy
//      slist_new
//      slist_delete
int32 print_log(int32 r4, ptr32 r5, ptr32 & r5Out, ptr32 & r6Out, ptr32 & r7Out, ptr32 & r25Out)
{
	ptr32 fp;
	ptr32 r6;
	ptr32 r7;
	ptr32 r25_n = 0x00406610;
	if ((word32) (*g_ptr100008F4 < r4) == 0x00)
	{
		word32 r2_n = vsnprintf(fp + -0x0418, 0x03FF, r5, fp + 8, fp + 8);
		g_t40697C();
	}
	r5Out = r5;
	r6Out = r6;
	r7Out = r7;
	r25Out = r25_n;
	return r4;
}

// 004066E8: void open_log(Register (ptr32 char) r4, Register word32 ra)
// Called from:
//      main
//      log_rotate
void open_log(char * r4, word32 ra)
{
	if ((word32) *g_ptr100008A0->ptr0000 != 0x00 && (word32) (*g_ptr100008A0->ptr0000) != 45)
	{
		*g_ptr10000A20 = (FILE **) fopen(g_ptr100008A0->ptr0000, r4);
		if (*g_ptr10000A20 == null)
		{
			*g_ptr10000A20 = *g_ptr10000914;
			word32 r5_n;
			word32 r6_n;
			word32 r7_n;
			word32 r25_n;
			print_log(0x00, 0x0040A704, out r5_n, out r6_n, out r7_n, out r25_n);
		}
	}
	else
	{
		*g_ptr10000A20 = *g_ptr10000914;
		strcpy(g_ptr100008A0->ptr0000, 0x0040A73C);
	}
}

// 00406848: void log_rotate(Register word32 ra)
// Called from:
//      handle_log_rotate
//      log_string
void log_rotate(word32 ra)
{
	ptr32 fp;
	fclose(*g_ptr10000A20);
	if ((word32) *g_ptr100008A0->ptr0000 != 0x00 && (word32) (*g_ptr100008A0->ptr0000) != 45)
	{
		strcpy(fp + -272, g_ptr100008A0->ptr0000);
		strcat(fp + -272, ".old");
		Eq_n r5_n = <invalid>;
		Eq_n r4_n = <invalid>;
		Eq_n r5_n = <invalid>;
		Eq_n r4_n = <invalid>;
		rename(fp + -272, r4_n, fp + -272, r4_n, g_ptr100008A0->ptr0000, r5_n, 0x00410000, 0x0040A744, r5_n, fp + -272);
	}
	open_log("w", ra);
}

// 0040697C: void log_string(Register (ptr32 Eq_n) r4, Register ui32 r5, Register (ptr32 char) r7, Register word32 ra)
void log_string(FILE * r4, ui32 r5, char * r7, word32 ra)
{
	ptr32 fp;
	word32 dwLoc28;
	int32 dwLoc24;
	gettimeofday(&dwLoc28, null);
	Eq_n r7_n = <invalid>;
	Eq_n r6_n = <invalid>;
	Eq_n r5_n = <invalid>;
	Eq_n r4_n = <invalid>;
	strftime(fp + -72, (size_t) 28, "%Y-%m-%d %H:%M:%S", gmtime(&dwLoc28, r4_n, &dwLoc28, 0x00, r5_n, r6_n, r7_n, 0x10008860));
	fprintf(r4, "%s:%s.%03d:%s\n", g_ptr100008FC[r5], fp + -72, (SLICE(dwLoc24 *s 274877907, word32, 32) >> 0x06) - (dwLoc24 >> 0x1F), r7);
	fflush(r4);
	++g_ptr10000878->dw0824;
	if (*g_ptr10000A28 != 0x00)
	{
		int32 r2_n = *g_ptr10000A28;
		int32 dwLoc20_n = r2_n;
		if (r2_n < 0x00)
			dwLoc20_n = r2_n + 0x03FF;
		if ((word32) (dwLoc20_n >> 0x0A < g_ptr10000878->dw0824) != 0x00)
		{
			if ((word32) (ftell(r4) < *g_ptr10000A28) == 0x00)
				log_rotate(ra);
			else
				g_ptr10000878->dw0824 += -0x0A;
		}
	}
}

// 00406BF0: Register (ptr32 Eq_n) server_new(Register word32 r4, Register word32 r5, Register word32 r6, Register int32 r7, Register word32 ra)
// Called from:
//      main
struct Eq_n * server_new(word32 r4, word32 r5, word32 r6, int32 r7, word32 ra)
{
	struct Eq_n * r2_n;
	uint16 wArg06_n = (uint16) r5;
	struct Eq_n * r2_n = malloc((size_t) 36);
	if (r2_n == null)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(0x00, 0x0040A770, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = null;
	}
	else
	{
		r2_n->dw0000 = -1;
		r2_n->dw0020 = r7;
		r2_n->dw0018 = 0x00;
		r2_n->dw001C = 0x00;
		r2_n->dw0004 = r6;
		bzero(&r2_n->w0008, (size_t) 16);
		r2_n->w0008 = 0x02;
		r2_n->w000A = wArg06_n;
		Eq_n r7_n = <invalid>;
		Eq_n r6_n = <invalid>;
		Eq_n r5_n = <invalid>;
		Eq_n r4_n = <invalid>;
		r2_n->dw000C = inet_addr(r4_n, r4, r5_n, r6_n, r7_n);
		r2_n = r2_n;
	}
	return r2_n;
}

// 00406D4C: Register int32 server_open(Register Eq_n r4, Register word32 ra, Register out ptr32 r5Out)
// Called from:
//      main
int32 server_open(Eq_n r4, word32 ra, ptr32 & r5Out)
{
	ptr32 r5_n;
	int32 r2_n;
	Eq_n r2_n = socket(2, 2, 6);
	if (r2_n < 0x00)
	{
		__errno_location();
		strerror(*__errno_location());
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(1, 4237212, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = 0x00;
	}
	else if (bind(r2_n, (char *) r4.ptr0000 + 8, 16) < 0x00)
	{
		__errno_location();
		strerror(*__errno_location());
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(1, 0x0040A7D4, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = 0x00;
	}
	else if (listen(r2_n, *((char *) r4.ptr0000 + 4)) < 0x00)
	{
		__errno_location();
		strerror(*__errno_location());
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(1, 0x0040A7FC, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = 0x00;
	}
	else
	{
		*r4.ptr0000 = (Eq_n) r2_n;
		r2_n = 1;
	}
	r5Out = r5_n;
	return r2_n;
}

// 00406FF8: void server_close(Register Eq_n r4)
// Called from:
//      server_destroy
//      slist_close_all
void server_close(Eq_n r4)
{
	if (r4 != 0x00 && *r4.ptr0000 > 0x00)
	{
		close(*r4.ptr0000);
		*r4.ptr0000 = (Eq_n) -1;
	}
}

// 0040708C: void server_destroy(Register Eq_n r4, Register word32 ra)
// Called from:
//      slist_delete
void server_destroy(Eq_n r4, word32 ra)
{
	word32 r5_n;
	word32 r6_n;
	word32 r7_n;
	word32 r25_n;
	print_log(4, 4237340, out r5_n, out r6_n, out r7_n, out r25_n);
	server_close(r4);
	free(r4);
}

// 00407150: Register (ptr32 Eq_n) slist_new(Register word32 ra)
// Called from:
//      main
struct Eq_n * slist_new(word32 ra)
{
	struct Eq_n * r2_n;
	struct Eq_n * r2_n = malloc((size_t) 0x0C);
	if (r2_n == null)
	{
		word32 r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 r25_n;
		print_log(0x00, 0x0040A850, out r5_n, out r6_n, out r7_n, out r25_n);
		r2_n = null;
	}
	else
	{
		r2_n->dw0008 = 0x00;
		r2_n->dw0000 = 0x00;
		r2_n->dw0004 = 0x00;
		r2_n = r2_n;
	}
	return r2_n;
}

// 0040720C: void slist_add(Register Eq_n r4, Register Eq_n r5)
// Called from:
//      main
void slist_add(Eq_n r4, Eq_n r5)
{
	if (*((char *) r4.ptr0000 + 8) != 0x00)
	{
		*((char *) ((char *) r4.ptr0000 + 8)->ptr0000 + 28) = r5;
		*((char *) r5.ptr0000 + 24) = *((char *) r4.ptr0000 + 8);
	}
	*((char *) r5.ptr0000 + 28) = (Eq_n) 0x00;
	*((char *) r4.ptr0000 + 8) = r5;
	*r4.ptr0000 = (Eq_n) ((char *) r4.ptr0000->ptr0000 + 1);
	if ((word32) (*((char *) r4.ptr0000 + 4) < *r4.ptr0000) != 0x00)
		*((char *) r4.ptr0000 + 4) = *r4.ptr0000;
}

// 0040730C: void slist_remove(Register Eq_n r4, Register Eq_n r5)
// Called from:
//      slist_delete
void slist_remove(Eq_n r4, Eq_n r5)
{
	if (r5 != 0x00)
	{
		if (r5 == *((char *) r4.ptr0000 + 8))
			*((char *) r4.ptr0000 + 8) = *((char *) r5.ptr0000 + 24);
		else
			*((char *) ((char *) r5.ptr0000 + 28)->ptr0000 + 24) = *((char *) r5.ptr0000 + 24);
		if (*((char *) r5.ptr0000 + 24) != 0x00)
			*((char *) ((char *) r5.ptr0000 + 24)->ptr0000 + 28) = *((char *) r5.ptr0000 + 28);
		*r4.ptr0000 = (Eq_n) ((word32) *r4.ptr0000 - 1);
	}
}

// 00407410: void slist_find_fd(Register (ptr32 Eq_n) r4, Register word32 r5)
void slist_find_fd(struct Eq_n * r4, word32 r5)
{
	struct Eq_n * dwLoc10_n = r4->ptr0008;
	while (dwLoc10_n != null && dwLoc10_n->dw0000 != r5)
		dwLoc10_n = dwLoc10_n->ptr0018;
}

// 004074AC: void slist_delete(Register Eq_n r4, Register Eq_n r5, Register word32 ra)
// Called from:
//      slist_destroy_all
void slist_delete(Eq_n r4, Eq_n r5, word32 ra)
{
	slist_remove(r4, r5);
	word32 r5_n;
	word32 r6_n;
	word32 r7_n;
	word32 r25_n;
	print_log(2, 4237436, out r5_n, out r6_n, out r7_n, out r25_n);
	server_destroy(r5, ra);
}

// 00407568: void slist_close_all(Register Eq_n r4, Register word32 ra)
// Called from:
//      slist_destroy
void slist_close_all(Eq_n r4, word32 ra)
{
	Eq_n dwLoc18_n = *((char *) r4.ptr0000 + 8);
	while (dwLoc18_n != 0x00)
	{
		server_close(dwLoc18_n);
		dwLoc18_n = *((char *) dwLoc18_n.ptr0000 + 24);
	}
}

// 00407600: void slist_destroy_all(Register Eq_n r4, Register word32 ra)
// Called from:
//      slist_destroy
void slist_destroy_all(Eq_n r4, word32 ra)
{
	while (*((char *) r4.ptr0000 + 8) != 0x00)
		slist_delete(r4, *((char *) r4.ptr0000 + 8), ra);
}

// 004076A8: void slist_destroy(Register Eq_n r4, Register word32 ra)
// Called from:
//      main
void slist_destroy(Eq_n r4, word32 ra)
{
	slist_close_all(r4, ra);
	slist_destroy_all(r4, ra);
	free(r4);
}

// 00407740: void __fixunsdfsi(Sequence real64 f12_f13)
void __fixunsdfsi(real64 f12_f13)
{
}

// 004077E0: void _fpadd_parts(Register (ptr32 Eq_n) r4, Register (ptr32 Eq_n) r5, Register (ptr32 Eq_n) r6)
void _fpadd_parts(struct Eq_n * r4, struct Eq_n * r5, struct Eq_n * r6)
{
	Eq_n r7_n = r4->t0000;
	if ((word32) (r7_n < 2) != 0x00)
		return;
	Eq_n r4_n = r5->t0000;
	if ((word32) (r4_n < 2) != 0x00)
		return;
	if ((r7_n ^ 0x04) != 0x00)
	{
		if ((r4_n ^ 0x04) == 0x00)
			return;
		if ((r4_n ^ 0x02) != 0x00)
		{
			if ((r7_n ^ 0x02) != 0x00)
			{
				int32 r8_n = r4->dw0008;
				int32 r7_n = r5->dw0008;
				Eq_n r10_n = r4->t000C;
				int32 r2_n = r8_n - r7_n;
				uint32 r9_n = r5->dw000C;
				if (r2_n < 0x00)
					r2_n = -r2_n;
				if ((word32) (r2_n < 32) != 0x00)
				{
					word32 r2_n = (word32) (r7_n < r8_n);
					word32 r2_n;
					if (r2_n != 0x00)
					{
						int32 r7_n = r8_n - r7_n;
						while (true)
						{
							uint32 r3_n = r9_n >> 0x01;
							ui32 r2_n = r9_n & 0x01;
							r7_n += -1;
							if (r7_n == 0x00)
								break;
							r9_n = r2_n | r3_n;
						}
						r9_n = r2_n | r3_n;
						r7_n = r8_n;
						r2_n = (word32) (r8_n < r8_n);
					}
					else
						r2_n = (word32) (r8_n < r7_n);
					if (r2_n != 0x00)
					{
						while (true)
						{
							++r8_n;
							uint32 r2_n = r10_n >> 0x01;
							ui32 r3_n = r10_n & 0x01;
							if ((word32) (r8_n < r7_n) == 0x00)
								break;
							r10_n = r3_n | r2_n;
						}
						r10_n = r3_n | r2_n;
					}
				}
				else
				{
					word32 r2_n = (word32) (r7_n < r8_n);
					if (r2_n != 0x00)
						r9_n = 0x00;
					else
					{
						r8_n = r7_n;
						r10_n.u0 = 0x00;
					}
				}
				Eq_n r7_n;
				int32 r4_n = r4->dw0004;
				if (r4_n != r5->dw0004)
				{
					Eq_n r3_n;
					if (r4_n == 0x00)
						r3_n = r10_n - r9_n;
					else
						r3_n = r9_n - r10_n;
					if (r3_n >= 0x00)
					{
						r6->dw0008 = r8_n;
						r6->t000C = r3_n;
						r6->dw0004 = 0x00;
					}
					else
					{
						r6->dw0004 = 1;
						r6->dw0008 = r8_n;
						r6->t000C = -r3_n;
					}
					r7_n = r6->t000C;
					if ((word32) (r7_n > 0xC0000001) == 0x00)
					{
						while (true)
						{
							r6->dw0008 += -1;
							Eq_n r5_n = r7_n << 0x01;
							r6->t000C = r5_n;
							if ((word32) (r5_n > 0xC0000001) != 0x00)
								break;
							r7_n = r5_n;
						}
						r7_n = r5_n;
					}
				}
				else
				{
					r6->dw0004 = r4_n;
					r6->dw0008 = r8_n;
					Eq_n r2_n = (word32) r10_n.u0 + r9_n;
					r6->t000C = r2_n;
					r7_n = r2_n;
				}
				if (r7_n < 0x00)
				{
					r6->t0000.u0 = 3;
					int32 r2_n = r6->dw0008;
					r6->t000C = r7_n & 0x01 | r7_n >> 0x01;
					r6->dw0008 = r2_n + 1;
				}
				else
					r6->t0000.u0 = 3;
			}
		}
		else
		{
			if ((r7_n ^ 0x02) != 0x00)
				return;
			r6->t0000 = r7_n;
			r6->dw0004 = r4->dw0004;
			r6->dw0008 = r4->dw0008;
			r6->t000C = r4->t000C;
			r6->dw0004 = r4->dw0004 & r5->dw0004;
		}
	}
	else if ((r4_n ^ 0x04) != 0x00 || r4->dw0004 == r5->dw0004)
		;
}

// 00407A38: void __addsf3(Register word32 r16, Register word32 ra, Register word32 f12, Register word32 f14)
void __addsf3(word32 r16, word32 ra, word32 f12, word32 f14)
{
	ptr32 fp;
	__unpack_f(fp + -24, fp + -72);
	__unpack_f(fp + -20, fp + -56);
	struct Eq_n * r2_n;
	g_t4077E0();
	__pack_f(r2_n);
}

// 00407AE0: void __subsf3(Register word32 r16, Register word32 ra, Register word32 f12, Register word32 f14)
void __subsf3(word32 r16, word32 ra, word32 f12, word32 f14)
{
	ptr32 fp;
	word32 dwLoc34;
	__unpack_f(fp + -24, fp + -72);
	__unpack_f(fp + -20, fp + -56);
	struct Eq_n * r2_n;
	g_t4077E0();
	__pack_f(r2_n);
}

// 00407BA0: void __mulsf3(Register word32 r16, Register word32 ra, Register word32 f12, Register word32 f14)
void __mulsf3(word32 r16, word32 ra, word32 f12, word32 f14)
{
	ptr32 fp;
	Eq_n dwLoc48;
	Eq_n dwLoc38;
	uint32 dwLoc3C;
	uint32 dwLoc2C;
	struct Eq_n * r4;
	__unpack_f(fp + -24, fp + -72);
	__unpack_f(fp + -20, fp + -56);
	if ((word32) (dwLoc48 < 2) != 0x00)
	{
l00407C64:
		goto l00407DA4;
	}
	else
	{
		if ((word32) (dwLoc38 < 2) == 0x00)
		{
			if ((dwLoc48 ^ 0x04) == 0x00)
			{
				if ((dwLoc38 ^ 0x02) != 0x00)
					goto l00407C64;
				goto l00407DA4;
			}
			if ((dwLoc38 ^ 0x04) == 0x00)
			{
				if ((dwLoc48 ^ 0x02) != 0x00)
					goto l00407C8C;
				goto l00407DA4;
			}
			if ((dwLoc48 ^ 0x02) == 0x00)
				goto l00407C64;
			if ((dwLoc38 ^ 0x02) != 0x00)
			{
				uint32 r4_n;
				Eq_n hi_lo_n = dwLoc3C * dwLoc2C;
				int32 hi_n = SLICE(hi_lo_n, word32, 32);
				uint32 lo_n = (word32) hi_lo_n;
				Eq_n r6_n = hi_n >> 0x00;
				if (hi_n >> 0x00 < 0x00)
				{
					r4_n = lo_n;
					ui32 r2_n = hi_n >> 0x00 & 0x01;
					while (true)
					{
						if (r2_n != 0x00)
						{
							r6_n >>= 0x01;
							r4_n = r4_n >> 0x01 | 0x80000000;
						}
						else
							r6_n >>= 0x01;
						if (r6_n >= 0x00)
							break;
						r2_n = r6_n & 0x01;
					}
				}
				else
					r4_n = lo_n;
				if ((word32) (r6_n > 0x3FFFFFFF) == 0x00)
				{
					while (true)
					{
						r6_n <<= 0x01;
						if ((r4_n & 0x80000000) != 0x00)
							r6_n |= 0x01;
						if ((word32) (r6_n > 0x3FFFFFFF) != 0x00)
							break;
						r4_n <<= 0x01;
					}
					r4_n <<= 0x01;
				}
				if ((r6_n & 0x7F) == 64 && ((r6_n & 0x80) != 0x00 || r4_n != 0x00))
					;
l00407DA4:
				__pack_f(r4);
				return;
			}
		}
l00407C8C:
		goto l00407DA4;
	}
}

// 00407DD0: void __divsf3(Register word32 r16, Register word32 ra, Register word32 f12, Register word32 f14)
void __divsf3(word32 r16, word32 ra, word32 f12, word32 f14)
{
	ptr32 fp;
	Eq_n dwLoc38;
	Eq_n dwLoc28;
	uint32 dwLoc1C;
	uint32 dwLoc2C;
	struct Eq_n * r4;
	__unpack_f(fp + -24, fp + -56);
	__unpack_f(fp + -20, fp + -40);
	if ((word32) (dwLoc38 < 2) == 0x00 && (word32) (dwLoc28 < 2) == 0x00)
	{
		if ((dwLoc38 ^ 0x04) != 0x00 && (dwLoc38 ^ 0x02) != 0x00)
		{
			if ((dwLoc28 ^ 0x04) != 0x00 && (dwLoc28 ^ 0x02) != 0x00)
			{
				uint32 r4_n = dwLoc2C;
				word32 r5_n = (word32) (dwLoc2C < dwLoc1C);
				if (r5_n != 0x00)
				{
					r4_n = dwLoc2C << 0x01;
					r5_n = (word32) (dwLoc2C << 0x01 < dwLoc1C);
				}
				uint32 r2_n = 0x40000000;
				ui32 r6_n = 0x00;
				while (true)
				{
					if (r5_n == 0x00)
					{
						r6_n |= r2_n;
						r4_n -= dwLoc1C;
					}
					r4_n <<= 0x01;
					r2_n >>= 0x01;
					if (r2_n == 0x00)
						break;
					r5_n = (word32) (r4_n < dwLoc1C);
				}
				if ((r6_n & 0x7F) == 64)
				{
					ui32 r2_n = r6_n & 0x80;
					if (r2_n != 0x00 || r4_n != 0x00)
						;
				}
			}
		}
	}
	__pack_f(r4);
}

// 00407F70: void __floatsisf(Register uint32 r4, Register word32 ra)
void __floatsisf(uint32 r4, word32 ra)
{
	ptr32 fp;
	if (r4 != 0x00)
	{
		uint32 dwLoc0C_n;
		if (r4 >> 0x1F != 0x00)
		{
			if (r4 == 0x80000000)
				return;
			uint32 r2_n = -r4;
			dwLoc0C_n = r2_n;
		}
		else
			dwLoc0C_n = r4;
		uint32 r6_n = dwLoc0C_n;
		if ((word32) (dwLoc0C_n > 0x3FFFFFFF) == 0x00)
		{
			while (true)
			{
				uint32 r3_n = r6_n << 0x01;
				if ((word32) (r3_n > 0x3FFFFFFF) != 0x00)
					break;
				r6_n = r3_n;
			}
		}
	}
	__pack_f(fp + -24);
}

// 00408040: void __fixsfsi(Register word32 ra, Register word32 f12)
void __fixsfsi(word32 ra, word32 f12)
{
	ptr32 fp;
	Eq_n dwLoc20;
	int32 dwLoc18;
	word32 dwLoc1C;
	__unpack_f(fp + -16, fp + -32);
	if ((dwLoc20 ^ 0x02) != 0x00 && ((word32) (dwLoc20 < 2) == 0x00 && ((dwLoc20 ^ 0x04) == 0x00 || dwLoc18 >= 0x00 && (word32) (dwLoc18 < 31) == 0x00)))
		;
}

// 00408100: void __extendsfdf2(Register word32 ra, Register word32 f12)
void __extendsfdf2(word32 ra, word32 f12)
{
	ptr32 fp;
	uint32 dwLoc14;
	word32 dwLoc1C;
	word32 dwLoc18;
	__unpack_f(fp + -16, fp + -32);
	__make_dp(dwLoc1C, dwLoc18, ra, dwLoc14 >> 0x02, dwLoc14 << 0x1E);
}

// 00408180: void _fpadd_parts(Register (ptr32 Eq_n) r4, Register (ptr32 Eq_n) r5, Register (ptr32 Eq_n) r6)
void _fpadd_parts(struct Eq_n * r4, struct Eq_n * r5, struct Eq_n * r6)
{
	Eq_n r7_n = r4->t0000;
	if ((word32) (r7_n < 2) != 0x00)
		return;
	Eq_n r4_n = r5->t0000;
	if ((word32) (r4_n < 2) != 0x00)
		return;
	if ((r7_n ^ 0x04) == 0x00)
	{
		if ((r4_n ^ 0x04) != 0x00 || r4->dw0004 == r5->dw0004)
			return;
		return;
	}
	if ((r4_n ^ 0x04) == 0x00)
		return;
	if ((r4_n ^ 0x02) == 0x00)
	{
		if ((r7_n ^ 0x02) != 0x00)
			return;
		r6->t0000 = r7_n;
		r6->dw0004 = r4->dw0004;
		r6->dw0008 = r4->dw0008;
		r6->dw000C = r4->dw000C;
		r6->t0010 = r4->t0010;
		r6->t0014 = r4->t0014;
		r6->dw0004 = r4->dw0004 & r5->dw0004;
		return;
	}
	if ((r7_n ^ 0x02) == 0x00)
		return;
	int32 r12_n = r4->dw0008;
	int32 r7_n = r5->dw0008;
	Eq_n r10_n = r4->t0010;
	Eq_n r11_n = r4->t0014;
	int32 r2_n = r12_n - r7_n;
	uint32 r8_n = r5->dw0010;
	Eq_n r9_n = r5->t0014;
	if (r2_n < 0x00)
		r2_n = -r2_n;
	if ((word32) (r2_n < 64) != 0x00)
	{
		word32 r2_n = (word32) (r7_n < r12_n);
		word32 r2_n;
		if (r2_n != 0x00)
		{
			int32 r7_n = r12_n - r7_n;
			while (true)
			{
				ui32 r5_n = r9_n >> 0x01 | r8_n << 0x1F;
				ui32 r3_n = r9_n & 1;
				r7_n += -1;
				r8_n >>= 0x01;
				if (r7_n == 0x00)
					break;
				r9_n = r3_n | r5_n;
			}
			r9_n = r3_n | r5_n;
			r7_n = r12_n;
			r2_n = (word32) (r12_n < r12_n);
		}
		else
			r2_n = (word32) (r12_n < r7_n);
		if (r2_n != 0x00)
		{
			while (true)
			{
				++r12_n;
				ui32 r5_n = r11_n >> 0x01 | r10_n << 0x1F;
				ui32 r3_n = r11_n & 1;
				r10_n >>= 0x01;
				if ((word32) (r12_n < r7_n) == 0x00)
					break;
				r11_n = r3_n | r5_n;
			}
			r11_n = r3_n | r5_n;
		}
	}
	else
	{
		word32 r2_n = (word32) (r7_n < r12_n);
		if (r2_n != 0x00)
		{
			r8_n = 0x00;
			r9_n.u0 = 0x00;
		}
		else
		{
			r12_n = r7_n;
			r10_n.u0 = 0x00;
			r11_n.u0 = 0x00;
		}
	}
	int32 r6_n = r4->dw0004;
	if (r6_n == r5->dw0004)
	{
		r6->dw0004 = r6_n;
		r6->dw0008 = r12_n;
		word32 r3_n = r11_n + r9_n;
		r6->t0010 = (word32) r10_n.u0 + r8_n + (word32) (r3_n < r9_n);
		r6->t0014 = r3_n;
		goto l00408490;
	}
	uint32 r2_n = (word32) (r9_n < r11_n);
	Eq_n r4_n;
	Eq_n r5_n = r9_n - r11_n;
	uint32 r4_n = r8_n - r10_n;
	if (r6_n == 0x00)
	{
		r5_n = r11_n - r9_n;
		r4_n = r10_n - r8_n - (word32) (r11_n < r9_n);
	}
	else
		r4_n = r4_n - r2_n;
	if (r4_n >= 0x00)
	{
		r6->dw0008 = r12_n;
		r6->t0010 = r4_n;
		r6->t0014 = r5_n;
		r6->dw0004 = 0x00;
	}
	else
	{
		r6->dw0004 = 1;
		r6->dw0008 = r12_n;
		Eq_n r5_n = -r5_n;
		r6->t0010 = -r4_n - (word32) (r5_n > 0x00);
		r6->t0014 = r5_n;
	}
	Eq_n r9_n = r6->t0014;
	Eq_n r8_n = r6->t0010;
	up32 r4_n = (word32) r8_n - 1 + (word32) (r9_n < 0);
	if ((word32) (r4_n > 0x0FFFFFFF) == 0x00)
	{
		uint32 r2_n;
		if (r4_n == 0x0FFFFFFF)
		{
			if ((word32) (r9_n < 0) == 0x00)
				goto l00408490;
l0040840C:
			r2_n = r9_n >> 0x1F;
		}
		else
			r2_n = r9_n >> 0x1F;
		ui32 r6_n = r8_n << 0x01;
		while (true)
		{
			Eq_n r7_n = r9_n << 0x01;
			Eq_n r6_n = r6_n | r2_n;
			r6->dw0008 += -1;
			r6->t0010 = r6_n;
			r6->t0014 = r7_n;
			uint32 r4_n = (word32) r6_n - 1 + (word32) (r7_n < 0);
			if ((word32) (r4_n > 0x0FFFFFFF) != 0x00)
				break;
			word32 r11_n = (word32) (r7_n < 0);
			r8_n = r6_n;
			if (r4_n != 0x0FFFFFFF)
			{
				r9_n = r7_n;
				goto l0040840C;
			}
			r9_n = r7_n;
			if (r11_n == 0x00)
				break;
			r2_n = r7_n >> 0x1F;
			r6_n = r6_n << 0x01;
		}
	}
l00408490:
	if ((word32) (r6->t0010 > 0x1FFFFFFF) != 0x00)
	{
		r6->t0000.u0 = 3;
		Eq_n r4_n = r6->t0010;
		Eq_n r5_n = r6->t0014;
		int32 r6_n = r6->dw0008;
		r6->t0010 = r4_n >> 0x01;
		r6->t0014 = r5_n & 1 | (r5_n >> 0x01 | r4_n << 0x1F);
		r6->dw0008 = r6_n + 1;
	}
	else
		r6->t0000.u0 = 3;
}

// 004084FC: void __adddf3(Register word32 r16, Register word32 ra, Register word32 f12, Register word32 f13, Register word32 f14, Register word32 f15)
void __adddf3(word32 r16, word32 ra, word32 f12, word32 f13, word32 f14, word32 f15)
{
	ptr32 fp;
	__unpack_d(fp + -40, fp + -112);
	__unpack_d(fp + -32, fp + -88);
	struct Eq_n * r2_n;
	g_t408180();
	__pack_d(r2_n);
}

// 004085CC: void __subdf3(Register word32 r16, Register word32 ra, Register word32 f12, Register word32 f13, Register word32 f14, Register word32 f15)
void __subdf3(word32 r16, word32 ra, word32 f12, word32 f13, word32 f14, word32 f15)
{
	ptr32 fp;
	word32 dwLoc54;
	__unpack_d(fp + -40, fp + -112);
	__unpack_d(fp + -32, fp + -88);
	struct Eq_n * r2_n;
	g_t408180();
	__pack_d(r2_n);
}

// 004086B0: void __muldf3(Register word32 r17, Register word32 r19, Register word32 r20, Register word32 r21, Register word32 r22, Register word32 ra, Register word32 f12, Register word32 f13, Register word32 f14, Register word32 f15)
void __muldf3(word32 r17, word32 r19, word32 r20, word32 r21, word32 r22, word32 ra, word32 f12, word32 f13, word32 f14, word32 f15)
{
	ptr32 fp;
	Eq_n dwLoc88;
	Eq_n dwLoc70;
	uint32 dwLoc78;
	Eq_n dwLoc74;
	uint32 dwLoc60;
	Eq_n dwLoc5C;
	struct Eq_n * r4;
	__unpack_d(fp + -64, fp + -0x0088);
	__unpack_d(fp + -56, fp + -112);
	if ((word32) (dwLoc88 < 2) != 0x00)
	{
l004087A8:
		goto l00408B58;
	}
	if ((word32) (dwLoc70 < 2) != 0x00)
	{
l004087D0:
		goto l00408B58;
	}
	if ((dwLoc88 ^ 0x04) == 0x00)
	{
		if ((dwLoc70 ^ 0x02) != 0x00)
			goto l004087A8;
		goto l00408B58;
	}
	if ((dwLoc70 ^ 0x04) == 0x00)
	{
		if ((dwLoc88 ^ 0x02) != 0x00)
			goto l004087D0;
		goto l00408B58;
	}
	if ((dwLoc88 ^ 0x02) == 0x00)
		goto l004087A8;
	if ((dwLoc70 ^ 0x02) == 0x00)
		goto l004087D0;
	uint32 r16_n;
	Eq_n hi_lo_n = (dwLoc60 >> 0x00) * dwLoc74;
	Eq_n hi_lo_n = dwLoc5C * (dwLoc78 >> 0x00);
	up32 lo_n = (word32) hi_lo_n;
	up32 lo_n = (word32) hi_lo_n;
	up32 r21_n = lo_n + lo_n;
	uint32 r24_n = SLICE(hi_lo_n, word32, 32) + (dwLoc60 >> 0x00) *s 0 + dwLoc74 *s 0x00;
	Eq_n hi_lo_n = dwLoc5C * dwLoc74;
	Eq_n hi_lo_n = (dwLoc60 >> 0x00) * (dwLoc78 >> 0x00);
	int32 lo_n = (dwLoc78 >> 0x00) *s 0x00;
	uint32 r20_n = r24_n + ((SLICE(hi_lo_n, word32, 32) + dwLoc5C *s 0x00) + (dwLoc78 >> 0x00) *s 0) + (word32) (r21_n < lo_n);
	int32 dwLoc30_n = 0x00;
	uint32 lo_n = (word32) hi_lo_n;
	word32 r16_n = SLICE(hi_lo_n, word32, 32) + dwLoc5C *s 0;
	uint32 lo_n = (word32) hi_lo_n;
	word32 r18_n = SLICE(hi_lo_n, word32, 32) + (dwLoc60 >> 0x00) *s 0x00 + lo_n;
	if ((word32) (r20_n < r24_n) != 0x00)
	{
		r16_n = r16_n + dwLoc74 *s 0;
		goto l00408924;
	}
	else
	{
		r16_n = r16_n + dwLoc74 *s 0;
		if (r24_n == r20_n)
		{
			word32 r2_n = (word32) (r21_n < lo_n);
			if (r2_n != 0x00)
			{
l00408924:
				dwLoc30_n = 1;
				goto l00408934;
			}
		}
l00408934:
		uint32 r10_n = r16_n + lo_n + (word32) (lo_n < 0x00);
		int32 dwLoc2C_n = 0x00;
		if ((word32) (r10_n < r16_n) != 0x00)
		{
l00408978:
			dwLoc2C_n = 1;
			goto l00408998;
		}
		else
		{
			if (r16_n == r10_n)
			{
				word32 r2_n = (word32) (lo_n < lo_n);
				if (r2_n != 0x00)
					goto l00408978;
			}
l00408998:
			uint32 r7_n;
			uint32 r5_n = (r20_n >> 0x00) + lo_n;
			uint32 r13_n = dwLoc2C_n + r5_n;
			Eq_n r12_n = dwLoc30_n + (r18_n + (word32) (r5_n < lo_n)) + (word32) (r13_n < r5_n);
			uint32 r6_n = r10_n;
			if ((word32) (r12_n > 0x1FFFFFFF) != 0x00)
			{
				r7_n = lo_n;
				do
				{
					r12_n >>= 0x01;
					r13_n = r13_n >> 0x01 | r12_n << 0x1F;
					word32 r4_n = (word32) (r12_n > 0x1FFFFFFF);
					if ((r13_n & 1) != 0x00)
					{
						r6_n = r6_n >> 0x01 | 0x80000000;
						r7_n = r7_n >> 0x01 | r6_n << 0x1F;
					}
				} while (r4_n != 0x00);
			}
			else
				r7_n = lo_n;
			if ((word32) (r12_n > 0x0FFFFFFF) == 0x00)
			{
				while (true)
				{
					Eq_n r12_n = r12_n << 0x01 | r13_n >> 0x1F;
					r13_n <<= 0x01;
					if ((r6_n & 0x80000000) != 0x00)
						r13_n |= 1;
					r12_n = r12_n;
					r6_n = r6_n << 0x01 | r7_n >> 0x1F;
					if ((word32) (r12_n > 0x0FFFFFFF) != 0x00)
						break;
					r7_n <<= 0x01;
				}
				r7_n <<= 0x01;
			}
			if (false)
			{
l00408B44:
				goto l00408B48;
			}
			int32 r5_n = r13_n & 0x00FF;
			if (r5_n == 0x0080)
			{
				if ((r13_n & 0x0100) != 0x00)
				{
l00408B38:
					goto l00408B44;
				}
				ui32 r2_n = r7_n | r6_n;
				if (r2_n != 0x00)
					goto l00408B38;
			}
l00408B58:
			__pack_d(r4);
		}
	}
}

// 00408BA0: void __divdf3(Register word32 r17, Register word32 ra, Register word32 f12, Register word32 f13, Register word32 f14, Register word32 f15)
void __divdf3(word32 r17, word32 ra, word32 f12, word32 f13, word32 f14, word32 f15)
{
	ptr32 fp;
	Eq_n dwLoc58;
	Eq_n dwLoc40;
	uint32 dwLoc30;
	uint32 dwLoc2C;
	uint32 dwLoc48;
	uint32 dwLoc44;
	struct Eq_n * r4;
	__unpack_d(fp + -40, fp + -88);
	__unpack_d(fp + -32, fp + -64);
	if ((word32) (dwLoc58 < 2) != 0x00 || (word32) (dwLoc40 < 2) != 0x00)
	{
l00408DDC:
		__pack_d(r4);
		return;
	}
	if ((dwLoc58 ^ 0x04) == 0x00 || (dwLoc58 ^ 0x02) == 0x00)
		goto l00408DDC;
	if ((dwLoc40 ^ 0x04) == 0x00 || (dwLoc40 ^ 0x02) == 0x00)
		goto l00408DDC;
	uint32 r4_n = dwLoc48;
	uint32 r5_n = dwLoc44;
	word32 r14_n = (word32) (dwLoc48 < dwLoc30);
	if (r14_n != 0x00)
	{
l00408CEC:
		r4_n = dwLoc48 << 0x01 | dwLoc44 >> 0x1F;
		r5_n = dwLoc44 << 0x01;
		r14_n = (word32) (r4_n < dwLoc30);
		goto l00408D08;
	}
	else
	{
		if (dwLoc30 == dwLoc48)
		{
			word32 r2_n = (word32) (dwLoc44 < dwLoc2C);
			if (r2_n != 0x00)
				goto l00408CEC;
		}
l00408D08:
		uint32 r10_n = 0x10000000;
		Eq_n r11_n = 0;
		ui32 r13_n = 0x00;
l00408D18:
		if (r14_n == 0x00)
		{
			uint32 r2_n;
			if (dwLoc30 != r4_n)
			{
				r2_n = (word32) (r5_n < dwLoc2C);
				goto l00408D38;
			}
			if ((word32) (r5_n < dwLoc2C) == 0x00)
			{
				r2_n = (word32) (r5_n < dwLoc2C);
l00408D38:
				r5_n -= dwLoc2C;
				r4_n = r4_n - dwLoc30 - r2_n;
				r13_n |= r11_n;
				goto l00408D4C;
			}
		}
l00408D4C:
		uint32 r6_n = r4_n << 0x01 | r5_n >> 0x1F;
		r11_n = r11_n >> 0x01 | r10_n << 0x1F;
		r10_n >>= 0x01;
		uint32 r7_n = r5_n << 0x01;
		r4_n = r6_n;
		r14_n = (word32) (r6_n < dwLoc30);
		if ((r11_n | r10_n) == 0x00)
		{
			if (true)
			{
				int32 r5_n = r13_n & 0x00FF;
				if (r5_n != 0x0080)
					goto l00408DD0;
				if ((r13_n & 0x0100) != 0x00)
				{
l00408DC4:
					goto l00408DD0;
				}
				ui32 r2_n = r7_n | r6_n;
				if (r2_n != 0x00)
					goto l00408DC4;
			}
l00408DD0:
			goto l00408DDC;
		}
		r5_n = r7_n;
		goto l00408D18;
	}
}

// 00408E10: void __eqdf2(Register word32 r17, Register word32 ra, Register word32 f12, Register word32 f13, Register word32 f14, Register word32 f15)
void __eqdf2(word32 r17, word32 ra, word32 f12, word32 f13, word32 f14, word32 f15)
{
	ptr32 fp;
	Eq_n dwLoc58;
	Eq_n dwLoc40;
	struct Eq_n * r4;
	__unpack_d(fp + -40, fp + -88);
	__unpack_d(fp + -32, fp + -64);
	if ((word32) (dwLoc58 < 2) == 0x00 && (word32) (dwLoc40 < 2) == 0x00)
		__fpcmp_parts_d(r4, fp + -64);
}

// 00408EE0: void __nedf2(Register word32 r17, Register word32 ra, Register word32 f12, Register word32 f13, Register word32 f14, Register word32 f15)
void __nedf2(word32 r17, word32 ra, word32 f12, word32 f13, word32 f14, word32 f15)
{
	ptr32 fp;
	Eq_n dwLoc58;
	Eq_n dwLoc40;
	struct Eq_n * r4;
	__unpack_d(fp + -40, fp + -88);
	__unpack_d(fp + -32, fp + -64);
	if ((word32) (dwLoc58 < 2) == 0x00 && (word32) (dwLoc40 < 2) == 0x00)
		__fpcmp_parts_d(r4, fp + -64);
}

// 00408FB0: void __gedf2(Register word32 r17, Register word32 ra, Register word32 f12, Register word32 f13, Register word32 f14, Register word32 f15)
void __gedf2(word32 r17, word32 ra, word32 f12, word32 f13, word32 f14, word32 f15)
{
	ptr32 fp;
	Eq_n dwLoc58;
	Eq_n dwLoc40;
	struct Eq_n * r4;
	__unpack_d(fp + -40, fp + -88);
	__unpack_d(fp + -32, fp + -64);
	if ((word32) (dwLoc58 < 2) == 0x00 && (word32) (dwLoc40 < 2) == 0x00)
		__fpcmp_parts_d(r4, fp + -64);
}

// 00409080: void __ltdf2(Register word32 r17, Register word32 ra, Register word32 f12, Register word32 f13, Register word32 f14, Register word32 f15)
void __ltdf2(word32 r17, word32 ra, word32 f12, word32 f13, word32 f14, word32 f15)
{
	ptr32 fp;
	Eq_n dwLoc58;
	Eq_n dwLoc40;
	struct Eq_n * r4;
	__unpack_d(fp + -40, fp + -88);
	__unpack_d(fp + -32, fp + -64);
	if ((word32) (dwLoc58 < 2) == 0x00 && (word32) (dwLoc40 < 2) == 0x00)
		__fpcmp_parts_d(r4, fp + -64);
}

// 00409150: void __floatsidf(Register Eq_n r4, Register word32 ra)
void __floatsidf(Eq_n r4, word32 ra)
{
	ptr32 fp;
	if (r4 != 0x00)
	{
		Eq_n dwLoc0C_n;
		Eq_n dwLoc10_n;
		if (r4 >> 0x1F != 0x00)
		{
			if (r4 == 0x80000000)
				return;
			Eq_n r2_n = -r4;
			dwLoc10_n = r2_n >> 0x1F;
			dwLoc0C_n = r2_n;
		}
		else
		{
			dwLoc10_n = r4 >> 0x1F;
			dwLoc0C_n = r4;
		}
		if ((word32) (dwLoc10_n > 0x0FFFFFFF) == 0x00)
		{
			do
			{
				Eq_n r2_n = dwLoc10_n << 0x01 | dwLoc0C_n >> 0x1F;
				dwLoc10_n = r2_n;
				dwLoc0C_n <<= 0x01;
			} while ((word32) (r2_n > 0x0FFFFFFF) == 0x00);
		}
	}
	__pack_d(fp + -32);
}

// 00409250: void __negdf2(Register word32 ra, Register word32 f12, Register word32 f13)
void __negdf2(word32 ra, word32 f12, word32 f13)
{
	ptr32 fp;
	__unpack_d(fp + -16, fp + -40);
	__pack_d(fp + -40);
}

// 004092D0: void __make_dp(Register word32 r5, Register word32 r6, Register word32 ra, Stack uint32 dwArg10, Stack ui32 dwArg14)
// Called from:
//      __extendsfdf2
void __make_dp(word32 r5, word32 r6, word32 ra, uint32 dwArg10, ui32 dwArg14)
{
	ptr32 fp;
	__pack_d(fp + -32);
}

// 00409330: void __truncdfsf2(Register word32 ra, Register word32 f12, Register word32 f13)
void __truncdfsf2(word32 ra, word32 f12, word32 f13)
{
	ptr32 fp;
	ui32 dwLoc14;
	Eq_n dwLoc28;
	word32 dwLoc24;
	int32 dwLoc20;
	Eq_n r7;
	__unpack_d(fp + -16, fp + -40);
	__make_fp(dwLoc28, dwLoc24, dwLoc20, r7, ra);
}

// 004093E0: void __pack_f(Register (ptr32 Eq_n) r4)
// Called from:
//      __addsf3
//      __subsf3
//      __mulsf3
//      __divsf3
//      __floatsisf
//      __make_fp
void __pack_f(struct Eq_n * r4)
{
	Eq_n r3_n = r4->t0000;
	Eq_n r4_n = r4->t000C;
	if ((word32) (r3_n < 2) != 0x00)
		return;
	if ((r3_n ^ 0x04) == 0x00)
		return;
	if ((r3_n ^ 0x02) == 0x00)
		return;
	if (r4_n == 0x00)
		return;
	int32 r5_n = r4->dw0008;
	if ((word32) (r5_n < -0x007E) == 0x00)
	{
		word32 r2_n = (word32) (r5_n < 0x0080);
		if (r2_n == 0x00)
			return;
		if ((r4_n & 0x7F) == 64)
		{
			if ((r4_n & 0x80) != 0x00)
				r4_n = (word32) r4_n + 64;
		}
		else
			r4_n = (word32) r4_n + 63;
	}
	else
	{
		ui32 r4_n;
		int32 r2_n = -0x007E - r5_n;
		ui32 r3_n = (word32) ((r4_n & (1 << r2_n) + -1) > 0x00);
		uint32 r4_n = r4_n >> r2_n;
		if ((word32) (r2_n < 26) == 0x00)
			r4_n = 0x00;
		else
			r4_n = r4_n | r3_n;
	}
}

// 00409540: void __unpack_f(Register (ptr32 uint32) r4, Register (ptr32 Eq_n) r5)
// Called from:
//      __addsf3
//      __subsf3
//      __mulsf3
//      __divsf3
//      __fixsfsi
//      __extendsfdf2
void __unpack_f(uint32 * r4, struct Eq_n * r5)
{
	uint32 r3_n = *r4;
	r5->dw0004 = r3_n >> 0x1F;
	int32 r4_n = r3_n >> 0x17 & 0xFF;
	switch (r4_n)
	{
	case 0x00:
		if ((r3_n & 0x007FFFFF) != 0x00)
		{
			r5->dw0008 = -0x007E;
			uint32 r5_n = (r3_n & 0x007FFFFF) << 0x07;
			if ((word32) (r5_n > 0x3FFFFFFF) == 0x00)
			{
				r5->dw0000 = 3;
				int32 r4_n = -0x007F;
				while (true)
				{
					r5_n <<= 0x01;
					if ((word32) (r5_n > 0x3FFFFFFF) != 0x00)
						break;
					r4_n += -1;
				}
				int32 r4_n = r4_n + 0;
				r5->dw0008 = r4_n;
			}
			else
				r5->dw0000 = 3;
			r5->dw000C = r5_n;
			return;
		}
		else
		{
			r5->dw0000 = 2;
			return;
		}
		break;
	case 0x00FF:
		if ((r3_n & 0x007FFFFF) != 0x00)
		{
			if ((r3_n & 0x007FFFFF & 0x00100000) != 0x00)
				r5->dw0000 = 1;
			else
				r5->dw0000 = 0x00;
			r5->dw000C = r3_n & 0x007FFFFF;
			return;
		}
		else
		{
			r5->dw0000 = 4;
			return;
		}
		break;
	default:
		r5->dw000C = (r3_n & 0x007FFFFF) << 0x07 | 0x40000000;
		r5->dw0008 = r4_n + -0x007F;
		r5->dw0000 = 3;
		return;
	}
}

// 00409630: void __make_fp(Register Eq_n r4, Register word32 r5, Register int32 r6, Register Eq_n r7, Register word32 ra)
// Called from:
//      __truncdfsf2
void __make_fp(Eq_n r4, word32 r5, int32 r6, Eq_n r7, word32 ra)
{
	Eq_n tLoc18;
	tLoc18.t0000 = r4;
	tLoc18.dw0004 = r5;
	tLoc18.dw0008 = r6;
	tLoc18.t000C = r7;
	__pack_f(&tLoc18);
}

// 00409680: void __pack_d(Register (ptr32 Eq_n) r4)
// Called from:
//      __adddf3
//      __subdf3
//      __muldf3
//      __divdf3
//      __floatsidf
//      __negdf2
//      __make_dp
void __pack_d(struct Eq_n * r4)
{
	Eq_n r3_n = r4->t0000;
	uint32 r10_n = r4->dw0010;
	Eq_n r11_n = r4->t0014;
	if ((word32) (r3_n < 2) != 0x00)
		return;
	if ((r3_n ^ 0x04) == 0x00)
		return;
	if ((r3_n ^ 0x02) == 0x00 || (r11_n | r10_n) == 0x00)
		return;
	int32 r4_n = r4->dw0008;
	if ((word32) (r4_n < -1022) == 0x00)
	{
		word32 r2_n = (word32) (r4_n < 0x0400);
		if (r2_n == 0x00)
			return;
		if (false || (r11_n & 0x00FF) != 0x0080)
			r10_n += (word32) (r11_n < 0);
		else
		{
			if ((r11_n & 0x0100) == 0x00)
				return;
			r10_n += (word32) (r11_n < 0);
		}
	}
	else
	{
		uint32 r10_n;
		Eq_n r11_n;
		int32 r4_n = -1022 - r4_n;
		if ((word32) (r4_n < 57) == 0x00)
		{
			r10_n = 0x00;
			r11_n.u0 = 0x00;
		}
		else
		{
			int32 r5_n;
			ui32 r2_n = 1 << r4_n;
			if ((r11_n & r2_n + -1 | r10_n & r2_n + -1 >> 0x1F) != 0x00)
				r5_n = 1;
			else
				r5_n = 0x00;
			uint32 r15_n;
			uint32 r14_n;
			if (r4_n << 0x1A < 0x00)
			{
				r15_n = r10_n >> r4_n;
				r14_n = 0x00;
			}
			else
			{
				if (r4_n << 0x1A != 0x00)
				{
					uint32 r15_n = r11_n >> r4_n;
					r15_n = r15_n | r10_n << -r4_n;
				}
				else
					r15_n = r11_n >> r4_n;
				r14_n = r10_n >> r4_n;
			}
			r10_n = r14_n;
			r11_n = r15_n | r5_n;
		}
		if (true)
		{
			int32 r5_n = r11_n & 0x00FF;
			if (r5_n == 0x0080)
			{
				if ((r11_n & 0x0100) == 0x00)
					return;
				r10_n += (word32) (r11_n < 0);
				return;
			}
		}
		r10_n += (word32) (r11_n < 0);
	}
}

// 00409930: void __unpack_d(Register (ptr32 Eq_n) r4, Register (ptr32 Eq_n) r5)
// Called from:
//      __adddf3
//      __subdf3
//      __muldf3
//      __divdf3
//      __eqdf2
//      __nedf2
//      __gedf2
//      __ltdf2
//      __negdf2
//      __truncdfsf2
void __unpack_d(struct Eq_n * r4, struct Eq_n * r5)
{
	uint32 r2_n = r4->dw0000;
	uint32 r3_n = r4->dw0004;
	r5->dw0004 = r2_n >> 0x1F & 0x01;
	int32 r7_n = r2_n >> 0x14 & 0x07FF;
	switch (r7_n)
	{
	case 0x00:
		if ((r3_n | r2_n & 0x000FFFFF) != 0x00)
		{
			r5->dw0008 = -1022;
			uint32 r8_n = (r2_n & 0x000FFFFF) << 0x08 | r3_n >> 0x18;
			uint32 r9_n = r3_n << 0x08;
			if ((word32) (r8_n > 0x0FFFFFFF) == 0x00)
			{
				r5->dw0000 = 3;
				while (true)
				{
					r8_n = r8_n << 0x01 | r9_n >> 0x1F;
					int32 r2_n = r5->dw0008;
					r9_n <<= 0x01;
					if ((word32) (r8_n > 0x0FFFFFFF) != 0x00)
						break;
					r5->dw0008 = r2_n + -1;
				}
				r5->dw0008 = r2_n + -1;
			}
			else
				r5->dw0000 = 3;
			r5->dw0010 = r8_n;
			r5->dw0014 = r9_n;
			return;
		}
		else
		{
			r5->dw0000 = 2;
			return;
		}
		break;
	case 0x07FF:
		if ((r3_n | r2_n & 0x000FFFFF) != 0x00)
		{
			if ((r2_n & 0x000FFFFF & 0x00080000) != 0x00)
				r5->dw0000 = 1;
			else
				r5->dw0000 = 0x00;
			r5->dw0010 = r2_n & 0x000FFFFF;
			r5->dw0014 = r3_n;
			return;
		}
		else
		{
			r5->dw0000 = 4;
			return;
		}
		break;
	default:
		r5->dw0010 = (r2_n & 0x000FFFFF) << 0x08 | r3_n >> 0x18 | 0x10000000;
		r5->dw0014 = r3_n << 0x08;
		r5->dw0008 = r7_n + -0x03FF;
		r5->dw0000 = 3;
		return;
	}
}

// 00409A90: void __fpcmp_parts_d(Register (ptr32 Eq_n) r4, Register (ptr32 Eq_n) r5)
// Called from:
//      __eqdf2
//      __nedf2
//      __gedf2
//      __ltdf2
void __fpcmp_parts_d(struct Eq_n * r4, struct Eq_n * r5)
{
	Eq_n r6_n = r4->t0000;
	if ((word32) (r6_n < 2) != 0x00)
		return;
	Eq_n r3_n = r5->t0000;
	if ((word32) (r3_n < 2) != 0x00)
		return;
	if ((r6_n ^ 0x04) != 0x00)
	{
		if ((r3_n ^ 0x04) == 0x00)
			return;
		if ((r6_n ^ 0x02) != 0x00)
		{
			if ((r3_n ^ 0x02) == 0x00)
				return;
			if (r4->dw0004 != r5->dw0004)
				return;
			int32 r6_n = r4->dw0008;
			int32 r3_n = r5->dw0008;
			if ((word32) (r3_n < r6_n) != 0x00)
				return;
			if ((word32) (r6_n < r3_n) != 0x00)
				return;
			up32 r7_n = r4->dw0010;
			up32 r6_n = r5->dw0010;
			if ((word32) (r6_n < r7_n) != 0x00)
				return;
			word32 r2_n;
			if (r7_n == r6_n)
			{
				if ((word32) (r5->dw0014 < r4->dw0014) != 0x00)
					return;
				r2_n = (word32) (r7_n < r6_n);
			}
			else
				r2_n = (word32) (r7_n < r6_n);
			if (r2_n != 0x00 || r6_n == r7_n && (word32) (r4->dw0014 < r5->dw0014) != 0x00)
				;
		}
		else if ((r3_n ^ 0x02) == 0x00)
			;
	}
	else if ((r3_n ^ 0x04) != 0x00)
		;
}

// 00409C10: void __do_global_ctors_aux()
void __do_global_ctors_aux()
{
	struct Eq_n * r2_n = g_ptr10000878;
	<anonymous> * r25_n = r2_n->ptr0854;
	if (r25_n != (<anonymous> *) -1)
	{
		word32 * r16_n = &r2_n->ptr0854;
		while (true)
		{
			r25_n();
			r16_n += -1;
			<anonymous> * r2_n = *r16_n;
			if (r2_n == (<anonymous> *) -1)
				break;
			r25_n = r2_n;
		}
	}
}

// 00409C84: void init_dummy()
void init_dummy()
{
}

