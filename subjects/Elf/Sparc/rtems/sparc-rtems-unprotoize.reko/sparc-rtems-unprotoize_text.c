// sparc-rtems-unprotoize_text.c
// Generated by decompiling sparc-rtems-unprotoize
// using Reko decompiler version 0.9.4.0.

#include "sparc-rtems-unprotoize.h"

// 00011498: void _start(Register (ptr32 Eq_n) g1, Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7)
void _start(void (* g1)(), word32 o3, word32 o4, word32 o5, word32 o7)
{
	if (g1 == null)
	{
		atexit(&g_t16EE4);
		_environ = fp + 0x44 + ((_init(o3, o4, o5, o7) << 0x02) + 0x04);
		exit(main(fp + 0x44));
	}
	else
		atexit(g1);
}

// 0001150C: Register word32 fn0001150C(Register word32 o7, Register word32 l7)
// Called from:
//      __do_global_dtors_aux
//      frame_dummy
word32 fn0001150C(word32 o7, word32 l7)
{
	return o7 + l7;
}

// 00011514: void __do_global_dtors_aux(Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7)
// Called from:
//      _fini
void __do_global_dtors_aux(word32 o3, word32 o4, word32 o5, word32 o7)
{
	struct Eq_n * l7_n = fn0001150C(o7, 0x00016660);
	if (*l7_n->ptr0008 != 0x00)
		return;
	word32 ** o2_n = l7_n->ptr0004;
	if (**o2_n != 0x00)
	{
		word32 ** l0_n = o2_n;
		struct Eq_n * o0_n = (char *) *o2_n + 4;
		while (true)
		{
			*l0_n = (word32 **) o0_n;
			<anonymous> * o1_n = o0_n->dwFFFFFFFC;
			o1_n();
			word32 * o0_n = *l0_n;
			if (*o0_n == 0x00)
				break;
			o0_n = (struct Eq_n *) (o0_n + 1);
		}
	}
	if (l7_n->dw001C == 0x00)
		*l7_n->ptr0008 = 0x01;
	else
	{
		word32 l0_n;
		__deregister_frame_info();
	}
}

// 000115CC: void fini_dummy()
void fini_dummy()
{
}

// 000115D8: void frame_dummy(Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7)
// Called from:
//      _init
void frame_dummy(word32 o3, word32 o4, word32 o5, word32 o7)
{
	struct Eq_n * l7_n = fn0001150C(o7, 0x0001659C);
	if (l7_n->dw0018 == 0x00)
		return;
	__register_frame_info();
}

// 00011620: void init_dummy()
void init_dummy()
{
}

// 0001162C: Register Eq_n notice(Register Eq_n o0, Register out ptr32 i1Out, Register out (ptr32 Eq_n) i2Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      xmalloc
//      xrealloc
//      fancy_abort
//      safe_write
//      usage
//      abspath
//      find_file
//      aux_info_corrupted
//      save_def_or_dec
//      gen_aux_info_file
//      process_aux_info_file
//      declare_source_confusing
//      edit_fn_declaration
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
//      edit_file
//      main
Eq_n notice(Eq_n o0, ptr32 & i1Out, struct Eq_n & i2Out, struct Eq_n & i6Out)
{
	vfprintf(&g_t2B640, o0, &fp->dw0044 + 1);
	i1Out = o1;
	i2Out = o2;
	i6Out = fp;
	return o0;
}

// 00011660: void xstrerror(Register (ptr32 char) o0)
// Called from:
//      safe_write
//      find_file
//      gen_aux_info_file
//      process_aux_info_file
//      main
//      pexecute
void xstrerror(char * o0)
{
	strerror(o0);
}

// 00011674: Register Eq_n xmalloc(Register Eq_n o0, Register out ptr32 i1Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
// Called from:
//      savestring
//      savestring2
//      dupnstr
//      string_list_cons
//      lookup
//      unexpand_if_needed
//      shortpath
//      find_file
//      save_def_or_dec
//      munge_compile_params
//      process_aux_info_file
//      main
//      getpwd
//      choose_temp_base
//      make_temp_file
Eq_n xmalloc(Eq_n o0, ptr32 & i1Out, ptr32 & i2Out, ptr32 & i6Out)
{
	if (malloc(o0) != null)
	{
		i1Out = o1;
		i2Out = o2;
		i6Out = fp;
		return o0;
	}
	else
	{
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(0x000170A8, out i1_n, out i2_n, out i6_n);
		exit(33);
	}
}

// 000116B0: Register Eq_n xrealloc(Register Eq_n o0, Register Eq_n o1, Register out Eq_n i1Out, Register out ptr32 i2Out)
// Called from:
//      unexpand_if_needed
//      output_bytes
Eq_n xrealloc(Eq_n o0, Eq_n o1, union Eq_n & i1Out, ptr32 & i2Out)
{
	bool v23_n;
	if (o0 != 0x00)
		v23_n = realloc(o0, o1) != null;
	else
		v23_n = malloc(o1) != null;
	if (v23_n)
	{
		i1Out = o1;
		i2Out = o2;
		return o0;
	}
	else
	{
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(0x000170A8, out i1_n, out i2_n, out i6_n);
		exit(33);
	}
}

// 00011708: Register Eq_n xfree(Register Eq_n o0)
// Called from:
//      free_def_dec
Eq_n xfree(Eq_n o0)
{
	if (o0 == 0x00)
		return o0;
	free(o0);
}

// 00011728: Register Eq_n savestring(Register Eq_n o0, Register (ptr32 char) o1, Register out Eq_n l0Out, Register out ptr32 i0Out, Register out ptr32 i1Out, Register out ptr32 i6Out)
// Called from:
//      add_symbol
//      unexpand_if_needed
//      abspath
Eq_n savestring(Eq_n o0, char * o1, union Eq_n & l0Out, ptr32 & i0Out, ptr32 & i1Out, ptr32 & i6Out)
{
	ptr32 i1_n;
	ptr32 i6_n;
	word32 i2_n;
	xmalloc(o1 + 1, out i1_n, out i2_n, out i6_n);
	strcpy(o1 + 1, o0);
	l0Out = o0;
	i0Out = o1 + 1;
	i1Out = i1_n;
	i6Out = i6_n;
	return o1 + 1;
}

// 0001174C: Register Eq_n savestring2(Register Eq_n o0, Register uint32 o1, Register word32 o3)
// Called from:
//      gen_aux_info_file
Eq_n savestring2(Eq_n o0, uint32 o1, word32 o3)
{
	word32 o0_n = o1 + o3;
	word32 i1_n;
	Eq_n i2_n;
	word32 i6_n;
	xmalloc(o0_n + 0x01, out i1_n, out i2_n, out i6_n);
	strcpy(o0_n + 0x01, o0);
	strcpy(o0_n + 0x01 + i1_n, i2_n);
	return o0_n + 0x01;
}

// 00011780: void fancy_abort()
void fancy_abort()
{
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice(94408, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000117A0: Register Eq_n dupnstr(Register Eq_n o0, Register (ptr32 Eq_n) o1, Register out Eq_n l0Out, Register out (ptr32 Eq_n) i0Out, Register out ptr32 i6Out)
// Called from:
//      save_def_or_dec
//      munge_compile_params
//      edit_formals_lists
Eq_n dupnstr(Eq_n o0, struct Eq_n * o1, union Eq_n & l0Out, struct Eq_n & i0Out, ptr32 & i6Out)
{
	int32 i1_n;
	ptr32 i6_n;
	word32 i2_n;
	xmalloc(o1->a0001, out i1_n, out i2_n, out i6_n);
	strncpy(o1->a0001, o0, i1_n);
	o1->a0001[i1_n] = 0x00;
	l0Out = o0;
	i0Out = (struct Eq_n *) o1->a0001;
	i6Out = i6_n;
	return o1->a0001;
}

// 000117CC: Register Eq_n substr(Register Eq_n o0, Register (ptr32 int8) o1)
// Called from:
//      other_variable_style_function
Eq_n substr(Eq_n o0, int8 * o1)
{
	int32 g2_n = (int32) *o0;
	if (g2_n != 0x00)
	{
		int8 * o3_n = o1;
		int32 g3_n = (int32) *o1;
		if (g3_n == 0x00)
			return o0;
		Eq_n o2_n = o0;
		while ((int32) *o2_n - g3_n == 0x00)
		{
			++o3_n;
			g3_n = (int32) *o3_n;
			if (g3_n == 0x00)
			{
				o0.u0 = (bool) o0.u0 + 1;
				return o0;
			}
			o2_n = (word32) o2_n + 1;
		}
	}
	else
	{
		o0.u0 = 0x00;
		return o0;
	}
}

// 00011828: Register Eq_n safe_read(Register Eq_n o0, Register Eq_n o1, Register Eq_n o2, Register out (ptr32 Eq_n) l1Out, Register out Eq_n l2Out)
// Called from:
//      process_aux_info_file
Eq_n safe_read(Eq_n o0, Eq_n o1, Eq_n o2, struct stat & l1Out, union Eq_n & l2Out)
{
safe_read_entry:
	Eq_n i1_n = o1
	Eq_n l0_n = o2
	goto l00011840
l00011828:
l0001183C:
	i1_n = i1_n + o0_n
l00011840:
	bool v27_n = l0_n <= 0x00
l00011844:
	branch v27_n l00011848_ds_t
l00011848_ds_f:
	Eq_n o0_n = (uint32) read(o0, i1_n, l0_n)
	branch o0_n >= 0x00 l00011860_ds_t
	goto l00011860_ds_f
l0001184C:
l00011860_ds_f:
	char * o0_n = errno
	branch o0_n == (char *) 0x04 l0001186C_ds_t
	goto l0001186C_ds_f
l00011860_ds_t:
	branch o0_n != 0x00 l00011878_ds_t
l00011864:
l0001186C_ds_f:
	branch l0_n != 0x00 l00011878_ds_t
l0001186C_ds_t:
	v27_n = l0_n <= 0x00
	goto l00011844
l00011870:
l00011874:
l00011878_ds_t:
	l0_n = l0_n - o0_n
	goto l0001183C
l00011878_ds_t:
	l0_n = l0_n - o0_n
	goto l0001183C
l0001187C:
l00011880:
	l1Out = (struct stat *) &g_qw2B400
	l2Out = o0
	return l0_n
safe_read_exit:
}

// 00011888: void safe_write(Register int32 o0, Register (ptr32 void) o1, Register Eq_n o2, Register Eq_n o3)
void safe_write(int32 o0, void * o1, Eq_n o2, Eq_n o3)
{
	void * i1_n = o1;
	Eq_n i2_n = o2;
	if (o2 > 0x00)
	{
		do
		{
			Eq_n o0_n = (uint32) write(o0, i1_n, i2_n);
			if (o0_n < 0x00)
			{
				if (errno != (char *) 0x04)
				{
					word32 l0_n;
					char * l2_n;
					ui32 l3_n;
					word32 i0_n;
					word32 l4_n;
					shortpath(0x00, o3, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
					xstrerror(l2_n);
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					notice(l3_n | 0xE0, out i1_n, out i2_n, out i6_n);
					return;
				}
			}
			else
			{
				i2_n -= o0_n;
				i1_n += o0_n;
			}
		} while (i2_n > 0x00);
	}
}

// 00011914: void save_pointers()
// Called from:
//      edit_fn_declaration
//      edit_fn_definition
void save_pointers()
{
	up32 o1_n = g_dw28210;
	g_dw2B280 = g_dw281E0;
	g_dw2B290 = o1_n;
}

// 00011938: void restore_pointers()
// Called from:
//      edit_fn_declaration
//      edit_fn_definition
void restore_pointers()
{
	up32 o1_n = g_dw2B290;
	g_dw281E0 = g_dw2B280;
	g_dw28210 = o1_n;
}

// 0001195C: Register int32 is_id_char(Register int32 o0)
// Called from:
//      unexpand_if_needed
//      save_def_or_dec
//      edit_formals_lists
//      scan_for_missed_items
int32 is_id_char(int32 o0)
{
	int32 g2_n;
	if (((ui32) (o0 & 0xFF)->b2B411 & 0x07) == 0x00)
	{
		g2_n = 0x00;
		if ((o0 & 0xFF) != 0x5F)
		{
			ui32 g0_n = (o0 & 0xFF) - 0x24;
			if (g0_n != 0x00)
				return g2_n;
		}
	}
	g2_n = 0x01;
	return g2_n;
}

// 00011998: void usage()
// Called from:
//      main
void usage()
{
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice(0x00017108, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000119BC: Register Eq_n in_system_include_dir(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n in_system_include_dir(Eq_n o0)
{
	if ((int32) *o0 == 0x2F)
	{
		Eq_n i0_n;
		if (g_t27ED0 != 0x00)
		{
			struct Eq_n * l1_n = &g_t27ED0;
			Eq_n l0_n = g_t27ED0;
			while (true)
			{
				if (strncmp(o0, l0_n, (uint32) strlen(l0_n)) == 0x00)
				{
					if ((int32) *((word32) o0 + (uint32) strlen(l1_n->ptr0000)) == 0x2F)
					{
						i0_n.u0 = 0x01;
						return i0_n;
					}
					++l1_n;
				}
				else
					++l1_n;
				if (l1_n->ptr0000 == 0x00)
					break;
				l0_n = l1_n->ptr0000;
			}
		}
		i0_n.u0 = 0x00;
		return i0_n;
	}
	else
		abort();
}

// 00011A4C: Register (ptr32 Eq_n) needs_to_be_converted(Register (ptr32 Eq_n) o0)
// Called from:
//      edit_file
struct Eq_n * needs_to_be_converted(struct Eq_n * o0)
{
	struct Eq_n * o0_n;
	struct Eq_n * g3_n = o0->ptr0004;
	if (g3_n != null)
	{
		int32 g2_n = (int32) g3_n->b0020;
		while (g2_n == 0x00)
		{
			g3_n = g3_n->ptr0000;
			if (g3_n == null)
			{
				o0_n = null;
				return o0_n;
			}
			g2_n = (int32) g3_n->b0020;
		}
		o0_n = (struct Eq_n *) ~0x00;
	}
	else
		o0_n = null;
	return o0_n;
}

// 00011A88: Register Eq_n directory_specified_p(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n directory_specified_p(Eq_n o0)
{
	Eq_n i0_n;
	struct Eq_n * l1_n = directory_list;
	if (l1_n == null)
	{
		i0_n.u0 = 0x00;
		return i0_n;
	}
	else
	{
		Eq_n l0_n = l1_n->t0000;
		while (true)
		{
			if (strncmp(o0, l0_n, (uint32) strlen(l0_n)) == 0x00)
			{
				if ((int32) *((word32) o0 + (uint32) strlen(l1_n->t0000)) == 0x2F)
				{
					struct Eq_n * o0_n = (word32) o0 + (uint32) strlen(l1_n->t0000);
					if ((int32) o0_n->b0001 == 0x00)
					{
l00011B1C:
						i0_n.u0 = 0x01;
						return i0_n;
					}
					int8 * o2_n = &o0_n->b0001;
					bool v24_n = (int32) o0_n->b0001 == 0x2F;
					while (!v24_n)
					{
						++o2_n;
						int32 o0_n = (int32) *o2_n;
						if (o0_n == 0x00)
							goto l00011B1C;
						v24_n = o0_n == 0x2F;
					}
					l1_n = l1_n->ptr0004;
				}
				else
					l1_n = l1_n->ptr0004;
			}
			else
				l1_n = l1_n->ptr0004;
			if (l1_n == null)
			{
				i0_n.u0 = 0x00;
				return i0_n;
			}
			l0_n = l1_n->t0000;
		}
	}
}

// 00011B40: Register Eq_n file_excluded_p(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n file_excluded_p(Eq_n o0)
{
	Eq_n i0_n;
	Eq_n o0_n = (uint32) strlen(o0);
	struct Eq_n * l0_n = exclude_list;
	if (l0_n != null)
	{
		word32 l2_n = o0 + o0_n;
		do
		{
			if (strcmp(l2_n - (uint32) strlen(l0_n->t0000), l0_n->t0000) == 0x00)
			{
				if (CONVERT(Mem0[o0_n - CONVERT(strlen(l0_n->t0000), size_t, uint32) + o0 + -1:int8], int8, int32) == 0x2F)
				{
					i0_n.u0 = 0x01;
					return i0_n;
				}
				l0_n = l0_n->ptr0004;
			}
			else
				l0_n = l0_n->ptr0004;
		} while (l0_n != null);
		i0_n.u0 = 0x00;
	}
	else
		i0_n.u0 = 0x00;
	return i0_n;
}

// 00011BC8: Register word32 string_list_cons(Register out ptr32 i6Out)
// Called from:
//      main
word32 string_list_cons(ptr32 & i6Out)
{
	word32 i1_n;
	ptr32 i6_n;
	word32 i2_n;
	*(union Eq_n *) 0x08 = xmalloc(0x08, out i1_n, out i2_n, out i6_n);
	*(word32 *) 0x0C = i1_n;
	i6Out = i6_n;
	return 0x08;
}

// 00011BE4: Register (ptr32 Eq_n) visit_each_hash_node(Register (ptr32 Eq_n) o0)
// Called from:
//      do_processing
struct Eq_n * visit_each_hash_node(struct Eq_n * o0)
{
	struct Eq_n * i0_n = o0;
	if (o0 - (o0 + 0x1800) <u 0x00)
	{
		word32 o0_n = o0->dw0004;
		while (true)
		{
			if (o0_n != 0x00)
			{
				l0 = i0_n + 1;
				do
				{
					reverse_def_dec_list(i0_n);
					i0_n = i0_n->dw0000;
				} while (i0_n != null);
			}
			else
				l0 = i0_n + 1;
			i0_n = l0;
			if (l0 - (o0 + 0x1800) >=u 0x00)
				break;
			o0_n = l0->dw0004;
		}
	}
	return l0;
}

// 00011C3C: Register Eq_n add_symbol(Register Eq_n o0, Register Eq_n o1, Register out ptr32 i1Out)
// Called from:
//      lookup
Eq_n add_symbol(Eq_n o0, Eq_n o1, ptr32 & i1Out)
{
	(&(&(&(&(&o0.ptr0000->a0000[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000 = (struct Eq_n *) 0x00;
	Eq_n i0_n;
	ptr32 i1_n;
	struct Eq_n * l0_n;
	word32 i6_n;
	l0_n->dw0004 = savestring(o1, (uint32) strlen(o1), out l0_n, out i0_n, out i1_n, out i6_n);
	l0_n->dw0008 = 0x00;
	i1Out = i1_n;
	return i0_n;
}

// 00011C6C: Register Eq_n lookup(Register Eq_n o0, Register Eq_n o1, Register out Eq_n l1Out, Register out Eq_n i1Out)
// Called from:
//      find_file
//      save_def_or_dec
Eq_n lookup(Eq_n o0, Eq_n o1, struct Eq_n & l1Out, union Eq_n & i1Out)
{
	Eq_n i1_n = o1;
	ui32 o3_n = 0x00;
	if ((int32) *o1 != 0x00)
	{
		Eq_n o2_n = o1;
		while (true)
		{
			o2_n = (word32) o2_n + 1;
			int32 o1_n = (int32) *o2_n;
			if ((int32) *o2_n == 0x00)
				break;
			o3_n += o1_n;
		}
		o3_n += o1_n;
	}
	Eq_n o0_n;
	ui32 o3_n = o3_n & 0x01FF;
	Eq_n i0_n = o0.ptr0000 + (o3_n * 0x0C) / 8;
	Eq_n o0_n = i0_n.ptr0000->t0004;
	if (o0_n == 0x00)
		o0_n = i0_n;
	else
	{
		if (strcmp(o0_n, o1) == 0x00)
			goto l00011D34;
		if (o0.ptr0000[o3_n * 0x0C / 8] != 0x00)
		{
			i0_n = (Eq_n) (&(&(&(&(&i0_n.ptr0000->a0000[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000;
			while (strcmp(i0_n.ptr0000->t0004, o1) != 0x00)
			{
				if ((&(&(&(&(&i0_n.ptr0000->a0000[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000 == 0x00)
					goto l00011D1C;
				i0_n = (Eq_n) (&(&(&(&(&i0_n.ptr0000->a0000[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000.a0000)[0].ptr0000;
			}
l00011D34:
			l1Out = o0;
			i1Out = i1_n;
			return i0_n;
		}
l00011D1C:
		word32 i2_n;
		word32 i6_n;
		*xmalloc(0x0C, out i1_n, out i2_n, out i6_n) = 0x0C;
		o0_n = (Eq_n) 0x0C;
	}
	i0_n = add_symbol(o0_n, i1_n, out i1_n);
	goto l00011D34;
}

// 00011D3C: void free_def_dec(Register (ptr32 Eq_n) o0)
// Called from:
//      save_def_or_dec
void free_def_dec(struct Eq_n * o0)
{
	xfree(xfree(o0->t000C));
}

// 00011D58: void unexpand_if_needed(Register Eq_n o0)
void unexpand_if_needed(Eq_n o0)
{
	Eq_n i0_n = o0;
	word32 i1_n = 0x00;
	if (line_buf.78 == 0x00)
	{
		line_buf_size.79.u0 = 0x0400;
		word32 i2_n;
		word32 i6_n;
		i0_n = xmalloc(0x0400, out i1_n, out i2_n, out i6_n);
		line_buf.78.u0 = 0x0400;
	}
	Eq_n l1_n;
	if ((int32) *i0_n == 0x0A)
	{
		l1_n = line_buf.78;
		goto l00011EC8;
	}
	l1_n = line_buf.78;
	Eq_n o0_n = g_t16F14;
l00011DA0:
	if (o0_n != 0x00)
	{
		struct Eq_n * l4_n = &g_t16F14;
		Eq_n l0_n = g_t16F14;
		while (true)
		{
			Eq_n o0_n = (uint32) strlen(l0_n);
			if ((int8) (*i0_n - *l0_n) == 0x00)
			{
				if (strncmp(i0_n, l0_n, o0_n) == 0x00)
				{
					if (is_id_char(CONVERT(Mem62[i0_n + o0_n:int8], int8, int32)) == 0x00)
					{
						char * o0_n = (uint32) strlen(l4_n->dw0004);
						Eq_n o1_n = line_buf.78;
						Eq_n o2_n = line_buf_size.79;
						i1_n = 0x01;
						if (l1_n + o0_n - o1_n - o2_n >= 0x00)
						{
							Eq_n o2_n = o0_n + (o2_n << 0x01);
							line_buf_size.79 = o2_n;
							word32 i2_n;
							i0_n = xrealloc(o1_n, o2_n, out i1_n, out i2_n);
							line_buf.78 = o1_n;
							l1_n = o1_n + (l1_n - o1_n);
						}
						strcpy(l1_n, l4_n->dw0004);
						l1_n += o0_n;
						i0_n += o0_n;
						goto l00011EB8;
					}
					++l4_n;
				}
				else
					++l4_n;
			}
			else
				++l4_n;
			if (l4_n->dw0000 == 0x00)
				break;
			l0_n = l4_n->dw0000;
		}
	}
	ui32 o0_n;
	Eq_n o1_n = line_buf.78;
	int32 l0_n = l1_n - o1_n;
	if (l0_n - line_buf_size.79 == 0x00)
	{
		line_buf_size.79 = l0_n << 0x01;
		word32 i2_n;
		i0_n = xrealloc(o1_n, l0_n << 0x01, out i1_n, out i2_n);
		line_buf.78 = o1_n;
		l1_n = (word32) o1_n + l0_n;
		o0_n = (ui32) *i0_n;
	}
	else
		o0_n = (ui32) *i0_n;
	*l1_n = (byte) o0_n;
	i0_n = (word32) i0_n + 1;
	++l1_n;
l00011EB8:
	if ((int32) *i0_n == 0x0A)
	{
l00011EC8:
		Eq_n o2_n = line_buf.78;
		Eq_n o1_n = line_buf_size.79;
		if (l1_n - ((word32) o2_n - 2) - o1_n >= 0x00)
		{
			line_buf_size.79 = o1_n << 0x01;
			word32 i2_n;
			xrealloc(o2_n, o1_n << 0x01, out i1_n, out i2_n);
			line_buf.78 = o2_n;
			l1_n = o2_n + (l1_n - o2_n);
		}
		*l1_n = 0x0A;
		word32 l1_n = l1_n + 0x01;
		if (i1_n == 0x00)
			*l1_n = 0x00;
		else
		{
			*l1_n = 0x00;
			Eq_n o0_n = line_buf.78;
			word32 i0_n;
			word32 i1_n;
			word32 i6_n;
			word32 l0_n;
			savestring(o0_n, l1_n - o0_n, out l0_n, out i0_n, out i1_n, out i6_n);
		}
		return;
	}
	o0_n = g_t16F14;
	goto l00011DA0;
}

// 00011F34: Register word32 abspath(Register Eq_n o0, Register Eq_n o1, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      shortpath
//      referenced_file_is_newer
//      save_def_or_dec
//      main
word32 abspath(Eq_n o0, Eq_n o1, struct Eq_n & i6Out)
{
	Eq_n i0_n = o0;
	if (o0 == 0x00)
		i0_n = g_t2B270;
	struct Eq_n * o2_n;
	word32 sp_n = fp + ~0x6F - (CONVERT(strlen(i0_n) + strlen(o1), size_t, size_t) + 0x09 & ~0x07);
	if ((int32) *o1 != 0x2F)
	{
		ui32 o1_n = (ui32) *i0_n;
		Mem52[sp_n + 0x60:byte] = SLICE(o1_n, byte, 0);
		o2_n = (word32) sp_n + 97;
		if (o1_n << 0x18 != 0x00)
		{
			byte * i0_n = (word32) i0_n + 1;
			while (true)
			{
				ui32 o0_n = (ui32) *i0_n;
				o2_n->b0000 = (byte) o0_n;
				++i0_n;
				if (o0_n << 0x18 == 0x00)
					break;
				++o2_n;
			}
			++o2_n;
		}
		o2_n->bFFFFFFFF = 0x2F;
	}
	else
		o2_n = sp_n + 0x60;
	ui32 o0_n = (ui32) *o1;
	o2_n->b0000 = (byte) o0_n;
	byte * i0_n = (word32) o1 + 1;
	byte * o2_n = o2_n + 1;
	if (o0_n << 0x18 != 0x00)
	{
		while (true)
		{
			ui32 o0_n = (ui32) *i0_n;
			*o2_n = (byte) o0_n;
			++i0_n;
			if (o0_n << 0x18 == 0x00)
				break;
			++o2_n;
		}
	}
	Eq_n o2_n = (word32) sp_n + 97;
	if ((int32) *((word32) sp_n + 97) != 0x00)
	{
		struct Eq_n * o1_n = (word32) sp_n + 97;
		bool v27_n = (int32) *((word32) sp_n + 97) != 0x2F;
l00012024:
		bool v30_n;
		if (!v27_n)
		{
			ui32 o3_n = (ui32) o1_n->b0000;
			if ((int32) *((word32) o2_n - 1) == 0x2F)
			{
				o1_n = (struct Eq_n *) &o1_n->b0001;
				goto l00012110;
			}
			v30_n = o3_n != 0x2E;
		}
		else
		{
			ui32 o3_n = (ui32) o1_n->b0000;
			v30_n = o3_n != 0x2E;
		}
		ui32 o0_n;
		if (v30_n)
		{
			o0_n = (ui32) o1_n->b0000;
			goto l00012104;
		}
		if ((int32) *((word32) o2_n - 1) != 0x2F)
		{
			o0_n = (ui32) o1_n->b0000;
			goto l00012104;
		}
		int32 o0_n = (int32) o1_n->b0001;
		if (o0_n != 0x00)
		{
			if (o0_n == 0x2F)
			{
				o1_n = (struct Eq_n *) &o1_n->b0002;
				goto l00012110;
			}
			if (o0_n == 0x2E)
			{
				int32 o0_n = (int32) o1_n->b0002;
				if (o0_n == 0x00 || o0_n == 0x2F)
				{
					struct Eq_n * o0_n;
					if (o0_n == 0x2F)
						o0_n = o1_n + 1;
					else
						o0_n = (struct Eq_n *) &o1_n->b0002;
					Eq_n o2_n = (word32) o2_n - 2;
					o1_n = o0_n;
					while (o2_n - (sp_n + 0x60) >=u 0x00 && (int32) (*o2_n) != 0x2F)
						o2_n += ~0x00;
					if (o2_n - (sp_n + 0x60) <u 0x00)
					{
						word32 i6_n;
						word32 i1_n;
						word32 i2_n;
						notice(0x00017148, out i1_n, out i2_n, out i6_n);
						exit(33);
					}
					o2_n = o2_n + 0x01;
					*o2_n = 0x00;
l00012110:
					int32 o0_n = (int32) o1_n->b0000;
					if (o0_n == 0x00)
						goto l00012120;
					v27_n = o0_n != 0x2F;
					goto l00012024;
				}
				o0_n = (ui32) o1_n->b0000;
			}
			else
				o0_n = (ui32) o1_n->b0000;
l00012104:
			*o2_n = (byte) o0_n;
			o1_n = (struct Eq_n *) &o1_n->b0001;
			o2_n = (word32) o2_n + 1;
			goto l00012110;
		}
	}
l00012120:
	if ((int32) *((word32) o2_n - 1) == 0x2F)
	{
		*o2_n = 0x00;
		o2_n = (word32) o2_n - 1;
		*o2_n = 0x00;
	}
	else
		*o2_n = 0x00;
	word32 i1_n;
	struct Eq_n * i6_n;
	word32 l0_n;
	word32 i0_n;
	savestring(sp_n + 0x60, o2_n - (sp_n + 0x60), out l0_n, out i0_n, out i1_n, out i6_n);
	i6Out = i6_n;
	return l0_n;
}

// 0001214C: Register Eq_n shortpath(Register Eq_n o0, Register Eq_n o1, Register out Eq_n l0Out, Register out (ptr32 Eq_n) l2Out, Register out Eq_n l3Out, Register out Eq_n l4Out, Register out Eq_n i0Out)
// Called from:
//      safe_write
//      find_file
//      gen_aux_info_file
//      process_aux_info_file
//      declare_source_confusing
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
//      edit_file
//      main
Eq_n shortpath(Eq_n o0, Eq_n o1, union Eq_n & l0Out, struct Eq_n & l2Out, union Eq_n & l3Out, union Eq_n & l4Out, union Eq_n & i0Out)
{
	Eq_n o0_n = (uint32) strlen(o1);
	word32 i6_n;
	Eq_n l0_n = abspath(o0, o1, out i6_n);
	Eq_n i1_n;
	word32 i6_n;
	word32 i2_n;
	Eq_n i0_n = xmalloc(o0_n, out i1_n, out i2_n, out i6_n);
	struct Eq_n * l2_n = null;
	int32 o1_n = (int32) *l0_n;
	while (true)
	{
		int32 o0_n;
		if (o1_n == 0x00)
			break;
		if (o1_n - (int32) (*i0_n) != 0x00)
		{
			o0_n = (int32) *l0_n;
			goto l000121B8;
		}
		l0_n = (word32) l0_n + 1;
		o1_n = (int32) *l0_n;
		i0_n = (word32) i0_n + 1;
	}
	o0_n = (int32) *l0_n;
l000121B8:
	Eq_n i0_n;
	bool v31_n;
	if (o0_n == 0x00)
	{
		ui32 o1_n = (ui32) *i0_n;
		int32 o0_n = (int32) (byte) o1_n;
		if (o0_n == 0x00 || o0_n == 0x2F)
		{
			if (o0_n == 0x00)
				i0_n.u0 = 0x00017168;
			else
				i0_n = (word32) i0_n + 1;
			goto l000122FC;
		}
		v31_n = o1_n == 0x00;
	}
	else
	{
		ui32 o1_n = (ui32) *i0_n;
		v31_n = o1_n == 0x00;
	}
	int32 o0_n;
	if (!v31_n)
	{
		while (true)
		{
			l0_n = (word32) l0_n - 1;
			if ((int32) *l0_n == 0x2F)
				break;
			i0_n = (word32) i0_n - 1;
		}
		ptr32 i0_n = (word32) i0_n - 1;
		l0_n = (word32) l0_n + 1;
		i0_n = i0_n + 0x01;
		l2_n = (struct Eq_n *) 0x01;
l00012238:
		o0_n = (int32) *l0_n;
	}
	else
		o0_n = (int32) *l0_n;
	Eq_n l1_n = o0_n;
	Mem134 = Mem0;
	if (o0_n == 0x00)
	{
		l0_n = l2_n * 0x03 + (uint32) strlen(i0_n);
		if (l0_n - o0_n >= 0x00)
		{
			l2_n = (struct Eq_n *) ((char *) l2_n - 1);
			goto l00012268;
		}
		l2_n = (struct Eq_n *) ((char *) l2_n - 1 + -1);
		if (l2_n != (struct Eq_n *) ~0x00)
		{
			while (o0_n * 0x02 - (l1_n + 0x03) >u 0x00)
			{
				l2_n = (struct Eq_n *) ((char *) l2_n - 1);
				*l1_n = 0x2E;
				struct Eq_n * l1_n = (word32) l1_n + 1;
				l1_n->b0000 = 0x2E;
				l1_n->b0001 = 0x2F;
				if (l2_n == null)
				{
					l1_n = &l1_n->b0001 + 1;
					goto l000122B8;
				}
				l1_n = &l1_n->b0001 + 1;
			}
			l2_n = l2_n;
l00012268:
			i0_n = i1_n;
			goto l000122FC;
		}
l000122B8:
		while (o0_n * 0x02 - l1_n > 0x00)
		{
			ui32 o0_n = (ui32) *i0_n;
			*l1_n = (byte) o0_n;
			i0_n = (word32) i0_n + 1;
			if (o0_n << 0x18 == 0x00)
			{
				word32 l1_n = l1_n + 0x01;
				if ((int32) l1_n->bFFFFFFFE == 0x2F)
					l1_n->bFFFFFFFE = 0x00;
				i0_n = o0_n;
				goto l000122FC;
			}
			++l1_n;
		}
		i0_n = i1_n;
l000122FC:
		l0Out = l0_n;
		l2Out = l2_n;
		l3Out = o0_n;
		l4Out = o0_n;
		i0Out = i0_n;
		return i0_n;
	}
	ui32 o1_n = (ui32) *l0_n;
	if (o1_n == 0x2F)
	{
		l0_n = (word32) l0_n + 1;
		l2_n = (struct Eq_n *) ((char *) l2_n + 1);
	}
	else
		l0_n = (word32) l0_n + 1;
	goto l00012238;
}

// 00012304: Register Eq_n find_file(Register Eq_n o0, Register out (ptr32 char) l2Out, Register out ptr32 l3Out, Register out Eq_n i0Out, Register out ptr32 i1Out)
// Called from:
//      referenced_file_is_newer
//      save_def_or_dec
Eq_n find_file(Eq_n o0, char & l2Out, ptr32 & l3Out, union Eq_n & i0Out, ptr32 & i1Out)
{
	Eq_n l1_n;
	ptr32 i1_n;
	struct Eq_n * o0_n = lookup(164416, o0, out l1_n, out i1_n);
	Eq_n i0_n = o0_n->t0008;
	if (i0_n != 0x00)
	{
l000123C8:
		l2Out = l2;
		l3Out = l3;
		i0Out = i0_n;
		i1Out = i1_n;
		return i0_n;
	}
	Eq_n l4_n;
	word32 i2_n;
	struct Eq_n * i6_n;
	xmalloc(0x0C, out i1_n, out i2_n, out i6_n);
	if (i1_n != 0x00)
	{
		l4_n.u0 = 0x0C;
		i6_n->tFFFFFFA8.u0 = 0x00;
	}
	else
	{
		l4_n.u0 = 0x0C;
		if (stat(l1_n, (char *) i6_n - 0x0098) != ~0x00)
		{
			o0_n->t0008.u0 = 0x0C;
l000123B4:
			*l4_n.u0 = (char) o0_n;
			l4_n.u0[4] = (char) 0x00;
			l4_n.u0[8] = (char) i6_n->tFFFFFFA8;
			i0_n = l4_n;
			goto l000123C8;
		}
		Eq_n l0_n;
		word32 i0_n;
		shortpath(0x00, l1_n, out l0_n, out l2, out l3, out l4_n, out i0_n);
		xstrerror(l2);
		word32 i2_n;
		i6_n->tFFFFFFA8 = notice(l0_n, out i1_n, out i2_n, out i6_n);
	}
	o0_n->t0008 = l4_n;
	goto l000123B4;
}

// 000123D0: void aux_info_corrupted()
// Called from:
//      check_aux_info
void aux_info_corrupted()
{
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice(0x00017190, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000123F8: Register word32 check_aux_info(Register word32 o0, Register out ptr32 i1Out)
// Called from:
//      referenced_file_is_newer
//      save_def_or_dec
word32 check_aux_info(word32 o0, ptr32 & i1Out)
{
	if (o0 != 0x00)
	{
		i1Out = o1;
		return o0;
	}
	else
		aux_info_corrupted();
}

// 00012418: Register (ptr32 Eq_n) find_corresponding_lparen(Register (ptr32 Eq_n) o0)
// Called from:
//      save_def_or_dec
struct Eq_n * find_corresponding_lparen(struct Eq_n * o0)
{
	int8 * o0_n = &o0->bFFFFFFFF + -1;
	word32 g3_n = 0x01;
	int32 g2_n = (int32) o0->bFFFFFFFF;
l00012424:
	if (g2_n != 0x28)
	{
		int32 g0_n = g2_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = o0_n;
l00012448:
			if (g3_n == 0x00)
				return o0_n + 1;
			g2_n = (int32) *o0_n;
			goto l00012424;
		}
		++g3_n;
	}
	else
		g3_n += ~0x00;
	o0_n += -1;
	goto l00012448;
}

// 0001245C: void referenced_file_is_newer(Register (ptr32 int8) o0)
void referenced_file_is_newer(int8 * o0)
{
	int8 * l1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (*o0) ^ 0x2F) > 0x00), out i1_n)[1] ^ 0x2A) > 0x00), out i1_n)[2] ^ 0x20) > 0x00), out i1_n);
	if ((int32) i0_n[3] != 0x3A)
	{
		l1_n = (int8 *) (i0_n + 4);
		while ((int32) *l1_n != 0x3A)
			++l1_n;
	}
	else
		l1_n = (int8 *) (i0_n + 3);
	int32 l1_n = l1_n - (i0_n + 3);
	struct Eq_n * sp_n = fp + ~0x6F - (l1_n + 0x08 & ~0x07);
	strncpy(sp_n->a0060, i0_n + 3, l1_n);
	Eq_n o0_n = g_t28190;
	sp_n->a0060[l1_n] = 0x00;
	word32 i6_n;
	abspath(o0_n, sp_n->a0060, out i6_n);
	int32 i1_n;
	word32 l2_n;
	word32 l3_n;
	word32 i0_n;
	find_file(o0_n, out l2_n, out l3_n, out i0_n, out i1_n)->dw0008 - i1_n > 0x00;
}

// 0001251C: void save_def_or_dec()
void save_def_or_dec()
{
	word32 i2_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i6_n;
	struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (*xmalloc(44, out i1_n, out i2_n, out i6_n)) ^ 0x2F) > 0x00), out i1_n)[1] ^ 0x2A) > 0x00), out i1_n)[2] ^ 0x20) > 0x00), out i1_n);
	int8 * i0_n = i0_n + 3;
	if ((int32) i0_n[3] != 0x3A)
	{
		i0_n = (int8 *) (i0_n + 4);
		while ((int32) *i0_n != 0x3A)
			++i0_n;
	}
	Eq_n i0_n;
	int32 l1_n = i0_n - (i0_n + 3);
	struct Eq_n * sp_n = fp + ~0x7F - (l1_n + 0x08 & ~0x07);
	strncpy(sp_n->a0060, i0_n + 3, l1_n);
	Eq_n o0_n = g_t28190;
	sp_n->a0060[l1_n] = 0x00;
	word32 i6_n;
	abspath(o0_n, sp_n->a0060, out i6_n);
	word32 i1_n;
	Eq_n i0_n;
	struct Eq_n * l2_n;
	union Eq_n * l3_n;
	l2_n->ptr0004 = find_file(o0_n, out l2_n, out l3_n, out i0_n, out i1_n);
	if ((int32) *i0_n != 0x3A)
	{
		i0_n = (word32) i0_n + 1;
		while ((int32) *i0_n != 0x3A)
			i0_n = (word32) i0_n + 1;
	}
	else
		i0_n = i0_n;
	word32 o2_n;
	int32 l0_n = i0_n - i0_n;
	strncpy(l3_n, i0_n, l0_n);
	*((char *) l3_n + l0_n) = (union Eq_n *) 0x00;
	l2_n->dw0008 = atoi(l3_n);
	ui32 o1_n = (ui32) *((word32) i0_n + 1);
	if ((o1_n + ~0x4D & 0xFF) > 0x01)
	{
		o2_n = 0x00;
		if (o1_n != 0x49)
		{
l00012648:
			word32 o2_n;
			word32 i1_n;
			struct Eq_n * i0_n = check_aux_info(o2_n, out i1_n);
			l2_n->b0020 = (byte) (0x01 - (((int32) i0_n->b0000 ^ 0x4E) > 0x00));
			int32 o0_n = (int32) i0_n[1];
			if (o0_n != 0x43)
			{
				o2_n = 0x00;
				if (o0_n != 0x46)
				{
l00012688:
					word32 i1_n;
					struct Eq_n * i0_n = check_aux_info(o2_n, out i1_n);
					if ((int32) i0_n->b0000 != 0x46 && i1_n == 0x00)
						l2_n->dw0014 = 0x00;
					else
						l2_n->dw0014 = 0x01;
					word32 o0_n;
					word32 i1_n;
					word32 i1_n;
					word32 i1_n;
					word32 i1_n;
					struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) ((byte) ((ui32) (check_aux_info)(0x01 - (((int32) ((byte) ((ui32) (check_aux_info)(0x01 - (((int32) ((byte) ((ui32) (check_aux_info)(0x01 - (((int32) ((byte) ((ui32) i0_n[1])) ^ 0x20) > 0x00), out i1_n)[1])) ^ 0x2A) > 0x00), out i1_n)[1])) ^ 0x2F) > 0x00), out i1_n)[1])) ^ 0x20) > 0x00), out i1_n);
					if (strncmp(i0_n + 1, 94664, 0x06) != 0x00 && strncmp(i0_n + 1, 0x000171D0, 0x06) != 0x00)
						o0_n = 0x00;
					else
						o0_n = 0x01;
					word32 i1_n;
					int8 * i0_n = check_aux_info(o0_n, out i1_n) + 7;
					while ((int32) *i0_n != 0x3B)
						++i0_n;
					word32 i6_n;
					word32 i0_n;
					ui32 l0_n;
					l2_n->t000C = dupnstr(i0_n + 1, i0_n - i0_n, out l0_n, out i0_n, out i6_n);
					struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
					struct Eq_n * i0_n = i0_n + ~0x00;
					while (true)
					{
						int32 o0_n;
						if (i0_n - l0_n == 0x00)
							break;
						int32 o0_n = (int32) i0_n->bFFFFFFFF;
						if (o0_n != 0x20)
						{
							if (o0_n == 0x09)
							{
								i0_n = (struct Eq_n *) &i0_n->bFFFFFFFF;
								continue;
							}
							else
							{
								o0_n = (int32) i0_n->b0000;
								goto l000127E4;
							}
						}
						i0_n = (struct Eq_n *) &i0_n->bFFFFFFFF;
					}
					o0_n = (int32) i0_n->b0000;
l000127E4:
					if (o0_n != 0x29)
					{
l00012AC0:
						free_def_dec(l2_n);
					}
					l2_n->dw001C = 0x00;
					struct Eq_n * o0_n = find_corresponding_lparen(i0_n);
					++l2_n->dw001C;
					if ((int32) o0_n->bFFFFFFFE == 0x29)
					{
						word32 i1_n;
						check_aux_info(0x01 - (((int32) o0_n->bFFFFFFFD ^ 0x29) > 0x00), out i1_n);
					}
					word32 i1_n;
					struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) o0_n->bFFFFFFFF ^ 0x20) > 0x00), out i1_n);
					while (is_id_char((int32) i0_n->b0000) != 0x00)
						i0_n = (struct Eq_n *) ((char *) i0_n - 1);
					word32 o0_n;
					Eq_n i0_n = i0_n + 1;
					int32 l1_n = &o0_n->bFFFFFFFF - i0_n;
					struct Eq_n * sp_n = sp_n - (l1_n + 0x08 & ~0x07);
					strncpy(sp_n->a0060, i0_n, l1_n);
					sp_n->a0060[l1_n] = 0x00;
					word32 l1_n;
					struct Eq_n * i1_n;
					struct Eq_n * o0_n = lookup(0x00029A40, sp_n->a0060, out l1_n, out i1_n);
					l2_n->ptr0010 = o0_n;
					Eq_n o2_n = o0_n->t0008;
					if (o2_n != 0x00)
					{
						int32 o1_n = l2_n->dw0008;
						while (true)
						{
							if (o1_n - *((word32) o2_n + 8) == 0x00)
							{
								if (l2_n->ptr0004 - *((word32) o2_n + 4) == 0x00)
								{
									if (strcmp(l2_n->t000C, *((word32) o2_n + 0x0C)) != 0x00)
									{
										word32 i2_n;
										word32 i6_n;
										word32 i1_n;
										notice(0x000171D8, out i1_n, out i2_n, out i6_n);
										exit(33);
									}
									goto l00012AC0;
								}
								o2_n = *((word32) o2_n + 24);
							}
							else
								o2_n = *((word32) o2_n + 24);
							if (o2_n == 0x00)
								break;
							o1_n = l2_n->dw0008;
						}
						o0_n = l2_n->dw0014;
					}
					else
						o0_n = l2_n->dw0014;
					int32 o0_n;
					l2_n->t0024.u0 = 0x00;
					if (o0_n != 0x00)
					{
						l2_n->dw0028 = 0x00;
						ptr32 i0_n;
						word32 i1_n;
						word32 i1_n;
						word32 i1_n;
						word32 i1_n;
						word32 i1_n;
						struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) i1_n->b0001 ^ 0x20) > 0x00), out i1_n)[1] ^ 0x2F) > 0x00), out i1_n)[1] ^ 0x2A) > 0x00), out i1_n)[1] ^ 0x20) > 0x00), out i1_n)[1] ^ 0x28) > 0x00), out i1_n);
						if ((int32) i0_n[1] != 0x29)
						{
							int8 * i0_n = i0_n + 2;
							while ((int32) *i0_n != 0x29)
								++i0_n;
							i0_n = i0_n + 1;
						}
						else
							i0_n = i0_n + 2;
						word32 l0_n;
						struct Eq_n * i0_n;
						word32 i6_n;
						l2_n->t0024 = dupnstr(i0_n + 1, i0_n + ~0x00 - (i0_n + 1), out l0_n, out i0_n, out i6_n);
						word32 i1_n;
						struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) i0_n->b0001 ^ 0x20) > 0x00), out i1_n);
						if ((int32) i0_n[1] != 0x2A)
						{
							struct Eq_n * i0_n = i0_n + 2;
							while (true)
							{
								while ((int32) i0_n->b0000 != 0x2A)
									++i0_n;
								if ((int32) i0_n[1] == 0x2F)
									break;
								++i0_n;
							}
							word32 i0_n;
							word32 i6_n;
							word32 i1_n;
							word32 l0_n;
							dupnstr(i0_n + 1, check_aux_info(0x01 - (((int32) i0_n->bFFFFFFFF ^ 0x20) > 0x00), out i1_n) - (i0_n + 1), out l0_n, out i0_n, out i6_n);
						}
						word32 i1_n;
						check_aux_info(0x01 - (((int32) i0_n[2] ^ 0x2F) > 0x00), out i1_n);
						l2_n->dw0028 = 94744;
						if ((int32) l2_n->b0020 != 0x00)
							return;
						if ((int32) *l2_n->t0024 != 0x00)
						{
							o0_n = (int32) l2_n->b0020;
l00012AB4:
							if (o0_n != 0x00)
								return;
							goto l00012AC0;
						}
						l2_n->b0020 = 0x01;
					}
					else
						l2_n->dw0028 = 0x00;
					o0_n = (int32) l2_n->b0020;
					goto l00012AB4;
				}
			}
			o2_n = 0x01;
			goto l00012688;
		}
	}
	o2_n = 0x01;
	goto l00012648;
}

// 00012B64: Register Eq_n munge_compile_params(Register Eq_n o0, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
//      main
Eq_n munge_compile_params(Eq_n o0, ptr32 & i6Out)
{
	struct Eq_n * sp_n = fp + ~0x6F - (((uint32) strlen(o0) << 0x02) + 0x27 & ~0x07);
	sp_n->a0060[0] = compiler_file_name;
	Eq_n i0_n = o0;
	ptr32 i6_n = fp;
	ui32 l0_n = 0x01;
	do
	{
		ui32 o3_n;
		int32 g2_n = l0_n << 0x02;
		if (((ui32) g_a2B411[(ui32) *i0_n] & 0x08) != 0x00)
		{
			o3_n = l0_n + 0x01;
			i0_n = (word32) i0_n + 1;
			while (((ui32) g_a2B411[(ui32) *i0_n] & 0x08) != 0x00)
				i0_n = (word32) i0_n + 1;
		}
		else
			o3_n = l0_n + 0x01;
		if ((int32) *i0_n == 0x00)
			goto l00012D00;
		struct Eq_n * o1_n = (ui32) *i0_n;
		Eq_n i0_n;
		if (((ui32) o1_n->b2B411 & 0x08) == 0x00)
		{
			i0_n = (word32) i0_n + 1;
			while ((int32) *i0_n != 0x00)
			{
				struct Eq_n * o1_n = (ui32) *i0_n;
				if (((ui32) o1_n->b2B411 & 0x08) != 0x00)
					break;
				i0_n = (word32) i0_n + 1;
			}
		}
		else
			i0_n = i0_n;
		if ((int32) *i0_n == 0x2D && (int32) ((byte) ((ui32) (*((word32) i0_n + 1)) + ~0x4E)) < 0x20)
		{
			i6Out = i6_n;
			return i0_n;
		}
		ui32 l0_n;
		sp_n->a0060[l0_n] = (word32) dupnstr(i0_n, i0_n - i0_n, out l0_n, out i0_n, out i6_n);
		l0_n = l0_n + 0x01;
		g2_n = l0_n + 0x01 << 0x02;
	} while ((int32) *i0_n != 0x00);
	o3_n = l0_n + 0x02;
l00012D00:
	aux_info_file_name_index = o3_n;
	sp_n->a0060[g2_n / 4] = 0x00017220;
	ui32 l0_n = o3_n + 0x01;
	input_file_name_index = l0_n + 0x03;
	sp_n->a0060[o3_n] = 0x00;
	sp_n->a0060[l0_n] = 0x00017230;
	sp_n->a0060[l0_n + 0x01] = 94776;
	sp_n->a0060[l0_n + 0x02] = 94784;
	sp_n->a0060[l0_n + 0x03] = 0x00;
	sp_n->a0060[l0_n + 0x04] = 0x00;
	Eq_n o0_n = l0_n + 0x06 << 0x02;
	ptr32 i6_n;
	word32 i2_n;
	word32 i1_n;
	Eq_n i0_n = xmalloc(o0_n, out i1_n, out i2_n, out i6_n);
	compile_params = o0_n;
	memcpy(o0_n, sp_n->a0060, l0_n + 0x05 << 0x02);
	i6Out = i6_n;
	return i0_n;
}

// 00012E2C: Register Eq_n gen_aux_info_file(Register Eq_n o0, Register out ptr32 l0Out, Register out (ptr32 Eq_n) l1Out, Register out (ptr32 char) l4Out, Register out Eq_n i0Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
// Called from:
//      process_aux_info_file
Eq_n gen_aux_info_file(Eq_n o0, ptr32 & l0Out, struct stat & l1Out, char & l4Out, union Eq_n & i0Out, ptr32 & i2Out, ptr32 & i6Out)
{
	Eq_n o1_n;
	if (input_file_name_index == 0x00)
	{
		word32 i6_n;
		o1_n = munge_compile_params(94744, out i6_n);
	}
	else
		o1_n = o0;
	struct Eq_n * l2_n;
	char * l4_n;
	word32 l0_n;
	word32 l3_n;
	word32 i0_n;
	Eq_n o0_n = shortpath(0x00, o1_n, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
	*((word32) compile_params + l2_n->dw0344 * 0x04) = o0_n;
	word32 o0_n = savestring2(o0_n, (uint32) strlen(o0_n), 0x02);
	word32 o1_n = quiet_flag;
	*((word32) compile_params + aux_info_file_name_index * 0x04) = o0_n;
	if (o1_n != 0x00)
	{
		struct Eq_n * i0_n;
		word32 i6_n;
		Eq_n l1_n;
		word32 o0_n = choose_temp_base(out l1_n, out i0_n, out i6_n);
		pid_t * o1_n = i0_n->ptr033C;
		struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
		Eq_n o0_n = *o1_n;
		sp_n->dw005C = 0x07;
		struct Eq_n * i6_n;
		struct Eq_n * l0_n;
		if (pexecute(o0_n, o1_n, o0_n, i6_n + ~0x13, i6_n + ~0x17, l1_n, sp_n->dw005C, out l0_n, out i6_n) != ~0x00)
		{
			word32 i2_n;
			word32 i6_n;
			pwait((char *) i6_n - 28, out i2_n, out i6_n);
		}
		else
		{
			char * l2_n = errno;
			fprintf(&g_t2B640, "%s: ", l0_n->ptr0150);
			fprintf(&g_t2B640, i6_n->ptrFFFFFFEC, 0x00);
			xstrerror(l2_n);
			fprintf(&g_t2B640, ": %s\n", l2_n);
			ptr32 i2_n;
			ptr32 i6_n;
			Eq_n i0_n = pwait(g_str17270, out i2_n, out i6_n);
			l0Out = 0x00017270;
			l1Out = (struct stat *) &g_t2B640;
			l4Out = l4_n;
			i0Out = i0_n;
			i2Out = i2_n;
			i6Out = i6_n;
			return i0_n;
		}
	}
	else
	{
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(94800, out i1_n, out i2_n, out i6_n);
	}
}

// 00013034: Register Eq_n process_aux_info_file(Register Eq_n o0, Register word32 o2, Register out Eq_n l1Out)
// Called from:
//      do_processing
Eq_n process_aux_info_file(Eq_n o0, word32 o2, union Eq_n & l1Out)
{
	ptr32 sp_n = (char *) fp - 0x00F8 - ((uint32) strlen(o0) + 0x0A & ~0x07);
	strcpy(sp_n + 0x60, o0);
	strcat(sp_n + 0x60, 0x00016F00);
	Eq_n i0_n = o0;
	word32 i2_n = o2;
	struct Eq_n * i6_n = fp;
	Eq_n l4_n = sp_n + 0x60;
	word32 l2_n = 0x00;
	while (true)
	{
		Eq_n o0_n;
		bool v34_n;
		if (access(l4_n, 0x04) == ~0x00)
		{
			if (errno != (char *) 0x02)
			{
				Eq_n l0_n;
				char * l3_n;
				word32 l4_n;
				word32 i0_n;
				word32 l2_n;
				shortpath(0x00, l4_n, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
				xstrerror(l3_n);
				o0_n = l0_n;
				goto l000131F0;
			}
			if (i2_n != 0x00)
			{
				word32 i1_n;
				i0_n = notice(94928, out i1_n, out i2_n, out i6_n);
				goto l000135B8;
			}
			v34_n = false;
		}
		else
			v34_n = l2_n == 0x00;
		Eq_n o1_n;
		if (!v34_n)
		{
			if (gen_aux_info_file(i0_n, out l0, out l1, out l4_n, out i0_n, out i2_n, out i6_n) == 0x00)
			{
				++errors;
				goto l000135B8;
			}
			if (access(l4_n, 0x04) == ~0x00)
			{
				o1_n = l4_n;
				goto l000131D0;
			}
			l1 = (char *) i6_n - 0x0098;
		}
		else
			l1 = (char *) i6_n - 0x0098;
		if (stat(l4_n, l1) == ~0x00)
		{
			o1_n = l4_n;
			goto l000131D0;
		}
		l0 = i6_n->tFFFFFF98;
		if (l0 == 0x00)
			break;
		if (i2_n != 0x00)
		{
l00013218:
			Eq_n o0_n = open(l4_n, 0x00);
			if (o0_n == ~0x00)
			{
				Eq_n l0_n;
				char * l2_n;
				word32 l4_n;
				word32 l3_n;
				word32 i0_n;
				shortpath(0x00, l4_n, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
				xstrerror(l2_n);
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				notice(l0_n, out i1_n, out i2_n, out i6_n);
			}
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			xmalloc(l0 + 0x01, out i1_n, out i2_n, out i6_n);
			Mem231[l0 + 0x01 + l0:byte] = 0x00;
			word32 l2_n;
			l0 = safe_read(o0_n, l0 + 0x01, l0, out l1, out l2_n);
			if (o0_n - l0 != 0x00 || close(o0_n) != 0x00)
			{
				char * l2_n;
				word32 l3_n;
				word32 l4_n;
				word32 i0_n;
				l1 = shortpath(0x00, l4_n, out l0, out l2_n, out l3_n, out l4_n, out i0_n);
				xstrerror(l2_n);
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				notice(l0, out i1_n, out i2_n, out i6_n);
				free(l0 + 0x01);
				close(o0_n);
			}
			break;
		}
		int32 l7_n = i6_n->dwFFFFFFA8;
		if (stat(i0_n, l1) == ~0x00)
		{
			o1_n = i0_n;
l000131D0:
			Eq_n l0_n;
			char * l2_n;
			word32 l3_n;
			word32 l4_n;
			word32 i0_n;
			shortpath(0x00, o1_n, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
			xstrerror(l2_n);
			o0_n = l0_n;
l000131F0:
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(o0_n, out i1_n, out i2_n, out i6_n);
		}
		int32 o0_n = i6_n->dwFFFFFFA8;
		if (o0_n - l7_n <= 0x00)
			goto l00013218;
		l2_n = 0x01;
	}
l000135B8:
	l1Out = l1;
	return l0;
}

// 000135C0: void reverse_def_dec_list(Register (ptr32 Eq_n) o0)
// Called from:
//      visit_each_hash_node
void reverse_def_dec_list(struct Eq_n * o0)
{
	struct Eq_n * o1_n = o0->ptr0008;
	struct Eq_n * g3_n = o1_n->ptr0004;
	if (g3_n != null)
	{
		struct Eq_n * o0_n = g3_n;
		struct Eq_n * g3_n = g3_n->ptr0000;
		if (g3_n != null)
		{
			g3_n->ptr0000 = null;
			struct Eq_n * g2_n = g3_n->ptr0000;
			while (true)
			{
				g3_n->ptr0000 = o0_n;
				o0_n = g3_n;
				g3_n = g2_n;
				if (g2_n == null)
					break;
				g2_n = g2_n->ptr0000;
			}
			o1_n->ptr0004 = g3_n;
		}
	}
}

// 0001360C: Register Eq_n identify_lineno(Register Eq_n o0)
// Called from:
//      declare_source_confusing
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
Eq_n identify_lineno(Eq_n o0)
{
	Eq_n o0_n;
	Eq_n g3_n = g_t281C0;
	if (g3_n - o0 < 0x00)
	{
		o0_n.u0 = 0x01;
		int32 g2_n = (int32) *g3_n;
		while (true)
		{
			if (g2_n == 0x0A)
				++o0_n.u0;
			g3_n = (word32) g3_n + 1;
			if (g3_n - o0 > 0x00)
				break;
			g2_n = (int32) *g3_n;
		}
	}
	else
		o0_n.u0 = (char *) 0x01;
	return o0_n;
}

// 0001364C: void declare_source_confusing(Register Eq_n o0)
// Called from:
//      check_source
void declare_source_confusing(Eq_n o0)
{
	if (quiet_flag == 0x00)
	{
		if (o0 == 0x00)
		{
			Eq_n l0_n;
			word32 l2_n;
			word32 l3_n;
			word32 l4_n;
			word32 i0_n;
			shortpath(0x00, g_t28180, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, out i1_n, out i2_n, out i6_n);
		}
		else
		{
			Eq_n i0_n;
			Eq_n l0_n;
			word32 l2_n;
			word32 l3_n;
			word32 l4_n;
			shortpath(0x00, g_t28180, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
			identify_lineno(i0_n);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, out i1_n, out i2_n, out i6_n);
		}
	}
	longjmp(0x0002B240, 0x01);
}

// 000136E0: Register Eq_n check_source(Register Eq_n o0, Register Eq_n o1, Register out Eq_n i1Out, Register out (ptr32 Eq_n) i2Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      seek_to_line
//      forward_to_next_token_char
//      edit_formals_lists
//      find_rightmost_formals_list
//      careful_find_l_paren
//      scan_for_missed_items
Eq_n check_source(Eq_n o0, Eq_n o1, union Eq_n & i1Out, struct Eq_n & i2Out, struct Eq_n & i6Out)
{
	if (o0 != 0x00)
	{
		i1Out = o1;
		i2Out = o2;
		i6Out = fp;
		return o0;
	}
	else
		declare_source_confusing(o1);
}

// 00013700: void seek_to_line(Register Eq_n o0)
void seek_to_line(Eq_n o0)
{
	Eq_n i0_n = o0;
	int32 g0_n = o0 - g_dw28230;
	if (g0_n >= 0x00)
	{
		if (g0_n > 0x00)
		{
			while (true)
			{
				int32 o1_n;
				int8 * o0_n = g_ptr28220;
				if ((int32) *o0_n != 0x0A)
				{
					int8 * o2_n = g_ptr28220;
					while (true)
					{
						int8 * o2_n = o2_n + 1;
						Eq_n C_n = (bool) cond(o2_n - g_dw281D0);
						g_ptr28220 = o2_n;
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						i0_n = check_source(C_n, 0x00, out i1_n, out i2_n, out i6_n);
						if ((int32) *g_ptr28220 == 0x0A)
							break;
						o2_n = g_ptr28220;
					}
					o0_n = g_ptr28220;
					o1_n = g_dw28230;
				}
				else
					o1_n = g_dw28230;
				g_ptr28220 = o0_n + 1;
				int32 o1_n = o1_n + 0x01;
				if (i0_n - o1_n <= 0x00)
					break;
				g_dw28230 = o1_n;
			}
			g_dw28230 = o1_n;
		}
	}
	else
		abort();
}

// 000137AC: Register Eq_n forward_to_next_token_char(Register Eq_n o0)
// Called from:
//      find_rightmost_formals_list
Eq_n forward_to_next_token_char(Eq_n o0)
{
	Eq_n i0_n = (word32) o0 + 1;
	if (((ui32) g_a2B411[(ui32) *((word32) o0 + 1)] & 0x08) != 0x00)
	{
		up32 o0_n = g_dw281D0;
		while (true)
		{
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			i0_n = check_source((bool) cond((word32) i0_n + 1 - o0_n), 0x00, out i1_n, out i2_n, out i6_n);
			if (((ui32) g_a2B411[(ui32) *i0_n] & 0x08) == 0x00)
				break;
			o0_n = g_dw281D0;
		}
	}
	return i0_n;
}

// 00013808: Register up32 output_bytes(Register Eq_n o0, Register Eq_n o1, Register out ptr32 l1Out, Register out ptr32 l2Out, Register out Eq_n i0Out, Register out Eq_n i1Out, Register out ptr32 i2Out)
// Called from:
//      output_string
//      output_up_to
up32 output_bytes(Eq_n o0, Eq_n o1, ptr32 & l1Out, ptr32 & l2Out, union Eq_n & i0Out, union Eq_n & i1Out, ptr32 & i2Out)
{
	up32 l0_n = g_dw28200;
	Eq_n i0_n = o0;
	Eq_n i1_n = o1;
	ptr32 i2_n = o2;
	if (g_dw28210 + ((word32) o1 + 1) - l0_n >= 0x00)
	{
		Eq_n o0_n = g_t281F0;
		uint32 l0_n = l0_n - o0_n;
		i0_n = xrealloc(o0_n, l0_n << 0x01, out i1_n, out i2_n);
		up32 o1_n = g_dw28210;
		l0_n = (word32) o0_n + (l0_n << 0x01);
		Eq_n o2_n = g_t281F0;
		g_dw28200 = l0_n;
		g_dw28210 = (word32) o0_n + (o1_n - o2_n);
		g_t281F0 = o0_n;
	}
	memcpy(g_dw28210 + 0x01, i0_n, i1_n);
	g_dw28210 = (word32) i1_n + g_dw28210;
	l1Out = 0x00028000;
	l2Out = 0x00028000;
	i0Out = i0_n;
	i1Out = i1_n;
	i2Out = i2_n;
	return l0_n;
}

// 0001388C: Register word32 output_string(Register Eq_n o0, Register out (ptr32 Eq_n) l2Out, Register out ptr32 i0Out, Register out ptr32 i1Out, Register out (ptr32 Eq_n) i2Out)
// Called from:
//      edit_formals_lists
word32 output_string(Eq_n o0, struct Eq_n & l2Out, ptr32 & i0Out, ptr32 & i1Out, struct Eq_n & i2Out)
{
	ptr32 i0_n;
	ptr32 i1_n;
	struct Eq_n * i2_n;
	word32 l1_n;
	struct Eq_n * l2_n;
	output_bytes(o0, (uint32) strlen(o0), out l1_n, out l2_n, out i0_n, out i1_n, out i2_n);
	l2Out = l2_n;
	i0Out = i0_n;
	i1Out = i1_n;
	i2Out = i2_n;
	return l1_n;
}

// 000138AC: Register word32 output_up_to(Register Eq_n o0, Register out ptr32 l2Out, Register out Eq_n i0Out, Register out ptr32 i1Out, Register out ptr32 i2Out)
// Called from:
//      edit_formals_lists
//      edit_fn_definition
word32 output_up_to(Eq_n o0, ptr32 & l2Out, union Eq_n & i0Out, ptr32 & i1Out, ptr32 & i2Out)
{
	ui32 o2_n = g_dw281E0;
	Eq_n i0_n = o0;
	ptr32 i1_n = o1;
	ptr32 i2_n = o2;
	word32 o0_n = g_dw281A0 + (o2_n - g_t281C0);
	Eq_n o1_n = o0 - o2_n;
	if (o1_n != 0x00)
		output_bytes(o0_n + 0x01, o1_n, out l1, out l2, out i0_n, out i1_n, out i2_n)->t01E0 = i0_n;
	l2Out = l2;
	i0Out = i0_n;
	i1Out = i1_n;
	i2Out = i2_n;
	return l1;
}

// 000138F0: Register Eq_n other_variable_style_function(Register Eq_n o0, Register out ptr32 i1Out, Register out ptr32 i6Out)
// Called from:
//      edit_fn_definition
Eq_n other_variable_style_function(Eq_n o0, ptr32 & i1Out, ptr32 & i6Out)
{
	Eq_n o0_n = (bool) cond(0x00 - substr(o0, &g_b17468));
	i1Out = o1;
	i6Out = fp;
	return o0_n;
}

// 00013914: void edit_fn_declaration(Register (ptr32 Eq_n) o0)
void edit_fn_declaration(struct Eq_n * o0)
{
	o0_n = (uint32) strlen(o0->ptr0010->t0004);
	save_pointers();
	if (setjmp(0x0002B240) != 0x00)
	{
		restore_pointers();
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(0x00017470, out i1_n, out i2_n, out i6_n);
	}
}

// 00013B68: Register Eq_n edit_formals_lists(Register Eq_n o0, Register out Eq_n l1Out, Register out Eq_n l2Out, Register out ptr32 i1Out, Register out (ptr32 Eq_n) i2Out)
// Called from:
//      edit_formals_lists
Eq_n edit_formals_lists(Eq_n o0, union Eq_n & l1Out, union Eq_n & l2Out, ptr32 & i1Out, struct Eq_n & i2Out)
{
	int8 * l1_n = (word32) o0 - 1 + ~0x00;
	word32 l0_n = 0x01;
	Eq_n l2_n = 0x00028000;
	int32 o0_n = (int32) *((word32) o0 - 1);
l00013B7C:
	ui32 o0_n;
	if (o0_n != 0x28)
	{
		int32 g0_n = o0_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = g_dw281E0;
			l1_n = l1_n;
			goto l00013BAC;
		}
		++l0_n;
	}
	else
		l0_n += ~0x00;
	o0_n = g_dw281E0;
	l1_n += -1;
l00013BAC:
	word32 i1_n;
	word32 i6_n;
	struct Eq_n * i2_n;
	check_source((bool) cond(o0_n - l1_n), 0x00, out i1_n, out i2_n, out i6_n);
	if (l0_n == 0x00)
	{
		ptr32 i1_n;
		Eq_n i0_n;
		bool v33_n;
		Eq_n l1_n;
		if (i1_n != ~0x00)
		{
			struct Eq_n * l1_n = l1_n + 1;
			int32 o0_n;
			word32 i6_n;
			word32 i1_n;
			word32 i2_n;
			check_source((bool) cond(g_dw281E0 - &l1_n->bFFFFFFFF), 0x00, out i1_n, out i2_n, out i6_n);
			Eq_n l0_n = &l1_n->bFFFFFFFF;
			if (((ui32) g_a2B411[(ui32) l1_n->bFFFFFFFF] & 0x08) != 0x00)
			{
				ui32 o0_n = g_dw281E0;
				while (true)
				{
					l0_n = (word32) l0_n - 1;
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					check_source((bool) cond(o0_n - l0_n), 0x00, out i1_n, out i2_n, out i6_n);
					if (((ui32) g_a2B411[(ui32) *l0_n] & 0x08) == 0x00)
						break;
					o0_n = g_dw281E0;
				}
				o0_n = (int32) *l0_n;
			}
			else
				o0_n = (int32) l1_n->bFFFFFFFF;
			word32 i6_n;
			word32 i2_n;
			word32 i1_n;
			check_source(0x01 - ((o0_n ^ 0x29) > 0x00), l0_n, out i1_n, out i2_n, out i6_n);
			Eq_n l0_n = (word32) l0_n - 1;
			word32 i6_n;
			word32 i2_n;
			word32 i1_n;
			check_source((bool) cond(g_dw281E0 - l0_n), 0x00, out i1_n, out i2_n, out i6_n);
			word32 i2_n;
			word32 i1_n;
			word32 i6_n;
			check_source(0x01 - (((int32) (*l0_n) ^ 0x29) > 0x00), l0_n, out i1_n, out i2_n, out i6_n);
			if (edit_formals_lists(l0_n, out l1_n, out l2_n, out i1_n, out i2_n) != 0x00)
			{
				i0_n.u0 = 0x01;
				goto l00013DFC;
			}
			v33_n = i1_n != 0x00;
		}
		else
		{
			l1_n = l1_n + 1;
			v33_n = i1_n != ~0x00;
		}
		if (!v33_n)
		{
			Eq_n l5_n;
			struct Eq_n * o1_n = i2_n->ptr0010;
			int8 * l0_n = (word32) l1_n - 1;
			if (((ui32) g_a2B411[(ui32) *((word32) l1_n - 1)] & 0x08) != 0x00)
			{
				l5_n = o1_n->t0004;
				ui32 o0_n = *((word32) l2_n + 480);
				while (true)
				{
					l0_n += -1;
					word32 i1_n;
					word32 i6_n;
					check_source((bool) cond(o0_n - l0_n), 0x00, out i1_n, out i2_n, out i6_n);
					if (((ui32) g_a2B411[(ui32) *l0_n] & 0x08) == 0x00)
						break;
					o0_n = (ui32) *((word32) l2_n + 480);
				}
			}
			else
				l5_n = o1_n->t0004;
			int8 * l3_n = l0_n;
			Eq_n l0_n = l0_n + 1;
			while (is_id_char((int32) *l3_n) != 0x00)
			{
				ui32 o0_n = *((word32) l2_n + 480);
				word32 i1_n;
				word32 i6_n;
				check_source((bool) cond(o0_n - l3_n), 0x00, out i1_n, out i2_n, out i6_n);
				l3_n += -1;
			}
			Eq_n l3_n = l3_n + 1;
			Eq_n l4_n = l0_n - l3_n;
			if (l4_n == 0x00)
			{
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				check_source(0x00, l3_n, out i1_n, out i2_n, out i6_n);
			}
			struct Eq_n ** o0_n;
			if (l4_n - (uint32) strlen(l5_n) != 0x00)
			{
				o0_n = i2_n->ptr0004;
				goto l00013D80;
			}
			if (strncmp(l3_n, l5_n, l4_n) != 0x00)
			{
				o0_n = i2_n->ptr0004;
l00013D80:
				Eq_n l3_n;
				struct Eq_n * l4_n;
				word32 l0_n;
				word32 l2_n;
				word32 i0_n;
				l2_n = shortpath(0x00, *((char *) *o0_n + 4), out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
				l1_n = identify_lineno(l3_n);
				Eq_n l0_n;
				word32 i0_n;
				word32 i6_n;
				dupnstr(l3_n, l4_n, out l0_n, out i0_n, out i6_n);
				word32 i6_n;
				notice(l0_n, out i1_n, out i2_n, out i6_n);
				i0_n.u0 = 0x01;
				goto l00013DFC;
			}
		}
		ui32 o0_n;
		word32 i0_n;
		l1_n = output_up_to(l1_n, out l2_n, out i0_n, out i1_n, out i2_n);
		if (i1_n == 0x00)
		{
			word32 i0_n;
			l1_n = output_string(i2_n->t0024, out l2_n, out i0_n, out i1_n, out i2_n);
			o0_n = i0_n + ~0x00;
		}
		else
			o0_n = i0_n + ~0x00;
		*((word32) l2_n + 480) = o0_n;
		i0_n.u0 = 0x00;
l00013DFC:
		l1Out = l1_n;
		l2Out = l2_n;
		i1Out = i1_n;
		i2Out = i2_n;
		return i0_n;
	}
	o0_n = (int32) *l1_n;
	goto l00013B7C;
}

// 00013E04: Register word32 find_rightmost_formals_list(Register (ptr32 int8) o0)
// Called from:
//      edit_fn_definition
word32 find_rightmost_formals_list(int8 * o0)
{
	int8 * i0_n = o0 + -1;
	int32 o0_n = (int32) *o0;
	while (o0_n != 0x0A)
	{
		++i0_n;
		o0_n = (int32) *i0_n;
	}
	Eq_n i0_n = i0_n;
	if ((int32) *i0_n != 0x29)
	{
		struct Eq_n * o1_n = (ui32) *i0_n;
		while (true)
		{
			int32 o0_n;
			if (((ui32) o1_n->b2B411 & 0x08) != 0x00)
			{
				ui32 o0_n = g_dw281E0;
				while (true)
				{
					word32 i2_n;
					word32 i6_n;
					word32 i1_n;
					i0_n = check_source(SLICE(cond(o0_n - (i0_n + ~0x00)), bool, 0), 0x00, out i1_n, out i2_n, out i6_n);
					if (((ui32) g_a2B411[(ui32) *i0_n] & 0x08) == 0x00)
						break;
					o0_n = g_dw281E0;
				}
				o0_n = (int32) *i0_n;
			}
			else
			{
				word32 i2_n;
				word32 i1_n;
				word32 i6_n;
				i0_n = check_source(SLICE(cond(Mem0[0x000281E0:word32] - (i0_n + ~0x00)), bool, 0), 0x00, out i1_n, out i2_n, out i6_n);
				o0_n = (int32) *i0_n;
			}
			if (o0_n == 0x29)
				break;
			o1_n = (ui32) *i0_n;
		}
	}
	Eq_n o0_n = forward_to_next_token_char(i0_n);
	word32 i2_n;
	word32 i6_n;
	word32 i1_n;
	check_source(0x01 - (((int32) (*o0_n) ^ 0x7B) > 0x00), o0_n, out i1_n, out i2_n, out i6_n);
	return i6_n;
}

// 00013EDC: void edit_fn_definition(Register (ptr32 int8) o1)
void edit_fn_definition(int8 * o1)
{
	save_pointers();
	if (setjmp(0x0002B240) != 0x00)
	{
		restore_pointers();
		Eq_n i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(95440, out i1_n, out i2_n, out i6_n);
		word32 l2_n;
		word32 i0_n;
		word32 i1_n;
		word32 i2_n;
		output_up_to(i1_n, out l2_n, out i0_n, out i1_n, out i2_n);
	}
	else
	{
		Eq_n i1_n;
		struct Eq_n * i6_n;
		if (other_variable_style_function(find_rightmost_formals_list(o1)->ptr0044->t000C, out i1_n, out i6_n) != 0x00)
		{
			if (quiet_flag != 0x00)
			{
				word32 l2_n;
				word32 i0_n;
				word32 i1_n;
				word32 i2_n;
				output_up_to(i1_n, out l2_n, out i0_n, out i1_n, out i2_n);
			}
			else
			{
				struct Eq_n * o1_n = i6_n->ptr0044;
				Eq_n l0_n;
				word32 l2_n;
				word32 l3_n;
				word32 l4_n;
				word32 i0_n;
				shortpath(0x00, *((char *) *o1_n->ptr0004 + 4), out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
				identify_lineno(i1_n);
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				notice(l0_n, out i1_n, out i2_n, out i6_n);
			}
		}
	}
}

// 000140B4: void do_cleaning(Register (ptr32 byte) o0, Register up32 o1)
void do_cleaning(byte * o0, up32 o1)
{
	byte * i0_n = o0;
	if (o0 - o1 >= 0x00)
		return;
	ui32 o1_n = (ui32) *o0;
	while ((int32) (byte) (o1_n + ~0x07) >= 0x54)
	{
		++i0_n;
		if (i0_n - o1 >= 0x00)
			return;
		o1_n = (ui32) *i0_n;
	}
}

// 00014518: Register (ptr32 Eq_n) careful_find_l_paren(Register (ptr32 Eq_n) o0, Register out (ptr32 Eq_n) l1Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      scan_for_missed_items
struct Eq_n * careful_find_l_paren(struct Eq_n * o0, struct Eq_n & l1Out, struct Eq_n & i6Out)
{
	Eq_n i0_n = &o0->bFFFFFFFF;
	word32 l0_n = 0x01;
	int32 o0_n = (int32) o0->bFFFFFFFF;
l0001452C:
	Eq_n o0_n;
	if (o0_n != 0x28)
	{
		int32 g0_n = o0_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = g_t281C0;
l00014550:
			word32 i2_n;
			word32 i1_n;
			struct Eq_n * i6_n;
			i0_n = check_source(0x01 - (((word32) i0_n - 1) - o0_n < 0x00), 0x00, out i1_n, out i2_n, out i6_n);
			if (l0_n == 0x00)
			{
				l1Out = &g_t28000;
				i6Out = i6_n;
				return (word32) i0_n + 1;
			}
			o0_n = (int32) *i0_n;
			goto l0001452C;
		}
		++l0_n;
	}
	else
		l0_n += ~0x00;
	o0_n = g_t281C0;
	goto l00014550;
}

// 00014578: void scan_for_missed_items()
void scan_for_missed_items()
{
	Eq_n o1_n = g_t281C0;
	up32 o0_n = g_dw281D0;
	g_t28130 = (word32) o1_n - 1;
	struct Eq_n * i6_n = fp;
	if (o1_n - (o0_n + ~0x02) >= 0x00)
	{
		g_t28120 = o1_n;
		return;
	}
	g_t28120 = o1_n;
l000145B4:
	Eq_n o3_n = g_t28120;
	if ((int32) *o3_n == 0x29)
	{
		Eq_n l0_n;
		g_t28140 = o3_n;
		if (((ui32) g_a2B411[(ui32) *((word32) o3_n + 1)] & 0x08) != 0x00)
		{
			l0_n = (word32) o3_n + 1;
			Eq_n o0_n = i6_n->tFFFFFFEC;
			while (true)
			{
				l0_n = (word32) l0_n + 1;
				word32 i2_n;
				word32 i1_n;
				check_source((bool) cond(l0_n - o0_n), i6_n->tFFFFFFEC, out i1_n, out i2_n, out i6_n);
				if (((ui32) g_a2B411[(ui32) *l0_n] & 0x08) == 0x00)
					break;
				o0_n = i6_n->tFFFFFFEC;
			}
		}
		else
			l0_n = (word32) o3_n + 1;
		g_t28120 = (word32) l0_n - 1;
		struct Eq_n * o2_n = (ui32) *l0_n;
		if (((ui32) o2_n->b2B411 & 0x03) != 0x00 || o2_n == (struct Eq_n *) 0x7B)
		{
			i6_n->tFFFFFFE8 = identify_lineno(l0_n);
			if (setjmp(0x0002B240) != 0x00)
				goto l00014854;
			struct Eq_n * l1_n = &g_t28000;
			do
			{
				struct Eq_n * o0_n;
				struct Eq_n * o0_n = careful_find_l_paren(l1_n->ptr0140, out l1_n, out i6_n);
				l1_n->ptr0140 = (struct Eq_n *) &o0_n->bFFFFFFFF;
				struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
				if (((ui32) g_a2B411[(ui32) o0_n->bFFFFFFFF] & 0x08) != 0x00)
				{
					Eq_n i0_n = 0x00028000;
					Eq_n o2_n = g_t28140;
					while (true)
					{
						Eq_n o1_n = *((word32) i0_n + 304);
						Eq_n o2_n = (word32) o2_n - 1;
						g_t28140 = o2_n;
						word32 i2_n;
						word32 i1_n;
						i0_n = check_source(0x01 - (o2_n - o1_n < 0x00), o1_n, out i1_n, out i2_n, out i6_n);
						if (((ui32) g_a2B411[(ui32) *g_t28140] & 0x08) == 0x00)
							break;
						o2_n = g_t28140;
					}
					o0_n = l1_n->ptr0140;
				}
				else
					o0_n = l1_n->ptr0140;
			} while ((int32) o0_n->b0000 == 0x29);
			if (is_id_char((int32) *g_t28140) != 0x00)
			{
				Eq_n o0_n = g_t28140;
				if (is_id_char((int32) *o0_n) != 0x00)
				{
					Eq_n o1_n = g_t28130;
					word32 i6_n;
					word32 i2_n;
					word32 i1_n;
					check_source(0x01 - (((word32) o0_n - 1) - o1_n < 0x00), o1_n, out i1_n, out i2_n, out i6_n);
				}
				word32 l0_n = o0_n + 0x01 - (o0_n + 0x01);
				if (l0_n != 0x00)
				{
					Mem274[164144:word32] = o0_n + 0x01;
					struct Eq_n * sp_n = sp_n - (l0_n + 0x6B & ~0x07);
					strncpy(sp_n->a0060, o0_n + 0x01, l0_n);
					Eq_n o0_n = g_t1753C;
					sp_n->a0060[l0_n] = 0x00;
					if (o0_n == 0x00)
					{
l000147BC:
						struct Eq_n * o1_n;
						struct Eq_n * o1_n = i6_n->ptr0044->ptr0004;
						if (o1_n != null)
						{
							word32 o0_n = o1_n->dw0014;
							while (true)
							{
								if (o0_n != 0x00)
								{
									Eq_n o2_n = i6_n->tFFFFFFE8;
									if (o1_n->dw0008 - o2_n == 0x00)
										goto l00014854;
								}
								o1_n = o1_n->ptr0000;
								if (o1_n == null)
									break;
								o0_n = o1_n->dw0014;
							}
							o1_n = i6_n->ptr0044;
						}
						else
							o1_n = i6_n->ptr0044;
						word32 l4_n;
						Eq_n i0_n;
						Eq_n l0_n;
						word32 l3_n;
						word32 l2_n;
						shortpath(0x00, o1_n->ptr0000->t0004, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
						identify_lineno(i0_n);
						word32 i1_n;
						word32 i6_n;
						word32 i2_n;
						notice(l0_n, out i1_n, out i2_n, out i6_n);
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						notice(0x000175D8, out i1_n, out i2_n, out i6_n);
					}
					word32 * l0_n = &g_t1753C;
					Eq_n o1_n = g_t1753C;
					while (strcmp(sp_n->a0060, o1_n) != 0x00)
					{
						++l0_n;
						if (*l0_n == 0x00)
							goto l000147BC;
						o1_n = *l0_n;
					}
				}
				else
					Mem273[164144:word32] = o0_n + 0x01;
			}
			goto l00014854;
		}
	}
l00014854:
	Eq_n o0_n = g_t28120;
	if ((word32) o0_n + 1 - i6_n->tFFFFFFEC >= 0x00)
	{
		g_t28120 = (word32) o0_n + 1;
		return;
	}
	g_t28120 = (word32) o0_n + 1;
	goto l000145B4;
}

// 00014878: void edit_file(Register (ptr32 Eq_n) o0)
void edit_file(struct Eq_n * o0)
{
	struct Eq_n * i0_n = o0->ptr0008;
	if (needs_to_be_converted(i0_n) == 0x00)
		return;
	Eq_n o1_n = i0_n->ptr0000->t0004;
	g_t28180 = o1_n;
	if (directory_specified_p(o1_n) == 0x00 || file_excluded_p(g_t28180) != 0x00)
	{
		if (quiet_flag == 0x00 && in_system_include_dir(g_t28180) == 0x00)
		{
			Eq_n l0_n;
			word32 l4_n;
			word32 i0_n;
			word32 l3_n;
			word32 l2_n;
			shortpath(0x00, g_t28180, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, out i1_n, out i2_n, out i6_n);
		}
	}
}

// 00014E24: void do_processing()
// Called from:
//      main
void do_processing()
{
	Eq_n o0_n = g_t28160;
	if (o0_n - ((word32) o0_n + (n_base_source_files << 0x02)) < 0x00)
	{
		Eq_n o0_n = *o0_n;
		while (true)
		{
			up32 l1_n;
			union Eq_n * l0_n = process_aux_info_file(o0_n, 0x00, out l1_n);
			if (l0_n - l1_n >= 0x00)
				break;
			o0_n = *l0_n;
		}
	}
	visit_each_hash_node(visit_each_hash_node(&g_t28240));
}

// 00014EA4: Register ui32 main(Register (ptr32 (ptr32 char)) o1)
// Called from:
//      _start
ui32 main(char ** o1)
{
	char * o0_n = strrchr(*o1, 0x2F);
	char * o2_n = o0_n + 1;
	if (o0_n == null)
	{
		g_ptr28150 = o0_n;
		o2_n = (char *) *o1;
	}
	else
		g_ptr28150 = o0_n;
	g_ptr28150 = o2_n;
	setlocale(0x05, "");
	Eq_n o0_n = getpwd();
	if (o0_n != 0x00)
	{
		g_t2B270 = o0_n;
		struct Eq_n * i6_n;
		directory_list = string_list_cons(out i6_n);
		word32 o0_n = i6_n->dw0044;
		struct Eq_n * i6_n;
		struct Eq_n * l6_n;
		struct Eq_n * l7_n;
		struct Eq_n * l0_n = getopt_long(i6_n->ptr0048, &g_b17838, (char *) i6_n - 20, out l6_n, out l7_n, out i6_n);
		if (o0_n != ~0x00)
		{
			uint32 o0_n;
			if (o0_n == 0x00)
				o0_n = l0_n->a000C[i6_n->dwFFFFFFEC].dw0000 + ~0x4D;
			else
				o0_n = o0_n + ~0x4D;
			if (o0_n < 0x2A)
				return o0_n << 0x02;
			usage();
		}
		else
		{
			struct Eq_n * i6_n;
			munge_compile_params(i6_n->tFFFFFFE8, out i6_n);
			ui32 o1_n = i6_n->dw0044 - l7_n->dw0068;
			l6_n->dw034C = o1_n;
			Eq_n o0_n = o1_n + 0x01 << 0x02;
			word32 i2_n;
			word32 i1_n;
			struct Eq_n * i6_n;
			xmalloc(o0_n, out i1_n, out i2_n, out i6_n);
			g_t28160 = o0_n;
			int32 o1_n = l7_n->dw0068;
			l6_n->dw034C = 0x00;
			if (o1_n - i6_n->dw0044 < 0x00)
			{
				struct Eq_n * l4_n = l6_n;
				struct Eq_n * l2_n = l7_n;
				while (true)
				{
					abspath(0x00, i6_n->ptr0048[l7_n->dw0068], out i6_n);
					struct Eq_n * o0_n = (uint32) strlen(0x00);
					if ((int32) o0_n->bFFFFFFFF == 99 && (int32) o0_n->bFFFFFFFE == 0x2E)
					{
						ui32 o0_n = l4_n->dw034C;
						*((word32) g_t28160 + o0_n * 0x04) = 0x00;
						l4_n->dw034C = o0_n + 0x01;
					}
					else
					{
						struct Eq_n * l3_n;
						word32 i0_n;
						word32 l0_n;
						shortpath(0x00, 0x00, out l0_n, out l2_n, out l3_n, out l4_n, out i0_n);
						word32 i2_n;
						word32 i1_n;
						notice(96336, out i1_n, out i2_n, out i6_n);
						++l3_n->dw0320;
					}
					int32 o0_n = l2_n->dw0068;
					if (o0_n + 0x01 - i6_n->dw0044 >= 0x00)
						break;
					l2_n->dw0068 = o0_n + 0x01;
				}
				l2_n->dw0068 = o0_n + 0x01;
			}
			if (errors == 0x00)
			{
				if (version_flag == 0x00)
				{
					int32 o1_n;
					do_processing();
					if (errors != 0x00)
						o1_n = 33;
					else
						o1_n = 0x00;
					exit(o1_n);
				}
				else
					fprintf(&g_t2B640, "%s: %s\n", g_ptr28150, version_string);
			}
			else
				usage();
		}
	}
	else
	{
		g_t2B270 = o0_n;
		xstrerror(errno);
		word32 i6_n;
		word32 i2_n;
		word32 i1_n;
		notice(0x00017810, out i1_n, out i2_n, out i6_n);
		exit(33);
	}
}

// 000152B8: Register Eq_n getpwd()
// Called from:
//      main
Eq_n getpwd()
{
	Eq_n i0_n = g_t2B2A0;
	if (i0_n != 0x00)
		return i0_n;
	char * o2_n = g_ptr2B2B0;
	if (o2_n != null)
	{
		errno = o2_n;
		return i0_n;
	}
	else
	{
		errno = o2_n;
		Eq_n l1_n;
		Eq_n o0_n = getenv("PWD");
		i0_n = o0_n;
		if (o0_n != 0x00)
		{
			l1_n.u0 = 100;
			if ((int32) *o0_n == 0x2F)
			{
				if (stat(o0_n, fp + ~0x011F) == 0x00)
				{
					if (stat(96400, fp + ~0x97) == 0x00)
					{
						if (dwLoc88 - dwLoc0110 == 0x00)
						{
							if (dwLoc98 - dwLoc0120 == 0x00)
							{
								g_t2B2A0 = o0_n;
								return i0_n;
							}
							l1_n.u0 = 100;
						}
						else
							l1_n.u0 = 100;
					}
					else
						l1_n.u0 = 100;
				}
				else
					l1_n.u0 = 100;
			}
		}
		else
			l1_n.u0 = (char *) 100;
		while (true)
		{
			word32 i6_n;
			word32 i2_n;
			word32 i1_n;
			xmalloc(l1_n, out i1_n, out i2_n, out i6_n);
			i0_n = l1_n;
			if (getcwd(l1_n, l1_n) != null)
				break;
			char * l0_n = errno;
			free(l1_n);
			if (l0_n != (char *) 0x22)
			{
				i0_n.u0 = 0x00;
				errno = l0_n;
				g_ptr2B2B0 = l0_n;
				break;
			}
			l1_n <<= 0x01;
		}
		g_t2B2A0 = i0_n;
		return i0_n;
	}
}

// 000153C4: void _obstack_begin(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o2, Register (ptr32 code) o3, Register word32 o4, Register word32 o5)
void _obstack_begin(struct Eq_n * o0, word32 o1, word32 o2, <anonymous> * o3, word32 o4, word32 o5)
{
	word32 i1_n = o1;
	word32 i2_n = o2;
	if (o2 == 0x00)
		i2_n = 0x08;
	if (o1 == 0x00)
		i1_n = 0x0FE8;
	word32 o5_n;
	word32 o4_n;
	word32 o3_n;
	word32 o2_n;
	struct Eq_n * i0_n;
	struct Eq_n * i1_n;
	int32 o1_n = o0->dw0028 & ~0x80000000;
	o0->dw0020 = o4;
	word32 o2_n = i2_n + ~0x00;
	o0->dw0018 = o2_n;
	o0->ptr001C = o3;
	o0->dw0000 = i1_n;
	if (o1_n < 0x00)
	{
		o0->dw0028 = o1_n;
		struct Eq_n * o0_n;
		o3();
		i1_n = o0_n;
	}
	else
	{
		o0->dw0028 = o1_n;
		struct Eq_n * o0_n;
		o3();
		i1_n = o0_n;
	}
	if (i1_n != null)
	{
		i0_n->ptr0004 = i1_n;
		word32 o0_n = i0_n->dw0000;
		word32 o1_n = &i1_n->dw0004 + 1;
		i0_n->dw000C = o1_n;
		i0_n->dw0008 = o1_n;
		word32 o0_n = i1_n + o0_n / 8;
		i1_n->dw0000 = o0_n;
		i0_n->dw0010 = o0_n;
		i1_n->dw0004 = 0x00;
		i0_n->dw0028 = i0_n->dw0028 & ~0x40000000 & ~0x20000000;
	}
	else
	{
		i0_n->ptr0004 = i1_n;
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
	}
}

// 00015488: void _obstack_begin_n(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o2, Register (ptr32 code) o3, Register word32 o4, Register word32 o5)
void _obstack_begin_n(struct Eq_n * o0, word32 o1, word32 o2, <anonymous> * o3, word32 o4, word32 o5)
{
	word32 i1_n = o1;
	word32 i2_n = o2;
	if (o2 == 0x00)
		i2_n = 0x08;
	if (o1 == 0x00)
		i1_n = 0x0FE8;
	word32 o5_n;
	word32 o4_n;
	word32 o3_n;
	word32 o2_n;
	struct Eq_n * i0_n;
	struct Eq_n * i1_n;
	ui32 o0_n = o0->dw0028;
	o0->dw0020 = o4;
	word32 o2_n = i2_n + ~0x00;
	o0->dw0018 = o2_n;
	o0->ptr001C = o3;
	o0->dw0000 = i1_n;
	o0->dw0024 = o5;
	if ((o0_n | 0x80000000) < 0x00)
	{
		o0->dw0028 = o0_n | 0x80000000;
		struct Eq_n * o0_n;
		o3();
		i1_n = o0_n;
	}
	else
	{
		o0->dw0028 = o0_n | 0x80000000;
		struct Eq_n * o0_n;
		o3();
		i1_n = o0_n;
	}
	if (i1_n != null)
	{
		i0_n->ptr0004 = i1_n;
		word32 o0_n = i0_n->dw0000;
		word32 o1_n = &i1_n->dw0004 + 1;
		i0_n->dw000C = o1_n;
		i0_n->dw0008 = o1_n;
		word32 o0_n = i1_n + o0_n / 8;
		i1_n->dw0000 = o0_n;
		i0_n->dw0010 = o0_n;
		i1_n->dw0004 = 0x00;
		i0_n->dw0028 = i0_n->dw0028 & ~0x40000000 & ~0x20000000;
	}
	else
	{
		i0_n->ptr0004 = i1_n;
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
	}
}

// 00015550: void _obstack_newchunk(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o3, Register word32 o4, Register word32 o5)
void _obstack_newchunk(struct Eq_n * o0, word32 o1, word32 o3, word32 o4, word32 o5)
{
	int32 l2_n = o0->dw000C - o0->dw0008;
	word32 i1_n = l2_n + o1 + (l2_n >> 0x03);
	int32 o2_n = o0->dw0000;
	int32 i1_n = i1_n + 100;
	if (i1_n + 100 - o2_n < 0x00)
		i1_n = o2_n;
	struct Eq_n * i0_n;
	Eq_n l2_n;
	struct Eq_n * o2_n;
	Eq_n o5_n;
	ptr32 o4_n;
	struct Eq_n * l1_n;
	int32 i1_n;
	struct Eq_n * l0_n;
	word32 o3_n;
	if (o0->dw0028 < 0x00)
	{
		<anonymous> * o2_n = o0->ptr001C;
		struct Eq_n * o0_n;
		o2_n();
		l0_n = o0_n;
	}
	else
	{
		<anonymous> * o1_n = o0->ptr001C;
		struct Eq_n * o0_n;
		o1_n();
		l0_n = o0_n;
	}
	if (l0_n == null)
	{
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
		i0_n->ptr0004 = l0_n;
	}
	else
		i0_n->ptr0004 = l0_n;
	struct Eq_n * i1_n;
	word32 g2_n;
	int32 o0_n;
	l0_n->ptr0004 = l1_n;
	ptr32 o1_n = l0_n + i1_n / 8;
	i0_n->ptr0010 = o1_n;
	l0_n->ptr0000 = o1_n;
	if (i0_n->dw0018 > 0x06)
	{
		Eq_n o0_n = l2_n >> 0x02;
		o5_n = o0_n;
		i1_n = (struct Eq_n *) ((char *) &l0_n->ptr0004 + 4);
		int32 o3_n = (word32) o0_n - 1;
		if (o0_n >= ~0x00)
		{
			g2_n = (char *) &l1_n->ptr0004 + 4;
			word32 * o4_n = l0_n + (((word32) o0_n - 1 << 0x02) + 0x08) / 8;
			while (true)
			{
				o2_n = (struct Eq_n *) i0_n->ptr0008[o3_n * 0x04];
				*o4_n = o2_n;
				o3_n += ~0x00;
				if (o3_n < 0x00)
					break;
				o4_n += -1;
			}
			o4_n = o4_n + -1;
		}
		else
			g2_n = (char *) &l1_n->ptr0004 + 4;
		o0_n = __align(l2_n, 4);
	}
	else
	{
		o0_n = 0x00;
		i1_n = (struct Eq_n *) ((char *) &l0_n->ptr0004 + 4);
		g2_n = (char *) &l1_n->ptr0004 + 4;
	}
	struct Eq_n * o0_n;
	int32 o3_n = o0_n;
	if (o0_n - l2_n < 0x00)
	{
		struct Eq_n * o0_n = i0_n->ptr0008;
		o2_n = i1_n;
		while (true)
		{
			i1_n[o3_n] = (struct Eq_n) (byte) (ui32) o0_n[o3_n];
			++o3_n;
			if (o3_n - l2_n >= 0x00)
				break;
			o0_n = i0_n->ptr0008;
		}
		o0_n = i0_n->ptr0008;
	}
	else
		o0_n = i0_n->ptr0008;
	Eq_n o0_n;
	if (o0_n - g2_n == 0x00)
	{
		Eq_n o0_n = i0_n->t0028;
		if ((o0_n >> 0x1E & 0x01) == 0x00)
		{
			l0_n->ptr0004 = l1_n->ptr0004;
			if (i0_n->t0028 >= 0x00)
			{
				<anonymous> * o1_n = i0_n->ptr0020;
				o1_n();
				o0_n = i0_n->t0028;
			}
			else
			{
				<anonymous> * o2_n = i0_n->ptr0020;
				o2_n();
				o0_n = i0_n->t0028;
			}
		}
		else
			o0_n = i0_n->t0028;
	}
	else
		o0_n = i0_n->t0028;
	i0_n->t0028 = o0_n & ~0x40000000;
	Mem336[i0_n + 0x0C:word32] = i1_n + l2_n;
	i0_n->ptr0008 = i1_n;
}

// 000156F0: void _obstack_allocated_p(Register (ptr32 Eq_n) o0, Register up32 o1)
void _obstack_allocated_p(struct Eq_n * o0, up32 o1)
{
	struct Eq_n * g3_n;
	for (g3_n = o0->ptr0004; g3_n != null; g3_n = g3_n->ptr0004)
	{
		up32 g0_n = g3_n - o1;
		if (g0_n < 0x00)
		{
			if (g3_n->dw0000 - o1 >= 0x00)
				return;
			g3_n = g3_n->ptr0004;
			continue;
		}
	}
}

// 00015724: void _obstack_free(Register (ptr32 Eq_n) o0, Register up32 o1, Register word32 o2, Register word32 o4, Register word32 o5)
void _obstack_free(struct Eq_n * o0, up32 o1, word32 o2, word32 o4, word32 o5)
{
	struct Eq_n * i0_n = o0;
	up32 i1_n = o1;
	up32 * o3_n = o0->ptr0004;
	while (o3_n != null)
	{
		up32 g0_n = o3_n - i1_n;
		int32 o0_n;
		if (g0_n < 0x00)
		{
			if (*o3_n - i1_n >= 0x00)
				break;
			o0_n = i0_n->dw0028;
		}
		else
			o0_n = i0_n->dw0028;
		int32 o1_n;
		up32 * l0_n;
		up32 * l0_n;
		if (o0_n < 0x00)
		{
			<anonymous> * o2_n = i0_n->ptr0020;
			o2_n();
			o1_n = i0_n->dw0028;
			l0_n = l0_n;
		}
		else
		{
			<anonymous> * o1_n = i0_n->ptr0020;
			o1_n();
			o1_n = i0_n->dw0028;
			l0_n = l0_n;
		}
		up32 * l0_n;
		i0_n->dw0028 = o1_n | 0x40000000;
		o3_n = l0_n;
	}
	if (o3_n == null)
	{
		if (i1_n == 0x00)
			return;
		abort();
	}
	else
	{
		i0_n->dw0008 = i1_n;
		i0_n->dw000C = i1_n;
		up32 o0_n = *o3_n;
		i0_n->ptr0004 = o3_n;
		i0_n->dw0010 = o0_n;
	}
}

// 000157D4: void obstack_free(Register (ptr32 Eq_n) o0, Register up32 o1, Register word32 o2, Register word32 o4, Register word32 o5)
void obstack_free(struct Eq_n * o0, up32 o1, word32 o2, word32 o4, word32 o5)
{
	struct Eq_n * i0_n = o0;
	up32 i1_n = o1;
	up32 * o3_n = o0->ptr0004;
	while (o3_n != null)
	{
		up32 g0_n = o3_n - i1_n;
		int32 o0_n;
		if (g0_n < 0x00)
		{
			if (*o3_n - i1_n >= 0x00)
				break;
			o0_n = i0_n->dw0028;
		}
		else
			o0_n = i0_n->dw0028;
		int32 o1_n;
		up32 * l0_n;
		up32 * l0_n;
		if (o0_n < 0x00)
		{
			<anonymous> * o2_n = i0_n->ptr0020;
			o2_n();
			o1_n = i0_n->dw0028;
			l0_n = l0_n;
		}
		else
		{
			<anonymous> * o1_n = i0_n->ptr0020;
			o1_n();
			o1_n = i0_n->dw0028;
			l0_n = l0_n;
		}
		up32 * l0_n;
		i0_n->dw0028 = o1_n | 0x40000000;
		o3_n = l0_n;
	}
	if (o3_n == null)
	{
		if (i1_n == 0x00)
			return;
		abort();
	}
	else
	{
		i0_n->dw0008 = i1_n;
		i0_n->dw000C = i1_n;
		up32 o0_n = *o3_n;
		i0_n->ptr0004 = o3_n;
		i0_n->dw0010 = o0_n;
	}
}

// 00015884: void _obstack_memory_used(Register (ptr32 Eq_n) o0)
void _obstack_memory_used(struct Eq_n * o0)
{
	struct Eq_n * g3_n;
	for (g3_n = o0->ptr0004; g3_n != null; g3_n = g3_n->ptr0004)
		;
}

// 000158B4: void print_and_abort()
void print_and_abort()
{
	fputs("memory exhausted\n", &g_t2B640);
	exit(obstack_exit_failure);
}

// 000158D8: Register Eq_n try(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      choose_temp_base
//      make_temp_file
Eq_n try(Eq_n o0, Eq_n o1)
{
	Eq_n i0_n = o0;
	if (o1 != 0x00)
		i0_n = o1;
	else if (o0 == 0x00 || access(o0, 0x07) != 0x00)
		i0_n.u0 = 0x00;
	return i0_n;
}

// 00015918: Register Eq_n choose_temp_base(Register out Eq_n l1Out, Register out Eq_n i0Out, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
Eq_n choose_temp_base(union Eq_n & l1Out, union Eq_n & i0Out, ptr32 & i6Out)
{
	Eq_n o0_n = try(0x00028038, try(0x00028040, try(0x00017900, try(getenv("TEMP"), try(getenv("TMP"), try(getenv("TMPDIR"), 0x00))))));
	Eq_n l0_n = o0_n;
	if (o0_n == 0x00)
		l0_n.u0 = 0x00017910;
	ui32 o0_n;
	Eq_n o0_n = (uint32) strlen(l0_n);
	ptr32 i6_n;
	word32 i1_n;
	word32 i2_n;
	xmalloc(o0_n + 0x0A, out i1_n, out i2_n, out i6_n);
	strcpy(o0_n + 0x0A, l0_n);
	Eq_n l1_n = o0_n;
	if (o0_n != 0x00)
	{
		if (CONVERT(Mem0[o0_n + (o0_n + 0x0A) + -1:int8], int8, int32) == 0x2F)
		{
			o0_n = (ui32) g_b17918;
l00015A04:
			Mem182[o0_n + 0x0A + l1_n:byte] = SLICE(o0_n, byte, 0);
			word32 o4_n = o0_n + 0x0A + l1_n;
			*((word32) o4_n + 1) = (byte) (ui32) g_b17919;
			*((word32) o4_n + 2) = (byte) (ui32) g_b1791A;
			*((word32) o4_n + 3) = (byte) (ui32) g_b1791B;
			*((word32) o4_n + 4) = (byte) (ui32) g_b1791C;
			*((word32) o4_n + 5) = (byte) (ui32) g_b1791D;
			*((word32) o4_n + 6) = (byte) (ui32) g_b1791E;
			*((word32) o4_n + 7) = (byte) (ui32) g_b1791F;
			*((word32) o4_n + 8) = (byte) (ui32) g_b17920;
			mktemp(o0_n + 0x0A);
			if (CONVERT(strlen(o0_n + 0x0A), size_t, uint32) != 0x00)
			{
				l1Out = l1_n;
				i0Out = o0_n + 0x0A;
				i6Out = i6_n;
				return o0_n + 0x0A;
			}
			else
				abort();
		}
		Mem170[o0_n + (o0_n + 0x0A):byte] = 0x2F;
		l1_n = o0_n + 0x01;
	}
	o0_n = (ui32) g_b17918;
	goto l00015A04;
}

// 00015A7C: void make_temp_file(Register Eq_n o0)
void make_temp_file(Eq_n o0)
{
	Eq_n o0_n = try(0x00028050, try(0x00028058, try(0x00017900, try(getenv("TEMP"), try(getenv("TMP"), try(getenv("TMPDIR"), 0x00))))));
	Eq_n l0_n = o0_n;
	if (o0_n == 0x00)
		l0_n.u0 = 0x00017910;
	Eq_n l2_n;
	Eq_n o0_n = (uint32) strlen(l0_n);
	if (o0 != 0x00)
		l2_n.u1 = (uint32) strlen(o0);
	else
		l2_n.u0 = 0x00;
	word32 o0_n = o0_n + l2_n;
	word32 i2_n;
	word32 i6_n;
	word32 i1_n;
	xmalloc(o0_n->a000A, out i1_n, out i2_n, out i6_n);
	strcpy(o0_n->a000A, l0_n);
	Eq_n l1_n = o0_n;
	if (o0_n != 0x00)
	{
		word32 o0_n = o0_n + (o0_n + 0x0A);
		if ((int32) o0_n->bFFFFFFFF != 0x2F)
		{
			Mem185[o0_n + (o0_n + 0x0A):byte] = 0x2F;
			l1_n = (word32) o0_n + 1;
		}
	}
	Mem193[o0_n + 0x0A + l1_n:byte] = SLICE(CONVERT(Mem188[0x00017918:byte], byte, ui32), byte, 0);
	word32 o3_n = o0_n + 0x0A + l1_n;
	o3_n->b0001 = (byte) (ui32) g_b17919;
	o3_n->b0002 = (byte) (ui32) g_b1791A;
	o3_n->b0003 = (byte) (ui32) g_b1791B;
	o3_n->b0004 = (byte) (ui32) g_b1791C;
	o3_n->b0005 = (byte) (ui32) g_b1791D;
	o3_n->b0006 = (byte) (ui32) g_b1791E;
	o3_n->b0007 = (byte) (ui32) g_b1791F;
	ui32 o1_n = (ui32) g_b17920;
	if (o0 == 0x00)
	{
		o3_n->b0008 = (byte) o1_n;
		Eq_n o0_n = mkstemps(o0_n->a000A, l2_n);
		if (o0_n != ~0x00)
		{
			if (close(o0_n) == 0x00)
				return;
			abort();
		}
		else
			abort();
	}
	else
	{
		o3_n->b0008 = (byte) o1_n;
		strcat(o0_n->a000A, o0);
	}
}

// 00015C24: Register (ptr32 int8) my_index(Register (ptr32 int8) o0, Register Eq_n o1)
// Called from:
//      _getopt_internal
int8 * my_index(int8 * o0, Eq_n o1)
{
	int32 g2_n = (int32) *o0;
	while (g2_n != 0x00)
	{
		ui32 g3_n = (ui32) *o0;
		if ((int32) (byte) g3_n - o1 == 0x00)
			return o0;
		++o0;
		g2_n = (int32) *o0;
	}
	o0 = null;
	return o0;
}

// 00015C60: Register (ptr32 (arr Eq_n)) exchange(Register (arr Eq_n) o0, Register out (ptr32 int8) i2Out, Register out (ptr32 ptr32) i4Out, Register out (ptr32 ptr32) i5Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      _getopt_internal
Eq_n (* exchange)[](Eq_n o0[], int8 & i2Out, ptr32 & i4Out, ptr32 & i5Out, struct Eq_n & i6Out)
{
	ptr32 * g2_n;
	ptr32 * g1_n = g_ptr2B300;
	ptr32 * i5_n = optind;
	int8 * i2_n = o2;
	Eq_n i1_n[] = &g_t28000;
	ptr32 * i4_n = g_ptr2B2F0;
	if (i5_n - g1_n <= 0x00)
	{
l00015D40:
		g2_n = optind;
		goto l00015D44;
	}
	if (g1_n - i4_n <= 0x00)
	{
		g2_n = optind;
l00015D44:
		g_ptr2B2F0 += g2_n - g_ptr2B300;
		g_ptr2B300 = g2_n;
		i2Out = i2_n;
		i4Out = i4_n;
		i5Out = i5_n;
		i6Out = fp;
		return i1_n;
	}
	int32 g3_n = i5_n - g1_n;
l00015CA4:
	bool v27_n;
	int32 g2_n = g1_n - i4_n;
	if (g3_n - g2_n > 0x00)
	{
		if (g2_n > 0x00)
		{
			i5_n -= g2_n;
			int32 i3_n = g2_n;
			i1_n = i5_n << 0x02;
			Eq_n (* g3_n)[] = i4_n << 0x02;
			while (true)
			{
				i2_n = Mem90[g3_n + o0:word32];
				Mem97[g3_n + o0:word32] = Mem90[i1_n + o0:word32];
				Mem98[i1_n + o0:word32] = i2_n;
				i3_n += ~0x00;
				i1_n = (Eq_n (*)[]) (i1_n + 1);
				if (i3_n == 0x00)
					break;
				g3_n += 0x04;
			}
			v27_n = i5_n - g1_n <= 0x00;
l00015D30:
			if (v27_n)
				goto l00015D40;
			int32 g0_n = g1_n - i4_n;
			if (g0_n <= 0x00)
				goto l00015D40;
			g3_n = i5_n - g1_n;
			goto l00015CA4;
		}
		i5_n -= g2_n;
	}
	else
	{
		ptr32 * g4_n;
		if (g3_n > 0x00)
		{
			g4_n = i4_n + g3_n;
			int32 i3_n = g3_n;
			int32 i1_n = i4_n << 0x02;
			int32 g3_n = g1_n << 0x02;
			while (true)
			{
				i2_n = (int8 *) o0[i1_n / 4];
				o0[i1_n / 4] = o0[g3_n / 4];
				o0[g3_n / 4] = i2_n;
				i3_n += ~0x00;
				g3_n += 0x04;
				if (i3_n == 0x00)
					break;
				i1_n += 0x04;
			}
			i1_n = i1_n + 0x04;
		}
		else
			g4_n = i4_n + g3_n;
		i4_n = g4_n;
	}
	v27_n = i5_n - g1_n <= 0x00;
	goto l00015D30;
}

// 00015D64: Register (ptr32 int8) _getopt_initialize(Register (ptr32 int8) o2, Register out ptr32 i1Out, Register out ptr32 i4Out, Register out ptr32 i5Out, Register out ptr32 i6Out)
// Called from:
//      _getopt_internal
int8 * _getopt_initialize(int8 * o2, ptr32 & i1Out, ptr32 & i4Out, ptr32 & i5Out, ptr32 & i6Out)
{
	ptr32 * o2_n = optind;
	g_ptr2B2F0 = o2_n;
	g_ptr2B300 = o2_n;
	g_t2B2C0.u0 = 0x00;
	Eq_n o0_n = getenv("POSIXLY_CORRECT");
	g_t2B2E0 = o0_n;
	int8 * i0_n = o2;
	int32 o0_n = (int32) *o2;
	if (o0_n == 0x2D)
	{
		g_dw2B2D0 = 0x02;
		i0_n = o2 + 1;
	}
	else if (o0_n == 0x2B)
	{
		g_dw2B2D0 = 0x00;
		i0_n = o2 + 1;
	}
	else if (o0_n != 0x00)
		g_dw2B2D0 = 0x00;
	else
		g_dw2B2D0 = 0x01;
	i1Out = o1;
	i4Out = o4;
	i5Out = o5;
	i6Out = fp;
	return i0_n;
}

// 00015E04: Register Eq_n _getopt_internal(Register (ptr32 (arr Eq_n)) o1, Register (ptr32 int8) o2, Register (ptr32 ptr32) o4, Register word32 o5, Register out ptr32 l6Out, Register out ptr32 l7Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      getopt
//      getopt_long
//      getopt_long_only
Eq_n _getopt_internal(Eq_n (* o1)[], int8 * o2, ptr32 * o4, word32 o5, ptr32 & l6Out, ptr32 & l7Out, struct Eq_n & i6Out)
{
	ptr32 * o2_n = optind;
	optarg.u0 = 0x00;
	Eq_n i1_n[] = o1;
	int8 * i2_n = o2;
	ptr32 * i4_n = o4;
	word32 i5_n = o5;
	struct Eq_n * i6_n = fp;
	if (o2_n == null || __getopt_initialized == 0x00)
	{
		if (o2_n == null)
			optind = (ptr32 *) 0x01;
		int8 * o0_n = _getopt_initialize(o2, out i1_n, out i4_n, out i5_n, out i6_n);
		__getopt_initialized = 0x01;
		i2_n = o0_n;
	}
	struct Eq_n * o0_n;
	Eq_n l0_n = 0x00028000;
	Eq_n o0_n = g_t2B2C0;
	if (o0_n != 0x00 && (int32) (*o0_n) != 0x00)
	{
		o0_n = i6_n->ptr0050;
		goto l000160C0;
	}
	ptr32 * o2_n = optind;
	if (g_ptr2B300 - o2_n > 0x00)
		g_ptr2B300 = o2_n;
	l0_n.u0 = 0x0002B000;
	if (g_ptr2B2F0 - o2_n > 0x00)
		g_ptr2B2F0 = o2_n;
	if (g_dw2B2D0 != 0x01)
	{
l00015F78:
		ptr32 * o2_n;
		ptr32 * o1_n = optind;
		if (o1_n - i6_n->ptr0044 == 0x00)
		{
l00016008:
			o2_n = optind;
			goto l0001600C;
		}
		if (strcmp(i1_n[o1_n], 96568) != 0x00)
		{
			o2_n = optind;
l0001600C:
			if (o2_n - i6_n->ptr0044 == 0x00)
			{
				ptr32 * o1_n = g_ptr2B2F0;
				if (o1_n - g_ptr2B300 == 0x00)
					goto l00016978;
				optind = o1_n;
			}
			else
			{
				word32 o0_n;
				Eq_n o3_n = i1_n[o2_n];
				if ((int32) *o3_n == 0x2D)
				{
					int32 o0_n = (int32) *((word32) o3_n + 1);
					if (o0_n != 0x00)
					{
						struct Eq_n * o2_n = i6_n->ptr0050;
						word32 o1_n;
						if (o2_n != null)
							o1_n = 0x01 - ((o0_n ^ 0x2D) > 0x00);
						else
							o1_n = 0x00;
						g_t2B2C0 = (word32) o3_n + (o1_n + 0x01);
						o0_n = i6_n->ptr0050;
l000160C0:
						union Eq_n * o1_n;
						Eq_n o0_n;
						int32 o0_n;
						Eq_n o1_n;
						if (o0_n == null)
						{
							o1_n = g_t2B2C0;
							goto l000164A0;
						}
						ptr32 * o0_n = optind;
						Eq_n l2_n;
						Eq_n o0_n = i1_n[o0_n];
						Eq_n o1_n = (int32) *((word32) o0_n + 1);
						if (o1_n != 0x2D)
						{
							if (i5_n == 0x00)
							{
								o1_n = g_t2B2C0;
								goto l000164A0;
							}
							if ((int32) *((word32) o0_n + 2) != 0x00)
							{
								l2_n = g_t2B2C0;
l00016114:
								struct Eq_n * l3_n = null;
								word32 i3_n = 0x00;
								int32 o0_n = (int32) *l2_n;
								word32 i0_n = 0x00;
								word32 o1_n = i6_n->ptr0050->dw0000;
								l7 = ~0x00;
								while (o0_n != 0x00)
								{
									int32 g0_n = o0_n - 0x3D;
									if (g0_n == 0x00)
										break;
									l2_n = (word32) l2_n + 1;
									o0_n = (int32) *l2_n;
								}
								struct Eq_n * l1_n = i6_n->ptr0050;
								if (o1_n != 0x00)
								{
									ptr32 l4_n = 0x00;
l0001615C:
									Eq_n o1_n = g_t2B2C0;
									if (strncmp(l1_n->dw0000, o1_n, l2_n - o1_n) != 0x00)
									{
										++l1_n;
										goto l000161A8;
									}
									l0_n = l2_n - g_t2B2C0;
									if (l0_n - (uint32) strlen(l1_n->dw0000) != 0x00)
									{
										if (l3_n == null)
										{
											l3_n = l1_n;
											l7 = l4_n;
										}
										else
											i0_n = 0x01;
										++l1_n;
l000161A8:
										if (l1_n->dw0000 == 0x00)
											goto l000161B8;
										++l4_n;
										goto l0001615C;
									}
									l3_n = l1_n;
									l7 = l4_n;
									i3_n = 0x01;
								}
l000161B8:
								bool v45_n;
								if (i0_n != 0x00)
								{
									if (i3_n == 0x00)
									{
										if (opterr != 0x00)
										{
											ptr32 * o1_n = optind;
											fprintf(&g_t2B640, "%s: option `%s' is ambiguous\n", i1_n[0], i1_n[o1_n]);
										}
										uint32 o0_n = (uint32) strlen(g_t2B2C0);
										ptr32 * o2_n = optind;
										g_t2B2C0 = (word32) g_t2B2C0 + o0_n;
										optind = (ptr32 *) ((char *) o2_n + 1);
										optopt.u0 = 0x00;
										goto l00016978;
									}
									v45_n = l3_n == null;
								}
								else
									v45_n = l3_n == null;
								if (!v45_n)
								{
									ptr32 * o2_n = optind;
									optind = (ptr32 *) ((char *) o2_n + 1);
									if ((int32) *l2_n != 0x00)
									{
										word32 o0_n = l3_n->dw0004;
										if (o0_n != 0x00)
										{
											Eq_n o0_n = (word32) l2_n + 1;
											optarg = o0_n;
										}
										else if (opterr != 0x00)
										{
											Eq_n o0_n;
											struct Eq_n * o3_n = (i1_n + ((char *) o2_n + 1 << 0x02) / 4)[-1];
											if ((int32) o3_n->b0001 == 0x2D)
											{
												fprintf(&g_t2B640, "%s: option `--%s' doesn't allow an argument\n", i1_n[0], l3_n->dw0000);
												o0_n = g_t2B2C0;
											}
											else
											{
												fprintf(&g_t2B640, "%s: option `%c%s' doesn't allow an argument\n", i1_n[0], (int32) o3_n->b0000, l3_n->dw0000);
												o0_n = g_t2B2C0;
											}
											uint32 o0_n = (uint32) strlen(o0_n);
											Eq_n o2_n = l3_n->t000C;
											g_t2B2C0 = (word32) g_t2B2C0 + o0_n;
											optopt = o2_n;
											goto l00016978;
										}
l00016398:
										Eq_n o1_n = (word32) g_t2B2C0 + (uint32) strlen(g_t2B2C0);
										if (i4_n != null)
										{
											g_t2B2C0 = o1_n;
											*i4_n = l7;
										}
										else
											g_t2B2C0 = o1_n;
										o1_n = l3_n->ptr0008;
										if (o1_n == null)
											goto l00016978;
										o0_n = l3_n->t000C;
										goto l00016874;
									}
									word32 o0_n = l3_n->dw0004;
									if (o0_n != 0x01)
										goto l00016398;
									ptr32 * o0_n = i6_n->ptr0044;
									if ((char *) o2_n + 1 - o0_n < 0x00)
									{
										optarg = i1_n[(char *) o2_n + 1];
										optind = (ptr32 *) ((char *) o2_n + 2);
										goto l00016398;
									}
									if (opterr != 0x00)
										fprintf(&g_t2B640, "%s: option `%s' requires an argument\n", i1_n[0], (i1_n + ((char *) o2_n + 1 << 0x02) / 4)[-1]);
									uint32 o0_n = (uint32) strlen(g_t2B2C0);
									Eq_n o2_n = l3_n->t000C;
									g_t2B2C0 = (word32) g_t2B2C0 + o0_n;
									optopt = o2_n;
									o0_n = (int32) *i2_n;
l00016388:
									if (o0_n != 0x3A)
										o0_n = (uint32) strlen(g_t2B2C0);
									goto l00016978;
								}
								if (i5_n == 0x00)
								{
l0001640C:
									ptr32 * o0_n;
									if (opterr != 0x00)
									{
										ptr32 * o0_n = optind;
										Eq_n o3_n = i1_n[o0_n];
										if ((int32) *((word32) o3_n + 1) != 0x2D)
											fprintf(&g_t2B640, "%s: unrecognized option `%c%s'\n", i1_n[0], (int32) *o3_n, g_t2B2C0);
										fprintf(&g_t2B640, "%s: unrecognized option `--%s'\n", i1_n[0], g_t2B2C0);
										o0_n = optind;
									}
									else
										o0_n = optind;
									g_t2B2C0.u0 = 96808;
									optind = (ptr32 *) ((char *) o0_n + 1);
									optopt.u0 = 0x00;
									goto l00016978;
								}
								ptr32 * o0_n = optind;
								if ((int32) *((word32) i1_n[o0_n] + 1) == 0x2D)
									goto l0001640C;
								Eq_n o2_n = g_t2B2C0;
								if (my_index(i2_n, (int32) *o2_n) == null)
									goto l0001640C;
								o1_n = g_t2B2C0;
l000164A0:
								ui32 i0_n = (ui32) *o1_n;
								g_t2B2C0 = (word32) o1_n + 1;
								l0_n.u1 = (int32) (byte) i0_n;
								struct Eq_n * o0_n = my_index(i2_n, l0_n);
								Eq_n o3_n = g_t2B2C0;
								if ((int32) *o3_n == 0x00)
									optind = (ptr32 *) ((char *) optind + 1);
								if (o0_n == null || l0_n == 0x3A)
								{
									if (opterr != 0x00)
									{
										if (g_t2B2E0 == 0x00)
											fprintf(&g_t2B640, "%s: invalid option -- %c\n", i1_n[0], l0_n);
										fprintf(&g_t2B640, "%s: illegal option -- %c\n", i1_n[0], l0_n);
									}
									optopt.u1 = (int32) (byte) i0_n;
									goto l00016978;
								}
								int32 o0_n = (int32) o0_n->b0000;
								int32 o0_n;
								if (o0_n == 0x57)
								{
									ui32 o1_n = (ui32) o0_n->b0001;
									if (o1_n == 0x3B)
									{
										struct Eq_n * l3_n = null;
										word32 i0_n = 0x00;
										word32 l4_n = 0x00;
										if ((int32) *o3_n != 0x00)
										{
											ptr32 * o0_n = optind;
											optarg = o3_n;
											optind = (ptr32 *) ((char *) o0_n + 1);
											goto l0001663C;
										}
										l7 = 0x00;
										ptr32 * o2_n = optind;
										if (o2_n - i6_n->ptr0044 != 0x00)
										{
											optarg = i1_n[o2_n];
											optind = (ptr32 *) ((char *) o2_n + 1);
l0001663C:
											Eq_n l1_n = optarg;
											g_t2B2C0 = l1_n;
											l7 = 0x00;
											while (true)
											{
												int32 o0_n = (int32) *l1_n;
												if (o0_n == 0x00 || o0_n == 0x3D)
													break;
												l1_n = (word32) l1_n + 1;
											}
											struct Eq_n * i3_n = i6_n->ptr0050;
											if (i3_n->dw0000 != 0x00)
											{
												ptr32 l2_n = 0x00;
l00016670:
												Eq_n o1_n = g_t2B2C0;
												if (strncmp(i3_n->dw0000, o1_n, l1_n - o1_n) != 0x00)
												{
													++i3_n;
													goto l000166BC;
												}
												l0_n = l1_n - g_t2B2C0;
												if (l0_n - (uint32) strlen(i3_n->dw0000) != 0x00)
												{
													if (l3_n == null)
													{
														l3_n = i3_n;
														l7 = l2_n;
													}
													else
														l4_n = 0x01;
													++i3_n;
l000166BC:
													if (i3_n->dw0000 == 0x00)
														goto l000166CC;
													++l2_n;
													goto l00016670;
												}
												l3_n = i3_n;
												l7 = l2_n;
												i0_n = 0x01;
											}
l000166CC:
											bool v51_n;
											if (l4_n != 0x00)
											{
												if (i0_n == 0x00)
												{
													if (opterr != 0x00)
													{
														ptr32 * o1_n = optind;
														fprintf(&g_t2B640, "%s: option `-W %s' is ambiguous\n", i1_n[0], i1_n[o1_n]);
													}
													uint32 o0_n = (uint32) strlen(g_t2B2C0);
													ptr32 * o2_n = optind;
													g_t2B2C0 = (word32) g_t2B2C0 + o0_n;
													optind = (ptr32 *) ((char *) o2_n + 1);
													goto l00016978;
												}
												v51_n = l3_n == null;
											}
											else
												v51_n = l3_n == null;
											if (v51_n)
											{
												g_t2B2C0.u0 = 0x00;
												goto l00016978;
											}
											if ((int32) *l1_n == 0x00)
											{
												word32 o0_n = l3_n->dw0004;
												if (o0_n == 0x01)
												{
													ptr32 * o2_n = optind;
													if (o2_n - i6_n->ptr0044 >= 0x00)
													{
														if (opterr != 0x00)
															fprintf(&g_t2B640, "%s: option `%s' requires an argument\n", i1_n[0], (i1_n + (o2_n << 0x02) / 4)[-1]);
														g_t2B2C0 = (word32) g_t2B2C0 + (uint32) strlen(g_t2B2C0);
														o0_n = (int32) *i2_n;
														goto l00016388;
													}
													optarg = i1_n[o2_n];
													optind = (ptr32 *) ((char *) o2_n + 1);
												}
												goto l00016840;
											}
											word32 o0_n = l3_n->dw0004;
											if (o0_n != 0x00)
											{
												Eq_n o0_n = (word32) l1_n + 1;
												optarg = o0_n;
l00016840:
												Eq_n o1_n = (word32) g_t2B2C0 + (uint32) strlen(g_t2B2C0);
												if (i4_n != null)
												{
													g_t2B2C0 = o1_n;
													*i4_n = l7;
												}
												else
													g_t2B2C0 = o1_n;
												o1_n = l3_n->ptr0008;
												if (o1_n == null)
													goto l00016978;
												o0_n = l3_n->t000C;
l00016874:
												*o1_n = (union Eq_n *) o0_n;
												goto l00016978;
											}
											if (opterr != 0x00)
												fprintf(&g_t2B640, "%s: option `-W %s' doesn't allow an argument\n", i1_n[0], l3_n->dw0000);
											g_t2B2C0 = (word32) g_t2B2C0 + (uint32) strlen(g_t2B2C0);
l00016978:
											l6Out = 0x0002B000;
											l7Out = l7;
											i6Out = i6_n;
											return l0_n;
										}
										if (opterr != 0x00)
											fprintf(&g_t2B640, "%s: option requires an argument -- %c\n", i1_n[0], l0_n);
										optopt = l0_n;
										(int32) *i2_n != 0x3A;
l00016974:
										goto l00016978;
									}
									o0_n = o1_n << 0x18;
								}
								else
								{
									ui32 o1_n = (ui32) o0_n->b0001;
									o0_n = o1_n << 0x18;
								}
								if (o0_n >> 0x18 != 0x3A)
									goto l00016974;
								Eq_n o1_n;
								ptr32 * o0_n;
								if ((int32) o0_n->b0002 == 0x3A)
								{
									o1_n = g_t2B2C0;
									if ((int32) *o1_n == 0x00)
									{
										optarg.u0 = 0x00;
										goto l0001696C;
									}
									o0_n = optind;
								}
								else
								{
									o1_n = g_t2B2C0;
									if ((int32) *o1_n == 0x00)
									{
										ptr32 * o2_n = optind;
										if (o2_n - i6_n->ptr0044 == 0x00)
										{
											if (opterr != 0x00)
												fprintf(&g_t2B640, "%s: option requires an argument -- %c\n", i1_n[0], (int32) (byte) i0_n);
											optopt.u1 = (int32) (byte) i0_n;
											(int32) *i2_n != 0x3A;
										}
										else
										{
											optarg = i1_n[o2_n];
											optind = (ptr32 *) ((char *) o2_n + 1);
										}
l0001696C:
										g_t2B2C0.u0 = 0x00;
										goto l00016970;
									}
									o0_n = optind;
								}
								optarg = o1_n;
								optind = (ptr32 *) ((char *) o0_n + 1);
								goto l0001696C;
							}
							if (my_index(i2_n, o1_n) != null)
							{
								o1_n = g_t2B2C0;
								goto l000164A0;
							}
						}
						l2_n = g_t2B2C0;
						goto l00016114;
					}
					o0_n = g_dw2B2D0;
				}
				else
					o0_n = g_dw2B2D0;
				if (o0_n != 0x00)
				{
					ptr32 * o0_n = (char *) o2_n + 1;
					optarg = o3_n;
					optind = o0_n;
					goto l00016978;
				}
			}
			goto l00016978;
		}
		ptr32 * o0_n;
		ptr32 * o1_n;
		ptr32 * o2_n = g_ptr2B300;
		ptr32 * o0_n = optind;
		if (g_ptr2B2F0 - o2_n != 0x00)
		{
			optind = (ptr32 *) ((char *) o0_n + 1);
			if (o2_n - ((char *) o0_n + 1) != 0x00)
			{
				i1_n = exchange(i1_n, out i2_n, out i4_n, out i5_n, out i6_n);
				o0_n = i6_n->ptr0044;
				goto l00016000;
			}
			o1_n = g_ptr2B2F0;
		}
		else
		{
			optind = (ptr32 *) ((char *) o0_n + 1);
			o1_n = g_ptr2B2F0;
		}
		if (o1_n - g_ptr2B300 == 0x00)
		{
			g_ptr2B2F0 = optind;
			o0_n = i6_n->ptr0044;
		}
		else
			o0_n = i6_n->ptr0044;
l00016000:
		g_ptr2B300 = o0_n;
		optind = o0_n;
		goto l00016008;
	}
	ptr32 * o0_n;
	ptr32 * o1_n = g_ptr2B300;
	if (g_ptr2B2F0 - o1_n != 0x00)
	{
		word32 g0_n = o1_n - o2_n;
		if (g0_n != 0x00)
		{
			i1_n = exchange(i1_n, out i2_n, out i4_n, out i5_n, out i6_n);
			goto l00015F24;
		}
		o0_n = g_ptr2B300;
	}
	else
		o0_n = g_ptr2B300;
	ptr32 * o1_n = optind;
	if (o0_n - o1_n != 0x00)
		g_ptr2B2F0 = o1_n;
l00015F24:
	ptr32 * o2_n = optind;
	bool v42_n = o2_n - i6_n->ptr0044 >= 0x00;
	while (!v42_n)
	{
		ptr32 * o0_n;
		Eq_n o0_n = i1_n[o2_n];
		if ((int32) *o0_n == 0x2D)
		{
			if ((int32) *((word32) o0_n + 1) != 0x00)
				break;
			o0_n = optind;
		}
		else
			o0_n = optind;
		ptr32 * o0_n = (char *) o0_n + 1;
		ptr32 * o1_n = i6_n->ptr0044;
		optind = o0_n;
		o2_n = o0_n;
		v42_n = o0_n - o1_n >= 0x00;
	}
	g_ptr2B300 = o2_n;
	goto l00015F78;
}

// 00016980: void getopt(Register (ptr32 (arr Eq_n)) o1, Register (ptr32 int8) o2)
void getopt(Eq_n (* o1)[], int8 * o2)
{
	word32 l6_n;
	word32 l7_n;
	word32 i6_n;
	_getopt_internal(o1, o2, null, 0x00, out l6_n, out l7_n, out i6_n);
}

// 000169A8: Register word32 getopt_long(Register (ptr32 (arr Eq_n)) o1, Register (ptr32 int8) o2, Register (ptr32 ptr32) o4, Register out ptr32 l6Out, Register out ptr32 l7Out, Register out ptr32 i6Out)
// Called from:
//      main
word32 getopt_long(Eq_n (* o1)[], int8 * o2, ptr32 * o4, ptr32 & l6Out, ptr32 & l7Out, ptr32 & i6Out)
{
	ptr32 i6_n;
	ptr32 l6_n;
	ptr32 l7_n;
	word32 l0_n = _getopt_internal(o1, o2, o4, 0x00, out l6_n, out l7_n, out i6_n);
	l6Out = l6_n;
	l7Out = l7_n;
	i6Out = i6_n;
	return l0_n;
}

// 000169D0: void getopt_long_only(Register (ptr32 (arr Eq_n)) o1, Register (ptr32 int8) o2, Register (ptr32 ptr32) o4)
void getopt_long_only(Eq_n (* o1)[], int8 * o2, ptr32 * o4)
{
	word32 l6_n;
	word32 l7_n;
	word32 i6_n;
	_getopt_internal(o1, o2, o4, 0x01, out l6_n, out l7_n, out i6_n);
}

// 000169F8: Register Eq_n pexecute(Register Eq_n o0, Register (ptr32 Eq_n) o1, Register word32 o3, Register (ptr32 word32) o4, Register (ptr32 word32) o5, Register Eq_n l1, Stack ui32 dwArg5C, Register out ptr32 l0Out, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
Eq_n pexecute(Eq_n o0, pid_t * o1, word32 o3, word32 * o4, word32 * o5, Eq_n l1, ui32 dwArg5C, ptr32 & l0Out, ptr32 & i6Out)
{
	<anonymous> * o0_n;
	if ((dwArg5C & 0x04) != 0x00)
		o0_n = &g_t27E3C;
	else
		o0_n = &g_t27E48;
	if ((dwArg5C & 0x01) != 0x00)
		g_t2B310.u0 = 0x00;
	Eq_n dwLoc24_n;
	Eq_n i0_n;
	word32 o0_n;
	Eq_n o0_n = g_t2B310;
	if ((dwArg5C & 0x02) == 0x00)
	{
		if (pipe(fp + ~0x17) < 0x00)
		{
			o0_n = 0x00017B18;
			goto l00016B10;
		}
		g_t2B310 = dwLoc18;
		dwLoc24_n = dwLoc14;
	}
	else
	{
		g_t2B310.u0 = 0x00;
		dwLoc24_n.u0 = 0x01;
	}
	uint32 dwLoc2C_n = 0x01;
	int32 dwLoc28_n = 0x00;
	while (true)
	{
		bool v26_n;
		if (dwLoc28_n > 0x03)
			break;
		Eq_n o0_n = vfork();
		l1 = o0_n;
		if (o0_n >= 0x00)
		{
			v26_n = o0_n == ~0x00;
			goto l00016AEC;
		}
		sleep(dwLoc2C_n);
		dwLoc2C_n <<= 0x01;
		++dwLoc28_n;
	}
	v26_n = l1 == ~0x00;
l00016AEC:
	if (!v26_n)
	{
		if (l1 == 0x00)
		{
			if (o0_n != 0x00)
			{
				close(0x00);
				dup(o0_n);
				close(o0_n);
			}
			if (dwLoc24_n != 0x01)
			{
				close(0x01);
				dup(dwLoc24_n);
				close(dwLoc24_n);
			}
			Eq_n o0_n = g_t2B310;
			if (o0_n != 0x00)
				close(o0_n);
			struct Eq_n * i6_n;
			o0_n();
			fprintf(&g_t2B640, "%s: ", i6_n->ptr004C);
			fprintf(&g_t2B640, install_error_msg, 0x00);
			char * o0_n = errno;
			xstrerror(o0_n);
			fprintf(&g_t2B640, ": %s\n", o0_n);
			exit(~0x00);
		}
		if (o0_n != 0x00)
			close(o0_n);
		if (dwLoc24_n != 0x01)
		{
			close(dwLoc24_n);
			i0_n = l1;
		}
		else
			i0_n = l1;
l00016C24:
		l0Out = 0x0002B000;
		i6Out = fp;
		return i0_n;
	}
	o0_n = 0x00017B20;
l00016B10:
	*o4 = o0_n;
	*o5 = 0x00;
	i0_n = ~0x00;
	goto l00016C24;
}

// 00016C2C: Register word32 pwait(Register (ptr32 int32) o1, Register out ptr32 i2Out, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
word32 pwait(int32 * o1, ptr32 & i2Out, ptr32 & i6Out)
{
	wait(o1);
	i2Out = o2;
	i6Out = fp;
	return o0;
}

// 00016C40: Register Eq_n mkstemps(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      make_temp_file
Eq_n mkstemps(Eq_n o0, Eq_n o1)
{
	Eq_n i0_n;
	Eq_n o0_n = (uint32) strlen(o0);
	if (o0_n - ((word32) o1 + 6) >= 0x00)
	{
		Eq_n o0_n = o0_n - ((word32) o1 + 6);
		if (strncmp(o0 + o0_n, 0x00017B78, 0x06) != 0x00)
			i0_n.u0 = ~0x00;
		else
		{
			gettimeofday(fp + ~0x17, null);
			Eq_n o0_n = getpid();
			ui32 o1_n = dwLoc14 >> 0x1F << 0x10;
			ui32 o5_n = dwLoc14 << 0x10 ^ dwLoc18 ^ o0_n;
			Eq_n o4_n = (dwLoc14 >> 0x10 | o1_n) ^ dwLoc18 >> 0x1F ^ o0_n >> 0x1F;
			g_qw2B400 = (word64) ((bool) (o1_n + o5_n < 0x00) + ((word32) o4_n + g_qw2B400));
			int32 l1_n = dwLoc18;
			word32 o7_n = 0x0002B400;
			union Eq_n * l4_n = &g_qw2B400;
			while (true)
			{
				Eq_n l0_n = *l4_n;
				byte * i1_n;
				int32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				word32 l1_n;
				word32 l0_n;
				ptr32 l2_n;
				__urem64();
				*i1_n = (byte) (ui32) (l2_n + o1_n);
				word32 o0_n;
				word32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				__udiv64();
				struct Eq_n * i1_n;
				int32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				word32 l1_n;
				word32 l0_n;
				ptr32 l2_n;
				__urem64();
				i1_n->b0001 = (byte) (ui32) (l2_n + o1_n);
				word32 o0_n;
				word32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				__udiv64();
				struct Eq_n * i1_n;
				int32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				word32 l1_n;
				word32 l0_n;
				ptr32 l2_n;
				__urem64();
				i1_n->b0002 = (byte) (ui32) (l2_n + o1_n);
				word32 o0_n;
				word32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				__udiv64();
				struct Eq_n * i1_n;
				int32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				word32 l1_n;
				word32 l0_n;
				ptr32 l2_n;
				__urem64();
				i1_n->b0003 = (byte) (ui32) (l2_n + o1_n);
				word32 o0_n;
				word32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				__udiv64();
				struct Eq_n * i1_n;
				int32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				word32 l1_n;
				word32 l0_n;
				ptr32 l2_n;
				__urem64();
				i1_n->b0004 = (byte) (ui32) (l2_n + o1_n);
				word32 o0_n;
				word32 o1_n;
				word32 o4_n;
				word32 o5_n;
				word32 o7_n;
				__udiv64();
				Eq_n i0_n;
				struct Eq_n * i1_n;
				int32 o1_n;
				up32 o3_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l0_n;
				int32 l5_n;
				ptr32 l2_n;
				__urem64();
				i1_n->b0005 = (byte) (ui32) (l2_n + o1_n);
				Eq_n o0_n = open(i0_n, 0x0502);
				if (o0_n >= 0x00)
					break;
				Eq_n o2_n = *l4_n;
				word32 o2_n = o2_n + (o3_n <u 7777);
				if (l3_n + 0x01 - l5_n > 0x00)
				{
					*l4_n = (union Eq_n *) o2_n;
					*i0_n = 0x00;
					goto l00016E58;
				}
				*l4_n = (union Eq_n *) o2_n;
			}
			i0_n = o0_n;
		}
	}
	else
	{
l00016E58:
		i0_n.u0 = ~0x00;
	}
	return i0_n;
}

// 00016E64: Register word32 fn00016E64(Register word32 o7, Register word32 l7)
// Called from:
//      __do_global_ctors_aux
word32 fn00016E64(word32 o7, word32 l7)
{
	return o7 + l7;
}

// 00016E6C: Register (ptr32 word32) __do_global_ctors_aux(Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7)
// Called from:
//      _init
word32 * __do_global_ctors_aux(word32 o3, word32 o4, word32 o5, word32 o7)
{
	word32 * l0_n;
	struct Eq_n * o1_n = fn00016E64(o7, 0x00010D08)->ptr0014;
	word32 o2_n = o1_n->dwFFFFFFFC;
	if (o2_n != ~0x00)
	{
		l0_n = &o1_n->dwFFFFFFFC;
		do
		{
			<anonymous> * o0_n = *l0_n;
			o0_n();
		} while (*l0_n != (<anonymous> *) ~0x00);
	}
	else
		l0_n = &o1_n->dwFFFFFFFC;
	return l0_n;
}

// 00016EBC: void init_dummy()
void init_dummy()
{
}

