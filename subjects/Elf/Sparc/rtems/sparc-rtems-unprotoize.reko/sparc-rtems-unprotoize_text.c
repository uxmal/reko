// sparc-rtems-unprotoize_text.c
// Generated by decompiling sparc-rtems-unprotoize
// using Reko decompiler version 0.11.5.0.

#include "sparc-rtems-unprotoize.h"

// 00011498: void _start(Register (ptr32 Eq_n) g1, Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7, Stack Eq_n tArg44)
void _start(void (* g1)(), word32 o3, word32 o4, word32 o5, word32 o7, Eq_n tArg44)
{
	if (g1 == null)
	{
		atexit(&g_t16EE4);
		_environ = (char *) &tArg44 + ((_init(o3, o4, o5, o7) << 0x02) + 0x04);
		exit(main(&tArg44));
	}
	else
		atexit(g1);
}

// 0001150C: Register word32 fn0001150C(Register word32 o7, Register word32 l7)
// Called from:
//      __do_global_dtors_aux
//      frame_dummy
word32 fn0001150C(word32 o7, word32 l7)
{
	return o7 + l7;
}

// 00011514: void __do_global_dtors_aux(Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7)
// Called from:
//      _fini
void __do_global_dtors_aux(word32 o3, word32 o4, word32 o5, word32 o7)
{
	struct Eq_n * l7_n = fn0001150C(o7, 0x00016660);
	if (*l7_n->ptr0008 != 0x00)
		return;
	word32 ** o2_n = l7_n->ptr0004;
	if (**o2_n != 0x00)
	{
		word32 ** l0_n = o2_n;
		struct Eq_n * o0_n = (struct Eq_n *) ((char *) *o2_n + 4);
		while (true)
		{
			*l0_n = (word32 **) o0_n;
			<anonymous> * o1_n = o0_n->dwFFFFFFFC;
			o1_n();
			word32 * o0_n = *l0_n;
			if (*o0_n == 0x00)
				break;
			o0_n = (struct Eq_n *) (o0_n + 1);
		}
	}
	if (l7_n->dw001C == 0x00)
		*l7_n->ptr0008 = 0x01;
	else
		__deregister_frame_info(l7_n->dw000C, 0x0C);
}

// 000115CC: void fini_dummy()
void fini_dummy()
{
}

// 000115D8: void frame_dummy(Register word32 o7)
// Called from:
//      _init
void frame_dummy(word32 o7)
{
	struct Eq_n * l7_n = fn0001150C(o7, 0x0001659C);
	if (l7_n->dw0018 == 0x00)
		return;
	__register_frame_info(l7_n->dw000C, 0x0C, l7_n->dw0010, 0x00, 0x10);
}

// 00011620: void init_dummy()
void init_dummy()
{
}

// 0001162C: Register Eq_n notice(Register Eq_n o0, Register (ptr32 Eq_n) o1, Stack word32 dwArg48, Register out (ptr32 Eq_n) i1Out, Register out (ptr32 Eq_n) i2Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      xmalloc
//      xrealloc
//      fancy_abort
//      safe_write
//      usage
//      abspath
//      find_file
//      aux_info_corrupted
//      save_def_or_dec
//      gen_aux_info_file
//      process_aux_info_file
//      declare_source_confusing
//      edit_fn_declaration
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
//      edit_file
//      main
Eq_n notice(Eq_n o0, struct stat * o1, word32 dwArg48, struct stat & i1Out, struct Eq_n & i2Out, struct Eq_n & i6Out)
{
	dwArg48 = o1;
	vfprintf(&g_t2B640, o0, &dwArg48);
	i1Out = o1;
	struct Eq_n * o2;
	i2Out = o2;
	struct Eq_n * fp;
	i6Out = fp;
	return o0;
}

// 00011660: void xstrerror(Register Eq_n o0)
// Called from:
//      safe_write
//      find_file
//      gen_aux_info_file
//      process_aux_info_file
//      main
//      pexecute
void xstrerror(Eq_n o0)
{
	strerror(o0);
}

// 00011674: Register word32 xmalloc(Register out ptr32 i1Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
// Called from:
//      savestring
//      savestring2
//      dupnstr
//      string_list_cons
//      lookup
//      unexpand_if_needed
//      shortpath
//      find_file
//      save_def_or_dec
//      munge_compile_params
//      process_aux_info_file
//      main
//      getpwd
//      choose_temp_base
//      make_temp_file
word32 xmalloc(ptr32 & i1Out, ptr32 & i2Out, ptr32 & i6Out)
{
	word32 o0;
	if (malloc((size_t) o0) != null)
	{
		ptr32 o1;
		i1Out = o1;
		ptr32 o2;
		i2Out = o2;
		ptr32 fp;
		i6Out = fp;
		return o0;
	}
	else
	{
		word32 dwLoc28;
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(0x000170A8, g_ptr28150, dwLoc28, out i1_n, out i2_n, out i6_n);
		exit(33);
	}
}

// 000116B0: Register Eq_n xrealloc(Register Eq_n o0, Register out ptr32 i1Out, Register out ptr32 i2Out)
// Called from:
//      unexpand_if_needed
//      output_bytes
Eq_n xrealloc(Eq_n o0, ptr32 & i1Out, ptr32 & i2Out)
{
	bool v24_n;
	ptr32 o1;
	if (o0 != 0x00)
		v24_n = realloc(o0, (size_t) o1) != null;
	else
		v24_n = malloc((size_t) o1) != null;
	if (v24_n)
	{
		i1Out = o1;
		ptr32 o2;
		i2Out = o2;
		return o0;
	}
	else
	{
		word32 dwLoc28;
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(0x000170A8, g_ptr28150, dwLoc28, out i1_n, out i2_n, out i6_n);
		exit(33);
	}
}

// 00011708: Register (ptr32 char) xfree(Register (ptr32 char) o0)
// Called from:
//      free_def_dec
char * xfree(char * o0)
{
	if (o0 == null)
		return o0;
	free(o0);
}

// 00011728: Register Eq_n savestring(Register Eq_n o0, Register Eq_n o1, Register out Eq_n l0Out, Register out ptr32 i0Out, Register out ptr32 i1Out, Register out ptr32 i6Out)
// Called from:
//      add_symbol
//      unexpand_if_needed
//      abspath
Eq_n savestring(Eq_n o0, Eq_n o1, union Eq_n & l0Out, ptr32 & i0Out, ptr32 & i1Out, ptr32 & i6Out)
{
	ptr32 i1_n;
	word32 i2_n;
	ptr32 i6_n;
	xmalloc(out i1_n, out i2_n, out i6_n);
	strcpy((word32) o1 + 1, o0);
	l0Out = o0;
	i0Out = (word32) o1 + 1;
	i1Out = i1_n;
	i6Out = i6_n;
	return (word32) o1 + 1;
}

// 0001174C: Register (ptr32 Eq_n) savestring2(Register (ptr32 Eq_n) o0, Register uint32 o1, Register word32 o3)
// Called from:
//      gen_aux_info_file
struct stat * savestring2(struct stat * o0, uint32 o1, word32 o3)
{
	word32 i1_n;
	char * i2_n;
	word32 i6_n;
	xmalloc(out i1_n, out i2_n, out i6_n);
	word32 o0_n = o1 + o3;
	strcpy(o0_n + 0x01, o0);
	strcpy(o0_n + 0x01 + i1_n, i2_n);
	return o0_n + 0x01;
}

// 00011780: void fancy_abort()
void fancy_abort()
{
	word32 dwLoc28;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice(94408, g_ptr28150, dwLoc28, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000117A0: Register Eq_n dupnstr(Register Eq_n o0, Register Eq_n o1, Register out Eq_n l0Out, Register out (ptr32 Eq_n) i0Out, Register out ptr32 i6Out)
// Called from:
//      save_def_or_dec
//      munge_compile_params
//      edit_formals_lists
Eq_n dupnstr(Eq_n o0, Eq_n o1, union Eq_n & l0Out, struct Eq_n & i0Out, ptr32 & i6Out)
{
	int32 i1_n;
	word32 i2_n;
	ptr32 i6_n;
	xmalloc(out i1_n, out i2_n, out i6_n);
	strncpy(o1.u1->a0001, o0, i1_n);
	o1.u1->a0001[i1_n] = 0x00;
	l0Out = o0;
	i0Out = (struct Eq_n *) o1.u1->a0001;
	i6Out = i6_n;
	return o1.u1->a0001;
}

// 000117CC: Register (ptr32 int8) substr(Register (ptr32 int8) o0, Register (ptr32 int8) o1)
// Called from:
//      other_variable_style_function
int8 * substr(int8 * o0, int8 * o1)
{
	int32 g2_n = (int32) *o0;
	if (g2_n != 0x00)
	{
		int8 * o3_n = o1;
		int32 g3_n = (int32) *o1;
		if (g3_n == 0x00)
			return o0;
		int8 * o2_n = o0;
		while ((int32) *o2_n == g3_n)
		{
			++o3_n;
			g3_n = (int32) *o3_n;
			if (g3_n == 0x00)
			{
				++o0;
				return o0;
			}
			++o2_n;
		}
	}
	else
	{
		o0 = null;
		return o0;
	}
}

// 00011828: Register Eq_n safe_read(Register Eq_n o0, Register Eq_n o1, Register Eq_n o2, Register out (ptr32 Eq_n) l1Out, Register out Eq_n l2Out)
// Called from:
//      process_aux_info_file
Eq_n safe_read(Eq_n o0, Eq_n o1, Eq_n o2, struct stat & l1Out, union Eq_n & l2Out)
{
safe_read_entry:
	i1_n = o1
	l0_n = o2
	goto l00011840
l00011828:
l0001183C:
	i1_n = i1_n + o0_n
l00011840:
	v28_n = l0_n <= 0x00
l00011844:
	branch v28_n l00011848_ds_t
l00011848_ds_f:
	o0_n.u1 = (uint32) read(o0, i1_n, (size_t) l0_n)
	branch o0_n >= 0x00 l00011860_ds_t
	goto l00011860_ds_f
l0001184C:
l00011860_ds_f:
	o0_n.u0 = errno.u0
	branch o0_n == 0x04 l0001186C_ds_t
	goto l0001186C_ds_f
l00011860_ds_t:
	branch o0_n != 0x00 l00011878_ds_t
l00011864:
l0001186C_ds_f:
	branch l0_n != 0x00 l00011878_ds_t
l0001186C_ds_t:
	v28_n = l0_n <= 0x00
	goto l00011844
l00011870:
l00011874:
l00011878_ds_t:
	l0_n = l0_n - o0_n
	goto l0001183C
l00011878_ds_t:
	l0_n = l0_n - o0_n
	goto l0001183C
l0001187C:
l00011880:
	l1Out = (struct stat *) &g_qw2B400
	l2Out = o0
	return l0_n
safe_read_exit:
}

// 00011888: void safe_write(Register int32 o0, Register (ptr32 void) o1, Register int32 o2, Register Eq_n o3)
void safe_write(int32 o0, void * o1, int32 o2, Eq_n o3)
{
	void * i1_n = o1;
	int32 i2_n = o2;
	if (o2 > 0x00)
	{
		do
		{
			Eq_n o0_n;
			o0_n.u1 = (uint32) write(o0, i1_n, (size_t) i2_n);
			if (o0_n < 0x00)
			{
				if (errno.u0 != 0x04)
				{
					word32 l0_n;
					struct stat * l1_n;
					Eq_n l2_n;
					ui32 l3_n;
					word32 l4_n;
					word32 i0_n;
					shortpath(0x00, o3, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
					xstrerror(l2_n);
					struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					notice(l3_n | 0xE0, l1_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
					return;
				}
			}
			else
			{
				i2_n -= o0_n;
				i1_n += o0_n;
			}
		} while (i2_n > 0x00);
	}
}

// 00011914: void save_pointers()
// Called from:
//      edit_fn_declaration
//      edit_fn_definition
void save_pointers()
{
	uint32 o1_n = g_dw28210;
	g_dw2B280 = g_dw281E0;
	g_dw2B290 = o1_n;
}

// 00011938: void restore_pointers()
// Called from:
//      edit_fn_declaration
//      edit_fn_definition
void restore_pointers()
{
	uint32 o1_n = g_dw2B290;
	g_dw281E0 = g_dw2B280;
	g_dw28210 = o1_n;
}

// 0001195C: Register int32 is_id_char(Register int32 o0)
// Called from:
//      unexpand_if_needed
//      save_def_or_dec
//      edit_formals_lists
//      scan_for_missed_items
int32 is_id_char(int32 o0)
{
	int32 g2_n;
	if (((ui32) (o0 & 0xFF).u1->b2B411 & 0x07) == 0x00)
	{
		g2_n = 0x00;
		if ((o0 & 0xFF) != 0x5F)
		{
			ui32 g0_n = (o0 & 0xFF) - 0x24;
			if (g0_n != 0x00)
				return g2_n;
		}
	}
	g2_n = 0x01;
	return g2_n;
}

// 00011998: void usage()
// Called from:
//      main
void usage()
{
	word32 dwLoc28;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice(0x00017108, g_ptr28150, dwLoc28, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000119BC: Register Eq_n in_system_include_dir(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n in_system_include_dir(Eq_n o0)
{
	if ((int32) *o0 == 0x2F)
	{
		Eq_n i0_n;
		if (g_ptr27ED0 != null)
		{
			struct Eq_n * l1_n = (struct Eq_n *) &g_ptr27ED0;
			char * l0_n = g_ptr27ED0;
			while (true)
			{
				if (strncmp(o0, l0_n, (uint32) strlen(l0_n)) == 0x00)
				{
					if ((int32) *((word32) o0 + (uint32) strlen(l1_n->ptr0000)) == 0x2F)
					{
						i0_n.u0 = 0x01;
						return i0_n;
					}
					++l1_n;
				}
				else
					++l1_n;
				if (l1_n->ptr0000 == 0x00)
					break;
				l0_n = l1_n->ptr0000;
			}
		}
		i0_n.u0 = 0x00;
		return i0_n;
	}
	else
		abort();
}

// 00011A4C: Register (ptr32 Eq_n) needs_to_be_converted(Register (ptr32 Eq_n) o0)
// Called from:
//      edit_file
struct Eq_n * needs_to_be_converted(struct Eq_n * o0)
{
	struct Eq_n * g3_n = o0->ptr0004;
	struct Eq_n * o0_n;
	if (g3_n != null)
	{
		int32 g2_n = (int32) g3_n->b0020;
		while (g2_n == 0x00)
		{
			g3_n = g3_n->ptr0000;
			if (g3_n == null)
			{
				o0_n = null;
				return o0_n;
			}
			g2_n = (int32) g3_n->b0020;
		}
		o0_n = (struct Eq_n *) ~0x00;
	}
	else
		o0_n = null;
	return o0_n;
}

// 00011A88: Register Eq_n directory_specified_p(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n directory_specified_p(Eq_n o0)
{
	struct Eq_n * l1_n = directory_list;
	Eq_n i0_n;
	if (l1_n == null)
	{
		i0_n.u0 = 0x00;
		return i0_n;
	}
	else
	{
		char * l0_n = l1_n->ptr0000;
		while (true)
		{
			if (strncmp(o0, l0_n, (uint32) strlen(l0_n)) == 0x00)
			{
				if ((int32) *((word32) o0 + (uint32) strlen(l1_n->ptr0000)) == 0x2F)
				{
					struct Eq_n * o0_n = (struct Eq_n *) (o0.u2 + (uint32) strlen(l1_n->ptr0000));
					if ((int32) o0_n->b0001 == 0x00)
					{
l00011B1C:
						i0_n.u0 = 0x01;
						return i0_n;
					}
					int8 * o2_n = &o0_n->b0001;
					bool v25_n = (int32) o0_n->b0001 == 0x2F;
					while (!v25_n)
					{
						++o2_n;
						int32 o0_n = (int32) *o2_n;
						if (o0_n == 0x00)
							goto l00011B1C;
						v25_n = o0_n == 0x2F;
					}
					l1_n = l1_n->ptr0004;
				}
				else
					l1_n = l1_n->ptr0004;
			}
			else
				l1_n = l1_n->ptr0004;
			if (l1_n == null)
			{
				i0_n.u0 = 0x00;
				return i0_n;
			}
			l0_n = l1_n->ptr0000;
		}
	}
}

// 00011B40: Register Eq_n file_excluded_p(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n file_excluded_p(Eq_n o0)
{
	Eq_n o0_n;
	o0_n.u1 = (uint32) strlen(o0);
	struct Eq_n * l0_n = exclude_list;
	Eq_n i0_n;
	if (l0_n != null)
	{
		ptr32 l2_n = o0 + o0_n;
		do
		{
			if (strcmp(l2_n - (uint32) strlen(l0_n->ptr0000), l0_n->ptr0000) == 0x00)
			{
				if (CONVERT(Mem0[o0_n - CONVERT(strlen(l0_n->ptr0000), size_t, uint32) + o0 + -1:int8], int8, int32) == 0x2F)
				{
					i0_n.u0 = 0x01;
					return i0_n;
				}
				l0_n = l0_n->ptr0004;
			}
			else
				l0_n = l0_n->ptr0004;
		} while (l0_n != null);
		i0_n.u0 = 0x00;
	}
	else
		i0_n.u0 = 0x00;
	return i0_n;
}

// 00011BC8: Register word32 string_list_cons(Register out ptr32 i6Out)
// Called from:
//      main
word32 string_list_cons(ptr32 & i6Out)
{
	word32 i1_n;
	word32 i2_n;
	ptr32 i6_n;
	*(union Eq_n *) 0x08 = xmalloc(out i1_n, out i2_n, out i6_n);
	*(word32 *) 0x0C = i1_n;
	i6Out = i6_n;
	return 0x08;
}

// 00011BE4: Register (ptr32 Eq_n) visit_each_hash_node(Register (ptr32 Eq_n) o0)
// Called from:
//      do_processing
struct Eq_n * visit_each_hash_node(struct Eq_n * o0)
{
	struct Eq_n * i0_n = o0;
	struct Eq_n * l0;
	if (o0 < o0 + 0x0200)
	{
		word32 o0_n = o0->dw0004;
		while (true)
		{
			if (o0_n != 0x00)
			{
				l0 = i0_n + 1;
				do
				{
					reverse_def_dec_list(i0_n);
					i0_n = i0_n->dw0000;
				} while (i0_n != null);
			}
			else
				l0 = i0_n + 1;
			i0_n = l0;
			if (l0 >= o0 + 0x0200)
				break;
			o0_n = l0->dw0004;
		}
	}
	return l0;
}

// 00011C3C: Register Eq_n add_symbol(Register Eq_n o0, Register Eq_n o1, Register out ptr32 i1Out, Register out ptr32 i6Out)
// Called from:
//      lookup
Eq_n add_symbol(Eq_n o0, Eq_n o1, ptr32 & i1Out, ptr32 & i6Out)
{
	o0.ptr0000->a0000[0].ptr0000 = (struct Eq_n *) 0x00;
	struct Eq_n * l0_n;
	Eq_n i0_n;
	ptr32 i1_n;
	ptr32 i6_n;
	l0_n->dw0004 = savestring(o1, (uint32) strlen(o1), out l0_n, out i0_n, out i1_n, out i6_n);
	l0_n->dw0008 = 0x00;
	i1Out = i1_n;
	i6Out = i6_n;
	return i0_n;
}

// 00011C6C: Register Eq_n lookup(Register Eq_n o0, Register Eq_n o1, Register out Eq_n l1Out, Register out Eq_n i1Out)
// Called from:
//      find_file
//      save_def_or_dec
Eq_n lookup(Eq_n o0, Eq_n o1, struct Eq_n & l1Out, union Eq_n & i1Out)
{
	Eq_n i1_n = o1;
	ui32 o3_n = 0x00;
	if ((int32) o1.u4->t0000.u1 != 0x00)
	{
		Eq_n o2_n = o1;
		int32 o1_n;
		while (true)
		{
			++o2_n.u4;
			o1_n = (int32) o2_n.u4->t0000.u1;
			if ((int32) o2_n.u4->t0000.u1 == 0x00)
				break;
			o3_n += o1_n;
		}
		o3_n += o1_n;
	}
	ui32 o3_n = o3_n & 0x01FF;
	Eq_n i0_n = (Eq_n) &(o0.ptr0000->a0000 + o3_n)->ptr0000;
	char * o0_n = i0_n.ptr0000->ptr0004;
	Eq_n o0_n;
	if (o0_n == null)
		o0_n = i0_n;
	else
	{
		if (strcmp(o0_n, o1) == 0x00)
			goto l00011D34;
		if (o0.ptr0000->a0000[o3_n].ptr0000 != 0x00)
		{
			i0_n = (Eq_n) i0_n.ptr0000->a0000[0].ptr0000;
			while (strcmp(i0_n.ptr0000->ptr0004, o1) != 0x00)
			{
				if (i0_n.ptr0000->a0000[0].ptr0000 == 0x00)
					goto l00011D1C;
				i0_n = (Eq_n) i0_n.ptr0000->a0000[0].ptr0000;
			}
l00011D34:
			l1Out = o0;
			i1Out = i1_n;
			return i0_n;
		}
l00011D1C:
		word32 i2_n;
		word32 i6_n;
		xmalloc(out i1_n, out i2_n, out i6_n).u3->t0000.u2 = 0x0C;
		o0_n = (Eq_n) 0x0C;
	}
	word32 i6_n;
	i0_n = add_symbol(o0_n, i1_n, out i1_n, out i6_n);
	goto l00011D34;
}

// 00011D3C: void free_def_dec(Register (ptr32 Eq_n) o0)
// Called from:
//      save_def_or_dec
void free_def_dec(struct Eq_n * o0)
{
	xfree(xfree(o0->ptr000C));
}

// 00011D58: void unexpand_if_needed(Register Eq_n o0)
void unexpand_if_needed(Eq_n o0)
{
	Eq_n i0_n = o0;
	word32 i1_n = 0x00;
	if (line_buf.78.u0 == 0x00)
	{
		line_buf_size.79.u0 = 0x0400;
		word32 i2_n;
		word32 i6_n;
		i0_n = xmalloc(out i1_n, out i2_n, out i6_n);
		line_buf.78.u0 = 0x0400;
	}
	Eq_n l1_n;
	if ((int32) i0_n.u3->t0000.u1 == 0x0A)
	{
		l1_n.u0 = line_buf.78.u0;
		goto l00011EC8;
	}
	l1_n.u0 = line_buf.78.u0;
	char * o0_n = (char *) "struct _iobuf";
l00011DA0:
	if (o0_n != null)
	{
		struct Eq_n * l4_n = (struct Eq_n *) &g_ptr16F14;
		char * l0_n = (char *) "struct _iobuf";
		while (true)
		{
			Eq_n o0_n;
			o0_n.u1 = (uint32) strlen(l0_n);
			if ((int8) (i0_n.u3->t0000.u1 - *l0_n) == 0x00)
			{
				if (strncmp(i0_n, l0_n, o0_n) == 0x00)
				{
					if (is_id_char(CONVERT(Mem62[i0_n + o0_n:int8], int8, int32)) == 0x00)
					{
						Eq_n o0_n;
						o0_n.u1 = (uint32) strlen(l4_n->dw0004);
						Eq_n o1_n;
						o1_n.u0 = line_buf.78.u0;
						Eq_n o2_n;
						o2_n.u0 = line_buf_size.79.u0;
						i1_n = 0x01;
						if (l1_n + o0_n - o1_n >= o2_n)
						{
							line_buf_size.79.u0 = (int32) (o0_n.u2 + (o2_n << 0x01));
							word32 i2_n;
							i0_n = xrealloc(o1_n, out i1_n, out i2_n);
							line_buf.78.u0 = (int32) o1_n;
							l1_n = o1_n + (l1_n - o1_n);
						}
						strcpy(l1_n, l4_n->dw0004);
						l1_n += o0_n;
						i0_n += o0_n;
						goto l00011EB8;
					}
					++l4_n;
				}
				else
					++l4_n;
			}
			else
				++l4_n;
			if (l4_n->dw0000 == 0x00)
				break;
			l0_n = l4_n->dw0000;
		}
	}
	Eq_n o1_n;
	o1_n.u0 = line_buf.78.u0;
	Eq_n l0_n = l1_n - o1_n;
	ui32 o0_n;
	if (l0_n == line_buf_size.79.u0)
	{
		line_buf_size.79.u0 = (int32) (l0_n << 0x01);
		word32 i2_n;
		i0_n = xrealloc(o1_n, out i1_n, out i2_n);
		line_buf.78.u0 = (int32) o1_n;
		l1_n = o1_n + l0_n;
		o0_n = (ui32) *i0_n.u2;
	}
	else
		o0_n = (ui32) *i0_n.u2;
	*l1_n.u2 = (byte) o0_n;
	++i0_n.u3;
	++l1_n.u4;
l00011EB8:
	if ((int32) i0_n.u3->t0000.u1 == 0x0A)
	{
l00011EC8:
		Eq_n o2_n;
		o2_n.u0 = line_buf.78.u0;
		Eq_n o1_n;
		o1_n.u0 = line_buf_size.79.u0;
		if (l1_n - &(o2_n.u4)->bFFFFFFFE >= o1_n)
		{
			line_buf_size.79.u0 = (int32) (o1_n << 0x01);
			word32 i2_n;
			xrealloc(o2_n, out i1_n, out i2_n);
			line_buf.78.u0 = (int32) o2_n;
			l1_n = o2_n + (l1_n - o2_n);
		}
		*l1_n.u2 = 0x0A;
		Eq_n l1_n;
		l1_n.u2 = l1_n.u4 + 1;
		if (i1_n == 0x00)
			*l1_n.u2 = 0x00;
		else
		{
			*l1_n.u2 = 0x00;
			Eq_n o0_n;
			o0_n.u0 = line_buf.78.u0;
			word32 l0_n;
			word32 i0_n;
			word32 i1_n;
			word32 i6_n;
			savestring(o0_n, l1_n - o0_n, out l0_n, out i0_n, out i1_n, out i6_n);
		}
		return;
	}
	o0_n = (char *) "struct _iobuf";
	goto l00011DA0;
}

// 00011F34: Register word32 abspath(Register Eq_n o0, Register Eq_n o1, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      shortpath
//      referenced_file_is_newer
//      save_def_or_dec
//      main
word32 abspath(Eq_n o0, Eq_n o1, struct Eq_n & i6Out)
{
	ptr32 fp;
	Eq_n i0_n = o0;
	if (o0 == 0x00)
		i0_n.u0 = g_t2B270.u0;
	Eq_n sp_n = fp + ~0x6F - (CONVERT(strlen(i0_n) + strlen(o1), size_t, size_t) + 0x09 & ~0x07);
	struct Eq_n * o2_n;
	if ((int32) *o1 != 0x2F)
	{
		ui32 o1_n = (ui32) *i0_n.u2;
		sp_n.u2[96] = (struct Eq_n) (byte) o1_n;
		o2_n = (struct Eq_n *) (sp_n.u2 + 97);
		if (o1_n << 0x18 != 0x00)
		{
			byte * i0_n = (byte *) (i0_n.u4 + 1);
			while (true)
			{
				ui32 o0_n = (ui32) *i0_n;
				o2_n->b0000 = (byte) o0_n;
				++i0_n;
				if (o0_n << 0x18 == 0x00)
					break;
				++o2_n;
			}
			++o2_n;
		}
		o2_n->bFFFFFFFF = 0x2F;
	}
	else
		o2_n = (struct Eq_n *) (sp_n.u2 + 96);
	ui32 o0_n = (ui32) *o1.u2;
	o2_n->b0000 = (byte) o0_n;
	byte * i0_n = (word32) o1 + 1;
	byte * o2_n = (byte *) (o2_n + 1);
	if (o0_n << 0x18 != 0x00)
	{
		while (true)
		{
			ui32 o0_n = (ui32) *i0_n;
			*o2_n = (byte) o0_n;
			++i0_n;
			if (o0_n << 0x18 == 0x00)
				break;
			++o2_n;
		}
	}
	Eq_n o2_n;
	o2_n.u1 = sp_n.u2 + 97;
	if ((int32) sp_n.u2[97] != 0x00)
	{
		struct Eq_n * o1_n = (struct Eq_n *) (sp_n.u2 + 97);
		bool v28_n = (int32) sp_n.u2[97] != 0x2F;
l00012024:
		bool v31_n;
		if (!v28_n)
		{
			ui32 o3_n = (ui32) o1_n->b0000;
			if ((int32) o2_n.u2->bFFFFFFFF == 0x2F)
			{
				o1_n = (struct Eq_n *) &o1_n->b0001;
				goto l00012110;
			}
			v31_n = o3_n != 0x2E;
		}
		else
		{
			ui32 o3_n = (ui32) o1_n->b0000;
			v31_n = o3_n != 0x2E;
		}
		ui32 o0_n;
		if (v31_n)
		{
			o0_n = (ui32) o1_n->b0000;
			goto l00012104;
		}
		if ((int32) o2_n.u2->bFFFFFFFF != 0x2F)
		{
			o0_n = (ui32) o1_n->b0000;
			goto l00012104;
		}
		int32 o0_n = (int32) o1_n->b0001;
		if (o0_n != 0x00)
		{
			if (o0_n == 0x2F)
			{
				o1_n = (struct Eq_n *) &o1_n->b0002;
				goto l00012110;
			}
			if (o0_n == 0x2E)
			{
				int32 o0_n = (int32) o1_n->b0002;
				if (o0_n == 0x00 || o0_n == 0x2F)
				{
					struct Eq_n * o0_n;
					if (o0_n == 0x2F)
						o0_n = o1_n + 1;
					else
						o0_n = (struct Eq_n *) &o1_n->b0002;
					Eq_n o2_n;
					o2_n.u1 = (word32) o2_n - 2;
					o1_n = o0_n;
					while (o2_n >= sp_n.u2 + 96 && (int32) (*o2_n.u1) != 0x2F)
						o2_n.u1 = &o2_n.u2->bFFFFFFFF;
					if (o2_n < sp_n.u2 + 96)
					{
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						notice(0x00017148, g_ptr28150, sp_n.u2[72], out i1_n, out i2_n, out i6_n);
						exit(33);
					}
					o2_n.u1 = (word32) o2_n + 1;
					*o2_n.u1 = 0x00;
l00012110:
					int32 o0_n = (int32) o1_n->b0000;
					if (o0_n == 0x00)
						goto l00012120;
					v28_n = o0_n != 0x2F;
					goto l00012024;
				}
				o0_n = (ui32) o1_n->b0000;
			}
			else
				o0_n = (ui32) o1_n->b0000;
l00012104:
			*o2_n.u1 = (byte) o0_n;
			o1_n = (struct Eq_n *) &o1_n->b0001;
			o2_n.u1 = (word32) o2_n + 1;
			goto l00012110;
		}
	}
l00012120:
	if ((int32) o2_n.u2->bFFFFFFFF == 0x2F)
	{
		*o2_n.u1 = 0x00;
		o2_n.u1 = &o2_n.u2->bFFFFFFFF;
		*o2_n.u1 = 0x00;
	}
	else
		*o2_n.u1 = 0x00;
	word32 l0_n;
	word32 i0_n;
	word32 i1_n;
	struct Eq_n * i6_n;
	savestring(sp_n.u2 + 96, o2_n - (sp_n.u2 + 96), out l0_n, out i0_n, out i1_n, out i6_n);
	i6Out = i6_n;
	return l0_n;
}

// 0001214C: Register Eq_n shortpath(Register Eq_n o0, Register Eq_n o1, Register out Eq_n l0Out, Register out Eq_n l1Out, Register out Eq_n l2Out, Register out Eq_n l3Out, Register out Eq_n l4Out, Register out Eq_n i0Out)
// Called from:
//      safe_write
//      find_file
//      gen_aux_info_file
//      process_aux_info_file
//      declare_source_confusing
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
//      edit_file
//      main
Eq_n shortpath(Eq_n o0, Eq_n o1, union Eq_n & l0Out, union Eq_n & l1Out, union Eq_n & l2Out, union Eq_n & l3Out, union Eq_n & l4Out, union Eq_n & i0Out)
{
	word32 i6_n;
	word32 i2_n;
	Eq_n i1_n;
	word32 i6_n;
	Eq_n o0_n;
	o0_n.u1 = (uint32) strlen(o1);
	Eq_n l0_n = abspath(o0, o1, out i6_n);
	Eq_n i0_n = xmalloc(out i1_n, out i2_n, out i6_n);
	Eq_n l2_n;
	l2_n.u0 = 0x00;
	int32 o1_n = (int32) l0_n.u4->t0000.u1;
	Eq_n l1_n = o0_n;
	int32 o0_n;
	while (o1_n != 0x00)
	{
		if (o1_n != (int32) ((i0_n.u3)->t0000).u1)
		{
			o0_n = (int32) l0_n.u4->t0000.u1;
			goto l000121B8;
		}
		++l0_n.u4;
		o1_n = (int32) l0_n.u4->t0000.u1;
		++i0_n.u3;
	}
	o0_n = (int32) l0_n.u4->t0000.u1;
l000121B8:
	Eq_n i0_n;
	bool v32_n;
	if (o0_n == 0x00)
	{
		ui32 o1_n = (ui32) *i0_n.u2;
		int32 o0_n = (int32) (byte) o1_n;
		if (o0_n == 0x00 || o0_n == 0x2F)
		{
			if (o0_n == 0x00)
				i0_n.u0 = 0x00017168;
			else
				i0_n.u2 = i0_n.u3 + 1;
			goto l000122FC;
		}
		v32_n = o1_n == 0x00;
	}
	else
	{
		ui32 o1_n = (ui32) *i0_n.u2;
		v32_n = o1_n == 0x00;
	}
	int32 o0_n;
	if (!v32_n)
	{
		while (true)
		{
			l0_n.u2 = (word32) l0_n - 1;
			if ((int32) l0_n.u4->t0000.u1 == 0x2F)
				break;
			i0_n.u2 = &i0_n.u3->bFFFFFFFF;
		}
		ptr32 i0_n = &i0_n.u3->bFFFFFFFF;
		++l0_n.u4;
		i0_n = i0_n + 0x01;
		l2_n.u0 = 0x01;
l00012238:
		o0_n = (int32) l0_n.u4->t0000.u1;
	}
	else
		o0_n = (int32) l0_n.u4->t0000.u1;
	l1_n = o0_n;
	Mem134 = Mem0;
	if (o0_n == 0x00)
	{
		l0_n = l2_n * 0x03 + (uint32) strlen(i0_n);
		if (l0_n >= o0_n)
		{
			l2_n = (word32) l2_n.u0 - 1;
			goto l00012268;
		}
		l2_n = (word32) l2_n.u0 - 1 + ~0x00;
		if (l2_n != ~0x00)
		{
			while (o0_n * 0x02 > (word32) l1_n + 3)
			{
				l2_n = (word32) l2_n.u0 - 1;
				*l1_n.u2 = 0x2E;
				Eq_n l1_n;
				l1_n.u1 = l1_n.u4 + 1;
				l1_n.u1->b0000 = 0x2E;
				l1_n.u1[1] = (struct Eq_n) 0x2F;
				if (l2_n == 0x00)
				{
					l1_n.u2 = (word32) l1_n + 2;
					goto l000122B8;
				}
				l1_n.u2 = (word32) l1_n + 2;
			}
			l2_n.u0 = l2_n.u0;
l00012268:
			i0_n = i1_n;
			goto l000122FC;
		}
l000122B8:
		while (o0_n * 0x02 > l1_n)
		{
			ui32 o0_n = (ui32) *i0_n.u2;
			*l1_n.u2 = (byte) o0_n;
			++i0_n.u3;
			if (o0_n << 0x18 == 0x00)
			{
				Eq_n l1_n;
				l1_n.u1 = l1_n.u4 + 1;
				l1_n.u2 = (word32) l1_n - 1;
				if ((int32) l1_n.u1->bFFFFFFFE == 0x2F)
					l1_n.u1->bFFFFFFFE = 0x00;
				i0_n = o0_n;
				goto l000122FC;
			}
			++l1_n.u4;
		}
		i0_n = i1_n;
l000122FC:
		l0Out = l0_n;
		l1Out = l1_n;
		l2Out = l2_n;
		l3Out = o0_n;
		l4Out = o0_n;
		i0Out = i0_n;
		return i0_n;
	}
	ui32 o1_n = (ui32) *l0_n.u2;
	if (o1_n == 0x2F)
	{
		++l0_n.u4;
		l2_n = (word32) l2_n.u0 + 1;
	}
	else
		++l0_n.u4;
	goto l00012238;
}

// 00012304: Register Eq_n find_file(Register Eq_n o0, Register out Eq_n l2Out, Register out (ptr32 Eq_n) l3Out, Register out Eq_n i0Out, Register out ptr32 i1Out)
// Called from:
//      referenced_file_is_newer
//      save_def_or_dec
Eq_n find_file(Eq_n o0, union Eq_n & l2Out, struct stat & l3Out, union Eq_n & i0Out, ptr32 & i1Out)
{
	ptr32 i1_n;
	Eq_n l1_n;
	struct Eq_n * o0_n = lookup(164416, o0, out l1_n, out i1_n);
	Eq_n i0_n;
	i0_n.u0 = o0_n->t0008.u0;
	Eq_n l2;
	struct stat * l3;
	if (i0_n != 0x00)
	{
l000123C8:
		l2Out = l2;
		l3Out = l3;
		i0Out = i0_n;
		i1Out = i1_n;
		return i0_n;
	}
	word32 i2_n;
	struct Eq_n * i6_n;
	xmalloc(out i1_n, out i2_n, out i6_n);
	Eq_n l4_n;
	if (i1_n != 0x00)
	{
		l4_n.u0 = 0x0C;
		i6_n->tFFFFFFA8.u0 = 0x00;
	}
	else
	{
		l4_n.u0 = 0x0C;
		if (stat(l1_n, (char *) i6_n - 0x0098) != ~0x00)
		{
			o0_n->t0008.u0 = 0x0C;
l000123B4:
			l4_n.u4->t0000.u2 = o0_n;
			l4_n.u4[4] = (struct Eq_n) null;
			l4_n.u4[8] = (struct Eq_n) i6_n->tFFFFFFA8.u0;
			i0_n = l4_n;
			goto l000123C8;
		}
		Eq_n l0_n;
		word32 l1_n;
		word32 i0_n;
		shortpath(0x00, l1_n, out l0_n, out l1_n, out l2, out l3, out l4_n, out i0_n);
		xstrerror(l2);
		struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
		word32 i2_n;
		i6_n->tFFFFFFA8.u0 = (int32) notice(l0_n, l3, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
	}
	o0_n->t0008.u0 = (int32) l4_n;
	goto l000123B4;
}

// 000123D0: void aux_info_corrupted()
// Called from:
//      check_aux_info
void aux_info_corrupted()
{
	word32 dwLoc28;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice(0x00017190, g_ptr28150, dwLoc28, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000123F8: Register word32 check_aux_info(Register word32 o0, Register out ptr32 i1Out)
// Called from:
//      referenced_file_is_newer
//      save_def_or_dec
word32 check_aux_info(word32 o0, ptr32 & i1Out)
{
	if (o0 != 0x00)
	{
		ptr32 o1;
		i1Out = o1;
		return o0;
	}
	else
		aux_info_corrupted();
}

// 00012418: Register (ptr32 Eq_n) find_corresponding_lparen(Register (ptr32 Eq_n) o0)
// Called from:
//      save_def_or_dec
struct Eq_n * find_corresponding_lparen(struct Eq_n * o0)
{
	int8 * o0_n = &o0->bFFFFFFFF + -1;
	word32 g3_n = 0x01;
	int32 g2_n = (int32) o0->bFFFFFFFF;
l00012424:
	if (g2_n != 0x28)
	{
		int32 g0_n = g2_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = o0_n;
l00012448:
			if (g3_n == 0x00)
				return o0_n + 1;
			g2_n = (int32) *o0_n;
			goto l00012424;
		}
		++g3_n;
	}
	else
		g3_n += ~0x00;
	o0_n += -1;
	goto l00012448;
}

// 0001245C: void referenced_file_is_newer(Register (ptr32 int8) o0)
void referenced_file_is_newer(int8 * o0)
{
	ptr32 fp;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	Eq_n i0_n = check_aux_info(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) (*o0) ^ 0x2F) > 0x00), out i1_n).u3)[1] ^ 0x2A) > 0x00), out i1_n).u3)[2] ^ 0x20) > 0x00), out i1_n);
	Eq_n l1_n;
	if ((int32) i0_n.u3[3] != 0x3A)
	{
		l1_n.u1 = (word32) i0_n + 4;
		while ((int32) *l1_n.u2 != 0x3A)
			++l1_n.u3;
	}
	else
		l1_n.u1 = i0_n.u3 + 3;
	int32 l1_n = l1_n - (i0_n.u3 + 3);
	struct Eq_n * sp_n = fp + ~0x6F - (l1_n + 0x08 & ~0x07);
	strncpy(sp_n->a0060, i0_n.u3 + 3, l1_n);
	Eq_n o0_n;
	o0_n.u0 = g_t28190.u0;
	sp_n->a0060[l1_n] = 0x00;
	word32 i6_n;
	abspath(o0_n, sp_n->a0060, out i6_n);
	word32 l2_n;
	word32 l3_n;
	word32 i0_n;
	int32 i1_n;
	find_file(o0_n, out l2_n, out l3_n, out i0_n, out i1_n)->dw0008 > i1_n;
}

// 0001251C: void save_def_or_dec()
void save_def_or_dec()
{
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	struct Eq_n * i1_n;
	word32 l1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	ptr32 fp;
	word32 i1_n;
	word32 i1_n;
	word32 i1_n;
	word32 i6_n;
	word32 i2_n;
	word32 i1_n;
	Eq_n i0_n = check_aux_info(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) (((xmalloc)(out i1_n, out i2_n, out i6_n).u3)->t0000).u1 ^ 0x2F) > 0x00), out i1_n).u3)[1] ^ 0x2A) > 0x00), out i1_n).u3)[2] ^ 0x20) > 0x00), out i1_n);
	Eq_n i0_n;
	i0_n.u1 = i0_n.u3 + 3;
	if ((int32) i0_n.u3[3] != 0x3A)
	{
		i0_n.u1 = (word32) i0_n + 4;
		while ((int32) *i0_n.u2 != 0x3A)
			i0_n.u1 = (word32) i0_n + 1;
	}
	int32 l1_n = i0_n - (i0_n.u3 + 3);
	struct Eq_n * sp_n = fp + ~0x7F - (l1_n + 0x08 & ~0x07);
	strncpy(sp_n->a0060, i0_n.u3 + 3, l1_n);
	Eq_n o0_n;
	o0_n.u0 = g_t28190.u0;
	sp_n->a0060[l1_n] = 0x00;
	word32 i6_n;
	abspath(o0_n, sp_n->a0060, out i6_n);
	struct Eq_n * l2_n;
	union Eq_n * l3_n;
	Eq_n i0_n;
	word32 i1_n;
	l2_n->ptr0004 = find_file(o0_n, out l2_n, out l3_n, out i0_n, out i1_n);
	Eq_n i0_n;
	if ((int32) i0_n.u2->b0000 != 0x3A)
	{
		i0_n.u2 = i0_n.u2 + 1;
		while ((int32) i0_n.u2->b0000 != 0x3A)
			++i0_n.u2;
	}
	else
		i0_n = i0_n;
	int32 l0_n = i0_n - i0_n;
	strncpy(l3_n, i0_n, l0_n);
	(&l3_n->u0)[l0_n] = 0x00;
	l2_n->t0008.u0 = (int32) atoi(l3_n);
	ui32 o1_n = (ui32) i0_n.u2[1];
	word32 o2_n;
	if ((o1_n + ~0x4D & 0xFF) > 0x01)
	{
		o2_n = 0x00;
		if (o1_n != 0x49)
		{
l00012648:
			Eq_n i0_n = check_aux_info(o2_n, out i1_n);
			l2_n->b0020 = 0x01 - (byte) (((int32) (*i0_n.u2) ^ 0x4E) > 0x00);
			int32 o0_n = (int32) i0_n.u3[1];
			word32 o2_n;
			if (o0_n != 0x43)
			{
				o2_n = 0x00;
				if (o0_n != 0x46)
				{
l00012688:
					Eq_n i0_n = check_aux_info(o2_n, out i1_n);
					if ((int32) *i0_n.u2 != 0x46 && i1_n == 0x00)
						l2_n->dw0014 = 0x00;
					else
						l2_n->dw0014 = 0x01;
					Eq_n i0_n = check_aux_info(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) (i0_n.u3)[1] ^ 0x20) > 0x00), out i1_n).u3)[1] ^ 0x2A) > 0x00), out i1_n).u3)[1] ^ 0x2F) > 0x00), out i1_n).u3)[1] ^ 0x20) > 0x00), out i1_n);
					word32 o0_n;
					if (strncmp(i0_n.u3 + 1, "static", 0x06) != 0x00 && strncmp(i0_n.u3 + 1, "extern", 0x06) != 0x00)
						o0_n = 0x00;
					else
						o0_n = 0x01;
					int8 * i0_n = (word32) check_aux_info(o0_n, out i1_n) + 7;
					while ((int32) *i0_n != 0x3B)
						++i0_n;
					struct Eq_n * l0_n;
					word32 i0_n;
					word32 i6_n;
					l2_n->ptr000C = dupnstr(i0_n.u3 + 1, i0_n - i0_n, out l0_n, out i0_n, out i6_n);
					struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
					struct Eq_n * i0_n = i0_n + ~0x00;
					int32 o0_n;
					while (i0_n != l0_n)
					{
						int32 o0_n = (int32) i0_n->bFFFFFFFF;
						if (o0_n != 0x20)
						{
							if (o0_n == 0x09)
							{
								i0_n = (struct Eq_n *) &i0_n->bFFFFFFFF;
								continue;
							}
							else
							{
								o0_n = (int32) i0_n->b0000;
								goto l000127E4;
							}
						}
						i0_n = (struct Eq_n *) &i0_n->bFFFFFFFF;
					}
					o0_n = (int32) i0_n->b0000;
l000127E4:
					if (o0_n != 0x29)
					{
l00012AC0:
						free_def_dec(l2_n);
					}
					l2_n->dw001C = 0x00;
					Eq_n o0_n = find_corresponding_lparen(i0_n);
					++l2_n->dw001C;
					if ((int32) o0_n.u3->bFFFFFFFE == 0x29)
					{
						word32 i1_n;
						check_aux_info(0x01 - (word32) (((int32) (o0_n.u3)->bFFFFFFFD ^ 0x29) > 0x00), out i1_n);
					}
					Eq_n i0_n = check_aux_info(0x01 - (word32) (((int32) (o0_n.u3)->bFFFFFFFF ^ 0x20) > 0x00), out i1_n);
					while (is_id_char((int32) *i0_n.u2) != 0x00)
						i0_n.u1 = (word32) i0_n - 1;
					Eq_n i0_n;
					i0_n.u1 = i0_n.u3 + 1;
					int32 l1_n = &o0_n.u3->bFFFFFFFF - i0_n;
					struct Eq_n * sp_n = sp_n - (l1_n + 0x08 & ~0x07);
					strncpy(sp_n->a0060, i0_n, l1_n);
					sp_n->a0060[l1_n] = 0x00;
					struct Eq_n * o0_n = lookup(0x00029A40, sp_n->a0060, out l1_n, out i1_n);
					l2_n->ptr0010 = o0_n;
					struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
					Eq_n o2_n;
					o2_n.u0 = o0_n->t0008.u0;
					word32 o0_n;
					if (o2_n != 0x00)
					{
						Eq_n o1_n;
						o1_n.u0 = l2_n->t0008.u0;
						while (true)
						{
							if (o1_n == (o2_n.u4)[8])
							{
								if (l2_n->ptr0004 == (o2_n.u4)[4])
								{
									if (strcmp(l2_n->ptr000C, o2_n.u4[0x0C]) != 0x00)
									{
										word32 i1_n;
										word32 i2_n;
										word32 i6_n;
										notice(0x000171D8, l2_n->ptr0004->ptr0000->ptr0004, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
										exit(33);
									}
									goto l00012AC0;
								}
								o2_n.u2 = o2_n.u4[24];
							}
							else
								o2_n.u2 = o2_n.u4[24];
							if (o2_n == 0x00)
								break;
							o1_n.u0 = l2_n->t0008.u0;
						}
						o0_n = l2_n->dw0014;
					}
					else
						o0_n = l2_n->dw0014;
					l2_n->ptr0024 = null;
					int32 o0_n;
					if (o0_n != 0x00)
					{
						l2_n->dw0028 = 0x00;
						Eq_n i0_n = check_aux_info(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) ((check_aux_info)(0x01 - (word32) (((int32) i1_n->b0001 ^ 0x20) > 0x00), out i1_n).u3)[1] ^ 0x2F) > 0x00), out i1_n).u3)[1] ^ 0x2A) > 0x00), out i1_n).u3)[1] ^ 0x20) > 0x00), out i1_n).u3)[1] ^ 0x28) > 0x00), out i1_n);
						Eq_n i0_n;
						if ((int32) i0_n.u3[1] != 0x29)
						{
							Eq_n i0_n;
							i0_n.u1 = i0_n.u3 + 2;
							while ((int32) *i0_n.u1 != 0x29)
								++i0_n.u2;
							i0_n.u2 = i0_n.u2 + 1;
						}
						else
							i0_n.u1 = i0_n.u3 + 2;
						word32 l0_n;
						struct Eq_n * i0_n;
						word32 i6_n;
						l2_n->ptr0024 = dupnstr(i0_n.u3 + 1, (word32) i0_n - 1 - (i0_n.u3 + 1), out l0_n, out i0_n, out i6_n);
						Eq_n i0_n = check_aux_info(0x01 - (word32) (((int32) i0_n->b0001 ^ 0x20) > 0x00), out i1_n);
						if ((int32) i0_n.u3[1] != 0x2A)
						{
							struct Eq_n * i0_n = (struct Eq_n *) (i0_n.u3 + 2);
							while (true)
							{
								while ((int32) i0_n->b0000 != 0x2A)
									++i0_n;
								if ((int32) i0_n[1] == 0x2F)
									break;
								++i0_n;
							}
							word32 i1_n;
							word32 l0_n;
							word32 i0_n;
							word32 i6_n;
							dupnstr(i0_n.u3 + 1, check_aux_info(0x01 - (word32) (((int32) i0_n->bFFFFFFFF ^ 0x20) > 0x00), out i1_n) - (i0_n.u3 + 1), out l0_n, out i0_n, out i6_n);
						}
						word32 i1_n;
						check_aux_info(0x01 - (word32) (((int32) (i0_n.u3)[2] ^ 0x2F) > 0x00), out i1_n);
						l2_n->dw0028 = 94744;
						if ((int32) l2_n->b0020 != 0x00)
							return;
						if ((int32) *l2_n->ptr0024 != 0x00)
						{
							o0_n = (int32) l2_n->b0020;
l00012AB4:
							if (o0_n != 0x00)
								return;
							goto l00012AC0;
						}
						l2_n->b0020 = 0x01;
					}
					else
						l2_n->dw0028 = 0x00;
					o0_n = (int32) l2_n->b0020;
					goto l00012AB4;
				}
			}
			o2_n = 0x01;
			goto l00012688;
		}
	}
	o2_n = 0x01;
	goto l00012648;
}

// 00012B64: Register Eq_n munge_compile_params(Register Eq_n o0, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
//      main
Eq_n munge_compile_params(Eq_n o0, ptr32 & i6Out)
{
	ptr32 i6_n;
	word32 i2_n;
	word32 i1_n;
	ptr32 fp;
	struct Eq_n * sp_n = fp + ~0x6F - (((uint32) strlen(o0) << 0x02) + 0x27 & ~0x07);
	sp_n->a0060[0] = compiler_file_name;
	Eq_n i0_n = o0;
	ptr32 i6_n = fp;
	ui32 l0_n = 0x01;
	int32 g2_n;
	ui32 o3_n;
	ui32 l0_n;
	do
	{
		g2_n = l0_n << 0x02;
		if (((ui32) g_a2B411[(ui32) *i0_n.u2] & 0x08) != 0x00)
		{
			o3_n = l0_n + 0x01;
			++i0_n.u3;
			while (((ui32) g_a2B411[(ui32) *i0_n.u2] & 0x08) != 0x00)
				++i0_n.u3;
		}
		else
			o3_n = l0_n + 0x01;
		if ((int32) i0_n.u3->t0000.u1 == 0x00)
			goto l00012D00;
		Eq_n o1_n;
		o1_n.u0 = (ui32) *i0_n.u2;
		Eq_n i0_n;
		if (((ui32) o1_n.u1->b2B411 & 0x08) == 0x00)
		{
			i0_n.u3 = i0_n.u3 + 1;
			while ((int32) i0_n.u3->t0000.u1 != 0x00)
			{
				Eq_n o1_n;
				o1_n.u0 = (ui32) *i0_n.u2;
				if (((ui32) o1_n.u1->b2B411 & 0x08) != 0x00)
					break;
				++i0_n.u3;
			}
		}
		else
			i0_n = i0_n;
		if ((int32) i0_n.u3->t0000.u1 == 0x2D && (int32) ((byte) ((i0_n.u3))[1].b0001 + 0x00B0) < 0x20)
		{
			i6Out = i6_n;
			return i0_n;
		}
		sp_n->a0060[l0_n] = dupnstr(i0_n, i0_n - i0_n, out l0_n, out i0_n, out i6_n);
		l0_n = l0_n + 0x01;
		g2_n = l0_n + 0x01 << 0x02;
	} while ((int32) i0_n.u3->t0000.u1 != 0x00);
	o3_n = l0_n + 0x02;
l00012D00:
	aux_info_file_name_index = o3_n;
	*((word32) &sp_n->a0060[0] + g2_n) = (word32[]) 0x00017220;
	ui32 l0_n = o3_n + 0x01;
	input_file_name_index = l0_n + 0x03;
	sp_n->a0060[o3_n] = 0x00;
	sp_n->a0060[l0_n] = 0x00017230;
	sp_n->a0060[l0_n + 0x01] = 94776;
	sp_n->a0060[l0_n + 0x02] = 94784;
	sp_n->a0060[l0_n + 0x03] = 0x00;
	sp_n->a0060[l0_n + 0x04] = 0x00;
	Eq_n o0_n = l0_n + 0x06 << 0x02;
	Eq_n i0_n = xmalloc(out i1_n, out i2_n, out i6_n);
	compile_params.u0 = (ui32) o0_n;
	memcpy(o0_n, sp_n->a0060, (size_t) (l0_n + 0x05 << 0x02));
	i6Out = i6_n;
	return i0_n;
}

// 00012E2C: Register Eq_n gen_aux_info_file(Register Eq_n o0, Register out ptr32 l0Out, Register out (ptr32 Eq_n) l1Out, Register out (ptr32 char) l4Out, Register out Eq_n i0Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
// Called from:
//      process_aux_info_file
Eq_n gen_aux_info_file(Eq_n o0, ptr32 & l0Out, struct stat & l1Out, char & l4Out, union Eq_n & i0Out, ptr32 & i2Out, ptr32 & i6Out)
{
	ptr32 i6_n;
	ptr32 i2_n;
	word32 i6_n;
	struct Eq_n * i0_n;
	Eq_n l1_n;
	word32 i0_n;
	char * l4_n;
	word32 l3_n;
	struct Eq_n * l2_n;
	word32 l1_n;
	word32 l0_n;
	Eq_n o1_n;
	if (input_file_name_index == 0x00)
	{
		word32 i6_n;
		o1_n = munge_compile_params(94744, out i6_n);
	}
	else
		o1_n = o0;
	struct stat * o0_n = shortpath(0x00, o1_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
	*((word32) compile_params.u0 + l2_n->dw0344 * 0x04) = (ui32) o0_n;
	struct stat * o0_n = savestring2(o0_n, (uint32) strlen(o0_n), 0x02);
	word32 o1_n = quiet_flag;
	*((word32) compile_params.u0 + aux_info_file_name_index * 0x04) = (ui32) o0_n;
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	if (o1_n != 0x00)
	{
		word32 o0_n = choose_temp_base(out l1_n, out i0_n, out i6_n);
		pid_t * o1_n = i0_n->ptr033C;
		struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
		Eq_n o0_n = (Eq_n) *o1_n;
		sp_n->dw005C = 0x07;
		struct Eq_n * l0_n;
		struct Eq_n * i6_n;
		if (pexecute(o0_n, o1_n, o0_n, i6_n + ~0x13, i6_n + ~0x17, l1_n, sp_n->dw005C, out l0_n, out i6_n) != ~0x00)
		{
			word32 i2_n;
			word32 i6_n;
			pwait((char *) i6_n - 28, out i2_n, out i6_n);
		}
		else
		{
			Eq_n l2_n;
			l2_n.u0 = errno.u0;
			fprintf(&g_t2B640, "%s: ", l0_n->ptr0150);
			fprintf(&g_t2B640, i6_n->ptrFFFFFFEC, 0x00);
			xstrerror(l2_n);
			fprintf(&g_t2B640, ": %s\n", l2_n);
			Eq_n i0_n = pwait(&g_dw17270, out i2_n, out i6_n);
			l0Out = 0x00017270;
			l1Out = (struct stat *) &g_t2B640;
			l4Out = l4_n;
			i0Out = i0_n;
			i2Out = i2_n;
			i6Out = i6_n;
			return i0_n;
		}
	}
	else
	{
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(94800, g_ptr28150, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
	}
}

// 00013034: Register Eq_n process_aux_info_file(Register Eq_n o0, Register word32 o2, Register out (ptr32 Eq_n) l1Out)
// Called from:
//      do_processing
Eq_n process_aux_info_file(Eq_n o0, word32 o2, struct stat & l1Out)
{
	struct Eq_n * fp;
	struct Eq_n * sp_n = (char *) fp - 0x00F8 - ((uint32) strlen(o0) + 0x0A & ~0x07);
	strcpy(&sp_n->dw005C + 1, o0);
	strcat(&sp_n->dw005C + 1, ".X");
	Eq_n i0_n = o0;
	word32 i2_n = o2;
	struct Eq_n * i6_n = fp;
	Eq_n l4_n;
	l4_n.u2 = &sp_n->dw005C + 1;
	word32 l2_n = 0x00;
	Eq_n l0;
	struct stat * l1;
	while (true)
	{
		struct Eq_n * sp_n;
		Eq_n o0_n;
		struct stat * o1_n;
		bool v35_n;
		if (access(l4_n, 0x04) == ~0x00)
		{
			if (errno.u0 != 0x02)
			{
				Eq_n l0_n;
				word32 l1_n;
				struct stat * l2_n;
				Eq_n l3_n;
				word32 l4_n;
				word32 i0_n;
				shortpath(0x00, l4_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
				xstrerror(l3_n);
				sp_n = (struct Eq_n *) <invalid>;
				o0_n = l0_n;
				o1_n = l2_n;
				goto l000131F0;
			}
			if (i2_n != 0x00)
			{
				struct stat * o1_n = g_ptr28150;
				word32 i1_n;
				i0_n = notice(94928, o1_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
				goto l000135B8;
			}
			v35_n = false;
		}
		else
			v35_n = l2_n == 0x00;
		Eq_n o1_n;
		if (!v35_n)
		{
			sp_n = (struct Eq_n *) <invalid>;
			if (gen_aux_info_file(i0_n, out l0, out l1, out l4_n, out i0_n, out i2_n, out i6_n) == 0x00)
			{
				++errors;
				goto l000135B8;
			}
			if (access(l4_n, 0x04) == ~0x00)
			{
				o1_n = l4_n;
				goto l000131D0;
			}
			l1 = (struct stat *) ((char *) i6_n - 0x0098);
		}
		else
			l1 = (struct stat *) ((char *) i6_n - 0x0098);
		if (stat(l4_n, l1) == ~0x00)
		{
			o1_n = l4_n;
			goto l000131D0;
		}
		l0.u0 = i6_n->tFFFFFF98.u0;
		if (l0 == 0x00)
			break;
		if (i2_n != 0x00)
		{
l00013218:
			Eq_n o0_n = open(l4_n, 0x00);
			if (o0_n == ~0x00)
			{
				Eq_n l0_n;
				word32 l1_n;
				Eq_n l2_n;
				struct stat * l3_n;
				word32 l4_n;
				word32 i0_n;
				shortpath(0x00, l4_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
				xstrerror(l2_n);
				struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				notice(l0_n, l3_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
			}
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			xmalloc(out i1_n, out i2_n, out i6_n);
			((Eq_n[]) 0x01)[l0].b0000 = 0x00;
			word32 l2_n;
			l0 = safe_read(o0_n, l0 + 0x01, l0, out l1, out l2_n);
			if (o0_n != l0 || close(o0_n) != 0x00)
			{
				word32 l1_n;
				Eq_n l2_n;
				struct stat * l3_n;
				word32 l4_n;
				word32 i0_n;
				l1 = shortpath(0x00, l4_n, out l0, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
				xstrerror(l2_n);
				struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				notice(l0, l3_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
				free(l0 + 0x01);
				close(o0_n);
			}
			break;
		}
		int32 l7_n = i6_n->dwFFFFFFA8;
		if (stat(i0_n, l1) == ~0x00)
		{
			o1_n = i0_n;
l000131D0:
			Eq_n l0_n;
			word32 l1_n;
			Eq_n l2_n;
			struct stat * l3_n;
			word32 l4_n;
			word32 i0_n;
			shortpath(0x00, o1_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
			xstrerror(l2_n);
			sp_n = (struct Eq_n *) <invalid>;
			o0_n = l0_n;
			o1_n = l3_n;
l000131F0:
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(o0_n, o1_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
		}
		int32 o0_n = i6_n->dwFFFFFFA8;
		if (o0_n <= l7_n)
			goto l00013218;
		l2_n = 0x01;
	}
l000135B8:
	l1Out = l1;
	return l0;
}

// 000135C0: void reverse_def_dec_list(Register (ptr32 Eq_n) o0)
// Called from:
//      visit_each_hash_node
void reverse_def_dec_list(struct Eq_n * o0)
{
	struct Eq_n * o1_n = o0->ptr0008;
	struct Eq_n * g3_n = o1_n->ptr0004;
	if (g3_n != null)
	{
		struct Eq_n * o0_n = g3_n;
		struct Eq_n * g3_n = g3_n->ptr0000;
		if (g3_n != null)
		{
			g3_n->ptr0000 = null;
			struct Eq_n * g2_n = g3_n->ptr0000;
			while (true)
			{
				g3_n->ptr0000 = o0_n;
				o0_n = g3_n;
				g3_n = g2_n;
				if (g2_n == null)
					break;
				g2_n = g2_n->ptr0000;
			}
			o1_n->ptr0004 = g3_n;
		}
	}
}

// 0001360C: Register Eq_n identify_lineno(Register Eq_n o0)
// Called from:
//      declare_source_confusing
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
Eq_n identify_lineno(Eq_n o0)
{
	Eq_n g3_n;
	g3_n.u0 = g_t281C0.u0;
	Eq_n o0_n;
	if (g3_n < o0)
	{
		o0_n.u0 = 0x01;
		int32 g2_n = (int32) g3_n.u3->t0000.u1;
		while (true)
		{
			if (g2_n == 0x0A)
				++o0_n.u3;
			++g3_n.u3;
			if (g3_n > o0)
				break;
			g2_n = (int32) g3_n.u3->t0000.u1;
		}
	}
	else
		o0_n.u0 = 0x01;
	return o0_n;
}

// 0001364C: void declare_source_confusing(Register Eq_n o0)
// Called from:
//      check_source
void declare_source_confusing(Eq_n o0)
{
	Eq_n i0_n;
	word32 l4_n;
	word32 l3_n;
	word32 l2_n;
	word32 l1_n;
	Eq_n l0_n;
	if (quiet_flag == 0x00)
	{
		if (o0 == 0x00)
		{
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			Eq_n l0_n;
			word32 l1_n;
			word32 l2_n;
			word32 l3_n;
			word32 l4_n;
			word32 i0_n;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, shortpath(0x00, g_t28180.u0, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n), sp_n->dw0048, out i1_n, out i2_n, out i6_n);
		}
		else
		{
			struct stat * o0_n = shortpath(0x00, g_t28180.u0, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
			identify_lineno(i0_n);
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, o0_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
		}
	}
	longjmp(&g_t2B240, 0x01);
}

// 000136E0: Register word32 check_source(Register word32 o0, Register Eq_n o1, Register out Eq_n i1Out, Register out (ptr32 Eq_n) i2Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      seek_to_line
//      forward_to_next_token_char
//      edit_formals_lists
//      find_rightmost_formals_list
//      careful_find_l_paren
//      scan_for_missed_items
word32 check_source(word32 o0, Eq_n o1, union Eq_n & i1Out, struct Eq_n & i2Out, struct Eq_n & i6Out)
{
	if (o0 != 0x00)
	{
		i1Out = o1;
		struct Eq_n * o2;
		i2Out = o2;
		struct Eq_n * fp;
		i6Out = fp;
		return o0;
	}
	else
		declare_source_confusing(o1);
}

// 00013700: void seek_to_line(Register Eq_n o0)
void seek_to_line(Eq_n o0)
{
	Eq_n i0_n = o0;
	int32 g0_n = o0 - g_t28230.u0;
	if (g0_n >= 0x00)
	{
		if (g0_n > 0x00)
		{
			Eq_n o1_n;
			while (true)
			{
				int8 * o0_n = g_ptr28220;
				Eq_n o1_n;
				if ((int32) *o0_n != 0x0A)
				{
					int8 * o2_n = g_ptr28220;
					while (true)
					{
						int8 * o2_n = o2_n + 1;
						word32 o0_n = (word32) (bool) cond(o2_n - g_dw281D0);
						g_ptr28220 = o2_n;
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						i0_n = check_source(o0_n, 0x00, out i1_n, out i2_n, out i6_n);
						if ((int32) *g_ptr28220 == 0x0A)
							break;
						o2_n = g_ptr28220;
					}
					o0_n = g_ptr28220;
					o1_n.u0 = g_t28230.u0;
				}
				else
					o1_n.u0 = g_t28230.u0;
				g_ptr28220 = o0_n + 1;
				o1_n.u1 = &o1_n.u2->b0001;
				if (i0_n <= o1_n)
					break;
				g_t28230.u0 = (int32) o1_n;
			}
			g_t28230.u0 = (int32) o1_n;
		}
	}
	else
		abort();
}

// 000137AC: Register Eq_n forward_to_next_token_char(Register Eq_n o0)
// Called from:
//      find_rightmost_formals_list
Eq_n forward_to_next_token_char(Eq_n o0)
{
	Eq_n i0_n;
	i0_n.u1 = &o0.u2->b0001;
	if (((ui32) g_a2B411[(ui32) o0.u2->b0001] & 0x08) != 0x00)
	{
		up32 o0_n = g_dw281D0;
		while (true)
		{
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			i0_n = check_source((word32) (bool) cond(&i0_n.u2->b0001 - o0_n), 0x00, out i1_n, out i2_n, out i6_n);
			if (((ui32) g_a2B411[(ui32) *i0_n.u1] & 0x08) == 0x00)
				break;
			o0_n = g_dw281D0;
		}
	}
	return i0_n;
}

// 00013808: Register uint32 output_bytes(Register Eq_n o0, Register Eq_n o1, Register out ptr32 l1Out, Register out ptr32 l2Out, Register out Eq_n i0Out, Register out Eq_n i1Out, Register out ptr32 i2Out)
// Called from:
//      output_string
//      output_up_to
uint32 output_bytes(Eq_n o0, Eq_n o1, ptr32 & l1Out, ptr32 & l2Out, union Eq_n & i0Out, union Eq_n & i1Out, ptr32 & i2Out)
{
	ptr32 o2;
	uint32 l0_n = g_dw28200;
	Eq_n i0_n = o0;
	Eq_n i1_n = o1;
	ptr32 i2_n = o2;
	if (g_dw28210 + ((word32) o1 + 1) >= l0_n)
	{
		Eq_n o0_n;
		o0_n.u0 = g_t281F0.u0;
		i0_n = xrealloc(o0_n, out i1_n, out i2_n);
		uint32 o1_n = g_dw28210;
		l0_n = (word32) o0_n.u1 + (l0_n - o0_n << 0x01);
		Eq_n o2_n;
		o2_n.u0 = g_t281F0.u0;
		g_dw28200 = l0_n;
		g_dw28210 = (word32) o0_n.u1 + (o1_n - o2_n);
		g_t281F0.u0 = (int32) o0_n;
	}
	memcpy(g_dw28210 + 0x01, i0_n, (size_t) i1_n);
	g_dw28210 = (word32) i1_n + g_dw28210;
	l1Out = 0x00028000;
	l2Out = 0x00028000;
	i0Out = i0_n;
	i1Out = i1_n;
	i2Out = i2_n;
	return l0_n;
}

// 0001388C: Register word32 output_string(Register Eq_n o0, Register out (ptr32 Eq_n) l2Out, Register out ptr32 i0Out, Register out ptr32 i1Out, Register out (ptr32 Eq_n) i2Out)
// Called from:
//      edit_formals_lists
word32 output_string(Eq_n o0, struct Eq_n & l2Out, ptr32 & i0Out, ptr32 & i1Out, struct Eq_n & i2Out)
{
	word32 l1_n;
	struct Eq_n * l2_n;
	ptr32 i0_n;
	ptr32 i1_n;
	struct Eq_n * i2_n;
	output_bytes(o0, (uint32) strlen(o0), out l1_n, out l2_n, out i0_n, out i1_n, out i2_n);
	l2Out = l2_n;
	i0Out = i0_n;
	i1Out = i1_n;
	i2Out = i2_n;
	return l1_n;
}

// 000138AC: Register word32 output_up_to(Register Eq_n o0, Register out ptr32 l2Out, Register out Eq_n i0Out, Register out ptr32 i1Out, Register out ptr32 i2Out)
// Called from:
//      edit_formals_lists
//      edit_fn_definition
word32 output_up_to(Eq_n o0, ptr32 & l2Out, union Eq_n & i0Out, ptr32 & i1Out, ptr32 & i2Out)
{
	ptr32 o2;
	ptr32 o1;
	ui32 o2_n = g_dw281E0;
	Eq_n i0_n = o0;
	ptr32 i1_n = o1;
	ptr32 i2_n = o2;
	word32 o0_n = g_dw281A0 + (o2_n - g_t281C0.u0);
	Eq_n o1_n = o0 - o2_n;
	word32 l1;
	ptr32 l2;
	if (o1_n != 0x00)
		output_bytes(o0_n + 0x01, o1_n, out l1, out l2, out i0_n, out i1_n, out i2_n)->t01E0.u0 = (int32) i0_n;
	l2Out = l2;
	i0Out = i0_n;
	i1Out = i1_n;
	i2Out = i2_n;
	return l1;
}

// 000138F0: Register (ptr32 int8) other_variable_style_function(Register (ptr32 int8) o0, Register out ptr32 i1Out, Register out ptr32 i6Out)
// Called from:
//      edit_fn_definition
int8 * other_variable_style_function(int8 * o0, ptr32 & i1Out, ptr32 & i6Out)
{
	int8 * o0_n = (word32) (bool) cond(0x00 - substr(o0, &g_b17468));
	ptr32 o1;
	i1Out = o1;
	ptr32 fp;
	i6Out = fp;
	return o0_n;
}

// 00013914: void edit_fn_declaration(Register (ptr32 Eq_n) o0)
void edit_fn_declaration(struct Eq_n * o0)
{
	strlen(o0->ptr0010->ptr0004);
	save_pointers();
	if (setjmp(&g_t2B240) != 0x00)
	{
		restore_pointers();
		word32 dwLoc30;
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(0x00017470, g_ptr28150, dwLoc30, out i1_n, out i2_n, out i6_n);
	}
}

// 00013B68: Register Eq_n edit_formals_lists(Register Eq_n o0, Register out Eq_n l1Out, Register out (ptr32 Eq_n) l2Out, Register out ptr32 i1Out, Register out (ptr32 Eq_n) i2Out)
// Called from:
//      edit_formals_lists
Eq_n edit_formals_lists(Eq_n o0, union Eq_n & l1Out, struct stat & l2Out, ptr32 & i1Out, struct Eq_n & i2Out)
{
	word32 i0_n;
	Eq_n l4_n;
	Eq_n l3_n;
	word32 l2_n;
	word32 l1_n;
	word32 l0_n;
	int8 * l1_n = &o0.u3->bFFFFFFFF + -1;
	word32 l0_n = 0x01;
	struct stat * l2_n = &g_t28000;
	int32 o0_n = (int32) o0.u3->bFFFFFFFF;
l00013B7C:
	ui32 o0_n;
	if (o0_n != 0x28)
	{
		int32 g0_n = o0_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = g_dw281E0;
			l1_n = l1_n;
			goto l00013BAC;
		}
		++l0_n;
	}
	else
		l0_n += ~0x00;
	o0_n = g_dw281E0;
	l1_n += -1;
l00013BAC:
	word32 i1_n;
	struct Eq_n * i2_n;
	word32 i6_n;
	check_source((word32) (bool) cond(o0_n - l1_n), 0x00, out i1_n, out i2_n, out i6_n);
	if (l0_n == 0x00)
	{
		Eq_n l1_n;
		ptr32 i1_n;
		Eq_n i0_n;
		bool v34_n;
		if (i1_n != 0x01)
		{
			struct Eq_n * l1_n = (struct Eq_n *) (l1_n + 1);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			check_source((word32) (bool) cond(g_dw281E0 - &l1_n->bFFFFFFFF), 0x00, out i1_n, out i2_n, out i6_n);
			Eq_n l0_n;
			l0_n.u2 = &l1_n->bFFFFFFFF;
			int32 o0_n;
			if (((ui32) g_a2B411[(ui32) l1_n->bFFFFFFFF] & 0x08) != 0x00)
			{
				ui32 o0_n = g_dw281E0;
				while (true)
				{
					l0_n.u2 = &l0_n.u3->bFFFFFFFF;
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					check_source((word32) (bool) cond(o0_n - l0_n), 0x00, out i1_n, out i2_n, out i6_n);
					if (((ui32) g_a2B411[(ui32) *l0_n.u2] & 0x08) == 0x00)
						break;
					o0_n = g_dw281E0;
				}
				o0_n = (int32) l0_n.u3->t0000.u1;
			}
			else
				o0_n = (int32) l1_n->bFFFFFFFF;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			check_source(0x01 - (word32) ((o0_n ^ 0x29) > 0x00), l0_n, out i1_n, out i2_n, out i6_n);
			Eq_n l0_n;
			l0_n.u2 = &l0_n.u3->bFFFFFFFF;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			check_source((word32) (bool) cond(g_dw281E0 - l0_n), 0x00, out i1_n, out i2_n, out i6_n);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			check_source(0x01 - (word32) (((int32) ((l0_n.u3)->t0000).u1 ^ 0x29) > 0x00), l0_n, out i1_n, out i2_n, out i6_n);
			if (edit_formals_lists(l0_n, out l1_n, out l2_n, out i1_n, out i2_n) != 0x00)
			{
				i0_n.u0 = 0x01;
				goto l00013DFC;
			}
			v34_n = i1_n != 0x00;
		}
		else
		{
			l1_n.u2 = l1_n + 1;
			v34_n = i1_n != 0x01;
		}
		if (!v34_n)
		{
			struct Eq_n * o1_n = i2_n->ptr0010;
			Eq_n l0_n;
			l0_n.u1 = &l1_n.u3->bFFFFFFFF;
			char * l5_n;
			if (((ui32) g_a2B411[(ui32) l1_n.u3->bFFFFFFFF] & 0x08) != 0x00)
			{
				l5_n = o1_n->ptr0004;
				ui32 o0_n = l2_n->dw01E0;
				while (true)
				{
					l0_n.u1 = (word32) l0_n - 1;
					word32 i1_n;
					word32 i6_n;
					check_source((word32) (bool) cond(o0_n - l0_n), 0x00, out i1_n, out i2_n, out i6_n);
					if (((ui32) g_a2B411[(ui32) *l0_n.u1] & 0x08) == 0x00)
						break;
					o0_n = l2_n->dw01E0;
				}
			}
			else
				l5_n = o1_n->ptr0004;
			Eq_n l3_n = l0_n;
			ptr32 l0_n = (word32) l0_n + 1;
			while (is_id_char((int32) *l3_n.u2) != 0x00)
			{
				ui32 o0_n = l2_n->dw01E0;
				word32 i1_n;
				word32 i6_n;
				check_source((word32) (bool) cond(o0_n - l3_n), 0x00, out i1_n, out i2_n, out i6_n);
				l3_n.u1 = (word32) l3_n - 1;
			}
			Eq_n l3_n;
			l3_n.u2 = (word32) l3_n + 1;
			Eq_n l4_n = l0_n - l3_n;
			if (l4_n == 0x00)
			{
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				check_source(0x00, l3_n, out i1_n, out i2_n, out i6_n);
			}
			struct Eq_n ** o0_n;
			if (l4_n != (uint32) strlen(l5_n))
			{
				o0_n = i2_n->ptr0004;
				goto l00013D80;
			}
			if (strncmp(l3_n, l5_n, l4_n) != 0x00)
			{
				o0_n = i2_n->ptr0004;
l00013D80:
				struct stat * o0_n = shortpath(0x00, *((char *) *o0_n + 4), out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
				l1_n = identify_lineno(l3_n);
				Eq_n l0_n;
				word32 i0_n;
				word32 i6_n;
				dupnstr(l3_n, l4_n, out l0_n, out i0_n, out i6_n);
				struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
				word32 i6_n;
				notice(l0_n, o0_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
				l2_n = o0_n;
				i0_n.u0 = 0x01;
				goto l00013DFC;
			}
		}
		word32 i0_n;
		l1_n = output_up_to(l1_n, out l2_n, out i0_n, out i1_n, out i2_n);
		ui32 o0_n;
		if (i1_n == 0x00)
		{
			word32 i0_n;
			l1_n = output_string(i2_n->t0024.u0, out l2_n, out i0_n, out i1_n, out i2_n);
			o0_n = i0_n + ~0x00;
		}
		else
			o0_n = i0_n + ~0x00;
		l2_n->dw01E0 = o0_n;
		i0_n.u0 = 0x00;
l00013DFC:
		l1Out = l1_n;
		l2Out = l2_n;
		i1Out = i1_n;
		i2Out = i2_n;
		return i0_n;
	}
	o0_n = (int32) *l1_n;
	goto l00013B7C;
}

// 00013E04: Register word32 find_rightmost_formals_list(Register (ptr32 int8) o0)
// Called from:
//      edit_fn_definition
word32 find_rightmost_formals_list(int8 * o0)
{
	int8 * i0_n = o0 + -1;
	int32 o0_n = (int32) *o0;
	while (o0_n != 0x0A)
	{
		++i0_n;
		o0_n = (int32) *i0_n;
	}
	Eq_n i0_n;
	i0_n.u1 = i0_n;
	if ((int32) *i0_n.u1 != 0x29)
	{
		Eq_n o1_n;
		o1_n.u0 = (ui32) *i0_n.u1;
		while (true)
		{
			int32 o0_n;
			if (((ui32) o1_n.u1->b2B411 & 0x08) != 0x00)
			{
				ui32 o0_n = g_dw281E0;
				while (true)
				{
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					i0_n = check_source((word32) (bool) cond(o0_n - ((word32) i0_n - 1)), 0x00, out i1_n, out i2_n, out i6_n);
					if (((ui32) g_a2B411[(ui32) *i0_n.u1] & 0x08) == 0x00)
						break;
					o0_n = g_dw281E0;
				}
				o0_n = (int32) *i0_n.u1;
			}
			else
			{
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				i0_n = check_source((word32) (bool) cond(g_dw281E0 - ((word32) i0_n - 1)), 0x00, out i1_n, out i2_n, out i6_n);
				o0_n = (int32) *i0_n.u1;
			}
			if (o0_n == 0x29)
				break;
			o1_n.u0 = (ui32) *i0_n.u1;
		}
	}
	Eq_n o0_n = forward_to_next_token_char(i0_n);
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	check_source(0x01 - (word32) (((int32) ((o0_n.u3)->t0000).u1 ^ 0x7B) > 0x00), o0_n, out i1_n, out i2_n, out i6_n);
	return i6_n;
}

// 00013EDC: void edit_fn_definition(Register (ptr32 int8) o1)
void edit_fn_definition(int8 * o1)
{
	word32 i0_n;
	word32 l4_n;
	word32 l3_n;
	word32 l2_n;
	word32 l1_n;
	Eq_n l0_n;
	save_pointers();
	if (setjmp(&g_t2B240) != 0x00)
	{
		restore_pointers();
		word32 dwLoc30;
		Eq_n i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(95440, g_ptr28150, dwLoc30, out i1_n, out i2_n, out i6_n);
		word32 l2_n;
		word32 i0_n;
		word32 i1_n;
		word32 i2_n;
		output_up_to(i1_n, out l2_n, out i0_n, out i1_n, out i2_n);
	}
	else
	{
		Eq_n i1_n;
		struct Eq_n * i6_n;
		if (other_variable_style_function(find_rightmost_formals_list(o1)->ptr0044->ptr000C, out i1_n, out i6_n) != 0x00)
		{
			if (quiet_flag != 0x00)
			{
				word32 l2_n;
				word32 i0_n;
				word32 i1_n;
				word32 i2_n;
				output_up_to(i1_n, out l2_n, out i0_n, out i1_n, out i2_n);
			}
			else
			{
				struct Eq_n * o1_n = i6_n->ptr0044;
				struct stat * o0_n = shortpath(0x00, *((char *) *o1_n->ptr0004 + 4), out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
				identify_lineno(i1_n);
				struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				notice(l0_n, o0_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
			}
		}
	}
}

// 000140B4: void do_cleaning(Register (ptr32 byte) o0, Register (ptr32 byte) o1)
void do_cleaning(byte * o0, byte * o1)
{
	byte * i0_n = o0;
	if (o0 >= o1)
		return;
	ui32 o1_n = (ui32) *o0;
	while ((int32) ((byte) o1_n + ~0x07) >= 0x54)
	{
		++i0_n;
		if (i0_n >= o1)
			return;
		o1_n = (ui32) *i0_n;
	}
}

// 00014518: Register (ptr32 Eq_n) careful_find_l_paren(Register (ptr32 Eq_n) o0, Register out (ptr32 Eq_n) l1Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      scan_for_missed_items
struct Eq_n * careful_find_l_paren(struct Eq_n * o0, struct Eq_n & l1Out, struct Eq_n & i6Out)
{
	Eq_n i0_n;
	i0_n.u1 = &o0->bFFFFFFFF;
	word32 l0_n = 0x01;
	int32 o0_n = (int32) o0->bFFFFFFFF;
l0001452C:
	Eq_n o0_n;
	if (o0_n != 0x28)
	{
		int32 g0_n = o0_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n.u0 = g_t281C0.u0;
l00014550:
			word32 i1_n;
			word32 i2_n;
			struct Eq_n * i6_n;
			i0_n = check_source(0x01 - (word32) ((word32) i0_n - 1 < o0_n), 0x00, out i1_n, out i2_n, out i6_n);
			if (l0_n == 0x00)
			{
				l1Out = (struct Eq_n *) &g_t28000;
				i6Out = i6_n;
				return &i0_n.u2->b0001;
			}
			o0_n = (int32) *i0_n.u1;
			goto l0001452C;
		}
		++l0_n;
	}
	else
		l0_n += ~0x00;
	o0_n.u0 = g_t281C0.u0;
	goto l00014550;
}

// 00014578: void scan_for_missed_items()
void scan_for_missed_items()
{
	Eq_n i0_n;
	word32 l4_n;
	word32 l3_n;
	word32 l2_n;
	word32 l1_n;
	Eq_n l0_n;
	struct Eq_n * fp;
	Eq_n o1_n;
	o1_n.u0 = g_t281C0.u0;
	up32 o0_n = g_dw281D0;
	g_t28130.u0 = (int32) &o1_n.u3->bFFFFFFFF;
	struct Eq_n * i6_n = fp;
	if (o1_n >= o0_n + ~0x02)
	{
		g_t28120.u0 = (int32) o1_n;
		return;
	}
	g_t28120.u0 = (int32) o1_n;
l000145B4:
	Eq_n o3_n;
	o3_n.u0 = g_t28120.u0;
	if ((int32) o3_n.u3->t0000.u1 == 0x29)
	{
		g_t28140.u0 = (int32) o3_n;
		Eq_n l0_n;
		if (((ui32) g_a2B411[(ui32) o3_n.u3[1]] & 0x08) != 0x00)
		{
			l0_n.u3 = o3_n.u3 + 1;
			Eq_n o0_n;
			o0_n.u0 = i6_n->tFFFFFFEC.u0;
			while (true)
			{
				++l0_n.u3;
				word32 i1_n;
				word32 i2_n;
				check_source((word32) (bool) cond(l0_n - o0_n), i6_n->tFFFFFFEC.u0, out i1_n, out i2_n, out i6_n);
				if (((ui32) g_a2B411[(ui32) *l0_n.u2] & 0x08) == 0x00)
					break;
				o0_n.u0 = i6_n->tFFFFFFEC.u0;
			}
		}
		else
			l0_n.u3 = o3_n.u3 + 1;
		g_t28120.u0 = (int32) &l0_n.u3->bFFFFFFFF;
		Eq_n o2_n;
		o2_n.u0 = (ui32) *l0_n.u2;
		if (((ui32) o2_n.u1->b2B411 & 0x03) != 0x00 || o2_n == 0x7B)
		{
			i6_n->tFFFFFFE8.u0 = (int32) identify_lineno(l0_n);
			if (setjmp(&g_t2B240) != 0x00)
				goto l00014854;
			struct Eq_n * l1_n = (struct Eq_n *) &g_t28000;
			struct Eq_n * sp_n;
			struct Eq_n * o0_n;
			do
			{
				struct Eq_n * o0_n = careful_find_l_paren(l1_n->ptr0140, out l1_n, out i6_n);
				l1_n->ptr0140 = (struct Eq_n *) &o0_n->bFFFFFFFF;
				sp_n = (struct Eq_n *) <invalid>;
				if (((ui32) g_a2B411[(ui32) o0_n->bFFFFFFFF] & 0x08) != 0x00)
				{
					Eq_n i0_n;
					i0_n.u0 = 0x00028000;
					Eq_n o2_n;
					o2_n.u0 = g_t28140.u0;
					while (true)
					{
						Eq_n o1_n;
						o1_n.u0 = i0_n.u2->t0130.u0;
						Eq_n o2_n;
						o2_n.u2 = &o2_n.u3->bFFFFFFFF;
						g_t28140.u0 = (int32) o2_n;
						word32 i1_n;
						word32 i2_n;
						i0_n = check_source(0x01 - (word32) (o2_n < o1_n), o1_n, out i1_n, out i2_n, out i6_n);
						if (((ui32) g_a2B411[(ui32) *g_t28140.u0] & 0x08) == 0x00)
							break;
						o2_n.u0 = g_t28140.u0;
					}
					o0_n = l1_n->ptr0140;
				}
				else
					o0_n = l1_n->ptr0140;
			} while ((int32) o0_n->b0000 == 0x29);
			if (is_id_char((int32) *g_t28140.u0) != 0x00)
			{
				Eq_n o0_n;
				o0_n.u0 = g_t28140.u0;
				if (is_id_char((int32) o0_n.u3->t0000.u1) != 0x00)
				{
					Eq_n o1_n;
					o1_n.u0 = g_t28130.u0;
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					check_source(0x01 - (word32) (&(o0_n.u3)->bFFFFFFFF < o1_n), o1_n, out i1_n, out i2_n, out i6_n);
				}
				int32 l0_n = o0_n.u3 + 1 - (o0_n.u3 + 1);
				if (l0_n != 0x00)
				{
					g_t28130.u0 = (int32) (o0_n.u3 + 1);
					struct Eq_n * sp_n = sp_n - (l0_n + 0x6B & ~0x07);
					strncpy(sp_n->a0060, o0_n.u3 + 1, l0_n);
					char * o0_n = (char *) "if";
					sp_n->a0060[l0_n] = 0x00;
					if (o0_n == null)
					{
l000147BC:
						struct Eq_n * o1_n = i6_n->ptr0044->ptr0004;
						struct Eq_n * o1_n;
						if (o1_n != null)
						{
							word32 o0_n = o1_n->dw0014;
							while (true)
							{
								if (o0_n != 0x00)
								{
									Eq_n o2_n;
									o2_n.u0 = i6_n->tFFFFFFE8.u0;
									if (o1_n->t0008.u0 == o2_n)
										goto l00014854;
								}
								o1_n = o1_n->ptr0000;
								if (o1_n == null)
									break;
								o0_n = o1_n->dw0014;
							}
							o1_n = i6_n->ptr0044;
						}
						else
							o1_n = i6_n->ptr0044;
						struct stat * o0_n = shortpath(0x00, o1_n->ptr0000->t0004.u0, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
						identify_lineno(i0_n);
						struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						notice(l0_n, o0_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						notice(0x000175D8, g_ptr28150, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
					}
					word32 * l0_n = &g_ptr1753C;
					char * o1_n = (char *) "if";
					while (strcmp(sp_n->a0060, o1_n) != 0x00)
					{
						++l0_n;
						if (*l0_n == null)
							goto l000147BC;
						o1_n = *l0_n;
					}
				}
				else
					g_t28130.u0 = (int32) (o0_n.u3 + 1);
			}
			goto l00014854;
		}
	}
l00014854:
	Eq_n o0_n;
	o0_n.u0 = g_t28120.u0;
	if (o0_n.u3 + 1 >= (i6_n->tFFFFFFEC).u0)
	{
		g_t28120.u0 = (int32) (o0_n.u3 + 1);
		return;
	}
	g_t28120.u0 = (int32) (o0_n.u3 + 1);
	goto l000145B4;
}

// 00014878: void edit_file(Register (ptr32 Eq_n) o0)
void edit_file(struct Eq_n * o0)
{
	struct Eq_n * i0_n = o0->ptr0008;
	if (needs_to_be_converted(i0_n) == 0x00)
		return;
	Eq_n o1_n;
	o1_n.u0 = i0_n->ptr0000->t0004.u0;
	g_t28180.u0 = (int32) o1_n;
	if (directory_specified_p(o1_n) == 0x00 || file_excluded_p(g_t28180.u0) != 0x00)
	{
		if (quiet_flag == 0x00 && in_system_include_dir(g_t28180.u0) == 0x00)
		{
			Eq_n l0_n;
			struct stat * l1_n;
			word32 l2_n;
			word32 l3_n;
			word32 l4_n;
			word32 i0_n;
			shortpath(0x00, g_t28180.u0, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, l1_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
		}
	}
}

// 00014E24: void do_processing()
// Called from:
//      main
void do_processing()
{
	union Eq_n * l1_n;
	Eq_n o0_n;
	o0_n.u0 = g_t28160.u0;
	if (o0_n < &(o0_n.u1 + n_base_source_files)->u0)
	{
		Eq_n o0_n;
		o0_n.u2 = *o0_n;
		while (true)
		{
			union Eq_n * l0_n = process_aux_info_file(o0_n, 0x00, out l1_n);
			if (l0_n >= l1_n)
				break;
			o0_n.u0 = l0_n->u0;
		}
	}
	visit_each_hash_node(visit_each_hash_node(&g_t28240));
}

// 00014EA4: Register ui32 main(Register (ptr32 (ptr32 Eq_n)) o1)
// Called from:
//      _start
ui32 main(struct stat ** o1)
{
	struct Eq_n * i6_n;
	struct Eq_n * l7_n;
	struct Eq_n * l6_n;
	struct stat * o0_n = strrchr(*o1, '/');
	struct stat * o2_n = &o0_n->b0000 + 1;
	if (o0_n == null)
	{
		g_ptr28150 = o0_n;
		o2_n = (struct stat *) *o1;
	}
	else
		g_ptr28150 = o0_n;
	g_ptr28150 = o2_n;
	setlocale(0x05, "");
	Eq_n o0_n = getpwd();
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	if (o0_n != 0x00)
	{
		g_t2B270.u0 = (int32) o0_n;
		struct Eq_n * i6_n;
		directory_list = string_list_cons(out i6_n);
		word32 o0_n = i6_n->dw0044;
		struct Eq_n * l0_n = getopt_long(i6_n->t0048.u0, &g_b17838, (char *) i6_n - 20, out l6_n, out l7_n, out i6_n);
		if (o0_n != ~0x00)
		{
			uint32 o0_n;
			if (o0_n == 0x00)
				o0_n = l0_n->a000C[i6_n->dwFFFFFFEC].dw0000 + ~0x4D;
			else
				o0_n = o0_n + ~0x4D;
			if (o0_n < 0x2A)
				return o0_n << 0x02;
			usage();
		}
		else
		{
			struct Eq_n * i6_n;
			munge_compile_params(i6_n->tFFFFFFE8.u0, out i6_n);
			ui32 o1_n = i6_n->dw0044 - l7_n->dw0068;
			l6_n->dw034C = o1_n;
			word32 i1_n;
			word32 i2_n;
			struct Eq_n * i6_n;
			xmalloc(out i1_n, out i2_n, out i6_n);
			g_t28160.u0 = (ui32) (o1_n + 0x01 << 0x02);
			int32 o1_n = l7_n->dw0068;
			l6_n->dw034C = 0x00;
			if (o1_n < i6_n->dw0044)
			{
				struct Eq_n * l4_n = l6_n;
				struct Eq_n * l2_n = l7_n;
				int32 o0_n;
				while (true)
				{
					abspath(0x00, i6_n->ptr0048[l7_n->dw0068].u0, out i6_n);
					Eq_n o0_n;
					o0_n.u0 = (uint32) strlen(null);
					if ((int32) o0_n.u1->bFFFFFFFF == 99 && (int32) (o0_n.u1)->bFFFFFFFE == 0x2E)
					{
						ui32 o0_n = l4_n->dw034C;
						*((word32) g_t28160.u0 + o0_n * 0x04) = 0x00;
						l4_n->dw034C = o0_n + 0x01;
					}
					else
					{
						struct stat * l0_n;
						word32 l1_n;
						struct Eq_n * l3_n;
						word32 i0_n;
						shortpath(0x00, 0x00, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n);
						struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
						word32 i1_n;
						word32 i2_n;
						notice(96336, l0_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
						++l3_n->dw0320;
					}
					o0_n = l2_n->dw0068;
					if (o0_n + 0x01 >= i6_n->dw0044)
						break;
					l2_n->dw0068 = o0_n + 0x01;
				}
				l2_n->dw0068 = o0_n + 0x01;
			}
			if (errors == 0x00)
			{
				if (version_flag == 0x00)
				{
					do_processing();
					int32 o1_n;
					if (errors != 0x00)
						o1_n = 33;
					else
						o1_n = 0x00;
					exit(o1_n);
				}
				else
					fprintf(&g_t2B640, "%s: %s\n", g_ptr28150, version_string);
			}
			else
				usage();
		}
	}
	else
	{
		g_t2B270.u0 = (int32) o0_n;
		struct stat * l1_n = g_ptr28150;
		xstrerror(errno.u0);
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice(0x00017810, l1_n, sp_n->dw0048, out i1_n, out i2_n, out i6_n);
		exit(33);
	}
}

// 000152B8: Register Eq_n getpwd()
// Called from:
//      main
Eq_n getpwd()
{
	Eq_n i0_n;
	i0_n.u0 = g_t2B2A0.u0;
	if (i0_n != 0x00)
		return i0_n;
	Eq_n o2_n;
	o2_n.u0 = g_t2B2B0.u0;
	if (o2_n != 0x00)
	{
		errno.u0 = (int32) o2_n;
		return i0_n;
	}
	else
	{
		errno.u0 = (int32) o2_n;
		Eq_n o0_n = getenv("PWD");
		i0_n = o0_n;
		Eq_n l1_n;
		if (o0_n != 0x00)
		{
			l1_n.u0 = 100;
			if ((int32) *o0_n == 0x2F)
			{
				word32 dwLoc0120;
				if (stat(o0_n, &dwLoc0120) == 0x00)
				{
					word32 dwLoc98;
					if (stat(".", &dwLoc98) == 0x00)
					{
						word32 dwLoc88;
						word32 dwLoc0110;
						if (dwLoc88 == dwLoc0110)
						{
							if (dwLoc98 == dwLoc0120)
							{
								g_t2B2A0.u0 = (ui32) o0_n;
								return i0_n;
							}
							l1_n.u0 = 100;
						}
						else
							l1_n.u0 = 100;
					}
					else
						l1_n.u0 = 100;
				}
				else
					l1_n.u0 = 100;
			}
		}
		else
			l1_n.u0 = 100;
		while (true)
		{
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			xmalloc(out i1_n, out i2_n, out i6_n);
			i0_n = l1_n;
			if (getcwd(l1_n, (size_t) l1_n) != null)
				break;
			Eq_n l0_n;
			l0_n.u0 = errno.u0;
			free(l1_n);
			if (l0_n != 0x22)
			{
				i0_n.u0 = 0x00;
				errno.u0 = (int32) l0_n;
				g_t2B2B0.u0 = (int32) l0_n;
				break;
			}
			l1_n <<= 0x01;
		}
		g_t2B2A0.u0 = (ui32) i0_n;
		return i0_n;
	}
}

// 000153C4: void _obstack_begin(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o2, Register (ptr32 code) o3, Register word32 o4, Register word32 o5)
void _obstack_begin(struct Eq_n * o0, word32 o1, word32 o2, <anonymous> * o3, word32 o4, word32 o5)
{
	word32 i1_n = o1;
	word32 i2_n = o2;
	if (o2 == 0x00)
		i2_n = 0x08;
	if (o1 == 0x00)
		i1_n = 0x0FE8;
	ui32 o0_n = o0->dw0028;
	o0->dw0020 = o4;
	word32 o2_n = i2_n + ~0x00;
	o0->dw0018 = o2_n;
	o0->ptr001C = o3;
	o0->dw0000 = i1_n;
	struct Eq_n * i1_n;
	if ((o0_n & 0x7FFFFFFF) < 0x00)
	{
		o0->dw0028 = o0_n & 0x7FFFFFFF;
		o3();
		struct Eq_n * o0_n;
		i1_n = o0_n;
	}
	else
	{
		o0->dw0028 = o0_n & 0x7FFFFFFF;
		o3();
		struct Eq_n * o0_n;
		i1_n = o0_n;
	}
	struct Eq_n * i0_n;
	if (i1_n != null)
	{
		i0_n->ptr0004 = i1_n;
		word32 o0_n = i0_n->dw0000;
		word32 o1_n = &i1_n->dw0004 + 1;
		i0_n->dw000C = o1_n;
		i0_n->dw0008 = o1_n;
		word32 o0_n = (char *) &i1_n->dw0000 + o0_n;
		i1_n->dw0000 = o0_n;
		i0_n->dw0010 = o0_n;
		i1_n->dw0004 = 0x00;
		i0_n->dw0028 = i0_n->dw0028 & ~0x40000000 & ~0x20000000;
	}
	else
	{
		i0_n->ptr0004 = i1_n;
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
	}
}

// 00015488: void _obstack_begin_n(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o2, Register (ptr32 code) o3, Register word32 o4, Register word32 o5)
void _obstack_begin_n(struct Eq_n * o0, word32 o1, word32 o2, <anonymous> * o3, word32 o4, word32 o5)
{
	word32 i1_n = o1;
	word32 i2_n = o2;
	if (o2 == 0x00)
		i2_n = 0x08;
	if (o1 == 0x00)
		i1_n = 0x0FE8;
	ui32 o0_n = o0->dw0028;
	o0->dw0020 = o4;
	word32 o2_n = i2_n + ~0x00;
	o0->dw0018 = o2_n;
	o0->ptr001C = o3;
	o0->dw0000 = i1_n;
	o0->dw0024 = o5;
	struct Eq_n * i1_n;
	if ((o0_n | 0x80000000) < 0x00)
	{
		o0->dw0028 = o0_n | 0x80000000;
		o3();
		struct Eq_n * o0_n;
		i1_n = o0_n;
	}
	else
	{
		o0->dw0028 = o0_n | 0x80000000;
		o3();
		struct Eq_n * o0_n;
		i1_n = o0_n;
	}
	struct Eq_n * i0_n;
	if (i1_n != null)
	{
		i0_n->ptr0004 = i1_n;
		word32 o0_n = i0_n->dw0000;
		word32 o1_n = &i1_n->dw0004 + 1;
		i0_n->dw000C = o1_n;
		i0_n->dw0008 = o1_n;
		word32 o0_n = (char *) &i1_n->dw0000 + o0_n;
		i1_n->dw0000 = o0_n;
		i0_n->dw0010 = o0_n;
		i1_n->dw0004 = 0x00;
		i0_n->dw0028 = i0_n->dw0028 & ~0x40000000 & ~0x20000000;
	}
	else
	{
		i0_n->ptr0004 = i1_n;
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
	}
}

// 00015550: void _obstack_newchunk(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o3, Register word32 o4, Register word32 o5)
void _obstack_newchunk(struct Eq_n * o0, word32 o1, word32 o3, word32 o4, word32 o5)
{
	int32 i1_n;
	int32 l2_n = o0->dw000C - o0->dw0008;
	word32 i1_n = l2_n + o1 + (l2_n >> 0x03);
	int32 o2_n = o0->dw0000;
	int32 i1_n = i1_n + 100;
	if (i1_n + 100 < o2_n)
		i1_n = o2_n;
	struct Eq_n * l0_n;
	if (o0->dw0028 < 0x00)
	{
		<anonymous> * o2_n = o0->ptr001C;
		o2_n();
		struct Eq_n * o0_n;
		l0_n = o0_n;
	}
	else
	{
		<anonymous> * o1_n = o0->ptr001C;
		o1_n();
		struct Eq_n * o0_n;
		l0_n = o0_n;
	}
	struct Eq_n * i0_n;
	if (l0_n == null)
	{
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
		i0_n->ptr0004 = l0_n;
	}
	else
		i0_n->ptr0004 = l0_n;
	struct Eq_n * l1_n;
	l0_n->ptr0004 = l1_n;
	ptr32 o1_n = (char *) &l0_n->ptr0000 + i1_n;
	i0_n->ptr0010 = o1_n;
	l0_n->ptr0000 = o1_n;
	Eq_n l2_n;
	Eq_n i1_n;
	Eq_n g2_n;
	Eq_n o2_n;
	Eq_n o0_n;
	if (i0_n->dw0018 > 0x06)
	{
		Eq_n o0_n = l2_n >> 0x02;
		Eq_n o5_n = o0_n;
		i1_n.u1 = (char *) &l0_n->ptr0004 + 4;
		int32 o3_n = (word32) o0_n - 1;
		if (o0_n >= 0x01)
		{
			g2_n.u1 = (char *) &l1_n->ptr0004 + 4;
			Eq_n o4_n;
			o4_n.u1 = (char *) &l0_n->ptr0000 + (((word32) o0_n - 1 << 0x02) + 0x08);
			while (true)
			{
				o2_n.u0 = *((word32) i0_n->t0008.u0 + o3_n * 0x04);
				*o4_n.u1 = (word32) o2_n;
				o3_n += ~0x00;
				if (o3_n < 0x00)
					break;
				o4_n.u1 = (word32) o4_n - 4;
			}
			Eq_n o4_n;
			o4_n.u1 = (word32) o4_n - 4;
		}
		else
			g2_n.u1 = (char *) &l1_n->ptr0004 + 4;
		o0_n = __align(l2_n, 4);
	}
	else
	{
		o0_n.u0 = 0x00;
		i1_n.u1 = (char *) &l0_n->ptr0004 + 4;
		g2_n.u1 = (char *) &l1_n->ptr0004 + 4;
	}
	Eq_n o3_n = o0_n;
	Eq_n o0_n;
	if (o0_n < l2_n)
	{
		Eq_n o0_n;
		o0_n.u0 = i0_n->t0008.u0;
		o2_n = i1_n;
		while (true)
		{
			Mem209[i1_n + o3_n:byte] = Mem206[o0_n + o3_n:byte];
			o3_n = (word32) o3_n.u0 + 1;
			if (o3_n >= l2_n)
				break;
			o0_n.u0 = i0_n->t0008.u0;
		}
		o0_n.u0 = i0_n->t0008.u0;
	}
	else
		o0_n.u0 = i0_n->t0008.u0;
	Eq_n o0_n;
	if (o0_n == g2_n)
	{
		Eq_n o0_n;
		o0_n.u0 = i0_n->t0028.u0;
		if ((o0_n >> 0x1E & 0x01) == 0x00)
		{
			l0_n->ptr0004 = l1_n->ptr0004;
			if (i0_n->t0028.u0 >= 0x00)
			{
				<anonymous> * o1_n = i0_n->ptr0020;
				o1_n();
				o0_n.u0 = i0_n->t0028.u0;
			}
			else
			{
				<anonymous> * o2_n = i0_n->ptr0020;
				o2_n();
				o0_n.u0 = i0_n->t0028.u0;
			}
		}
		else
			o0_n.u0 = i0_n->t0028.u0;
	}
	else
		o0_n.u0 = i0_n->t0028.u0;
	i0_n->t0028.u0 = (int32) (o0_n & ~0x40000000);
	Mem336[i0_n + 0x0C:word32] = i1_n + l2_n;
	i0_n->t0008.u0 = (int32) i1_n;
}

// 000156F0: void _obstack_allocated_p(Register (ptr32 Eq_n) o0, Register up32 o1)
void _obstack_allocated_p(struct Eq_n * o0, up32 o1)
{
	struct Eq_n * g3_n;
	for (g3_n = o0->ptr0004; g3_n != null; g3_n = g3_n->ptr0004)
	{
		up32 g0_n = g3_n - o1;
		if (g0_n < 0x00)
		{
			if (g3_n->dw0000 >= o1)
				return;
			g3_n = g3_n->ptr0004;
			continue;
		}
	}
}

// 00015724: void _obstack_free(Register (ptr32 Eq_n) o0, Register up32 o1, Register word32 o2, Register word32 o4, Register word32 o5)
void _obstack_free(struct Eq_n * o0, up32 o1, word32 o2, word32 o4, word32 o5)
{
	struct Eq_n * i0_n = o0;
	up32 i1_n = o1;
	up32 * o3_n = o0->ptr0004;
	while (o3_n != null)
	{
		up32 g0_n = o3_n - i1_n;
		int32 o0_n;
		if (g0_n < 0x00)
		{
			if (*o3_n >= i1_n)
				break;
			o0_n = i0_n->dw0028;
		}
		else
			o0_n = i0_n->dw0028;
		int32 o1_n;
		up32 * l0_n;
		if (o0_n < 0x00)
		{
			<anonymous> * o2_n = i0_n->ptr0020;
			o2_n();
			o1_n = i0_n->dw0028;
			up32 * l0_n;
			l0_n = l0_n;
		}
		else
		{
			<anonymous> * o1_n = i0_n->ptr0020;
			o1_n();
			o1_n = i0_n->dw0028;
			up32 * l0_n;
			l0_n = l0_n;
		}
		i0_n->dw0028 = o1_n | 0x40000000;
		o3_n = l0_n;
	}
	if (o3_n == null)
	{
		if (i1_n == 0x00)
			return;
		abort();
	}
	else
	{
		i0_n->dw0008 = i1_n;
		i0_n->dw000C = i1_n;
		up32 o0_n = *o3_n;
		i0_n->ptr0004 = o3_n;
		i0_n->dw0010 = o0_n;
	}
}

// 000157D4: void obstack_free(Register (ptr32 Eq_n) o0, Register up32 o1, Register word32 o2, Register word32 o4, Register word32 o5)
void obstack_free(struct Eq_n * o0, up32 o1, word32 o2, word32 o4, word32 o5)
{
	struct Eq_n * i0_n = o0;
	up32 i1_n = o1;
	up32 * o3_n = o0->ptr0004;
	while (o3_n != null)
	{
		up32 g0_n = o3_n - i1_n;
		int32 o0_n;
		if (g0_n < 0x00)
		{
			if (*o3_n >= i1_n)
				break;
			o0_n = i0_n->dw0028;
		}
		else
			o0_n = i0_n->dw0028;
		int32 o1_n;
		up32 * l0_n;
		if (o0_n < 0x00)
		{
			<anonymous> * o2_n = i0_n->ptr0020;
			o2_n();
			o1_n = i0_n->dw0028;
			up32 * l0_n;
			l0_n = l0_n;
		}
		else
		{
			<anonymous> * o1_n = i0_n->ptr0020;
			o1_n();
			o1_n = i0_n->dw0028;
			up32 * l0_n;
			l0_n = l0_n;
		}
		i0_n->dw0028 = o1_n | 0x40000000;
		o3_n = l0_n;
	}
	if (o3_n == null)
	{
		if (i1_n == 0x00)
			return;
		abort();
	}
	else
	{
		i0_n->dw0008 = i1_n;
		i0_n->dw000C = i1_n;
		up32 o0_n = *o3_n;
		i0_n->ptr0004 = o3_n;
		i0_n->dw0010 = o0_n;
	}
}

// 00015884: void _obstack_memory_used(Register (ptr32 Eq_n) o0)
void _obstack_memory_used(struct Eq_n * o0)
{
	struct Eq_n * g3_n;
	for (g3_n = o0->ptr0004; g3_n != null; g3_n = g3_n->ptr0004)
		;
}

// 000158B4: void print_and_abort()
void print_and_abort()
{
	fputs("memory exhausted\n", &g_t2B640);
	exit(obstack_exit_failure);
}

// 000158D8: Register (ptr32 char) try(Register (ptr32 char) o0, Register (ptr32 char) o1)
// Called from:
//      choose_temp_base
//      make_temp_file
char * try(char * o0, char * o1)
{
	char * i0_n = o0;
	if (o1 != null)
		i0_n = o1;
	else if (o0 == null || access(o0, 0x07) != 0x00)
		i0_n = null;
	return i0_n;
}

// 00015918: Register Eq_n choose_temp_base(Register out Eq_n l1Out, Register out Eq_n i0Out, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
Eq_n choose_temp_base(union Eq_n & l1Out, union Eq_n & i0Out, ptr32 & i6Out)
{
	char * o0_n = try(&g_b28038, try(&g_b28040, try("/var/tmp/", try(getenv("TEMP"), try(getenv("TMP"), try(getenv("TMPDIR"), null))))));
	char * l0_n = o0_n;
	if (o0_n == null)
		l0_n = (char *) ".";
	Eq_n o0_n;
	o0_n.u0 = (uint32) strlen(l0_n);
	word32 i1_n;
	word32 i2_n;
	ptr32 i6_n;
	xmalloc(out i1_n, out i2_n, out i6_n);
	strcpy(o0_n.u2->a000A, l0_n);
	Eq_n l1_n = o0_n;
	ui32 o0_n;
	if (o0_n != 0x00)
	{
		if (CONVERT(Mem0[o0_n + (o0_n + 0x0A) + -1:int8], int8, int32) == 0x2F)
		{
			o0_n = (ui32) g_b17918;
l00015A04:
			Mem182[o0_n + 0x0A + l1_n:byte] = SLICE(o0_n, byte, 0);
			Eq_n o4_n = o0_n + 0x0A + l1_n;
			o4_n.u2->b0001 = g_b17919;
			o4_n.u2->b0002 = g_b1791A;
			o4_n.u2->b0003 = g_b1791B;
			o4_n.u2->b0004 = g_b1791C;
			o4_n.u2->b0005 = g_b1791D;
			o4_n.u2->b0006 = g_b1791E;
			o4_n.u2->b0007 = g_b1791F;
			o4_n.u2->b0008 = g_b17920;
			mktemp(o0_n.u2->a000A);
			if ((uint32) strlen(o0_n.u2->a000A) != 0x00)
			{
				l1Out = l1_n;
				i0Out.u1 = o0_n.u2->a000A;
				i6Out = i6_n;
				return o0_n.u2->a000A;
			}
			else
				abort();
		}
		Mem170[o0_n + (o0_n + 0x0A):byte] = 0x2F;
		l1_n.u1 = &o0_n.u2->b0001;
	}
	o0_n = (ui32) g_b17918;
	goto l00015A04;
}

// 00015A7C: void make_temp_file(Register (ptr32 char) o0)
void make_temp_file(char * o0)
{
	char * o0_n = try(&g_b28050, try(&g_b28058, try("/var/tmp/", try(getenv("TEMP"), try(getenv("TMP"), try(getenv("TMPDIR"), null))))));
	char * l0_n = o0_n;
	if (o0_n == null)
		l0_n = (char *) ".";
	Eq_n o0_n;
	o0_n.u0 = (uint32) strlen(l0_n);
	Eq_n l2_n;
	if (o0 != null)
		l2_n.u1 = (uint32) strlen(o0);
	else
		l2_n.u0 = 0x00;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	xmalloc(out i1_n, out i2_n, out i6_n);
	Eq_n o0_n = o0_n + l2_n;
	strcpy(o0_n.u1->a000A, l0_n);
	Eq_n l1_n = o0_n;
	if (o0_n != 0x00)
	{
		Eq_n o0_n = o0_n + (o0_n + 0x0A);
		if ((int32) o0_n.u1->bFFFFFFFF != 0x2F)
		{
			Mem185[o0_n + (o0_n + 0x0A):byte] = 0x2F;
			l1_n.u1 = (word32) o0_n + 1;
		}
	}
	Mem193[o0_n + 0x0A + l1_n:byte] = Mem188[0x00017918:byte];
	Eq_n o3_n = o0_n + 0x0A + l1_n;
	o3_n.u1->b0001 = g_b17919;
	o3_n.u1->b0002 = g_b1791A;
	o3_n.u1->b0003 = g_b1791B;
	o3_n.u1->b0004 = g_b1791C;
	o3_n.u1->b0005 = g_b1791D;
	o3_n.u1->b0006 = g_b1791E;
	o3_n.u1->b0007 = g_b1791F;
	ui32 o1_n = (ui32) g_b17920;
	if (o0 == null)
	{
		o3_n.u1->b0008 = (byte) o1_n;
		int32 o0_n = mkstemps(o0_n.u1->a000A, l2_n);
		if (o0_n != ~0x00)
		{
			if (close(o0_n) == 0x00)
				return;
			abort();
		}
		else
			abort();
	}
	else
	{
		o3_n.u1->b0008 = (byte) o1_n;
		strcat(o0_n.u1->a000A, o0);
	}
}

// 00015C24: Register (ptr32 int8) my_index(Register (ptr32 int8) o0, Register Eq_n o1)
// Called from:
//      _getopt_internal
int8 * my_index(int8 * o0, Eq_n o1)
{
	int32 g2_n = (int32) *o0;
	while (g2_n != 0x00)
	{
		ui32 g3_n = (ui32) *o0;
		if ((int32) (byte) g3_n == o1)
			return o0;
		++o0;
		g2_n = (int32) *o0;
	}
	o0 = null;
	return o0;
}

// 00015C60: Register Eq_n exchange(Register Eq_n o0, Register out (ptr32 char) i2Out, Register out Eq_n i4Out, Register out Eq_n i5Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      _getopt_internal
Eq_n exchange(Eq_n o0, char & i2Out, union Eq_n & i4Out, union Eq_n & i5Out, struct Eq_n & i6Out)
{
	char * o2;
	Eq_n g1_n;
	g1_n.u0 = g_t2B300.u0;
	Eq_n i5_n;
	i5_n.u0 = optind.u0;
	char * i2_n = o2;
	Eq_n i1_n;
	i1_n.u0 = 0x00028000;
	Eq_n i4_n;
	i4_n.u0 = g_t2B2F0.u0;
	Eq_n g2_n;
	if (i5_n <= g1_n)
	{
l00015D40:
		g2_n.u0 = optind.u0;
		goto l00015D44;
	}
	if (g1_n <= i4_n)
	{
		g2_n.u0 = optind.u0;
l00015D44:
		g_t2B2F0.u0 = (int32) (g_t2B2F0.u0 + (g2_n - g_t2B300.u0));
		g_t2B300.u0 = (int32) g2_n;
		i2Out = i2_n;
		i4Out = i4_n;
		i5Out = i5_n;
		struct Eq_n * fp;
		i6Out = fp;
		return i1_n;
	}
	int32 g3_n = i5_n - g1_n;
l00015CA4:
	int32 g2_n = g1_n - i4_n;
	bool v28_n;
	if (g3_n > g2_n)
	{
		if (g2_n > 0x00)
		{
			i5_n -= g2_n;
			int32 i3_n = g2_n;
			i1_n = i5_n << 0x02;
			Eq_n g3_n = i4_n << 0x02;
			while (true)
			{
				i2_n = Mem90[g3_n + o0:word32];
				Mem97[g3_n + o0:word32] = Mem90[i1_n + o0:word32];
				Mem98[i1_n + o0:word32] = i2_n;
				i3_n += ~0x00;
				i1_n.u1 = (word32) i1_n + 4;
				if (i3_n == 0x00)
					break;
				g3_n.u1 = (word32) g3_n + 4;
			}
			v28_n = i5_n <= g1_n;
l00015D30:
			if (v28_n)
				goto l00015D40;
			int32 g0_n = g1_n - i4_n;
			if (g0_n <= 0x00)
				goto l00015D40;
			g3_n = i5_n - g1_n;
			goto l00015CA4;
		}
		i5_n -= g2_n;
	}
	else
	{
		Eq_n g4_n;
		if (g3_n > 0x00)
		{
			g4_n.u1 = (word32) i4_n.u0 + g3_n;
			int32 i3_n = g3_n;
			Eq_n i1_n = i4_n << 0x02;
			Eq_n g3_n = g1_n << 0x02;
			while (true)
			{
				i2_n = Mem55[i1_n + o0:word32];
				Mem62[i1_n + o0:word32] = Mem55[g3_n + o0:word32];
				Mem63[g3_n + o0:word32] = i2_n;
				i3_n += ~0x00;
				g3_n.u1 = (word32) g3_n + 4;
				if (i3_n == 0x00)
					break;
				i1_n.u1 = (word32) i1_n + 4;
			}
			i1_n.u1 = (word32) i1_n + 4;
		}
		else
			g4_n.u1 = (word32) i4_n.u0 + g3_n;
		i4_n = g4_n;
	}
	v28_n = i5_n <= g1_n;
	goto l00015D30;
}

// 00015D64: Register (ptr32 int8) _getopt_initialize(Register (ptr32 int8) o2, Register out ptr32 i1Out, Register out ptr32 i4Out, Register out ptr32 i5Out, Register out ptr32 i6Out)
// Called from:
//      _getopt_internal
int8 * _getopt_initialize(int8 * o2, ptr32 & i1Out, ptr32 & i4Out, ptr32 & i5Out, ptr32 & i6Out)
{
	Eq_n o2_n;
	o2_n.u0 = optind.u0;
	g_t2B2F0.u0 = (int32) o2_n;
	g_t2B300.u0 = (int32) o2_n;
	g_t2B2C0.u0 = 0x00;
	char * o0_n = getenv("POSIXLY_CORRECT");
	g_ptr2B2E0 = o0_n;
	int8 * i0_n = o2;
	int32 o0_n = (int32) *o2;
	switch (o0_n)
	{
	case 0x2D:
		g_dw2B2D0 = 0x02;
		i0_n = o2 + 1;
		break;
	case 0x2B:
		g_dw2B2D0 = 0x00;
		i0_n = o2 + 1;
		break;
	default:
		if (o0_n != null)
			g_dw2B2D0 = 0x00;
		else
			g_dw2B2D0 = 0x01;
		break;
	}
	ptr32 o1;
	i1Out = o1;
	ptr32 o4;
	i4Out = o4;
	ptr32 o5;
	i5Out = o5;
	ptr32 fp;
	i6Out = fp;
	return i0_n;
}

// 00015E04: Register Eq_n _getopt_internal(Register Eq_n o1, Register (ptr32 int8) o2, Register (ptr32 ptr32) o4, Register word32 o5, Register out ptr32 l6Out, Register out ptr32 l7Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      getopt
//      getopt_long
//      getopt_long_only
Eq_n _getopt_internal(Eq_n o1, int8 * o2, ptr32 * o4, word32 o5, ptr32 & l6Out, ptr32 & l7Out, struct Eq_n & i6Out)
{
	struct Eq_n * fp;
	Eq_n o2_n;
	o2_n.u0 = optind.u0;
	optarg.u0 = 0x00;
	Eq_n i1_n = o1;
	int8 * i2_n = o2;
	ptr32 * i4_n = o4;
	word32 i5_n = o5;
	struct Eq_n * i6_n = fp;
	if (o2_n == 0x00 || __getopt_initialized == 0x00)
	{
		if (o2_n == 0x00)
			optind.u0 = 0x01;
		int8 * o0_n = _getopt_initialize(o2, out i1_n, out i4_n, out i5_n, out i6_n);
		__getopt_initialized = 0x01;
		i2_n = o0_n;
	}
	Eq_n l0_n;
	l0_n.u0 = 0x00028000;
	Eq_n o0_n;
	o0_n.u0 = g_t2B2C0.u0;
	struct Eq_n * o0_n;
	if (o0_n != 0x00 && (int32) (o0_n.u2)->b0000 != 0x00)
	{
		o0_n = i6_n->ptr0050;
		goto l000160C0;
	}
	Eq_n o2_n;
	o2_n.u0 = optind.u0;
	if (g_t2B300.u0 > o2_n)
		g_t2B300.u0 = (int32) o2_n;
	l0_n.u0 = 0x0002B000;
	if (g_t2B2F0.u0 > o2_n)
		g_t2B2F0.u0 = (int32) o2_n;
	if (g_dw2B2D0 != 0x01)
	{
l00015F78:
		Eq_n o1_n;
		o1_n.u0 = optind.u0;
		Eq_n o2_n;
		if (o1_n == (i6_n->t0044).u0)
		{
l00016008:
			o2_n.u0 = optind.u0;
			goto l0001600C;
		}
		if (strcmp(*((word32) i1_n + o1_n * 0x04), "--") != 0x00)
		{
			o2_n.u0 = optind.u0;
l0001600C:
			if (o2_n == (i6_n->t0044).u0)
			{
				Eq_n o1_n;
				o1_n.u0 = g_t2B2F0.u0;
				if (o1_n == g_t2B300.u0)
					goto l00016978;
				optind.u0 = (int32) o1_n;
			}
			else
			{
				Eq_n o3_n;
				o3_n.u1 = *((word32) i1_n + o2_n * 0x04);
				word32 o0_n;
				if ((int32) o3_n.u2->b0000 == 0x2D)
				{
					int32 o0_n = (int32) o3_n.u2[1];
					if (o0_n != 0x00)
					{
						struct Eq_n * o2_n = i6_n->ptr0050;
						word32 o1_n;
						if (o2_n != null)
							o1_n = 0x01 - (word32) ((o0_n ^ 0x2D) > 0x00);
						else
							o1_n = 0x00;
						g_t2B2C0.u0 = (ui32) (o3_n.u1 + (o1_n + 0x01));
						o0_n = i6_n->ptr0050;
l000160C0:
						Eq_n o1_n;
						if (o0_n == null)
						{
							o1_n.u0 = g_t2B2C0.u0;
							goto l000164A0;
						}
						Eq_n o0_n;
						o0_n.u0 = optind.u0;
						struct Eq_n * o0_n = (struct Eq_n *) *((word32) i1_n + o0_n * 0x04);
						Eq_n o1_n;
						o1_n.u0 = (int32) o0_n->b0001;
						Eq_n l2_n;
						if (o1_n != 0x2D)
						{
							if (i5_n == 0x00)
							{
								o1_n.u0 = g_t2B2C0.u0;
								goto l000164A0;
							}
							if ((int32) o0_n->b0002 != 0x00)
							{
								l2_n.u0 = g_t2B2C0.u0;
l00016114:
								struct Eq_n * l3_n = null;
								word32 i3_n = 0x00;
								int32 o0_n = (int32) l2_n.u2->b0000;
								word32 i0_n = 0x00;
								word32 o1_n = i6_n->ptr0050->dw0000;
								ptr32 l7 = ~0x00;
								while (o0_n != 0x00)
								{
									int32 g0_n = o0_n - 0x3D;
									if (g0_n == 0x00)
										break;
									++l2_n.u2;
									o0_n = (int32) l2_n.u2->b0000;
								}
								struct Eq_n * l1_n = i6_n->ptr0050;
								if (o1_n != 0x00)
								{
									ptr32 l4_n = 0x00;
l0001615C:
									Eq_n o1_n;
									o1_n.u0 = g_t2B2C0.u0;
									if (strncmp(l1_n->dw0000, o1_n, l2_n - o1_n) != 0x00)
									{
										++l1_n;
										goto l000161A8;
									}
									l0_n = l2_n - g_t2B2C0.u0;
									if (l0_n != (uint32) strlen(l1_n->dw0000))
									{
										if (l3_n == null)
										{
											l3_n = l1_n;
											l7 = l4_n;
										}
										else
											i0_n = 0x01;
										++l1_n;
l000161A8:
										if (l1_n->dw0000 == 0x00)
											goto l000161B8;
										++l4_n;
										goto l0001615C;
									}
									l3_n = l1_n;
									l7 = l4_n;
									i3_n = 0x01;
								}
l000161B8:
								bool v46_n;
								if (i0_n != 0x00)
								{
									if (i3_n == 0x00)
									{
										if (opterr != 0x00)
										{
											Eq_n o1_n;
											o1_n.u0 = optind.u0;
											fprintf(&g_t2B640, "%s: option `%s' is ambiguous\n", *i1_n, *((word32) i1_n + o1_n * 0x04));
										}
										uint32 o0_n = (uint32) strlen(g_t2B2C0.u0);
										Eq_n o2_n;
										o2_n.u0 = optind.u0;
										g_t2B2C0.u0 = (ui32) (g_t2B2C0.u0 + o0_n);
										optind.u0 = (word32) o2_n + 1;
										optopt.u0 = 0x00;
										goto l00016978;
									}
									v46_n = l3_n == null;
								}
								else
									v46_n = l3_n == null;
								union Eq_n * o1_n;
								Eq_n o0_n;
								int32 o0_n;
								if (!v46_n)
								{
									Eq_n o2_n;
									o2_n.u0 = optind.u0;
									optind.u0 = (word32) o2_n + 1;
									if ((int32) l2_n.u2->b0000 != 0x00)
									{
										word32 o0_n = l3_n->dw0004;
										if (o0_n != 0x00)
										{
											Eq_n o0_n;
											o0_n.u2 = l2_n.u2 + 1;
											optarg.u0 = (ui32) o0_n;
										}
										else if (opterr != 0x00)
										{
											struct Eq_n * o3_n = Mem1270[(o2_n + 0x01 << 0x02) + i1_n + -4:word32];
											Eq_n o0_n;
											if ((int32) o3_n->b0001 == 0x2D)
											{
												fprintf(&g_t2B640, "%s: option `--%s' doesn't allow an argument\n", *i1_n, l3_n->dw0000);
												o0_n.u0 = g_t2B2C0.u0;
											}
											else
											{
												fprintf(&g_t2B640, "%s: option `%c%s' doesn't allow an argument\n", *i1_n, o3_n->b0000, l3_n->dw0000);
												o0_n.u0 = g_t2B2C0.u0;
											}
											uint32 o0_n = (uint32) strlen(o0_n);
											Eq_n o2_n;
											o2_n.u0 = l3_n->t000C.u0;
											g_t2B2C0.u0 = (ui32) (g_t2B2C0.u0 + o0_n);
											optopt.u0 = (int32) o2_n;
											goto l00016978;
										}
l00016398:
										Eq_n o1_n = g_t2B2C0.u0 + (uint32) strlen(g_t2B2C0.u0);
										if (i4_n != null)
										{
											g_t2B2C0.u0 = (ui32) o1_n;
											*i4_n = l7;
										}
										else
											g_t2B2C0.u0 = (ui32) o1_n;
										o1_n = l3_n->ptr0008;
										if (o1_n == null)
											goto l00016978;
										o0_n.u0 = l3_n->t000C.u0;
										goto l00016874;
									}
									word32 o0_n = l3_n->dw0004;
									if (o0_n != 0x01)
										goto l00016398;
									Eq_n o0_n;
									o0_n.u0 = i6_n->t0044.u0;
									if ((word32) o2_n + 1 < o0_n)
									{
										optarg.u0 = (ui32) *((word32) i1_n + ((word32) o2_n + 1) * 0x04);
										optind.u0 = (word32) o2_n + 2;
										goto l00016398;
									}
									if (opterr != 0x00)
										fprintf(&g_t2B640, "%s: option `%s' requires an argument\n", *i1_n, Mem1270[(o2_n + 0x01 << 0x02) + i1_n + -4:word32]);
									uint32 o0_n = (uint32) strlen(g_t2B2C0.u0);
									Eq_n o2_n;
									o2_n.u0 = l3_n->t000C.u0;
									g_t2B2C0.u0 = (ui32) (g_t2B2C0.u0 + o0_n);
									optopt.u0 = (int32) o2_n;
									o0_n = (int32) *i2_n;
l00016388:
									if (o0_n != 0x3A)
										strlen(g_t2B2C0.u0);
									goto l00016978;
								}
								if (i5_n == 0x00)
								{
l0001640C:
									Eq_n o0_n;
									if (opterr != 0x00)
									{
										Eq_n o0_n;
										o0_n.u0 = optind.u0;
										struct Eq_n * o3_n = (struct Eq_n *) *((word32) i1_n + o0_n * 0x04);
										if ((int32) o3_n->b0001 != 0x2D)
											fprintf(&g_t2B640, "%s: unrecognized option `%c%s'\n", *i1_n, o3_n->t0000.u1, g_t2B2C0.u0);
										fprintf(&g_t2B640, "%s: unrecognized option `--%s'\n", *i1_n, g_t2B2C0.u0);
										o0_n.u0 = optind.u0;
									}
									else
										o0_n.u0 = optind.u0;
									g_t2B2C0.u0 = 96808;
									optind.u0 = (word32) o0_n + 1;
									optopt.u0 = 0x00;
									goto l00016978;
								}
								Eq_n o0_n;
								o0_n.u0 = optind.u0;
								if ((int32) *((word32) *((word32) i1_n + o0_n * 0x04) + 1) == 0x2D)
									goto l0001640C;
								Eq_n o2_n;
								o2_n.u0 = g_t2B2C0.u0;
								if (my_index(i2_n, (int32) o2_n.u2->b0000) == null)
									goto l0001640C;
								o1_n.u0 = g_t2B2C0.u0;
l000164A0:
								ui32 i0_n = (ui32) *o1_n.u1;
								g_t2B2C0.u0 = (ui32) (o1_n.u2 + 1);
								l0_n.u0 = (int32) (byte) i0_n;
								struct Eq_n * o0_n = my_index(i2_n, l0_n);
								Eq_n o3_n;
								o3_n.u0 = g_t2B2C0.u0;
								if ((int32) o3_n.u2->b0000 == 0x00)
									optind.u0 = (int32) (optind.u0 + 0x01);
								if (o0_n == null || l0_n == 0x3A)
								{
									if (opterr != 0x00)
									{
										if (g_ptr2B2E0 == null)
											fprintf(&g_t2B640, "%s: invalid option -- %c\n", *i1_n, (char) l0_n);
										fprintf(&g_t2B640, "%s: illegal option -- %c\n", *i1_n, (char) l0_n);
									}
									optopt.u0 = (int32) (byte) i0_n;
									goto l00016978;
								}
								int32 o0_n = (int32) o0_n->b0000;
								int32 o0_n;
								if (o0_n == 0x57)
								{
									ui32 o1_n = (ui32) o0_n->b0001;
									if (o1_n == 0x3B)
									{
										struct Eq_n * l3_n = null;
										word32 i0_n = 0x00;
										word32 l4_n = 0x00;
										if ((int32) o3_n.u2->b0000 != 0x00)
										{
											Eq_n o0_n;
											o0_n.u0 = optind.u0;
											optarg.u0 = (ui32) o3_n;
											optind.u0 = (word32) o0_n + 1;
											goto l0001663C;
										}
										l7 = 0x00;
										Eq_n o2_n;
										o2_n.u0 = optind.u0;
										if (o2_n != (i6_n->t0044).u0)
										{
											optarg.u0 = (ui32) *((word32) i1_n + o2_n * 0x04);
											optind.u0 = (word32) o2_n + 1;
l0001663C:
											Eq_n l1_n;
											l1_n.u0 = optarg.u0;
											g_t2B2C0.u0 = (ui32) l1_n;
											l7 = 0x00;
											while (true)
											{
												int32 o0_n = (int32) l1_n.u2->b0000;
												if (o0_n == 0x00 || o0_n == 0x3D)
													break;
												++l1_n.u2;
											}
											struct Eq_n * i3_n = i6_n->ptr0050;
											if (i3_n->dw0000 != 0x00)
											{
												ptr32 l2_n = 0x00;
l00016670:
												Eq_n o1_n;
												o1_n.u0 = g_t2B2C0.u0;
												if (strncmp(i3_n->dw0000, o1_n, l1_n - o1_n) != 0x00)
												{
													++i3_n;
													goto l000166BC;
												}
												l0_n = l1_n - g_t2B2C0.u0;
												if (l0_n != (uint32) strlen(i3_n->dw0000))
												{
													if (l3_n == null)
													{
														l3_n = i3_n;
														l7 = l2_n;
													}
													else
														l4_n = 0x01;
													++i3_n;
l000166BC:
													if (i3_n->dw0000 == 0x00)
														goto l000166CC;
													++l2_n;
													goto l00016670;
												}
												l3_n = i3_n;
												l7 = l2_n;
												i0_n = 0x01;
											}
l000166CC:
											bool v52_n;
											if (l4_n != 0x00)
											{
												if (i0_n == 0x00)
												{
													if (opterr != 0x00)
													{
														Eq_n o1_n;
														o1_n.u0 = optind.u0;
														fprintf(&g_t2B640, "%s: option `-W %s' is ambiguous\n", *i1_n, *((word32) i1_n + o1_n * 0x04));
													}
													uint32 o0_n = (uint32) strlen(g_t2B2C0.u0);
													Eq_n o2_n;
													o2_n.u0 = optind.u0;
													g_t2B2C0.u0 = (ui32) (g_t2B2C0.u0 + o0_n);
													optind.u0 = (word32) o2_n + 1;
													goto l00016978;
												}
												v52_n = l3_n == null;
											}
											else
												v52_n = l3_n == null;
											if (v52_n)
											{
												g_t2B2C0.u0 = 0x00;
												goto l00016978;
											}
											if ((int32) l1_n.u2->b0000 == 0x00)
											{
												word32 o0_n = l3_n->dw0004;
												if (o0_n == 0x01)
												{
													Eq_n o2_n;
													o2_n.u0 = optind.u0;
													if (o2_n >= (i6_n->t0044).u0)
													{
														if (opterr != 0x00)
															fprintf(&g_t2B640, "%s: option `%s' requires an argument\n", *i1_n, Mem874[(o2_n << 0x02) + i1_n + -4:word32]);
														g_t2B2C0.u0 = (ui32) (g_t2B2C0.u0 + (uint32) strlen(g_t2B2C0.u0));
														o0_n = (int32) *i2_n;
														goto l00016388;
													}
													optarg.u0 = (ui32) *((word32) i1_n + o2_n * 0x04);
													optind.u0 = (word32) o2_n.u0 + 1;
												}
												goto l00016840;
											}
											word32 o0_n = l3_n->dw0004;
											if (o0_n != 0x00)
											{
												Eq_n o0_n;
												o0_n.u2 = l1_n.u2 + 1;
												optarg.u0 = (ui32) o0_n;
l00016840:
												Eq_n o1_n = g_t2B2C0.u0 + (uint32) strlen(g_t2B2C0.u0);
												if (i4_n != null)
												{
													g_t2B2C0.u0 = (ui32) o1_n;
													*i4_n = l7;
												}
												else
													g_t2B2C0.u0 = (ui32) o1_n;
												o1_n = l3_n->ptr0008;
												if (o1_n == null)
													goto l00016978;
												o0_n.u0 = l3_n->t000C.u0;
l00016874:
												o1_n->u0 = (int32) o0_n;
												goto l00016978;
											}
											if (opterr != 0x00)
												fprintf(&g_t2B640, "%s: option `-W %s' doesn't allow an argument\n", *i1_n, l3_n->dw0000);
											g_t2B2C0.u0 = (ui32) (g_t2B2C0.u0 + (uint32) strlen(g_t2B2C0.u0));
l00016978:
											l6Out = 0x0002B000;
											l7Out = l7;
											i6Out = i6_n;
											return l0_n;
										}
										if (opterr != 0x00)
											fprintf(&g_t2B640, "%s: option requires an argument -- %c\n", *i1_n, (char) l0_n);
										optopt.u0 = (int32) l0_n;
										(int32) *i2_n != 0x3A;
l00016974:
										goto l00016978;
									}
									o0_n = o1_n << 0x18;
								}
								else
								{
									ui32 o1_n = (ui32) o0_n->b0001;
									o0_n = o1_n << 0x18;
								}
								if (o0_n >> 0x18 != 0x3A)
									goto l00016974;
								Eq_n o1_n;
								Eq_n o0_n;
								if ((int32) o0_n->b0002 == 0x3A)
								{
									o1_n.u0 = g_t2B2C0.u0;
									if ((int32) o1_n.u2->b0000 == 0x00)
									{
										optarg.u0 = 0x00;
										goto l0001696C;
									}
									o0_n.u0 = optind.u0;
								}
								else
								{
									o1_n.u0 = g_t2B2C0.u0;
									if ((int32) o1_n.u2->b0000 == 0x00)
									{
										Eq_n o2_n;
										o2_n.u0 = optind.u0;
										if (o2_n == (i6_n->t0044).u0)
										{
											if (opterr != 0x00)
												fprintf(&g_t2B640, "%s: option requires an argument -- %c\n", *i1_n, (byte) i0_n);
											optopt.u0 = (int32) (byte) i0_n;
											(int32) *i2_n != 0x3A;
										}
										else
										{
											optarg.u0 = (ui32) *((word32) i1_n + o2_n * 0x04);
											optind.u0 = (word32) o2_n + 1;
										}
l0001696C:
										g_t2B2C0.u0 = 0x00;
										goto l00016970;
									}
									o0_n.u0 = optind.u0;
								}
								optarg.u0 = (ui32) o1_n;
								optind.u0 = (word32) o0_n + 1;
								goto l0001696C;
							}
							if (my_index(i2_n, o1_n) != null)
							{
								o1_n.u0 = g_t2B2C0.u0;
								goto l000164A0;
							}
						}
						l2_n.u0 = g_t2B2C0.u0;
						goto l00016114;
					}
					o0_n = g_dw2B2D0;
				}
				else
					o0_n = g_dw2B2D0;
				if (o0_n != 0x00)
				{
					Eq_n o0_n;
					o0_n.u1 = (word32) o2_n + 1;
					optarg.u0 = (ui32) o3_n;
					optind.u0 = (int32) o0_n;
					goto l00016978;
				}
			}
			goto l00016978;
		}
		Eq_n o2_n;
		o2_n.u0 = g_t2B300.u0;
		Eq_n o0_n;
		o0_n.u0 = optind.u0;
		Eq_n o0_n;
		Eq_n o1_n;
		if (g_t2B2F0.u0 != o2_n)
		{
			optind.u0 = (word32) o0_n + 1;
			if (o2_n != (word32) o0_n + 1)
			{
				i1_n = exchange(i1_n, out i2_n, out i4_n, out i5_n, out i6_n);
				o0_n.u0 = i6_n->t0044.u0;
				goto l00016000;
			}
			o1_n.u0 = g_t2B2F0.u0;
		}
		else
		{
			optind.u0 = (word32) o0_n + 1;
			o1_n.u0 = g_t2B2F0.u0;
		}
		if (o1_n == g_t2B300.u0)
		{
			g_t2B2F0.u0 = optind.u0;
			o0_n.u0 = i6_n->t0044.u0;
		}
		else
			o0_n.u0 = i6_n->t0044.u0;
l00016000:
		g_t2B300.u0 = (int32) o0_n;
		optind.u0 = (int32) o0_n;
		goto l00016008;
	}
	Eq_n o1_n;
	o1_n.u0 = g_t2B300.u0;
	Eq_n o0_n;
	if (g_t2B2F0.u0 != o1_n)
	{
		word32 g0_n = o1_n - o2_n;
		if (g0_n != 0x00)
		{
			i1_n = exchange(i1_n, out i2_n, out i4_n, out i5_n, out i6_n);
			goto l00015F24;
		}
		o0_n.u0 = g_t2B300.u0;
	}
	else
		o0_n.u0 = g_t2B300.u0;
	Eq_n o1_n;
	o1_n.u0 = optind.u0;
	if (o0_n != o1_n)
		g_t2B2F0.u0 = (int32) o1_n;
l00015F24:
	Eq_n o2_n;
	o2_n.u0 = optind.u0;
	bool v43_n = o2_n >= (i6_n->t0044).u0;
	while (!v43_n)
	{
		struct Eq_n * o0_n = (struct Eq_n *) *((word32) i1_n + o2_n * 0x04);
		Eq_n o0_n;
		if ((int32) o0_n->b0000 == 0x2D)
		{
			if ((int32) o0_n->b0001 != 0x00)
				break;
			o0_n.u0 = optind.u0;
		}
		else
			o0_n.u0 = optind.u0;
		Eq_n o0_n;
		o0_n.u1 = (word32) o0_n + 1;
		Eq_n o1_n;
		o1_n.u0 = i6_n->t0044.u0;
		optind.u0 = (int32) o0_n;
		o2_n = o0_n;
		v43_n = o0_n >= o1_n;
	}
	g_t2B300.u0 = (int32) o2_n;
	goto l00015F78;
}

// 00016980: void getopt(Register Eq_n o1, Register (ptr32 int8) o2)
void getopt(Eq_n o1, int8 * o2)
{
	word32 l6_n;
	word32 l7_n;
	word32 i6_n;
	_getopt_internal(o1, o2, null, 0x00, out l6_n, out l7_n, out i6_n);
}

// 000169A8: Register word32 getopt_long(Register Eq_n o1, Register (ptr32 int8) o2, Register (ptr32 ptr32) o4, Register out ptr32 l6Out, Register out ptr32 l7Out, Register out ptr32 i6Out)
// Called from:
//      main
word32 getopt_long(Eq_n o1, int8 * o2, ptr32 * o4, ptr32 & l6Out, ptr32 & l7Out, ptr32 & i6Out)
{
	ptr32 i6_n;
	ptr32 l7_n;
	ptr32 l6_n;
	word32 l0_n = _getopt_internal(o1, o2, o4, 0x00, out l6_n, out l7_n, out i6_n);
	l6Out = l6_n;
	l7Out = l7_n;
	i6Out = i6_n;
	return l0_n;
}

// 000169D0: void getopt_long_only(Register Eq_n o1, Register (ptr32 int8) o2, Register (ptr32 ptr32) o4)
void getopt_long_only(Eq_n o1, int8 * o2, ptr32 * o4)
{
	word32 l6_n;
	word32 l7_n;
	word32 i6_n;
	_getopt_internal(o1, o2, o4, 0x01, out l6_n, out l7_n, out i6_n);
}

// 000169F8: Register Eq_n pexecute(Register Eq_n o0, Register (ptr32 Eq_n) o1, Register word32 o3, Register (ptr32 word32) o4, Register (ptr32 word32) o5, Register Eq_n l1, Stack ui32 dwArg5C, Register out ptr32 l0Out, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
Eq_n pexecute(Eq_n o0, pid_t * o1, word32 o3, word32 * o4, word32 * o5, Eq_n l1, ui32 dwArg5C, ptr32 & l0Out, ptr32 & i6Out)
{
	<anonymous> * o0_n;
	if ((dwArg5C & 0x04) != 0x00)
		o0_n = &g_t27E3C;
	else
		o0_n = &g_t27E48;
	if ((dwArg5C & 0x01) != 0x00)
		g_dw2B310 = 0x00;
	int32 o0_n = g_dw2B310;
	word32 o0_n;
	int32 dwLoc24_n;
	if ((dwArg5C & 0x02) == 0x00)
	{
		int32 dwLoc18;
		if (pipe(&dwLoc18) < 0x00)
		{
			o0_n = 0x00017B18;
			goto l00016B10;
		}
		int32 o0_n = dwLoc18;
		g_dw2B310 = o0_n;
		int32 dwLoc14;
		dwLoc24_n = dwLoc14;
	}
	else
	{
		g_dw2B310 = 0x00;
		dwLoc24_n = 0x01;
	}
	uint32 dwLoc2C_n = 0x01;
	int32 dwLoc28_n;
	bool v27_n;
	for (dwLoc28_n = 0x00; dwLoc28_n <= 0x03; ++dwLoc28_n)
	{
		Eq_n o0_n = vfork();
		l1 = o0_n;
		if (o0_n >= 0x00)
		{
			v27_n = o0_n == ~0x00;
			goto l00016AEC;
		}
		sleep(dwLoc2C_n);
		dwLoc2C_n <<= 0x01;
	}
	v27_n = l1 == ~0x00;
l00016AEC:
	Eq_n i0_n;
	if (!v27_n)
	{
		if (l1 == 0x00)
		{
			if (o0_n != 0x00)
			{
				close(0x00);
				dup(o0_n);
				close(o0_n);
			}
			if (dwLoc24_n != 0x01)
			{
				close(0x01);
				dup(dwLoc24_n);
				close(dwLoc24_n);
			}
			int32 o0_n = g_dw2B310;
			if (o0_n != 0x00)
				close(o0_n);
			o0_n();
			struct Eq_n * i6_n;
			fprintf(&g_t2B640, "%s: ", i6_n->ptr004C);
			fprintf(&g_t2B640, install_error_msg, 0x00);
			Eq_n o0_n;
			o0_n.u0 = errno.u0;
			xstrerror(o0_n);
			fprintf(&g_t2B640, ": %s\n", o0_n);
			exit(~0x00);
		}
		if (o0_n != 0x00)
			close(o0_n);
		if (dwLoc24_n != 0x01)
		{
			close(dwLoc24_n);
			i0_n = l1;
		}
		else
			i0_n = l1;
l00016C24:
		l0Out = 0x0002B000;
		ptr32 fp;
		i6Out = fp;
		return i0_n;
	}
	o0_n = 0x00017B20;
l00016B10:
	*o4 = o0_n;
	*o5 = 0x00;
	i0_n = ~0x00;
	goto l00016C24;
}

// 00016C2C: Register word32 pwait(Register (ptr32 int32) o1, Register out ptr32 i2Out, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
word32 pwait(int32 * o1, ptr32 & i2Out, ptr32 & i6Out)
{
	wait(o1);
	ptr32 o2;
	i2Out = o2;
	ptr32 fp;
	i6Out = fp;
	word32 o0;
	return o0;
}

// 00016C40: Register Eq_n mkstemps(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      make_temp_file
Eq_n mkstemps(Eq_n o0, Eq_n o1)
{
	word64 * l4_n;
	Eq_n dwLoc14;
	Eq_n o0_n;
	o0_n.u1 = (uint32) strlen(o0);
	Eq_n i0_n;
	if (o0_n >= (word32) o1 + 6)
	{
		Eq_n o0_n = o0_n - ((word32) o1 + 6);
		if (strncmp(o0 + o0_n, 0x00017B78, 0x06) != 0x00)
			i0_n.u0 = ~0x00;
		else
		{
			word32 dwLoc18;
			gettimeofday(&dwLoc18, null);
			Eq_n o0_n = getpid();
			word64 o0_o1_n = g_qw2B400;
			int32 o7_n = dwLoc18;
			up32 o1_n = (word32) o0_o1_n + ((dwLoc14 << 0x10 ^ o7_n) ^ o0_n);
			g_qw2B400 = SEQ(SLICE(o0_o1_n, word32, 32) + (((dwLoc14 >> 0x10 | (dwLoc14 >> 0x1F) << 0x10) ^ o7_n >> 0x1F) ^ o0_n >> 0x1F) + (word32) (o1_n < 0x00), o1_n);
			word64 * l4_n = &g_qw2B400;
			Eq_n o0_n;
			while (true)
			{
				word64 l0_l1_n = *l4_n;
				__urem64(SLICE(l0_l1_n, word32, 32), (word32) l0_l1_n, 0x00, 0x3E);
				byte * i1_n;
				ptr32 l2_n;
				int32 o1_n;
				*i1_n = (byte) *((word32) l2_n + o1_n);
				word32 l0_n;
				word32 l1_n;
				__udiv64(l0_n, l1_n, 0x00, 0x3E);
				__urem64(0x00, 0x3E);
				struct Eq_n * i1_n;
				ptr32 l2_n;
				int32 o1_n;
				i1_n->b0001 = (byte) *((word32) l2_n + o1_n);
				word32 l0_n;
				word32 l1_n;
				__udiv64(l0_n, l1_n, 0x00, 0x3E);
				__urem64(0x00, 0x3E);
				struct Eq_n * i1_n;
				ptr32 l2_n;
				int32 o1_n;
				i1_n->b0002 = (byte) *((word32) l2_n + o1_n);
				word32 l0_n;
				word32 l1_n;
				__udiv64(l0_n, l1_n, 0x00, 0x3E);
				__urem64(0x00, 0x3E);
				struct Eq_n * i1_n;
				ptr32 l2_n;
				int32 o1_n;
				i1_n->b0003 = (byte) *((word32) l2_n + o1_n);
				word32 l0_n;
				word32 l1_n;
				__udiv64(l0_n, l1_n, 0x00, 0x3E);
				__urem64(0x00, 0x3E);
				struct Eq_n * i1_n;
				ptr32 l2_n;
				int32 o1_n;
				i1_n->b0004 = (byte) *((word32) l2_n + o1_n);
				word32 l0_n;
				word32 l1_n;
				__urem64(__udiv64(l0_n, l1_n, 0x00, 0x3E), 0x00, 0x3E);
				struct Eq_n * i1_n;
				ptr32 l2_n;
				int32 o1_n;
				i1_n->b0005 = (byte) *((word32) l2_n + o1_n);
				char * i0_n;
				o0_n = open(i0_n, 0x0502);
				if (o0_n >= 0x00)
					break;
				word64 o2_o3_n = *l4_n;
				up32 o3_n = (word32) o2_o3_n;
				word32 o2_n = SLICE(o2_o3_n, word32, 32);
				word32 o2_n = o2_n + (word32) (o3_n < ~0x1E60);
				word32 l3_n;
				int32 l5_n;
				if (l3_n + 0x01 > l5_n)
				{
					*l4_n = SEQ(o2_n, o3_n + 7777);
					*i0_n = 0x00;
					goto l00016E58;
				}
				*l4_n = SEQ(o2_n, o3_n + 7777);
				l4_n = l4_n;
			}
			i0_n = o0_n;
		}
	}
	else
	{
l00016E58:
		i0_n.u0 = ~0x00;
	}
	return i0_n;
}

// 00016E64: Register word32 fn00016E64(Register word32 o7, Register word32 l7)
// Called from:
//      __do_global_ctors_aux
word32 fn00016E64(word32 o7, word32 l7)
{
	return o7 + l7;
}

// 00016E6C: Register (ptr32 word32) __do_global_ctors_aux(Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7)
// Called from:
//      _init
word32 * __do_global_ctors_aux(word32 o3, word32 o4, word32 o5, word32 o7)
{
	struct Eq_n * o1_n = fn00016E64(o7, 0x00010D08)->ptr0014;
	word32 o2_n = o1_n->dwFFFFFFFC;
	word32 * l0_n;
	if (o2_n != ~0x00)
	{
		l0_n = &o1_n->dwFFFFFFFC;
		do
		{
			<anonymous> * o0_n = *l0_n;
			o0_n();
		} while (*l0_n != (<anonymous> *) ~0x00);
	}
	else
		l0_n = &o1_n->dwFFFFFFFC;
	return l0_n;
}

// 00016EBC: void init_dummy()
void init_dummy()
{
}

