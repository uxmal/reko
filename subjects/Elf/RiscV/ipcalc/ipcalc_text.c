// ipcalc_text.c
// Generated by decompiling ipcalc
// using Reko decompiler version 0.11.2.0.

#include "ipcalc.h"

// 0000000000015180: void fn0000000000015180(Register word64 ra, Register (ptr64 Eq_n) gp, Register int64 a0, Register (ptr64 (ptr64 char)) a1, Register word64 a7, Register word64 s5, Register word64 s11)
void fn0000000000015180(word64 ra, struct Eq_n * gp, int64 a0, char ** a1, word64 a7, word64 s5, word64 s11)
{
	word64 qwLoc01A8;
	char * ptrLoc01A0;
	Eq_n tLoc0198;
	Eq_n tLoc0188;
	word64 qwLocC0;
	char bLocB8;
	int64 qwLoc0190;
	Eq_n a5_n = gp->tFFFFF870;
	qwLoc01A8.dw0004 = 0x00;
	Eq_n s0_n = 0;
	do
	{
		Eq_n a0_n = (uint64) getopt_long((int32) a0, a1, "cr:i46bho:gmnpsv", &g_t108E0, null);
		if (a0_n == -1)
		{
			Eq_n s1_n;
			Eq_n s4_n;
			int64 a4_n = (int64) gp->dwFFFFF890;
			if (a4_n < a0)
			{
				int64 a1_n = (int64) ((word32) a4_n + 1);
				gp->dw0890 = (word32) a1_n;
				struct Eq_n * s2_n = (char *) a1 + (a4_n << 0x03);
				s1_n = s2_n->t0000;
				s4_n.u0 = 0;
				if (a1_n < a0)
				{
					s4_n = s2_n->t0008;
					gp->dw0890 = (word32) a4_n + 2;
				}
			}
			else
			{
				s4_n.u0 = 0;
				s1_n.u0 = 0;
			}
			if (false)
			{
				__printf_chk(1, "ipcalc %s\n", 0x00);
				goto l00000000000153DC;
			}
			if ((int64) qwLoc01A8.dw0004 != 0x00 && false)
			{
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				fwrite(&g_v119D8, (size_t) 1, (size_t) 46, gp->ptrFFFFF880);
				goto l00000000000153DC;
			}
			word64 a6_n;
			byte * a4_n;
			int64 a0_n;
			Eq_n a5_n;
			FILE * a0_n;
			char * a0_n;
			Eq_n a5_n;
			Eq_n s2_n;
			if (false)
			{
				s2_n.u0 = 2;
				word64 a1_n;
				word64 a2_n;
				word64 a3_n;
				word64 a4_n;
				if (fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) != 0x00 || true)
					goto l00000000000153CC;
				s0_n.u0 = 2;
				goto l0000000000015448;
			}
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			if (fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) == 0x00 && false)
			{
l0000000000015448:
				s2_n = s0_n | 0x4000;
				if (true)
				{
					s0_n = s2_n;
					goto l0000000000015458;
				}
l00000000000153CC:
				if (false)
				{
					if ((int64) gp->dwFFFFF814 == 0x00)
						fwrite(&g_v11A08, (size_t) 1, (size_t) 37, gp->ptrFFFFF880);
					goto l00000000000153D8;
				}
				if ((int64) qwLoc01A8.dw0004 != 0x00)
				{
					Eq_n a0_n = fn00000000000169D8(gp, 0x0A, null);
					s1_n = a0_n;
					s0_n = s2_n;
					a5_n = a0_n;
					if (a0_n == 0x00)
						goto l0000000000015964;
					goto l0000000000015510;
				}
				if (false)
				{
					Eq_n a0_n = fn00000000000169D8(gp, 2, null);
					s1_n = a0_n;
					if (a0_n == 0x00)
						goto l0000000000015964;
					a5_n = a0_n;
					s0_n = s2_n;
					goto l00000000000155D8;
				}
				Eq_n a0_n = fn00000000000169D8(gp, 0, null);
				s1_n = a0_n;
				if (a0_n != 0x00)
				{
					s0_n = s2_n;
					a5_n = a0_n;
					goto l0000000000015518;
				}
l0000000000015964:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: could not resolve %s\n", 0x00);
				goto l00000000000153DC;
			}
l0000000000015458:
			a5_n = a0_n;
			if (true)
			{
				if (s1_n != 0x00)
					goto l0000000000015510;
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				fwrite(&g_v11A30, (size_t) 1, (size_t) 28, gp->ptrFFFFF880);
				fn0000000000015FCC(gp, 1);
				goto l00000000000153DC;
			}
			Eq_n a0_n = fn00000000000166F4(gp, (char *) &qwLoc01A8 + 4, 0, 1);
			if (a0_n < 0x00)
			{
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				a0_n = gp->ptrFFFFF880;
				goto l0000000000015B8C;
			}
			int64 s1_n = (int64) qwLoc01A8.dw0004;
			ptrLoc01A0 = 0x00;
			if ((uint64) clock_gettime(2, &tLoc0198) < 0x00)
			{
l0000000000015CB0:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: cannot generate network with prefix: %u\n", 0x00);
				goto l00000000000153DC;
			}
			if (s1_n != 0x00)
			{
				tLoc0188.t0000 = (byte) qwLoc0190 & 0x01 | 252;
				if (fn00000000000164D0((char *) &tLoc0188.t0000 + 1, 0x0F) >= 0x00 && inet_ntop(0x0A, &tLoc0188, &bLocB8, 64) != null)
					goto l00000000000154DC;
				goto l0000000000015CB0;
			}
			if (fn00000000000164D0(&qwLocC0, 4) < 0x00)
				goto l0000000000015CB0;
			if (a0_n > 0x0F && (qwLoc0190 | 4) <= 1)
			{
				if ((qwLoc0190 | 4) != 1)
				{
					qwLocC0 = (word64) 0xAC;
					qwLocC0.b0001 = (byte) (qwLoc0190 >> 0x04) & 0x0F | 0x10;
				}
				else
				{
					qwLocC0 = (word64) 0xC0;
					qwLocC0.b0001 = 0xA8;
				}
			}
			else
				qwLocC0 = (word64) 0x0A;
			qwLoc01A8 = qwLocC0;
			if (inet_ntop(2, &qwLoc01A8, &bLocB8, 64) == null)
				goto l0000000000015CB0;
l00000000000154DC:
			a5_n = a0_n;
			if ((uint64) __asprintf_chk(&ptrLoc01A0, 1, "%s/%u", 0x00) == -1)
				goto l0000000000015CB0;
			s1_n = ptrLoc01A0;
			if (s1_n == 0x00)
				goto l0000000000015CB0;
l0000000000015510:
			if (true)
			{
l0000000000015518:
				if (strchr(s1_n, ':') == null)
					goto l00000000000155D8;
				qwLoc01A8.dw0004 = 0x01;
				if (s4_n != 0x00)
					goto l000000000001553C;
				a0_n = strchr(s1_n, '/');
				a5_n = a5_n;
				if (a0_n == null)
					goto l0000000000015604;
				goto l0000000000015BB8;
			}
l00000000000155D8:
			if (s4_n != 0x00)
			{
				if ((int64) qwLoc01A8.dw0004 == 0x00)
					goto l00000000000155E4;
l000000000001553C:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: unexpected argument: %s\n", 0x00);
				fn0000000000015FCC(gp, 1);
				goto l00000000000153DC;
			}
			a0_n = strchr(s1_n, '/');
			a5_n = a5_n;
			if (a0_n != null)
			{
l0000000000015BB8:
				*a0_n = 0x00;
				s4_n = a0_n + 1;
				if (s4_n == 0x00)
					goto l00000000000155FC;
l00000000000155E4:
				Eq_n a0_n = fn00000000000166F4(gp, (char *) &qwLoc01A8 + 4, s4_n, 0);
				a5_n = a0_n;
				if (a0_n >= 0x00)
					goto l00000000000155FC;
				if ((int64) gp->dwFFFFF814 == 0x00)
				{
					a0_n = gp->ptrFFFFF880;
l0000000000015B8C:
					__fprintf_chk(a0_n, 1, "ipcalc: bad %s prefix: %s\n", 0x00);
				}
				goto l00000000000153D8;
			}
l00000000000155FC:
			if ((int64) qwLoc01A8.dw0004 != 0x00)
			{
l0000000000015604:
				a0_n = fn00000000000175BC(ra, gp, s1_n, s1_n, a5_n, &tLoc0188, s0_n, out a4_n);
			}
			else
				a0_n = fn0000000000016D74(ra, gp, s1_n, a5_n, &tLoc0188, s0_n, out a4_n);
			if (a0_n < 0x00)
			{
l00000000000153D8:
				goto l00000000000153DC;
			}
			if ((s0_n & 0xFFFABFFF) == 0x00)
				s0_n |= 8;
			if ((uint64) isatty(1) != 0x00)
			{
				gp->dw0810 = 0x01;
				a4_n = (byte *) 1;
			}
			if ((s0_n & 8) == 0x00)
			{
				if ((s0_n & 0x0080) != 0x00)
					__printf_chk(1, "NETMASK=%s\n", 0x00);
				if ((s0_n & 0x0200) != 0x00)
					__printf_chk(1, "PREFIX=%u\n", 0x00);
				if ((s0_n & 64) != 0x00 && (int64) qwLoc01A8.dw0004 == 0x00)
					__printf_chk(1, "BROADCAST=%s\n", 0x00);
				if ((s0_n & 0x0100) != 0x00)
					__printf_chk(1, "NETWORK=%s\n", 0x00);
				if (s0_n << 0x2E < 0x00)
					__printf_chk(1, "REVERSEDNS=%s\n", 0x00);
				if ((s0_n & 0x0400) != 0x00 && tLoc0188.t00A8 != 0x00)
					__printf_chk(1, "MINADDR=%s\n", 0x00);
				if (s0_n << 0x34 < 0x00 && tLoc0188.t00B0 != 0x00)
					__printf_chk(1, "MAXADDR=%s\n", 0x00);
				if (s0_n << 0x32 < 0x00)
				{
					Eq_n s2_n = tLoc0188.t00B8;
					if (s2_n != 0x00)
					{
						if (strchr(s2_n, ' ') != null)
							__printf_chk(1, "ADDRSPACE=\"%s\"\n", 0x00);
						else
							__printf_chk(1, "ADDRSPACE=%s\n", 0x00);
					}
				}
				if (s0_n << 0x33 < 0x00)
				{
					if (strchr(&tLoc0188.b0060, ' ') != null)
						__printf_chk(1, "ADDRESSES=\"%s\"\n", 0x00);
					else
						__printf_chk(1, "ADDRESSES=%s\n", 0x00);
				}
				if ((s0_n & 1) != 0x00 && tLoc0188.qw0038 != 0x00)
					__printf_chk(1, "HOSTNAME=%s\n", 0x00);
				if ((s0_n & 2) != 0x00)
					__printf_chk(1, "ADDRESS=%s\n", 0x00);
				if ((s0_n & 0xC000) == 0xC000)
				{
					if (tLoc0188.qw0048 != 0x00)
						__printf_chk(1, "COUNTRYCODE=%s\n", 0x00);
					Eq_n s0_n = tLoc0188.t0040;
					if (s0_n != 0x00)
					{
						if (strchr(s0_n, ' ') != null)
							__printf_chk(1, "COUNTRY=\"%s\"\n", 0x00);
						else
							__printf_chk(1, "COUNTRY=%s\n", 0x00);
					}
					Eq_n s0_n = tLoc0188.t0050;
					if (s0_n != 0x00)
					{
						if (strchr(s0_n, ' ') != null)
							__printf_chk(1, "CITY=\"%s\"\n", 0x00);
						else
							__printf_chk(1, "CITY=%s\n", 0x00);
					}
					if (tLoc0188.qw0058 != 0x00)
						__printf_chk(1, "COORDINATES=\"%s\"\n", 0x00);
				}
				goto l00000000000153DC;
			}
			byte * a4_n;
			Eq_n a5_n;
			int64 s0_n;
			Eq_n a3_n;
			Eq_n a5_n;
			int64 s4_n;
			Eq_n a3_n;
			byte * s2_n = (int64) tLoc0188.dw00A0;
			if ((int64) qwLoc01A8.dw0004 == 0x00)
			{
				a5_n.u0 = 32;
				if (s2_n != (byte *) 32)
					goto l0000000000015660;
				goto l0000000000015914;
			}
			a5_n.u0 = 0x0080;
			if (s2_n == (byte *) 0x0080)
			{
l0000000000015914:
				a3_n = tLoc0188.t0008;
				if (a3_n != 0x00)
				{
					s4_n = 1;
					goto l0000000000015880;
				}
				word64 a5_n;
				gp = fn000000000001654C(gp, tLoc0188.t0000, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				goto l00000000000158B8;
			}
l0000000000015660:
			if (false)
			{
l0000000000015664:
				goto l0000000000015668;
			}
			Eq_n s3_n = tLoc0188.t0000;
			if ((uint64) strcmp(tLoc0188.t0020, s3_n) == 0x00)
				goto l0000000000015664;
			a3_n = tLoc0188.t0008;
			s4_n = 0;
			if (a3_n == 0x00)
			{
				word64 a4_n;
				gp = fn000000000001654C(gp, s3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				s2_n = (int64) tLoc0188.dw00A0;
				goto l0000000000015668;
			}
l0000000000015880:
			byte * a4_n;
			Eq_n a5_n;
			word64 a6_n;
			word64 a7_n;
			gp = fn000000000001654C(fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n), tLoc0188.t0000, a4_n, a5_n, a6_n, a7_n, out a4_n, out a5_n, out a6_n, out a7);
			if (s4_n != 0x00)
			{
l00000000000158B8:
				a5_n.u0 = 0x00010008;
				if ((s0_n & 0x00010008) != 0x00010008)
					goto l00000000000158C8;
				a3_n = tLoc0188.t0018;
				s0_n = 1;
				if (a3_n == 0x00)
					goto l00000000000158C8;
				goto l0000000000015C2C;
			}
			s2_n = (int64) tLoc0188.dw00A0;
l0000000000015668:
			Eq_n a3_n = tLoc0188.t0010;
			if (a3_n != 0x00)
			{
				word64 a4_n;
				gp = fn000000000001654C(gp, a3_n, s2_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				s2_n = (int64) tLoc0188.dw00A0;
			}
			Eq_n a5_n;
			word64 a6_n;
			word64 a7_n;
			Eq_n a5_n;
			word64 a4_n;
			gp = fn000000000001654C(fn000000000001654C(gp, tLoc0188.t0020, s2_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n), tLoc0188.t0030, (int64) tLoc0188.dw00A0, a5_n, a6_n, a7_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = tLoc0188.t0028;
			if (a3_n != 0x00)
			{
				word64 a5_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			a5_n.u0 = 0x00010008;
			if ((s0_n & 0x00010008) == 0x00010008)
			{
				a3_n = tLoc0188.t0018;
				if (a3_n == 0x00)
					goto l00000000000156FC;
				s0_n = 0;
l0000000000015C2C:
				gp = fn000000000001654C(gp, a3_n, a4_n, 0x00010008, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				if (s0_n == 0x00)
					goto l00000000000156FC;
l00000000000158C8:
				Eq_n a3_n = tLoc0188.t00B8;
				if (a3_n != 0x00)
					gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				Eq_n a3_n = tLoc0188.t00C0;
				if (a3_n != 0x00)
				{
					word64 a5_n;
					gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				}
				goto l00000000000157BC;
			}
l00000000000156FC:
			putchar(0x0A);
			Eq_n a3_n = tLoc0188.t00B8;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = tLoc0188.t00C0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = tLoc0188.t00A8;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = tLoc0188.t00B0;
			if (a3_n != 0x00)
			{
				word64 a5_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			Eq_n a5_n = (int64) qwLoc01A8.dw0004;
			if (a5_n != 0x00)
			{
				a5_n.u0 = (int64) tLoc0188.dw00A0;
				a4_n = (byte *) 111;
				if (a5_n > 111)
					goto l00000000000157A0;
				word64 a5_n;
				gp = fn000000000001654C(gp, (int64) (0x80 - (word32) a5_n), &tLoc0188.b0060, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			else
			{
l00000000000157A0:
				word64 a5_n;
				gp = fn000000000001654C(gp, &tLoc0188.b0060, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
l00000000000157BC:
			Eq_n a5_n = tLoc0188.t0040;
			if (a5_n == 0x00)
			{
				a5_n = tLoc0188.t0050;
				if (a5_n == 0x00)
				{
					a5_n = tLoc0188.t0058;
					if (a5_n == 0x00)
					{
l00000000000153DC:
						if (a5_n != gp->tFFFFF870)
							__stack_chk_fail();
						else
							return;
					}
				}
			}
			putchar(0x0A);
			Eq_n a3_n = tLoc0188.t0048;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = tLoc0188.t0040;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = tLoc0188.t0050;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = tLoc0188.t0058;
			if (a3_n != 0x00)
			{
				word64 a4_n;
				word64 a5_n;
				word64 a7_n;
				word64 a6_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n);
			}
			goto l00000000000153DC;
		}
	} while (a0_n > 118);
	<anonymous> * a5_n = (int64) (a0_n << 0x20 >> 0x1E)->dw102A0;
	word64 a6_n;
	word64 t1_n;
	word64 t3_n;
	word64 a7_n;
	a5_n();
}

// 0000000000015EB8: void fn0000000000015EB8(Register (ptr64 Eq_n) a0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void fn0000000000015EB8(void (* a0)(), word32 dwArg00, char * ptrArg08)
{
	Eq_n fp;
	word64 qwArg00;
	__libc_start_main(&g_t15180, (int32) qwArg00, &ptrArg08, &g_t182E8, &g_t18378, a0, fp & -16);
}

// 0000000000015EF0: void fn0000000000015EF0()
// Called from:
//      fn0000000000015F64
void fn0000000000015EF0()
{
	if (true || true)
		return;
	word64 t1_n;
	word64 ra_n;
	null();
}

// 0000000000015F24: void fn0000000000015F24()
// Called from:
//      fn0000000000015F94
void fn0000000000015F24()
{
	if (true || true)
		return;
	word64 t1_n;
	null();
}

// 0000000000015F64: void fn0000000000015F64(Register (ptr64 Eq_n) gp)
void fn0000000000015F64(struct Eq_n * gp)
{
	if ((word64) gp->bFFFFF894 == 0x00)
	{
		fn0000000000015EF0();
		gp->b0894 = 0x01;
	}
}

// 0000000000015F94: void fn0000000000015F94(Register word64 ra)
void fn0000000000015F94(word64 ra)
{
	if (g_qw19E28 != 0x00 && false)
	{
		null();
		fn0000000000015F24();
	}
	else
		fn0000000000015F24();
}

// 0000000000015FCC: void fn0000000000015FCC(Register (ptr64 Eq_n) gp, Register int64 a0)
// Called from:
//      fn0000000000015180
void fn0000000000015FCC(struct Eq_n * gp, int64 a0)
{
	FILE * a3_n = gp->ptrFFFFF880;
	if (a0 != 0x00)
	{
		fwrite(&g_v10BE0, (size_t) 1, (size_t) 26, a3_n);
		fwrite(&g_v10C00, (size_t) 1, (size_t) 54, gp->ptrFFFFF880);
		fwrite(&g_v10C38, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v10C88, (size_t) 1, (size_t) 62, gp->ptrFFFFF880);
		fwrite(&g_v10CC8, (size_t) 1, (size_t) 79, gp->ptrFFFFF880);
		fwrite(&g_v10D18, (size_t) 1, (size_t) 79, gp->ptrFFFFF880);
		fwrite(&g_v10D68, (size_t) 1, (size_t) 42, gp->ptrFFFFF880);
		fwrite(&g_v10D98, (size_t) 1, (size_t) 76, gp->ptrFFFFF880);
		fwrite(&g_v10DE8, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v10E38, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fputc();
		fwrite(&g_v10E88, (size_t) 1, (size_t) 23, gp->ptrFFFFF880);
		fwrite(&g_v10EA0, (size_t) 1, (size_t) 71, gp->ptrFFFFF880);
		fwrite(&g_v10EE8, (size_t) 1, (size_t) 57, gp->ptrFFFFF880);
		fwrite(&g_v10F28, (size_t) 1, (size_t) 58, gp->ptrFFFFF880);
		fwrite(&g_v10F68, (size_t) 1, (size_t) 57, gp->ptrFFFFF880);
		fwrite(&g_v10FA8, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v10FF8, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v11048, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v11098, (size_t) 1, (size_t) 46, gp->ptrFFFFF880);
		fwrite(&g_v110C8, (size_t) 1, (size_t) 72, gp->ptrFFFFF880);
		fwrite(&g_v11118, (size_t) 1, (size_t) 45, gp->ptrFFFFF880);
		fwrite(&g_v11148, (size_t) 1, (size_t) 67, gp->ptrFFFFF880);
		fwrite(&g_v11190, (size_t) 1, (size_t) 64, gp->ptrFFFFF880);
		fwrite(&g_v111D8, (size_t) 1, (size_t) 72, gp->ptrFFFFF880);
		fwrite(&g_v11228, (size_t) 1, (size_t) 46, gp->ptrFFFFF880);
		fputc();
		fwrite(&g_v11258, (size_t) 1, (size_t) 0x0F, gp->ptrFFFFF880);
		fwrite(&g_v11268, (size_t) 1, (size_t) 87, gp->ptrFFFFF880);
		fwrite(&g_v112C0, (size_t) 1, (size_t) 60, gp->ptrFFFFF880);
		fwrite(&g_v11300, (size_t) 1, (size_t) 0x0044, gp->ptrFFFFF880);
		fwrite(&g_v11348, (size_t) 1, (size_t) 58, gp->ptrFFFFF880);
		fwrite(&g_v11388, (size_t) 1, (size_t) 57, gp->ptrFFFFF880);
		fwrite(&g_v113C8, (size_t) 1, (size_t) 62, gp->ptrFFFFF880);
	}
	else
	{
		fwrite(&g_v11408, (size_t) 1, (size_t) 77, a3_n);
		fwrite(&g_v11458, (size_t) 1, (size_t) 62, gp->ptrFFFFF880);
		fwrite(&g_v11498, (size_t) 1, (size_t) 65, gp->ptrFFFFF880);
		fwrite(&g_v114E0, (size_t) 1, (size_t) 76, gp->ptrFFFFF880);
		fwrite(&g_v11530, (size_t) 1, (size_t) 65, gp->ptrFFFFF880);
		fwrite(&g_v11578, (size_t) 1, (size_t) 41, gp->ptrFFFFF880);
		fwrite(&g_v115A8, (size_t) 1, (size_t) 30, gp->ptrFFFFF880);
	}
}

// 00000000000163B0: Register Eq_n fn00000000000163B0(Register (ptr64 Eq_n) gp)
// Called from:
//      fn00000000000175BC
Eq_n fn00000000000163B0(struct Eq_n * gp)
{
	ptr64 fp;
	char bLocE8;
	Eq_n a5_n = gp->tFFFFF870;
	__sprintf_chk(&bLocE8, 1, (size_t) 0x0080, "%.2x", 0x00);
	int64 s0_n = 1;
	struct Eq_n * s1_n = fp + -0x00E6;
	if (true)
	{
		do
		{
			__sprintf_chk(s1_n, 1, (size_t) 0x0080, "%.2x", 0x00);
			struct Eq_n * a4_n = s1_n + 1;
			if ((s0_n & 1) != 0x00)
			{
				if (s0_n == 0x0F)
				{
					s1_n = a4_n;
					break;
				}
				s1_n[1] = (struct Eq_n) 0x3A;
				s1_n = &s1_n->b0002 + 1;
			}
			else
				s1_n = a4_n;
			s0_n = (int64) ((word32) s0_n + 1);
		} while (s0_n != 16);
	}
	s1_n->b0000 = 0x00;
	Eq_n a0_n = __strdup(&bLocE8);
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000164D0: Register (ptr64 word64) fn00000000000164D0(Register (ptr64 word64) a0, Register Eq_n a1)
// Called from:
//      fn0000000000015180
word64 * fn00000000000164D0(word64 * a0, Eq_n a1)
{
	word64 * a0_n;
	Eq_n a0_n = (uint64) open("/dev/urandom", 0);
	if (a0_n >= 0x00)
	{
		uint64 a0_n = (uint64) read((int32) a0_n, a0, (size_t) a1);
		close((int32) a0_n);
		a0_n = (int64) (0x00 - (word32) ((int64) ((word32) (a0_n - a1)) != 0x00));
	}
	else
		a0_n = (word64 *) -1;
	return a0_n;
}

// 000000000001654C: Register (ptr64 Eq_n) fn000000000001654C(Register (ptr64 Eq_n) gp, Register Eq_n a3, Register (ptr64 byte) a4, Register Eq_n a5, Register word64 a6, Register word64 a7, Register out Eq_n a4Out, Register out Eq_n a5Out, Register out ptr64 a6Out, Register out ptr64 a7Out)
// Called from:
//      fn0000000000015180
struct Eq_n * fn000000000001654C(struct Eq_n * gp, Eq_n a3, byte * a4, Eq_n a5, word64 a6, word64 a7, union Eq_n & a4Out, union Eq_n & a5Out, ptr64 & a6Out, ptr64 & a7Out)
{
	ptr64 fp;
	Eq_n t3_n = gp->tFFFFF870;
	__vasprintf_chk(fp + -112, 1, fp + -40, fp + -40, a3, a4, a5, a6, a7);
	if (a0_n >= 0x00)
	{
		fputs(s2_n, gp_n->ptrFFFFF888);
		if ((int64) gp_n->dwFFFFF810 != 0x00)
			fputs(s3_n, gp_n->ptrFFFFF888);
		fputs(null, gp_n->ptrFFFFF888);
		if ((int64) gp_n->dwFFFFF810 != 0x00)
			fwrite(&g_v115E0, (size_t) 1, (size_t) 4, gp_n->ptrFFFFF888);
		free(null);
	}
	Eq_n a5_n = gp_n->tFFFFF870;
	if (t3_n != a5_n)
		__stack_chk_fail();
	else
	{
		a4Out = t3_n;
		a5Out = a5_n;
		a6Out = a6_n;
		a7Out = a7_n;
		return gp_n;
	}
}

// 0000000000016630: Register Eq_n fn0000000000016630(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 word64) a1)
// Called from:
//      fn00000000000166F4
Eq_n fn0000000000016630(struct Eq_n * gp, Eq_n a0, word64 * a1)
{
	Eq_n a5_n;
	Eq_n a5_n = gp->tFFFFF870;
	int32 * a0_n = __errno_location();
	*a0_n = 0x00;
	uint64 a0_n = (uint64) strtol(a0);
	if (false && (a0 != 0x00 && (word64) null == 0x00))
	{
		a5_n = (int64) *a0_n;
		if (a5_n == 0x00)
		{
			if (a0_n == a0_n)
				*a1 = (word64) (word32) a0_n;
			else
				a5_n.u0 = -0x0022;
			goto l0000000000016698;
		}
	}
	else
		a5_n = (int64) *a0_n;
	if (a5_n > 0x00)
		a5_n = (int64) (0x00 - (word32) a5_n);
	else
		a5_n.u0 = -22;
l0000000000016698:
	if (a5_n == gp->tFFFFF870)
		return a5_n;
	__stack_chk_fail();
}

// 00000000000166F4: Register (ptr64 int32) fn00000000000166F4(Register (ptr64 Eq_n) gp, Register (ptr64 int32) a0, Register Eq_n a1, Register int64 a2)
// Called from:
//      fn0000000000015180
int32 * fn00000000000166F4(struct Eq_n * gp, int32 * a0, Eq_n a1, int64 a2)
{
	word64 qwLoc40;
	int32 * a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	int64 s0_n = (int64) *a0;
	if (s0_n == 0x00 && strchr(a1, '.') != null)
	{
		if ((uint64) inet_pton(2, a1, &qwLoc40) != 0x00)
		{
			word64 a4_n;
			word64 a3_n;
			int64 a0_n = fn00000000000182B4((int64) qwLoc40, out a3_n, out a4_n);
			while (a0_n != 0x00)
			{
				if ((a0_n & 1) != 0x00)
				{
l0000000000016778:
					do
					{
						a0_n = (int64) ((word32) a0_n >> 1);
						s0_n = (int64) ((word32) s0_n + 1);
						if (a0_n == 0x00)
							goto l0000000000016790;
					} while ((a0_n & 1) != 0x00);
					goto l000000000001678C;
				}
				int64 a5_n = (int64) ((word32) a0_n >> 1);
				if (a5_n == 0x00)
					break;
				if ((a5_n & 1) != 0x00)
				{
					a0_n = a5_n;
					goto l0000000000016778;
				}
				a0_n = (int64) ((word32) a0_n >> 2);
			}
		}
		else
		{
l000000000001678C:
			s0_n = -1;
		}
l0000000000016790:
		qwLoc40 = (word64) (word32) s0_n;
	}
	else if (fn0000000000016630(gp, a1, &qwLoc40) != 0x00)
		goto l00000000000167C0;
	int32 * a5_n = (int64) qwLoc40;
	if (a2 != 0x00 && a5_n > (int32 *) 32)
	{
		if ((int64) *a0 == 0x00)
			*a0 = 0x01;
	}
	else
	{
		a0_n = a5_n;
		if (a5_n < null)
			goto l00000000000167C0;
		if ((int64) *a0 == 0x00)
		{
			if (a5_n > (int32 *) 32)
			{
l00000000000167C0:
				a0_n = (int32 *) -1;
				goto l00000000000167F4;
			}
l00000000000167F4:
			if (a5_n == gp->tFFFFF870)
				return a0_n;
			__stack_chk_fail();
		}
	}
	a0_n = a5_n;
	if (a5_n > (int32 *) 0x0080)
		goto l00000000000167C0;
	goto l00000000000167F4;
}

// 0000000000016830: Register Eq_n fn0000000000016830(Register (ptr64 Eq_n) gp, Register Eq_n a0)
// Called from:
//      fn00000000000168B8
//      fn0000000000016D74
Eq_n fn0000000000016830(struct Eq_n * gp, Eq_n a0)
{
	Eq_n a5_n = gp->tFFFFF870;
	word32 dwLoc20_n = 0x00;
	if (a0 != 0x00)
	{
		word64 a3_n;
		word64 a4_n;
		dwLoc20_n = (word32) fn00000000000182B4((int64) (~0x00 << (int64) (0x20 - (word32) a0)), out a3_n, out a4_n);
	}
	Eq_n a0_n = (int64) dwLoc20_n;
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000168B8: void fn00000000000168B8(Register (ptr64 Eq_n) gp, Register Eq_n a1)
void fn00000000000168B8(struct Eq_n * gp, Eq_n a1)
{
	fn0000000000016830(gp, a1);
}

// 00000000000168E4: Register Eq_n fn00000000000168E4(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 Eq_n) a1)
// Called from:
//      fn0000000000016D74
//      fn00000000000175BC
Eq_n fn00000000000168E4(struct Eq_n * gp, Eq_n a0, struct Eq_n * a1)
{
	word64 qwLoc58;
	word64 qwLoc48;
	word64 qwLoc40;
	Eq_n a0_n;
	uint64 a0_n;
	Eq_n a4_n = gp->tFFFFF870;
	if (a0 != 2)
	{
		if (a0 != 0x0A)
			goto l0000000000016910;
		qwLoc48 = 0x00;
		qwLoc40 = 0x00;
		qwLoc48 = (word64) (word16) a0;
		memcpy(&qwLoc40, a1, (size_t) 16);
		a0_n = (uint64) getnameinfo(&qwLoc48, 28, &gp->dwFFFFF890 + 2, 0x0401, null, 0, 0);
	}
	else
	{
		word64 t5_n = (word64) a1->qw0000;
		word64 t4_n = (word64) a1->b0001;
		word64 t3_n = (word64) a1->b0002;
		word64 t1_n = (word64) a1->b0003;
		qwLoc58 = 0x00;
		qwLoc58 = (word64) (word16) a0;
		qwLoc58.b0004 = (byte) t5_n;
		qwLoc58.b0005 = (byte) t4_n;
		qwLoc58.b0006 = (byte) t3_n;
		qwLoc58.b0007 = (byte) t1_n;
		a0_n = (uint64) getnameinfo(&qwLoc58, 16, &gp->dwFFFFF890 + 2, 0x0401, null, 0, 0);
	}
	if (a0_n == 0x00)
	{
		a0_n = __strdup(&gp->dwFFFFF890 + 2);
l0000000000016914:
		if (a4_n == gp->tFFFFF870)
			return a0_n;
		__stack_chk_fail();
	}
l0000000000016910:
	a0_n.u0 = 0;
	goto l0000000000016914;
}

// 00000000000169D8: Register Eq_n fn00000000000169D8(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 char) a1)
// Called from:
//      fn0000000000015180
Eq_n fn00000000000169D8(struct Eq_n * gp, Eq_n a0, char * a1)
{
	struct addrinfo * ptrLoc70;
	Eq_n tLoc68;
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	tLoc68.ai_flags = (int32) 0x00;
	tLoc68.ai_family = (word32) a0;
	tLoc68.ai_socktype = (int32) 0x00;
	tLoc68.ai_addrlen = (socklen_t) 0x00;
	tLoc68.ai_canonname = null;
	if ((uint64) getaddrinfo(a1, null, &tLoc68, &ptrLoc70) == 0x00)
	{
		struct addrinfo * s0_n = ptrLoc70;
		if (s0_n != null)
		{
			do
			{
				int64 a0_n = (int64) s0_n->ai_family;
				char * a1_n = s0_n->ai_canonname;
				if (a0_n == 2)
				{
					if (inet_ntop((int32) a0_n, a1_n + 4, &gp->dwFFFFF890 + 260, 64) != null)
						goto l0000000000016A88;
				}
				else if (inet_ntop((int32) a0_n, a1_n + 8, &gp->dwFFFFF890 + 260, 64) != null)
				{
l0000000000016A88:
					freeaddrinfo(ptrLoc70);
					a0_n = __strdup(&gp->dwFFFFF890 + 260);
					goto l0000000000016AAC;
				}
				s0_n = s0_n->ptr0028;
			} while (s0_n != null);
			s0_n = (struct addrinfo *) ptrLoc70;
		}
		freeaddrinfo(s0_n);
		a0_n.u0 = 0;
	}
	else
		a0_n.u0 = 0;
l0000000000016AAC:
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 0000000000016B38: void fn0000000000016B38(Register Eq_n a0)
void fn0000000000016B38(Eq_n a0)
{
	if (a0 > 0x007F)
		;
}

// 0000000000016B68: Register int64 fn0000000000016B68(Register int64 a0)
// Called from:
//      fn0000000000016D74
int64 fn0000000000016B68(int64 a0)
{
	int64 a4_n;
	word64 a3_n;
	word64 a4_n;
	int64 a0_n = fn00000000000182B4(a0, out a3_n, out a4_n);
	int64 a5_n = (int64) ((word32) a0_n >> 24);
	if (a5_n == 0x00)
	{
		a4_n = 71144;
		return a4_n;
	}
	if (a5_n == 0x0A)
		return 71176;
	int64 a4_n = (int64) ((word32) a0_n >> 16);
	if (a5_n != 100)
	{
		if (a5_n == 0x007F)
		{
			a4_n = 0x00011630;
			return a4_n;
		}
		int64 a2_n = (int64) ((word32) a0_n >> 8);
		if (a5_n != 0x00A9)
		{
			if (a5_n == 0x00AC)
			{
				if ((a4_n & 0x00F0) == 16)
					return 71176;
			}
			else if (a5_n == 0x00C0)
			{
				if (((a4_n | a2_n) & 0x00FF) == 0x00)
				{
					a4_n = 0x00011660;
					return a4_n;
				}
				if ((a4_n & 0x00FF) != 2)
				{
					if ((a4_n & 0x00FF) != 0x0033)
					{
						if ((a4_n & 0x00FF) == 88)
						{
							if ((a2_n & 0x00FF) == 99)
							{
								a4_n = 0x000116E0;
								return a4_n;
							}
l0000000000016CB8:
							if ((a5_n & 0x00F0) != 0x00F0)
								a4_n = 0x00011650;
							else
								a4_n = 0x00011710;
							return a4_n;
						}
						if ((a4_n & 0x00FF) != 52)
						{
							if ((a4_n & 0x00FF) == 0x00A8)
								return 71176;
						}
						else if ((a2_n & 0x00FF) == 0x00C1)
						{
							a4_n = 0x00011708;
							return a4_n;
						}
					}
					else if ((a2_n & 0x00FF) == 100)
					{
						a4_n = 0x000116A0;
						return a4_n;
					}
				}
				else if ((a2_n & 0x00FF) == 0x00)
				{
					a4_n = 0x00011680;
					return a4_n;
				}
			}
			else if (a5_n == 0x00CB)
			{
				if ((a4_n & 0x00FF) == 0x00 && (a2_n & 0x00FF) == 113)
				{
					a4_n = 0x000116C0;
					return a4_n;
				}
			}
			else
			{
				if (a5_n == 0x00FF)
				{
					a4_n = 0x00011710;
					if ((a4_n & 0x00FF) == a5_n)
					{
						a4_n = 0x00011710;
						if ((a2_n & 0x00FF) == 0x00FF && (a0_n & 0x00FF) == (a2_n & 0x00FF))
							a4_n = 0x00011720;
					}
					return a4_n;
				}
				if (a5_n == 0x00C6)
				{
					a4_n = 0x00011650;
					if ((a4_n & 0x00FE) == 18)
						a4_n = 0x00011738;
					return a4_n;
				}
			}
		}
		else if ((a4_n & 0x00FF) == 0x00FE)
		{
			a4_n = 0x00011640;
			return a4_n;
		}
	}
	else if ((a4_n & 0x00C0) == 64)
	{
		a4_n = 0x00011618;
		return a4_n;
	}
	if ((int64) ((word32) a5_n + -224) <= 0x0F)
	{
		a4_n = 0x00011748;
		return a4_n;
	}
	goto l0000000000016CB8;
}

// 0000000000016D74: Register Eq_n fn0000000000016D74(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1, Register (ptr64 Eq_n) a2, Register Eq_n a3, Register out Eq_n a4Out)
// Called from:
//      fn0000000000015180
Eq_n fn0000000000016D74(word64 ra, struct Eq_n * gp, Eq_n a0, Eq_n a1, struct Eq_n * a2, Eq_n a3, union Eq_n & a4Out)
{
	word64 qwLoc01B8;
	word64 qwLoc01B0;
	word64 qwLoc01A8;
	word64 qwLoc01A0;
	word64 qwLoc0198;
	char * ptrLoc0190;
	char bLoc0188;
	char bLoc0158;
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	memset(a2, 0, (size_t) 200);
	struct Eq_n * s6_n = a2;
	Eq_n s5_n = a1;
	if ((uint64) inet_pton(2, a0, &qwLoc01B8) <= 0x00)
	{
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000016E20;
		__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: bad IPv4 address: %s\n", 0x00);
		a0_n.u0 = -1;
l0000000000016E24:
		if (a5_n != gp->tFFFFF870)
			__stack_chk_fail();
		else
		{
			a4Out = a5_n;
			return a0_n;
		}
	}
	FILE * a0_n;
	if (a1 >= 0x00)
	{
		ptrLoc0190 = (char *) a0;
		Eq_n a0_n = a0;
		int64 s0_n = 3;
		do
		{
			char * a0_n = strchr(a0_n, '.');
			ptrLoc0190 = a0_n;
			if (a0_n == null)
			{
				do
				{
					if ((uint64) __asprintf_chk(&ptrLoc0190, 1, "%s.0", 0x00) == -1)
					{
						a0_n = gp->ptrFFFFF880;
						goto l00000000000172C4;
					}
					s0_n = (int64) ((word32) s0_n + -1);
				} while (s0_n != 0x00);
				break;
			}
			ptrLoc0190 = a0_n + 1;
			a0_n = a0_n + 1;
			s0_n = (int64) ((word32) s0_n + -1);
		} while (s0_n != 0x00);
		if (a1 > 32)
		{
			if ((int64) gp->dwFFFFF814 == 0x00)
			{
				__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: bad IPv4 prefix %d\n", 0x00);
				a0_n.u0 = -1;
				goto l0000000000016E24;
			}
			goto l0000000000016E20;
		}
	}
	else
	{
		s5_n.u0 = 32;
		if (a3 << 0x2D < 0x00)
		{
			word64 a4_n;
			word64 a3_n;
			int64 a0_n = fn00000000000182B4((int64) qwLoc01B8, out a3_n, out a4_n);
			s5_n.u0 = 8;
			int64 a5_n = (int64) ((word32) a0_n >> 24);
			if (a0_n < 0x00)
			{
				s5_n.u0 = 24;
				if ((int64) ((word32) a5_n + -0x0080) <= 63)
					s5_n.u0 = 16;
			}
		}
	}
	if (inet_ntop(2, &qwLoc01B8, &bLoc0188, 47) != null)
	{
		a2->t0000 = __strdup(&bLoc0188);
		qwLoc01B0 = (word64) (word32) fn0000000000016830(gp, s5_n);
		bLoc0188 = (char) 0x00;
		if (inet_ntop(2, &qwLoc01B0, &bLoc0188, 16) == null)
		{
			a0_n = gp->ptrFFFFF880;
			goto l00000000000172C4;
		}
		a2->t0030 = __strdup(&bLoc0188);
		int64 s0_n = (int64) qwLoc01B8;
		a2->dw00A0 = (word32) s5_n;
		qwLoc01A0 = (word64) (word32) (~fn0000000000016830(gp, s5_n) | s0_n);
		bLoc0188 = (char) 0x00;
		if (inet_ntop(2, &qwLoc01A0, &bLoc0188, 16) == null)
		{
			a0_n = gp->ptrFFFFF880;
			goto l00000000000172C4;
		}
		a2->t0028 = __strdup(&bLoc0188);
		int64 s0_n = (int64) qwLoc01B8;
		ui64 a0_n = fn0000000000016830(gp, s5_n);
		int64 a3_n = (int64) qwLoc01A0;
		int64 s0_n = a0_n & s0_n;
		qwLoc01A8 = (word64) (word32) s0_n;
		a2->t0018 = fn0000000000017F04(gp, s0_n, s5_n, s0_n, a3_n);
		bLoc0188 = (char) 0x00;
		if (inet_ntop(2, &qwLoc01A8, &bLoc0188, 16) == null)
		{
			a0_n = gp->ptrFFFFF880;
			goto l00000000000172C4;
		}
		Eq_n a5_n;
		Eq_n a0_n = __strdup(&bLoc0188);
		int64 s0_n = (int64) qwLoc01A8;
		a2->t0020 = a0_n;
		a2->t00B8 = fn0000000000016B68(s0_n);
		word64 a3_n;
		word64 a4_n;
		int64 a0_n = fn00000000000182B4(s0_n, out a3_n, out a4_n);
		int64 a5_n = (int64) ((word32) a0_n >> 24);
		if (a0_n < 0x00)
		{
			if ((int64) ((word32) a5_n + -0x0080) > 63)
			{
				if ((int64) ((word32) a5_n + -0x00C0) > 31)
				{
					if ((int64) ((word32) a5_n + -224) <= 0x0E)
						a5_n.u0 = 0x00011770;
					else
						a5_n.u0 = 0x00011778;
				}
				else
					a5_n.u0 = 0x00011768;
			}
			else
				a5_n.u0 = 0x00011760;
		}
		else
			a5_n.u0 = 0x00011758;
		struct Eq_n * a5_n;
		a2->t00C0 = a5_n;
		if (s5_n == 32)
		{
			a2->t00A8 = a0_n;
			a2->t00B0 = a0_n;
			a5_n = &g_t11780;
			goto l000000000001716C;
		}
		qwLoc0198 = (word64) (word32) s0_n;
		if (s5_n != 31)
		{
			qwLoc0198 = (word64) ((word32) s0_n | 0x01000000);
			if (inet_ntop(2, &qwLoc0198, &bLoc0188, 16) != null)
			{
				Eq_n a0_n = __strdup(&bLoc0188);
				int64 a5_n = (int64) qwLoc01B0;
				a2->t00A8 = a0_n;
				word64 a4_n;
				word64 a3_n;
				word64 a3_n;
				word64 a4_n;
				ptrLoc0190 = (char *) (word32) fn00000000000182B4((int64) ((word32) fn00000000000182B4(~a5_n | (int64) qwLoc01A8, out a3_n, out a4_n) + -1), out a3_n, out a4_n);
				if (inet_ntop(2, &ptrLoc0190, &bLoc0188, 47) != null)
				{
					a2->t00B0 = __strdup(&bLoc0188);
					__snprintf_chk(&a2->b0060, (size_t) 64, 1, (size_t) 64, "%u", 0x00);
					goto l000000000001717C;
				}
				goto l0000000000017074;
			}
l00000000000172E8:
			a0_n = gp->ptrFFFFF880;
l00000000000172C4:
			__fprintf_chk(a0_n, 1, "Memory allocation failure line %d\n", 0x00);
			abort();
		}
		if (inet_ntop(2, &qwLoc0198, &bLoc0188, 16) == null)
			goto l00000000000172E8;
		Eq_n a0_n = __strdup(&bLoc0188);
		int64 a5_n = (int64) qwLoc01B0;
		int64 a4_n = (int64) qwLoc01A8;
		a2->t00A8 = a0_n;
		ptrLoc0190 = (char *) (word32) (~a5_n | a4_n);
		if (inet_ntop(2, &ptrLoc0190, &bLoc0188, 47) != null)
		{
			a2->t00B0 = __strdup(&bLoc0188);
			a5_n = &g_t12660;
l000000000001716C:
			a2->b0060 = a5_n->b0000;
			a2->b0061 = a5_n->b0001;
l000000000001717C:
			if (a3 << 0x31 < 0x00)
				gp = fn0000000000017B40(ra, gp, (int64) qwLoc01B8, &a2->qw0038 + 1, &a2->qw0038 + 2, &a2->qw0038 + 3, &a2->qw0038 + 4, s5_n, a2, out s6_n);
			if ((a3 & 1) == 0x00)
			{
l000000000001718C:
				a0_n.u0 = 0;
				goto l0000000000016E24;
			}
			word64 a0_n = fn00000000000168E4(gp, 2, &qwLoc01B8);
			s6_n->qw0038 = a0_n;
			if (a0_n != 0x00)
				goto l000000000001718C;
			if ((int64) gp->dwFFFFF814 == 0x00)
			{
				__sprintf_chk(&bLoc0158, 1, (size_t) 0x00FA, "ipcalc: cannot find hostname for %s", 0x00);
				herror(&bLoc0158);
				a0_n.u0 = -1;
				goto l0000000000016E24;
			}
l0000000000016E20:
			a0_n.u0 = -1;
			goto l0000000000016E24;
		}
	}
l0000000000017074:
	if ((int64) gp->dwFFFFF814 == 0x00)
		fwrite(&g_v117F8, (size_t) 1, (size_t) 43, gp->ptrFFFFF880);
	goto l0000000000016E20;
}

// 000000000001730C: Register Eq_n fn000000000001730C(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 word64) a1)
// Called from:
//      fn00000000000175BC
Eq_n fn000000000001730C(struct Eq_n * gp, Eq_n a0, word64 * a1)
{
	word64 qwLocB8;
	char bLocA8;
	Eq_n a0_n;
	Eq_n a4_n = gp->tFFFFF870;
	if (a0 <= 0x0080)
	{
		qwLocB8 = 0x00;
		union Eq_n * a5_n = &qwLocB8;
		int64 a4_n = (int64) (0x08 - (word32) a0);
		while (0x00 < a0)
		{
			if (a0 > 7)
				*a5_n = (union Eq_n *) ~0x00;
			else
				*a5_n = (union Eq_n *) (~0x00 << (byte) a4_n);
			a0 = (int64) ((word32) a0 + -8);
			a5_n = (union Eq_n *) ((char *) a5_n + 1);
			a4_n = (int64) ((word32) a4_n + 8);
		}
		if (inet_ntop(0x0A, &qwLocB8, &bLocA8, 0x0080) != null)
		{
			memcpy(a1, &qwLocB8, (size_t) 16);
			a0_n = __strdup(&bLocA8);
l000000000001739C:
			if (a4_n == gp->tFFFFF870)
				return a0_n;
			__stack_chk_fail();
		}
	}
	a0_n.u0 = 0;
	goto l000000000001739C;
}

// 00000000000173D4: Register (ptr64 Eq_n) fn00000000000173D4(Register (ptr64 Eq_n) a0, Register Eq_n a1)
// Called from:
//      fn00000000000175BC
struct Eq_n * fn00000000000173D4(struct Eq_n * a0, Eq_n a1)
{
	struct Eq_n * a0_n;
	int64 s2_n = (word64) a0->qw0000;
	ui64 s3_n = (word64) a0->b0001;
	if (a1 != 0x0080)
	{
		if (a1 <= 95)
			goto l0000000000017408;
	}
	else
	{
		if ((uint64) memcmp(a0, &g_v10880, (size_t) 16) == 0x00)
			return &g_t11858;
		if ((uint64) memcmp(a0, &g_v10898, (size_t) 16) == 0x00)
		{
			a0_n = &g_t11870;
			return a0_n;
		}
	}
	if ((uint64) memcmp(a0, &g_v108B0, (size_t) 0x0C) == 0x00)
		return &g_t11888;
	if ((uint64) memcmp(a0, &g_v108C0, (size_t) 0x0C) == 0x00)
		return &g_t118A0;
	if ((uint64) memcmp(a0, &g_v108D0, (size_t) 0x0C) == 0x00)
		return &g_t118B8;
l0000000000017408:
	ui64 a5_n = s2_n << 0x08 | s3_n;
	if ((a5_n & 0xFFFFE000) != 0x2000)
	{
		if ((s2_n & 0x00FE) != 252)
		{
			if ((a5_n & -64) != 65152)
			{
				if (s2_n != 0x00FF)
				{
					a0_n = &g_t11710;
					if ((a5_n & -2) == 0x00002002)
						a0_n = &g_t11918;
				}
				else
					a0_n = &g_t11748;
			}
			else
				a0_n = &g_t11900;
		}
		else
			a0_n = &g_t118E8;
	}
	else
		a0_n = &g_t118D8;
	return a0_n;
}

// 00000000000175BC: Register Eq_n fn00000000000175BC(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n s1, Register Eq_n a0, Register Eq_n a1, Register (ptr64 Eq_n) a2, Register Eq_n a3, Register out Eq_n a4Out)
// Called from:
//      fn0000000000015180
Eq_n fn00000000000175BC(word64 ra, struct Eq_n * gp, Eq_n s1, Eq_n a0, Eq_n a1, struct Eq_n * a2, Eq_n a3, union Eq_n & a4Out)
{
	word64 qwLoc0198;
	word64 qwLoc0188;
	word64 qwLoc0178;
	char bLoc0168;
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	memset(a2, 0, (size_t) 200);
	struct Eq_n * s0_n = a2;
	Eq_n s2_n = a1;
	Eq_n s6_n = a3;
	if ((uint64) inet_pton(0x0A, a0, &qwLoc0198) <= 0x00)
	{
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000017770;
		__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: bad IPv6 address: %s\n", 0x00);
		a0_n.u0 = -1;
		goto l0000000000017774;
	}
	a2->qw0008 = fn00000000000163B0(gp);
	struct Eq_n * s3_n = &bLoc0168;
	if (inet_ntop(0x0A, &qwLoc0198, &bLoc0168, 0x00FA) == null)
	{
l0000000000017768:
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000017770;
		fwrite(&g_v117F8, (size_t) 1, (size_t) 43, gp->ptrFFFFF880);
		a0_n.u0 = -1;
		goto l0000000000017774;
	}
	else
	{
		a2->t0000 = __strdup(&bLoc0168);
		Eq_n s5_n = 0x0080;
		if (a1 <= 0x0080)
		{
			if (a1 >= 0x00)
				s5_n = a1;
			else
				s2_n.u0 = 0x0080;
			a2->dw00A0 = (word32) s5_n;
			Eq_n a0_n = fn000000000001730C(gp, s5_n, &qwLoc0188);
			a2->t0030 = a0_n;
			if (a0_n != 0x00)
			{
				union Eq_n * s8_n = &qwLoc0178;
				union Eq_n * a5_n = &qwLoc0198;
				union Eq_n * s9_n = &qwLoc0188;
				union Eq_n * a2_n = &qwLoc0178;
				union Eq_n * a3_n = &qwLoc0188;
				do
				{
					*a2_n = (union Eq_n *) (*a5_n & *a3_n);
					a5_n = (union Eq_n *) ((char *) a5_n + 1);
					a3_n = (union Eq_n *) ((char *) a3_n + 1);
					a2_n = (union Eq_n *) ((char *) a2_n + 1);
				} while (&qwLoc0188 != a5_n);
				if (inet_ntop(0x0A, &qwLoc0178, &bLoc0168, 0x00FA) != null)
				{
					a2->t0020 = __strdup(&bLoc0168);
					a2->qw0010 = fn00000000000163B0(gp);
					a2->t00B8 = fn00000000000173D4(&qwLoc0178, s2_n);
					a2->t0018 = fn0000000000018118(gp, &qwLoc0178, s5_n);
					if (s2_n == 0x0080)
					{
						Eq_n a5_n = a2->t0020;
						a2->t00A8 = a5_n;
						a2->t00B0 = a5_n;
						goto l0000000000017728;
					}
					a2->t00A8 = __strdup(&bLoc0168);
					do
					{
						s8_n = (union Eq_n *) ((char *) s8_n + 1);
						*((char *) s8_n + 0x0FFF) = (union Eq_n *) ((byte) ~(word64) *s9_n | *s8_n);
						s9_n = (union Eq_n *) ((char *) s9_n + 1);
					} while (&bLoc0168 != s8_n);
					if (inet_ntop(0x0A, &qwLoc0178, &bLoc0168, 0x00FA) != null)
					{
						a2->t00B0 = __strdup(&bLoc0168);
						if ((int64) (0x80 - (word32) s2_n) == 0x0080)
							goto l0000000000017740;
l0000000000017740:
						snprintf(&a2->b0060, (size_t) 64, "%s", 0x00);
						if (a3 << 0x31 < 0x00)
							gp = fn0000000000017D10(ra, gp, s1, &qwLoc0198, &a2->qw0038 + 1, &a2->qw0038 + 2, &a2->qw0038 + 3, &a2->qw0038 + 4, a3, &qwLoc0188, out s0_n, out s3_n, out s6_n);
						if ((s6_n & 1) == 0x00)
						{
l0000000000017760:
							a0_n.u0 = 0;
							goto l0000000000017774;
						}
						word64 a0_n = fn00000000000168E4(gp, 0x0A, &qwLoc0198);
						s0_n->qw0038 = a0_n;
						if (a0_n != 0x00)
							goto l0000000000017760;
						if ((int64) gp->dwFFFFF814 == 0x00)
						{
							__sprintf_chk(s3_n, 1, (size_t) 0x00FA, "ipcalc: cannot find hostname for %s", 0x00);
							herror(s3_n);
						}
l0000000000017770:
						a0_n.u0 = -1;
						goto l0000000000017774;
					}
				}
				goto l0000000000017768;
			}
			if ((int64) gp->dwFFFFF814 != 0x00)
				goto l0000000000017770;
			__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: error converting IPv6 prefix: %d\n", 0x00);
			a0_n.u0 = -1;
		}
		else
		{
			if ((int64) gp->dwFFFFF814 != 0x00)
				goto l0000000000017770;
			__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: bad IPv6 prefix: %d\n", 0x00);
			a0_n.u0 = -1;
		}
l0000000000017774:
		if (a5_n != gp->tFFFFF870)
			__stack_chk_fail();
		else
		{
			a4Out = a5_n;
			return a0_n;
		}
	}
}

// 0000000000017924: Register int64 fn0000000000017924(Register (ptr64 Eq_n) gp, Register out (ptr64 Eq_n) a1Out, Register out Eq_n a2Out, Register out Eq_n a3Out, Register out Eq_n a4Out, Register out Eq_n a6Out)
// Called from:
//      fn0000000000015180
//      fn0000000000017B40
//      fn0000000000017D10
int64 fn0000000000017924(struct Eq_n * gp, FILE & a1Out, union Eq_n & a2Out, union Eq_n & a3Out, union Eq_n & a4Out, union Eq_n & a6Out)
{
	FILE * a1;
	Eq_n a2;
	Eq_n a3;
	Eq_n a4;
	Eq_n a6;
	int64 s0_n;
	if (gp->qwFFFFF820 == 0x00)
	{
		s0_n = (int64) gp->dwFFFFF818;
		if (s0_n == 0x00)
		{
			void * a0_n = dlopen("/usr/lib64/libGeoIP.so.1", 1);
			gp->ptr0820 = a0_n;
			if (a0_n != null)
			{
				gp->ptr0868 = dlsym(a0_n, "_GeoIP_setup_dbfilename");
				void * a0_n = dlsym(a0_n, "GeoIP_open_type");
				gp->ptr0860 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_country_name_by_id");
				gp->ptr0858 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_delete");
				gp->ptr0848 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_record_by_ipnum");
				gp->ptr0840 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_id_by_ipnum");
				gp->ptr0838 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_id_by_ipnum_v6");
				gp->ptr0830 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_record_by_ipnum_v6");
				gp->ptr0828 = a0_n;
				gp->ptr0850 = dlsym(a0_n, "GeoIP_code_by_id");
				a1 = (FILE *) g_str12B38;
				if (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && a0_n != null))))))
					gp->dw0818 = 0x00;
				else
				{
					a6 = g_t12B50;
					word64 a0_n = g_qw12B58;
					a1 = g_ptr12B60;
					a2 = g_t12B68;
					a3 = g_t12B70;
					a4.u0 = (int64) g_dw12B78;
					gp->tFFFFFCE0 = a6;
					gp->qwFFFFFCE8 = a0_n;
					gp->ptrFFFFFCF0 = a1;
					gp->tFFFFFCF8 = a2;
					gp->tFFFFFD00 = a3;
					gp->dwFFFFFD08 = (word32) a4;
					gp->dw0818 = ~0x00;
					s0_n = -1;
				}
			}
			else
			{
				__snprintf_chk(&gp->tFFFFFCE0, (size_t) 0x0100, 1, (size_t) 0x0100, "ipcalc: could not open %s\n", 0x00);
				gp->dw0818 = ~0x00;
				a3.u0 = 0x0100;
				a4.u0 = 76376;
				a2.u0 = 1;
				a1 = (FILE *) 0x0100;
				s0_n = -1;
			}
l0000000000017970:
			a1Out = a1;
			a2Out = a2;
			a3Out = a3;
			a4Out = a4;
			a6Out = a6;
			return s0_n;
		}
	}
	if ((int64) gp->dwFFFFF814 == 0x00 && (word64) gp->tFFFFFCE0 != 0x00)
	{
		a1 = gp->ptrFFFFF880;
		fputs(&gp->tFFFFFCE0, a1);
	}
	s0_n = (int64) gp->dwFFFFF818;
	goto l0000000000017970;
}

// 0000000000017B40: Register (ptr64 Eq_n) fn0000000000017B40(Register word64 ra, Register (ptr64 Eq_n) gp, Register int64 a0, Register ptr64 a1, Register ptr64 a2, Register ptr64 a3, Register ptr64 a4, Register Eq_n s5, Register (ptr64 Eq_n) s6, Register out (ptr64 Eq_n) s6Out)
// Called from:
//      fn0000000000016D74
struct Eq_n * fn0000000000017B40(word64 ra, struct Eq_n * gp, int64 a0, ptr64 a1, ptr64 a2, ptr64 a3, ptr64 a4, Eq_n s5, struct Eq_n * s6, struct Eq_n & s6Out)
{
	word64 a1_n;
	word64 a2_n;
	word64 a3_n;
	word64 a4_n;
	word64 a6_n;
	if (fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) == 0x00)
	{
		word64 a3_n;
		word64 a4_n;
		int64 a0_n = fn00000000000182B4(a0, out a3_n, out a4_n);
		word64 s0_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		gp->ptrFFFFF868();
		struct Eq_n * a0_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * gp_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s0_n = a0_n;
		if (a0_n != null)
		{
			<anonymous> * a5_n = gp_n->ptrFFFFF838;
			a0_n->dw004C = 0x01;
			word64 s0_n;
			word64 s1_n;
			word64 s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s7_n;
			int64 a0_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			a5_n();
			if (a0_n < 0x00)
				goto l0000000000017B84;
			word64 s0_n;
			word64 s1_n;
			word64 s2_n;
			union Eq_n * s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s6_n;
			word64 s7_n;
			char * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF858();
			if (a0_n != null)
				*s3_n = (union Eq_n *) __strdup(a0_n);
			word64 s0_n;
			word64 s1_n;
			union Eq_n * s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s6_n;
			word64 s7_n;
			char * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF850();
			if (a0_n != null)
				*s2_n = (union Eq_n *) __strdup(a0_n);
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF848();
		}
		word64 a4_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		word64 s7_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		struct Eq_n * a0_n;
		word64 a2_n;
		word64 a3_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s0_n = a0_n;
		if (a0_n == null)
		{
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF860();
			s0_n = a0_n;
			if (a0_n == null)
				goto l0000000000017B84;
		}
		<anonymous> * a5_n = gp->ptrFFFFF840;
		s0_n->dw004C = 0x01;
		word64 sp_n;
		word64 s0_n;
		union Eq_n * s1_n;
		char ** s4_n;
		struct Eq_n * a0_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		int64 a1_n;
		word64 a2_n;
		a5_n();
		if (a0_n != null)
		{
			char * a0_n = a0_n->ptr0020;
			if (a0_n != null)
				*s1_n = (union Eq_n *) __strdup(a0_n);
			if ((word64) (a0_n->r0034 == 0.0F) == 0x00)
			{
				__asprintf_chk(s4_n, 1, "%f,%f", 0x00);
				a2_n = 76672;
				a1_n = 1;
			}
		}
		struct Eq_n * s6_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		gp_n->ptrFFFFF848();
		s6Out = s6_n;
		return gp_n;
	}
	else
	{
l0000000000017B84:
		s6Out = s6;
		return gp;
	}
}

// 0000000000017D10: Register (ptr64 Eq_n) fn0000000000017D10(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n s1, Register (ptr64 word64) a0, Register ptr64 a1, Register ptr64 a2, Register ptr64 a3, Register ptr64 a4, Register Eq_n s6, Register (ptr64 word64) s7, Register out (ptr64 void) s0Out, Register out (ptr64 char) s3Out, Register out Eq_n s6Out)
// Called from:
//      fn00000000000175BC
struct Eq_n * fn0000000000017D10(word64 ra, struct Eq_n * gp, Eq_n s1, word64 * a0, ptr64 a1, ptr64 a2, ptr64 a3, ptr64 a4, Eq_n s6, word64 * s7, void & s0Out, char & s3Out, union Eq_n & s6Out)
{
	void * s0;
	char * s3;
	word64 a1_n;
	word64 a2_n;
	word64 a3_n;
	word64 a4_n;
	word64 a6_n;
	word64 a0_n = fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n);
	if (a0_n == 0x00)
	{
		word64 s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s1_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		gp->ptrFFFFF868();
		struct Eq_n * a0_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * gp_n;
		struct Eq_n * s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s1_n = a0_n;
		if (a0_n != null)
		{
			word64 a4_n = (word64) s0_n->dw0004;
			word64 a5_n = (word64) s0_n->dw000C;
			word64 a1_n = (word64) s0_n->dw0000;
			word64 a2_n = (word64) s0_n->dw0008;
			<anonymous> * a3_n = gp_n->ptrFFFFF830;
			a0_n->dw004C = 0x01;
			word64 s0_n;
			word64 s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			int64 a0_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			a3_n();
			if (a0_n < 0x00)
				goto l0000000000017D54;
			word64 s0_n;
			word64 s2_n;
			word64 s3_n;
			union Eq_n * s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			word64 s7_n;
			char * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF858();
			if (a0_n != null)
				*s4_n = (union Eq_n *) __strdup(a0_n);
			word64 s0_n;
			word64 s2_n;
			union Eq_n * s3_n;
			word64 s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			word64 s7_n;
			char * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF850();
			if (a0_n != null)
				*s3_n = (union Eq_n *) __strdup(a0_n);
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF848();
		}
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s6_n;
		word64 s7_n;
		struct Eq_n * a0_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s1_n = a0_n;
		if (a0_n == null)
		{
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF860();
			s1_n = a0_n;
			if (a0_n == null)
				goto l0000000000017D54;
		}
		word64 a4_n = (word64) s0_n->dw0004;
		word64 a5_n = (word64) s0_n->dw000C;
		word64 a1_n = (word64) s0_n->dw0000;
		word64 a2_n = (word64) s0_n->dw0008;
		<anonymous> * a3_n = gp->ptrFFFFF828;
		s1_n->dw004C = 0x01;
		word64 sp_n;
		union Eq_n * s2_n;
		char ** s5_n;
		word64 s1_n;
		struct Eq_n * a0_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		int64 a1_n;
		word64 a2_n;
		a3_n();
		if (a0_n != null)
		{
			char * a0_n = a0_n->ptr0020;
			if (a0_n != null)
				*s2_n = (union Eq_n *) __strdup(a0_n);
			if ((word64) (a0_n->r0034 == 0.0F) == 0x00)
			{
				__asprintf_chk(s5_n, 1, "%f,%f", 0x00);
				a2_n = 76672;
				a1_n = 1;
			}
		}
		void * s0_n;
		char * s3_n;
		Eq_n s6_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		gp_n->ptrFFFFF848();
		s0Out = s0_n;
		s3Out = s3_n;
		s6Out = s6_n;
		return gp_n;
	}
	else
	{
l0000000000017D54:
		s0Out = s0;
		s3Out = s3;
		s6Out = s6;
		return gp;
	}
}

// 0000000000017F04: Register int64 fn0000000000017F04(Register (ptr64 Eq_n) gp, Register int64 a0, Register Eq_n a1, Register int64 a2, Register int64 a3)
// Called from:
//      fn0000000000016D74
int64 fn0000000000017F04(struct Eq_n * gp, int64 a0, Eq_n a1, int64 a2, int64 a3)
{
	char * ptrLoc50;
	int64 a0_n;
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	ptrLoc50 = 0x00;
	word64 a3_n;
	word64 a4_n;
	fn00000000000182B4(a0, out a3_n, out a4_n);
	if (a1 != 32)
	{
		if (a1 != 24)
		{
			if (a1 != 16)
			{
				if (a1 != 8)
				{
					if (a1 <= 24)
					{
						if (a1 <= 16)
						{
							if (a1 <= 8)
								goto l0000000000017F84;
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a2, out a3_n, out a4_n);
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a3, out a3_n, out a4_n);
							a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.in-addr.arpa.", 0x00);
						}
						else
						{
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a2, out a3_n, out a4_n);
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a3, out a3_n, out a4_n);
							a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.%u.in-addr.arpa.", 0x00);
						}
					}
					else
					{
						word64 a3_n;
						word64 a4_n;
						fn00000000000182B4(a2, out a3_n, out a4_n);
						word64 a3_n;
						word64 a4_n;
						fn00000000000182B4(a3, out a3_n, out a4_n);
						a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.%u.%u.in-addr.arpa.", 0x00);
					}
				}
				else
					a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.in-addr.arpa.", 0x00);
			}
			else
				a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.in-addr.arpa.", 0x00);
		}
		else
			a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.%u.in-addr.arpa.", 0x00);
	}
	else
		a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.%u.%u.in-addr.arpa.", 0x00);
	if (a0_n != -1)
	{
		a0_n = ptrLoc50;
l0000000000017F88:
		if (a5_n == gp->tFFFFF870)
			return a0_n;
		__stack_chk_fail();
	}
l0000000000017F84:
	a0_n = 0;
	goto l0000000000017F88;
}

// 0000000000018118: Register Eq_n fn0000000000018118(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1)
// Called from:
//      fn00000000000175BC
Eq_n fn0000000000018118(struct Eq_n * gp, Eq_n a0, Eq_n a1)
{
	ptr64 fp;
	char bLoc0118;
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	int64 t4_n = a1 & 3;
	if ((a1 & 3) == 0x00)
	{
		int64 t5_n = (int64) ((word32) a1 >> 3);
		if ((a1 & 7) == 4)
		{
			uint64 a5_n = (word64) *((word64) a0 + (word64) (((word32) a1 + 4 >> 3) + -1));
			uint64 a4_n = (a5_n >> 0x04) + 87;
			if (a5_n >> 0x04 <= 9)
				a4_n = (a5_n >> 0x04) + 48;
			bLoc0118 = (byte) a4_n;
			t4_n = 2;
		}
		if (t5_n != 0x00)
		{
			int64 a1_n = (int64) ((word32) t5_n + -1);
			int64 a4_n = t4_n;
			do
			{
				uint64 a5_n = (word64) *((word64) a0 + (word64) ((word32) a1_n));
				int64 a3_n = (int64) ((word32) a4_n + 1);
				ui64 a6_n = (a5_n & 0x0F) + 87;
				if ((a5_n & 0x0F) <= 9)
					a6_n = (a5_n & 0x0F) + 48;
				(fp + -16 + (word64) ((word32) a4_n))->b0EF8 = (byte) a6_n;
				(fp + -16 + (word64) ((word32) a3_n))->b0EF8 = 0x2E;
				int64 a2_n = (int64) ((word32) a4_n + 2);
				int64 a3_n = (int64) ((word32) a4_n + 3);
				uint64 a6_n = (a5_n >> 0x04) + 48;
				if (a5_n >> 0x04 > 9)
					a6_n = (a5_n >> 0x04) + 87;
				(fp + -16 + (word64) ((word32) a2_n))->b0EF8 = (byte) a6_n;
				(fp + -16 + (word64) ((word32) a3_n))->b0EF8 = 0x2E;
				a1_n = (int64) ((word32) a1_n + -1);
				a4_n = (int64) ((word32) a4_n + 4);
			} while (a1_n != -1);
			t4_n = (int64) ((word32) t4_n + (int64) ((word32) t5_n << 0x02));
		}
		struct Eq_n * t4_n = &bLoc0118 + (word64) ((word32) t4_n);
		t4_n->w0004 = 29281;
		t4_n->w0000 = 28777;
		t4_n->w0006 = 24944;
		t4_n->w0002 = 11830;
		t4_n->w0008 = 0x2E;
		a0_n = __strdup(&bLoc0118);
	}
	else
		a0_n.u0 = 0;
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000182B4: Register int64 fn00000000000182B4(Register int64 a0, Register out Eq_n a3Out, Register out Eq_n a4Out)
// Called from:
//      fn00000000000166F4
//      fn0000000000016830
//      fn0000000000016B68
//      fn0000000000016D74
//      fn0000000000017B40
//      fn0000000000017F04
int64 fn00000000000182B4(int64 a0, union Eq_n & a3Out, union Eq_n & a4Out)
{
	Eq_n a3_n = (int64) ((word32) a0 >> 24) | (int64) ((word32) a0 << 0x18);
	a3Out = a3_n;
	Eq_n a4_n = (int64) (((word32) a0 & 0x00FF0000) >> 0x08);
	a4Out = a4_n;
	return a3_n | a4_n | (int64) (((word32) a0 & 0xFF00) << 0x08);
}

// 00000000000182E8: void fn00000000000182E8(Register word64 ra, Register word64 a0, Register word64 a1, Register word64 a2)
void fn00000000000182E8(word64 ra, word64 a0, word64 a1, word64 a2)
{
	int64 s2_n = 106016 - 106008;
	<anonymous> ** s0_n = &g_ptr19E18;
	int64 s2_n = s2_n >> 0x03;
	if (s2_n >> 0x03 != 0x00)
	{
		word64 s5_n = a0;
		word64 s4_n = a1;
		word64 s3_n = a2;
		int64 s1_n = 0;
		do
		{
			word64 s0_n;
			word64 a5_n;
			(*s0_n)();
			s0_n = s0_n + 8;
		} while (s2_n != s1_n);
	}
}

// 0000000000018378: void fn0000000000018378()
void fn0000000000018378()
{
}

