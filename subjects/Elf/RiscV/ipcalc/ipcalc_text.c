// ipcalc_text.c
// Generated by decompiling ipcalc
// using Reko decompiler version 0.11.1.0.

#include "ipcalc.h"

// 0000000000015180: void fn0000000000015180(Register word64 ra, Register (ptr64 Eq_n) gp, Register int64 a0, Register (ptr64 (ptr64 char)) a1, Register word64 a7, Register word64 s5, Register word64 s11)
void fn0000000000015180(word64 ra, struct Eq_n * gp, int64 a0, char ** a1, word64 a7, word64 s5, word64 s11)
{
	ptr64 fp;
	int32 tLoc01A4;
	char * ptrLoc01A0;
	Eq_n tLoc0198;
	void vLoc0188;
	char bLocB8;
	ui64 qwLoc0190;
	word24 nLocBF;
	Eq_n a5_n = gp->tFFFFF870;
	tLoc01A4 = 0x00;
	Eq_n s0_n = 0;
	do
	{
		char * a0_n = (uint64) getopt_long((int32) a0, a1, "cr:i46bho:gmnpsv", &g_t108E0, null);
		if (a0_n == (char *) -1)
		{
			char * s1_n;
			char * s4_n;
			int64 a4_n = (int64) gp->dwFFFFF890;
			if (a4_n < a0)
			{
				int64 a1_n = (int64) ((word32) a4_n + 1);
				gp->dw0890 = (word32) a1_n;
				struct Eq_n * s2_n = (char *) a1 + (a4_n << 0x03);
				s1_n = s2_n->ptr0000;
				s4_n = null;
				if (a1_n < a0)
				{
					s4_n = s2_n->ptr0008;
					gp->dw0890 = (word32) a4_n + 2;
				}
			}
			else
			{
				s4_n = null;
				s1_n = null;
			}
			if (false)
			{
				__printf_chk(1, "ipcalc %s\n", 0x00);
				goto l00000000000153DC;
			}
			if ((int64) tLoc01A4 != 0x00 && false)
			{
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				fwrite(&g_v119D8, (size_t) 1, (size_t) 46, gp->ptrFFFFF880);
				goto l00000000000153DC;
			}
			word64 a6_n;
			Eq_n a4_n;
			int64 a0_n;
			char * a5_n;
			FILE * a0_n;
			char * a0_n;
			char * a5_n;
			Eq_n s2_n;
			if (false)
			{
				s2_n.u0 = 2;
				word64 a1_n;
				word64 a2_n;
				word64 a3_n;
				word64 a4_n;
				if (fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) != 0x00 || true)
					goto l00000000000153CC;
				s0_n.u0 = 2;
				goto l0000000000015448;
			}
			word64 a2_n;
			word64 a1_n;
			word64 a4_n;
			word64 a3_n;
			if (fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) == 0x00 && false)
			{
l0000000000015448:
				s2_n = s0_n | 0x4000;
				if (true)
				{
					s0_n = s2_n;
					goto l0000000000015458;
				}
l00000000000153CC:
				if (false)
				{
					if ((int64) gp->dwFFFFF814 == 0x00)
						fwrite(&g_v11A08, (size_t) 1, (size_t) 37, gp->ptrFFFFF880);
					goto l00000000000153D8;
				}
				if ((int64) tLoc01A4 != 0x00)
				{
					char * a0_n = fn00000000000169D8(gp, (char *) 0x0A, null);
					s1_n = a0_n;
					s0_n = s2_n;
					a5_n = a0_n;
					if (a0_n == null)
						goto l0000000000015964;
					goto l0000000000015510;
				}
				if (false)
				{
					char * a0_n = fn00000000000169D8(gp, (char *) 2, null);
					s1_n = a0_n;
					if (a0_n == null)
						goto l0000000000015964;
					a5_n = a0_n;
					s0_n = s2_n;
					goto l00000000000155D8;
				}
				char * a0_n = fn00000000000169D8(gp, null, null);
				s1_n = a0_n;
				if (a0_n != null)
				{
					s0_n = s2_n;
					a5_n = a0_n;
					goto l0000000000015518;
				}
l0000000000015964:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: could not resolve %s\n", 0x00);
				goto l00000000000153DC;
			}
l0000000000015458:
			a5_n = a0_n;
			if (true)
			{
				if (s1_n != null)
					goto l0000000000015510;
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				fwrite(&g_v11A30, (size_t) 1, (size_t) 28, gp->ptrFFFFF880);
				fn0000000000015FCC(gp, 1);
				goto l00000000000153DC;
			}
			char * a0_n = fn00000000000166F4(gp, &tLoc01A4, null, 1);
			if (a0_n < null)
			{
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				a0_n = gp->ptrFFFFF880;
				goto l0000000000015B8C;
			}
			int64 s1_n = (int64) tLoc01A4;
			ptrLoc01A0 = 0x00;
			if ((uint64) clock_gettime(2, &tLoc0198) < 0x00)
			{
l0000000000015CB0:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: cannot generate network with prefix: %u\n", 0x00);
				goto l00000000000153DC;
			}
			if (s1_n != 0x00)
			{
				vLoc0188 = (void) ((byte) qwLoc0190 & 0x01 | 252);
				if (fn00000000000164D0((char *) &vLoc0188 + 1, 0x0F) >= 0x00 && inet_ntop(0x0A, &vLoc0188, &bLocB8, 64) != null)
					goto l00000000000154DC;
				goto l0000000000015CB0;
			}
			if (fn00000000000164D0(fp + -0x00C0, 4) < 0x00)
				goto l0000000000015CB0;
			if (a0_n <= (char *) 0x0F || (qwLoc0190 | 4) > 1)
				;
			if (inet_ntop(2, fp + -424, &bLocB8, 64) == null)
				goto l0000000000015CB0;
l00000000000154DC:
			a5_n = a0_n;
			if ((uint64) __asprintf_chk(&ptrLoc01A0, 1, "%s/%u", 0x00) == -1)
				goto l0000000000015CB0;
			s1_n = ptrLoc01A0;
			if (s1_n == null)
				goto l0000000000015CB0;
l0000000000015510:
			if (true)
			{
l0000000000015518:
				if (strchr(s1_n, ':') == null)
					goto l00000000000155D8;
				tLoc01A4 = 0x01;
				if (s4_n != null)
					goto l000000000001553C;
				a0_n = strchr(s1_n, '/');
				a5_n = a5_n;
				if (a0_n == null)
					goto l0000000000015604;
				goto l0000000000015BB8;
			}
l00000000000155D8:
			if (s4_n != null)
			{
				if ((int64) tLoc01A4 == 0x00)
					goto l00000000000155E4;
l000000000001553C:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: unexpected argument: %s\n", 0x00);
				fn0000000000015FCC(gp, 1);
				goto l00000000000153DC;
			}
			a0_n = strchr(s1_n, '/');
			a5_n = a5_n;
			if (a0_n != null)
			{
l0000000000015BB8:
				*a0_n = 0x00;
				s4_n = a0_n + 1;
				if (s4_n == null)
					goto l00000000000155FC;
l00000000000155E4:
				char * a0_n = fn00000000000166F4(gp, &tLoc01A4, s4_n, 0);
				a5_n = a0_n;
				if (a0_n >= null)
					goto l00000000000155FC;
				if ((int64) gp->dwFFFFF814 == 0x00)
				{
					a0_n = gp->ptrFFFFF880;
l0000000000015B8C:
					__fprintf_chk(a0_n, 1, "ipcalc: bad %s prefix: %s\n", 0x00);
				}
				goto l00000000000153D8;
			}
l00000000000155FC:
			if ((int64) tLoc01A4 != 0x00)
			{
l0000000000015604:
				a0_n = fn00000000000175BC(ra, gp, s1_n, s1_n, a5_n, &vLoc0188, s0_n, out a4_n);
			}
			else
				a0_n = fn0000000000016D74(ra, gp, s1_n, a5_n, &vLoc0188, s0_n, out a4_n);
			if (a0_n < 0x00)
			{
l00000000000153D8:
				goto l00000000000153DC;
			}
			if ((s0_n & 0xFFFABFFF) == 0x00)
				s0_n |= 8;
			if ((uint64) isatty(1) != 0x00)
			{
				gp->dw0810 = 0x01;
				a4_n.u0 = 1;
			}
			if ((s0_n & 8) == 0x00)
			{
				if ((s0_n & 0x0080) != 0x00)
					__printf_chk(1, "NETMASK=%s\n", 0x00);
				if ((s0_n & 0x0200) != 0x00)
					__printf_chk(1, "PREFIX=%u\n", 0x00);
				if ((s0_n & 64) != 0x00 && (int64) tLoc01A4 == 0x00)
					__printf_chk(1, "BROADCAST=%s\n", 0x00);
				if ((s0_n & 0x0100) != 0x00)
					__printf_chk(1, "NETWORK=%s\n", 0x00);
				if (s0_n << 0x2E < 0x00)
					__printf_chk(1, "REVERSEDNS=%s\n", 0x00);
				if ((s0_n & 0x0400) != 0x00 && vLoc0188.qw00A8 != 0x00)
					__printf_chk(1, "MINADDR=%s\n", 0x00);
				if (s0_n << 0x34 < 0x00 && vLoc0188.qw00B0 != 0x00)
					__printf_chk(1, "MAXADDR=%s\n", 0x00);
				if (s0_n << 0x32 < 0x00)
				{
					char * s2_n = vLoc0188.ptr00B8;
					if (s2_n != null)
					{
						if (strchr(s2_n, ' ') != null)
							__printf_chk(1, "ADDRSPACE=\"%s\"\n", 0x00);
						else
							__printf_chk(1, "ADDRSPACE=%s\n", 0x00);
					}
				}
				if (s0_n << 0x33 < 0x00)
				{
					if (strchr((char *) &vLoc0188 + 96, ' ') != null)
						__printf_chk(1, "ADDRESSES=\"%s\"\n", 0x00);
					else
						__printf_chk(1, "ADDRESSES=%s\n", 0x00);
				}
				if ((s0_n & 1) != 0x00 && vLoc0188.qw0038 != 0x00)
					__printf_chk(1, "HOSTNAME=%s\n", 0x00);
				if ((s0_n & 2) != 0x00)
					__printf_chk(1, "ADDRESS=%s\n", 0x00);
				if ((s0_n & 0xC000) == 0xC000)
				{
					if (vLoc0188.qw0048 != 0x00)
						__printf_chk(1, "COUNTRYCODE=%s\n", 0x00);
					char * s0_n = vLoc0188.ptr0040;
					if (s0_n != null)
					{
						if (strchr(s0_n, ' ') != null)
							__printf_chk(1, "COUNTRY=\"%s\"\n", 0x00);
						else
							__printf_chk(1, "COUNTRY=%s\n", 0x00);
					}
					char * s0_n = vLoc0188.ptr0050;
					if (s0_n != null)
					{
						if (strchr(s0_n, ' ') != null)
							__printf_chk(1, "CITY=\"%s\"\n", 0x00);
						else
							__printf_chk(1, "CITY=%s\n", 0x00);
					}
					if (vLoc0188.qw0058 != 0x00)
						__printf_chk(1, "COORDINATES=\"%s\"\n", 0x00);
				}
				goto l00000000000153DC;
			}
			Eq_n a4_n;
			Eq_n a5_n;
			int64 s0_n;
			char * a3_n;
			Eq_n a5_n;
			int64 s4_n;
			char * a3_n;
			Eq_n s2_n = (int64) vLoc0188.dw00A0;
			if ((int64) tLoc01A4 == 0x00)
			{
				a5_n.u0 = 32;
				if (s2_n != 32)
					goto l0000000000015660;
				goto l0000000000015914;
			}
			a5_n.u0 = 0x0080;
			if (s2_n == 0x0080)
			{
l0000000000015914:
				a3_n = vLoc0188.ptr0008;
				if (a3_n != null)
				{
					s4_n = 1;
					goto l0000000000015880;
				}
				word64 a5_n;
				gp = fn000000000001654C(gp, vLoc0188, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				goto l00000000000158B8;
			}
l0000000000015660:
			if (false)
			{
l0000000000015664:
				goto l0000000000015668;
			}
			char * s3_n = vLoc0188;
			if ((uint64) strcmp(vLoc0188.ptr0020, s3_n) == 0x00)
				goto l0000000000015664;
			a3_n = vLoc0188.ptr0008;
			s4_n = 0;
			if (a3_n == null)
			{
				word64 a4_n;
				gp = fn000000000001654C(gp, s3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				s2_n.u0 = (int64) vLoc0188.dw00A0;
				goto l0000000000015668;
			}
l0000000000015880:
			Eq_n a4_n;
			Eq_n a5_n;
			word64 a6_n;
			word64 a7_n;
			gp = fn000000000001654C(fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n), vLoc0188, a4_n, a5_n, a6_n, a7_n, out a4_n, out a5_n, out a6_n, out a7);
			if (s4_n != 0x00)
			{
l00000000000158B8:
				a5_n.u0 = 0x00010008;
				if ((s0_n & 0x00010008) != 0x00010008)
					goto l00000000000158C8;
				a3_n = vLoc0188.ptr0018;
				s0_n = 1;
				if (a3_n == null)
					goto l00000000000158C8;
				goto l0000000000015C2C;
			}
			s2_n.u0 = (int64) vLoc0188.dw00A0;
l0000000000015668:
			char * a3_n = vLoc0188.ptr0010;
			if (a3_n != null)
			{
				word64 a4_n;
				gp = fn000000000001654C(gp, a3_n, s2_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				s2_n.u0 = (int64) vLoc0188.dw00A0;
			}
			Eq_n a5_n;
			word64 a6_n;
			word64 a7_n;
			Eq_n a5_n;
			word64 a4_n;
			gp = fn000000000001654C(fn000000000001654C(gp, vLoc0188.ptr0020, s2_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n), vLoc0188.ptr0030, (int64) vLoc0188.dw00A0, a5_n, a6_n, a7_n, out a4_n, out a5_n, out a6_n, out a7);
			char * a3_n = vLoc0188.ptr0028;
			if (a3_n != null)
			{
				word64 a5_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			a5_n.u0 = 0x00010008;
			if ((s0_n & 0x00010008) == 0x00010008)
			{
				a3_n = vLoc0188.ptr0018;
				if (a3_n == null)
					goto l00000000000156FC;
				s0_n = 0;
l0000000000015C2C:
				gp = fn000000000001654C(gp, a3_n, a4_n, 0x00010008, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				if (s0_n == 0x00)
					goto l00000000000156FC;
l00000000000158C8:
				char * a3_n = vLoc0188.ptr00B8;
				if (a3_n != null)
					gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				char * a3_n = vLoc0188.ptr00C0;
				if (a3_n != null)
				{
					word64 a5_n;
					gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				}
				goto l00000000000157BC;
			}
l00000000000156FC:
			putchar(0x0A);
			char * a3_n = vLoc0188.ptr00B8;
			if (a3_n != null)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			char * a3_n = vLoc0188.ptr00C0;
			if (a3_n != null)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			char * a3_n = vLoc0188.ptr00A8;
			if (a3_n != null)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			char * a3_n = vLoc0188.ptr00B0;
			if (a3_n != null)
			{
				word64 a5_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			Eq_n a5_n = (int64) tLoc01A4;
			if (a5_n != 0x00)
			{
				a5_n.u0 = (int64) vLoc0188.dw00A0;
				a4_n.u0 = 111;
				if (a5_n > 111)
					goto l00000000000157A0;
				word64 a5_n;
				gp = fn000000000001654C(gp, (int64) (0x80 - (word32) a5_n), (char *) &vLoc0188 + 96, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			else
			{
l00000000000157A0:
				word64 a5_n;
				gp = fn000000000001654C(gp, (char *) &vLoc0188 + 96, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
l00000000000157BC:
			Eq_n a5_n = vLoc0188.t0040;
			if (a5_n == 0x00)
			{
				a5_n = vLoc0188.t0050;
				if (a5_n == 0x00)
				{
					a5_n = vLoc0188.t0058;
					if (a5_n == 0x00)
					{
l00000000000153DC:
						if (a5_n != gp->tFFFFF870)
							__stack_chk_fail();
						else
							return;
					}
				}
			}
			putchar(0x0A);
			char * a3_n = vLoc0188.ptr0048;
			if (a3_n != null)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			char * a3_n = vLoc0188.ptr0040;
			if (a3_n != null)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			char * a3_n = vLoc0188.ptr0050;
			if (a3_n != null)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			char * a3_n = vLoc0188.ptr0058;
			if (a3_n != null)
			{
				word64 a6_n;
				word64 a4_n;
				word64 a5_n;
				word64 a7_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n);
			}
			goto l00000000000153DC;
		}
	} while (a0_n > (char *) 118);
	<anonymous> * a5_n = (int64) (a0_n << 0x20 >> 0x1E)->dw102A0;
	word64 a6_n;
	word64 t1_n;
	word64 t3_n;
	word64 a7_n;
	a5_n();
}

// 0000000000015EB8: void fn0000000000015EB8(Register (ptr64 Eq_n) a0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void fn0000000000015EB8(void (* a0)(), word32 dwArg00, char * ptrArg08)
{
	Eq_n fp;
	word64 qwArg00;
	__libc_start_main(&g_t15180, (int32) qwArg00, &ptrArg08, &g_t182E8, &g_t18378, a0, fp & -16);
}

// 0000000000015EF0: void fn0000000000015EF0()
// Called from:
//      fn0000000000015F64
void fn0000000000015EF0()
{
	if (true || true)
		return;
	word64 t1_n;
	word64 ra_n;
	null();
}

// 0000000000015F24: void fn0000000000015F24()
// Called from:
//      fn0000000000015F94
void fn0000000000015F24()
{
	if (true || true)
		return;
	word64 t1_n;
	null();
}

// 0000000000015F64: void fn0000000000015F64(Register (ptr64 Eq_n) gp)
void fn0000000000015F64(struct Eq_n * gp)
{
	if ((word64) gp->bFFFFF894 == 0x00)
	{
		fn0000000000015EF0();
		gp->b0894 = 0x01;
	}
}

// 0000000000015F94: void fn0000000000015F94(Register word64 ra)
void fn0000000000015F94(word64 ra)
{
	if (g_qw19E28 != 0x00 && false)
	{
		null();
		fn0000000000015F24();
	}
	else
		fn0000000000015F24();
}

// 0000000000015FCC: void fn0000000000015FCC(Register (ptr64 Eq_n) gp, Register int64 a0)
// Called from:
//      fn0000000000015180
void fn0000000000015FCC(struct Eq_n * gp, int64 a0)
{
	FILE * a3_n = gp->ptrFFFFF880;
	if (a0 != 0x00)
	{
		fwrite(&g_v10BE0, (size_t) 1, (size_t) 26, a3_n);
		fwrite(&g_v10C00, (size_t) 1, (size_t) 54, gp->ptrFFFFF880);
		fwrite(&g_v10C38, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v10C88, (size_t) 1, (size_t) 62, gp->ptrFFFFF880);
		fwrite(&g_v10CC8, (size_t) 1, (size_t) 79, gp->ptrFFFFF880);
		fwrite(&g_v10D18, (size_t) 1, (size_t) 79, gp->ptrFFFFF880);
		fwrite(&g_v10D68, (size_t) 1, (size_t) 42, gp->ptrFFFFF880);
		fwrite(&g_v10D98, (size_t) 1, (size_t) 76, gp->ptrFFFFF880);
		fwrite(&g_v10DE8, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v10E38, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fputc();
		fwrite(&g_v10E88, (size_t) 1, (size_t) 23, gp->ptrFFFFF880);
		fwrite(&g_v10EA0, (size_t) 1, (size_t) 71, gp->ptrFFFFF880);
		fwrite(&g_v10EE8, (size_t) 1, (size_t) 57, gp->ptrFFFFF880);
		fwrite(&g_v10F28, (size_t) 1, (size_t) 58, gp->ptrFFFFF880);
		fwrite(&g_v10F68, (size_t) 1, (size_t) 57, gp->ptrFFFFF880);
		fwrite(&g_v10FA8, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v10FF8, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v11048, (size_t) 1, (size_t) 77, gp->ptrFFFFF880);
		fwrite(&g_v11098, (size_t) 1, (size_t) 46, gp->ptrFFFFF880);
		fwrite(&g_v110C8, (size_t) 1, (size_t) 72, gp->ptrFFFFF880);
		fwrite(&g_v11118, (size_t) 1, (size_t) 45, gp->ptrFFFFF880);
		fwrite(&g_v11148, (size_t) 1, (size_t) 67, gp->ptrFFFFF880);
		fwrite(&g_v11190, (size_t) 1, (size_t) 64, gp->ptrFFFFF880);
		fwrite(&g_v111D8, (size_t) 1, (size_t) 72, gp->ptrFFFFF880);
		fwrite(&g_v11228, (size_t) 1, (size_t) 46, gp->ptrFFFFF880);
		fputc();
		fwrite(&g_v11258, (size_t) 1, (size_t) 0x0F, gp->ptrFFFFF880);
		fwrite(&g_v11268, (size_t) 1, (size_t) 87, gp->ptrFFFFF880);
		fwrite(&g_v112C0, (size_t) 1, (size_t) 60, gp->ptrFFFFF880);
		fwrite(&g_v11300, (size_t) 1, (size_t) 0x0044, gp->ptrFFFFF880);
		fwrite(&g_v11348, (size_t) 1, (size_t) 58, gp->ptrFFFFF880);
		fwrite(&g_v11388, (size_t) 1, (size_t) 57, gp->ptrFFFFF880);
		fwrite(&g_v113C8, (size_t) 1, (size_t) 62, gp->ptrFFFFF880);
	}
	else
	{
		fwrite(&g_v11408, (size_t) 1, (size_t) 77, a3_n);
		fwrite(&g_v11458, (size_t) 1, (size_t) 62, gp->ptrFFFFF880);
		fwrite(&g_v11498, (size_t) 1, (size_t) 65, gp->ptrFFFFF880);
		fwrite(&g_v114E0, (size_t) 1, (size_t) 76, gp->ptrFFFFF880);
		fwrite(&g_v11530, (size_t) 1, (size_t) 65, gp->ptrFFFFF880);
		fwrite(&g_v11578, (size_t) 1, (size_t) 41, gp->ptrFFFFF880);
		fwrite(&g_v115A8, (size_t) 1, (size_t) 30, gp->ptrFFFFF880);
	}
}

// 00000000000163B0: Register (ptr64 char) fn00000000000163B0(Register (ptr64 Eq_n) gp)
// Called from:
//      fn00000000000175BC
char * fn00000000000163B0(struct Eq_n * gp)
{
	ptr64 fp;
	char bLocE8;
	Eq_n a5_n = gp->tFFFFF870;
	__sprintf_chk(&bLocE8, 1, (size_t) 0x0080, "%.2x", 0x00);
	int64 s0_n = 1;
	struct Eq_n * s1_n = fp + -0x00E6;
	if (true)
	{
		do
		{
			__sprintf_chk(s1_n, 1, (size_t) 0x0080, "%.2x", 0x00);
			struct Eq_n * a4_n = s1_n + 1;
			if ((s0_n & 1) != 0x00)
			{
				if (s0_n == 0x0F)
				{
					s1_n = a4_n;
					break;
				}
				s1_n[1] = (struct Eq_n) 0x3A;
				s1_n = &s1_n->b0002 + 1;
			}
			else
				s1_n = a4_n;
			s0_n = (int64) ((word32) s0_n + 1);
		} while (s0_n != 16);
	}
	s1_n->b0000 = 0x00;
	char * a0_n = __strdup(&bLocE8);
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000164D0: Register (ptr64 void) fn00000000000164D0(Register (ptr64 void) a0, Register Eq_n a1)
// Called from:
//      fn0000000000015180
void * fn00000000000164D0(void * a0, Eq_n a1)
{
	void * a0_n;
	Eq_n a0_n = (uint64) open("/dev/urandom", 0);
	if (a0_n >= 0x00)
	{
		uint64 a0_n = (uint64) read((int32) a0_n, a0, (size_t) a1);
		close((int32) a0_n);
		a0_n = (int64) (0x00 - (word32) ((int64) ((word32) (a0_n - a1)) != 0x00));
	}
	else
		a0_n = (void *) -1;
	return a0_n;
}

// 000000000001654C: Register (ptr64 Eq_n) fn000000000001654C(Register (ptr64 Eq_n) gp, Register (ptr64 char) a3, Register Eq_n a4, Register Eq_n a5, Register word64 a6, Register word64 a7, Register out Eq_n a4Out, Register out Eq_n a5Out, Register out ptr64 a6Out, Register out ptr64 a7Out)
// Called from:
//      fn0000000000015180
struct Eq_n * fn000000000001654C(struct Eq_n * gp, char * a3, Eq_n a4, Eq_n a5, word64 a6, word64 a7, union Eq_n & a4Out, union Eq_n & a5Out, ptr64 & a6Out, ptr64 & a7Out)
{
	ptr64 fp;
	Eq_n t3_n = gp->tFFFFF870;
	__vasprintf_chk(fp + -112, 1, fp + -40, fp + -40, a3, a4, a5, a6, a7);
	if (a0_n >= 0x00)
	{
		fputs(s2_n, gp_n->ptrFFFFF888);
		if ((int64) gp_n->dwFFFFF810 != 0x00)
			fputs(s3_n, gp_n->ptrFFFFF888);
		fputs(null, gp_n->ptrFFFFF888);
		if ((int64) gp_n->dwFFFFF810 != 0x00)
			fwrite(&g_v115E0, (size_t) 1, (size_t) 4, gp_n->ptrFFFFF888);
		free(null);
	}
	Eq_n a5_n = gp_n->tFFFFF870;
	if (t3_n != a5_n)
		__stack_chk_fail();
	else
	{
		a4Out = t3_n;
		a5Out = a5_n;
		a6Out = a6_n;
		a7Out = a7_n;
		return gp_n;
	}
}

// 0000000000016630: Register (ptr64 char) fn0000000000016630(Register (ptr64 Eq_n) gp, Register (ptr64 char) a0, Register (ptr64 word32) a1)
// Called from:
//      fn00000000000166F4
char * fn0000000000016630(struct Eq_n * gp, char * a0, word32 * a1)
{
	char * a5_n;
	Eq_n a5_n = gp->tFFFFF870;
	int32 * a0_n = __errno_location();
	*a0_n = 0x00;
	uint64 a0_n = (uint64) strtol(a0);
	if (false && (a0 != null && (word64) null == 0x00))
	{
		a5_n = (int64) *a0_n;
		if (a5_n == null)
		{
			if (a0_n == a0_n)
				*a1 = (word32) a0_n;
			else
				a5_n = (char *) -0x0022;
			goto l0000000000016698;
		}
	}
	else
		a5_n = (int64) *a0_n;
	if (a5_n > null)
		a5_n = (int64) (0x00 - (word32) a5_n);
	else
		a5_n = (char *) -22;
l0000000000016698:
	if (a5_n == gp->tFFFFF870)
		return a5_n;
	__stack_chk_fail();
}

// 00000000000166F4: Register (ptr64 int32) fn00000000000166F4(Register (ptr64 Eq_n) gp, Register (ptr64 int32) a0, Register (ptr64 char) a1, Register int64 a2)
// Called from:
//      fn0000000000015180
int32 * fn00000000000166F4(struct Eq_n * gp, int32 * a0, char * a1, int64 a2)
{
	void vLoc40;
	int32 * a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	int64 s0_n = (int64) *a0;
	if (s0_n == 0x00 && strchr(a1, '.') != null)
	{
		if ((uint64) inet_pton(2, a1, &vLoc40) != 0x00)
		{
			word64 a4_n;
			word64 a3_n;
			int64 a0_n = fn00000000000182B4((int64) vLoc40, out a3_n, out a4_n);
			while (a0_n != 0x00)
			{
				if ((a0_n & 1) != 0x00)
				{
l0000000000016778:
					do
					{
						a0_n = (int64) ((word32) a0_n >> 1);
						s0_n = (int64) ((word32) s0_n + 1);
						if (a0_n == 0x00)
							goto l0000000000016790;
					} while ((a0_n & 1) != 0x00);
					goto l000000000001678C;
				}
				int64 a5_n = (int64) ((word32) a0_n >> 1);
				if (a5_n == 0x00)
					break;
				if ((a5_n & 1) != 0x00)
				{
					a0_n = a5_n;
					goto l0000000000016778;
				}
				a0_n = (int64) ((word32) a0_n >> 2);
			}
		}
		else
		{
l000000000001678C:
			s0_n = -1;
		}
l0000000000016790:
		vLoc40 = (void) (word32) s0_n;
	}
	else if (fn0000000000016630(gp, a1, &vLoc40) != 0x00)
		goto l00000000000167C0;
	int32 * a5_n = (int64) vLoc40;
	if (a2 != 0x00 && a5_n > (int32 *) 32)
	{
		if ((int64) *a0 == 0x00)
			*a0 = 0x01;
	}
	else
	{
		a0_n = a5_n;
		if (a5_n < null)
			goto l00000000000167C0;
		if ((int64) *a0 == 0x00)
		{
			if (a5_n > (int32 *) 32)
			{
l00000000000167C0:
				a0_n = (int32 *) -1;
				goto l00000000000167F4;
			}
l00000000000167F4:
			if (a5_n == gp->tFFFFF870)
				return a0_n;
			__stack_chk_fail();
		}
	}
	a0_n = a5_n;
	if (a5_n > (int32 *) 0x0080)
		goto l00000000000167C0;
	goto l00000000000167F4;
}

// 0000000000016830: Register (ptr64 char) fn0000000000016830(Register (ptr64 Eq_n) gp, Register (ptr64 char) a0)
// Called from:
//      fn00000000000168B8
//      fn0000000000016D74
char * fn0000000000016830(struct Eq_n * gp, char * a0)
{
	Eq_n a5_n = gp->tFFFFF870;
	word32 dwLoc20_n = 0x00;
	if (a0 != null)
	{
		word64 a3_n;
		word64 a4_n;
		dwLoc20_n = (word32) fn00000000000182B4((int64) (~0x00 << (int64) (0x20 - (word32) a0)), out a3_n, out a4_n);
	}
	char * a0_n = (int64) dwLoc20_n;
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000168B8: void fn00000000000168B8(Register (ptr64 Eq_n) gp, Register (ptr64 char) a1)
void fn00000000000168B8(struct Eq_n * gp, char * a1)
{
	fn0000000000016830(gp, a1);
}

// 00000000000168E4: Register (ptr64 char) fn00000000000168E4(Register (ptr64 Eq_n) gp, Register (ptr64 char) a0, Register (ptr64 void) a1)
// Called from:
//      fn0000000000016D74
//      fn00000000000175BC
char * fn00000000000168E4(struct Eq_n * gp, char * a0, void * a1)
{
	ptr64 fp;
	char * a0_n;
	uint64 a0_n;
	Eq_n a4_n = gp->tFFFFF870;
	if (a0 != (char *) 2)
	{
		if (a0 != (char *) 0x0A)
			goto l0000000000016910;
		memcpy(fp + -64, a1, (size_t) 16);
		a0_n = (uint64) getnameinfo(fp + -72, 28, &gp->dwFFFFF890 + 2, 0x0401, null, 0, 0);
	}
	else
		a0_n = (uint64) getnameinfo(fp + -88, 16, &gp->dwFFFFF890 + 2, 0x0401, null, 0, 0);
	if (a0_n == 0x00)
	{
		a0_n = __strdup(&gp->dwFFFFF890 + 2);
l0000000000016914:
		if (a4_n == gp->tFFFFF870)
			return a0_n;
		__stack_chk_fail();
	}
l0000000000016910:
	a0_n = null;
	goto l0000000000016914;
}

// 00000000000169D8: Register (ptr64 char) fn00000000000169D8(Register (ptr64 Eq_n) gp, Register (ptr64 char) a0, Register (ptr64 char) a1)
// Called from:
//      fn0000000000015180
char * fn00000000000169D8(struct Eq_n * gp, char * a0, char * a1)
{
	struct addrinfo * ptrLoc70;
	Eq_n tLoc68;
	char * a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	tLoc68.ai_flags = (int32) 0x00;
	tLoc68.ai_family = (word32) a0;
	tLoc68.ai_socktype = (int32) 0x00;
	tLoc68.ai_addrlen = (socklen_t) 0x00;
	tLoc68.ai_canonname = null;
	if ((uint64) getaddrinfo(a1, null, &tLoc68, &ptrLoc70) == 0x00)
	{
		struct addrinfo * s0_n = ptrLoc70;
		if (s0_n != null)
		{
			do
			{
				int64 a0_n = (int64) s0_n->ai_family;
				char * a1_n = s0_n->ai_canonname;
				if (a0_n == 2)
				{
					if (inet_ntop((int32) a0_n, a1_n + 4, &gp->dwFFFFF890 + 260, 64) != null)
						goto l0000000000016A88;
				}
				else if (inet_ntop((int32) a0_n, a1_n + 8, &gp->dwFFFFF890 + 260, 64) != null)
				{
l0000000000016A88:
					freeaddrinfo(ptrLoc70);
					a0_n = __strdup(&gp->dwFFFFF890 + 260);
					goto l0000000000016AAC;
				}
				s0_n = s0_n->ptr0028;
			} while (s0_n != null);
			s0_n = (struct addrinfo *) ptrLoc70;
		}
		freeaddrinfo(s0_n);
		a0_n = null;
	}
	else
		a0_n = null;
l0000000000016AAC:
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 0000000000016B38: void fn0000000000016B38(Register Eq_n a0)
void fn0000000000016B38(Eq_n a0)
{
	if (a0 > 0x007F)
		;
}

// 0000000000016B68: Register int64 fn0000000000016B68(Register int64 a0)
// Called from:
//      fn0000000000016D74
int64 fn0000000000016B68(int64 a0)
{
	int64 a4_n;
	word64 a3_n;
	word64 a4_n;
	int64 a0_n = fn00000000000182B4(a0, out a3_n, out a4_n);
	int64 a5_n = (int64) ((word32) a0_n >> 24);
	if (a5_n == 0x00)
	{
		a4_n = 71144;
		return a4_n;
	}
	if (a5_n == 0x0A)
		return 71176;
	int64 a4_n = (int64) ((word32) a0_n >> 16);
	if (a5_n != 100)
	{
		if (a5_n == 0x007F)
		{
			a4_n = 0x00011630;
			return a4_n;
		}
		int64 a2_n = (int64) ((word32) a0_n >> 8);
		if (a5_n != 0x00A9)
		{
			if (a5_n == 0x00AC)
			{
				if ((a4_n & 0x00F0) == 16)
					return 71176;
			}
			else if (a5_n == 0x00C0)
			{
				if (((a4_n | a2_n) & 0x00FF) == 0x00)
				{
					a4_n = 0x00011660;
					return a4_n;
				}
				if ((a4_n & 0x00FF) != 2)
				{
					if ((a4_n & 0x00FF) != 0x0033)
					{
						if ((a4_n & 0x00FF) == 88)
						{
							if ((a2_n & 0x00FF) == 99)
							{
								a4_n = 0x000116E0;
								return a4_n;
							}
l0000000000016CB8:
							if ((a5_n & 0x00F0) != 0x00F0)
								a4_n = 0x00011650;
							else
								a4_n = 0x00011710;
							return a4_n;
						}
						if ((a4_n & 0x00FF) != 52)
						{
							if ((a4_n & 0x00FF) == 0x00A8)
								return 71176;
						}
						else if ((a2_n & 0x00FF) == 0x00C1)
						{
							a4_n = 0x00011708;
							return a4_n;
						}
					}
					else if ((a2_n & 0x00FF) == 100)
					{
						a4_n = 0x000116A0;
						return a4_n;
					}
				}
				else if ((a2_n & 0x00FF) == 0x00)
				{
					a4_n = 0x00011680;
					return a4_n;
				}
			}
			else if (a5_n == 0x00CB)
			{
				if ((a4_n & 0x00FF) == 0x00 && (a2_n & 0x00FF) == 113)
				{
					a4_n = 0x000116C0;
					return a4_n;
				}
			}
			else
			{
				if (a5_n == 0x00FF)
				{
					a4_n = 0x00011710;
					if ((a4_n & 0x00FF) == a5_n)
					{
						a4_n = 0x00011710;
						if ((a2_n & 0x00FF) == 0x00FF && (a0_n & 0x00FF) == (a2_n & 0x00FF))
							a4_n = 0x00011720;
					}
					return a4_n;
				}
				if (a5_n == 0x00C6)
				{
					a4_n = 0x00011650;
					if ((a4_n & 0x00FE) == 18)
						a4_n = 0x00011738;
					return a4_n;
				}
			}
		}
		else if ((a4_n & 0x00FF) == 0x00FE)
		{
			a4_n = 0x00011640;
			return a4_n;
		}
	}
	else if ((a4_n & 0x00C0) == 64)
	{
		a4_n = 0x00011618;
		return a4_n;
	}
	if ((int64) ((word32) a5_n + -224) <= 0x0F)
	{
		a4_n = 0x00011748;
		return a4_n;
	}
	goto l0000000000016CB8;
}

// 0000000000016D74: Register (ptr64 char) fn0000000000016D74(Register word64 ra, Register (ptr64 Eq_n) gp, Register (ptr64 char) a0, Register (ptr64 char) a1, Register (ptr64 Eq_n) a2, Register Eq_n a3, Register out Eq_n a4Out)
// Called from:
//      fn0000000000015180
char * fn0000000000016D74(word64 ra, struct Eq_n * gp, char * a0, char * a1, struct Eq_n * a2, Eq_n a3, union Eq_n & a4Out)
{
	ptr64 fp;
	void vLoc01B8;
	char * ptrLoc0190;
	char bLoc0188;
	char bLoc0158;
	char * a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	memset(a2, 0, (size_t) 200);
	struct Eq_n * s6_n = a2;
	char * s5_n = a1;
	if ((uint64) inet_pton(2, a0, &vLoc01B8) <= 0x00)
	{
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000016E20;
		__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: bad IPv4 address: %s\n", 0x00);
		a0_n = (char *) -1;
l0000000000016E24:
		if (a5_n != gp->tFFFFF870)
			__stack_chk_fail();
		else
		{
			a4Out = a5_n;
			return a0_n;
		}
	}
	FILE * a0_n;
	if (a1 >= null)
	{
		ptrLoc0190 = a0;
		char * a0_n = a0;
		int64 s0_n = 3;
		do
		{
			char * a0_n = strchr(a0_n, '.');
			ptrLoc0190 = a0_n;
			if (a0_n == null)
			{
				do
				{
					if ((uint64) __asprintf_chk(&ptrLoc0190, 1, "%s.0", 0x00) == -1)
					{
						a0_n = gp->ptrFFFFF880;
						goto l00000000000172C4;
					}
					s0_n = (int64) ((word32) s0_n + -1);
				} while (s0_n != 0x00);
				break;
			}
			ptrLoc0190 = a0_n + 1;
			a0_n = a0_n + 1;
			s0_n = (int64) ((word32) s0_n + -1);
		} while (s0_n != 0x00);
		if (a1 > (char *) 32)
		{
			if ((int64) gp->dwFFFFF814 == 0x00)
			{
				__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: bad IPv4 prefix %d\n", 0x00);
				a0_n = (char *) -1;
				goto l0000000000016E24;
			}
			goto l0000000000016E20;
		}
	}
	else
	{
		s5_n = (char *) 32;
		if (a3 << 0x2D < 0x00)
		{
			word64 a4_n;
			word64 a3_n;
			int64 a0_n = fn00000000000182B4((int64) vLoc01B8, out a3_n, out a4_n);
			s5_n = (char *) 8;
			int64 a5_n = (int64) ((word32) a0_n >> 24);
			if (a0_n < 0x00)
			{
				s5_n = (char *) 24;
				if ((int64) ((word32) a5_n + -0x0080) <= 63)
					s5_n = (char *) 16;
			}
		}
	}
	if (inet_ntop(2, &vLoc01B8, &bLoc0188, 47) != null)
	{
		a2->ptr0000 = __strdup(&bLoc0188);
		word32 dwLoc01B0_n = (word32) fn0000000000016830(gp, s5_n);
		bLoc0188 = (char) 0x00;
		if (inet_ntop(2, fp + -432, &bLoc0188, 16) == null)
		{
			a0_n = gp->ptrFFFFF880;
			goto l00000000000172C4;
		}
		a2->ptr0030 = __strdup(&bLoc0188);
		int64 s0_n = (int64) vLoc01B8;
		a2->dw00A0 = (word32) s5_n;
		word32 dwLoc01A0_n = (word32) (~fn0000000000016830(gp, s5_n) | s0_n);
		bLoc0188 = (char) 0x00;
		if (inet_ntop(2, fp + -416, &bLoc0188, 16) == null)
		{
			a0_n = gp->ptrFFFFF880;
			goto l00000000000172C4;
		}
		a2->ptr0028 = __strdup(&bLoc0188);
		int64 s0_n = fn0000000000016830(gp, s5_n) & (int64) vLoc01B8;
		a2->qw0018 = fn0000000000017F04(gp, s0_n, s5_n, s0_n, (int64) dwLoc01A0_n);
		bLoc0188 = (char) 0x00;
		ui32 dwLoc01A8_n = (word32) s0_n;
		if (inet_ntop(2, fp + -424, &bLoc0188, 16) == null)
		{
			a0_n = gp->ptrFFFFF880;
			goto l00000000000172C4;
		}
		word64 a5_n;
		char * a0_n = __strdup(&bLoc0188);
		a2->ptr0020 = a0_n;
		int64 s0_n = (int64) dwLoc01A8_n;
		a2->qw00B8 = fn0000000000016B68(s0_n);
		word64 a3_n;
		word64 a4_n;
		int64 a0_n = fn00000000000182B4(s0_n, out a3_n, out a4_n);
		int64 a5_n = (int64) ((word32) a0_n >> 24);
		if (a0_n < 0x00)
		{
			if ((int64) ((word32) a5_n + -0x0080) > 63)
			{
				if ((int64) ((word32) a5_n + -0x00C0) > 31)
				{
					if ((int64) ((word32) a5_n + -224) <= 0x0E)
						a5_n = 0x00011770;
					else
						a5_n = 0x00011778;
				}
				else
					a5_n = 0x00011768;
			}
			else
				a5_n = 0x00011760;
		}
		else
			a5_n = 0x00011758;
		struct Eq_n * a5_n;
		a2->qw00C0 = a5_n;
		if (s5_n == (char *) 32)
		{
			a2->ptr00A8 = a0_n;
			a2->ptr00B0 = a0_n;
			a5_n = &g_t11780;
			goto l000000000001716C;
		}
		if (s5_n != (char *) 31)
		{
			if (inet_ntop(2, fp + -408, &bLoc0188, 16) != null)
			{
				a2->ptr00A8 = __strdup(&bLoc0188);
				word64 a4_n;
				word64 a3_n;
				word64 a3_n;
				word64 a4_n;
				ptrLoc0190 = (char *) (word32) fn00000000000182B4((int64) ((word32) fn00000000000182B4(~(int64) dwLoc01B0_n | (int64) dwLoc01A8_n, out a3_n, out a4_n) + -1), out a3_n, out a4_n);
				if (inet_ntop(2, &ptrLoc0190, &bLoc0188, 47) != null)
				{
					a2->ptr00B0 = __strdup(&bLoc0188);
					__snprintf_chk(&a2->b0060, (size_t) 64, 1, (size_t) 64, "%u", 0x00);
					goto l000000000001717C;
				}
				goto l0000000000017074;
			}
l00000000000172E8:
			a0_n = gp->ptrFFFFF880;
l00000000000172C4:
			__fprintf_chk(a0_n, 1, "Memory allocation failure line %d\n", 0x00);
			abort();
		}
		if (inet_ntop(2, fp + -408, &bLoc0188, 16) == null)
			goto l00000000000172E8;
		a2->ptr00A8 = __strdup(&bLoc0188);
		ptrLoc0190 = (char *) ((word32) ~(int64) dwLoc01B0_n | dwLoc01A8_n);
		if (inet_ntop(2, &ptrLoc0190, &bLoc0188, 47) != null)
		{
			a2->ptr00B0 = __strdup(&bLoc0188);
			a5_n = &g_t12660;
l000000000001716C:
			a2->b0060 = a5_n->b0000;
			a2->b0061 = a5_n->b0001;
l000000000001717C:
			if (a3 << 0x31 < 0x00)
				gp = fn0000000000017B40(ra, gp, (int64) vLoc01B8, &a2->qw0038 + 1, &a2->qw0038 + 2, &a2->qw0038 + 3, &a2->qw0038 + 4, s5_n, a2, out s6_n);
			if ((a3 & 1) == 0x00)
			{
l000000000001718C:
				a0_n = null;
				goto l0000000000016E24;
			}
			word64 a0_n = fn00000000000168E4(gp, (char *) 2, &vLoc01B8);
			s6_n->qw0038 = a0_n;
			if (a0_n != 0x00)
				goto l000000000001718C;
			if ((int64) gp->dwFFFFF814 == 0x00)
			{
				__sprintf_chk(&bLoc0158, 1, (size_t) 0x00FA, "ipcalc: cannot find hostname for %s", 0x00);
				herror(&bLoc0158);
				a0_n = (char *) -1;
				goto l0000000000016E24;
			}
l0000000000016E20:
			a0_n = (char *) -1;
			goto l0000000000016E24;
		}
	}
l0000000000017074:
	if ((int64) gp->dwFFFFF814 == 0x00)
		fwrite(&g_v117F8, (size_t) 1, (size_t) 43, gp->ptrFFFFF880);
	goto l0000000000016E20;
}

// 000000000001730C: Register (ptr64 char) fn000000000001730C(Register (ptr64 Eq_n) gp, Register (ptr64 char) a0, Register (ptr64 void) a1)
// Called from:
//      fn00000000000175BC
char * fn000000000001730C(struct Eq_n * gp, char * a0, void * a1)
{
	ptr64 fp;
	char bLocA8;
	char * a0_n;
	Eq_n a4_n = gp->tFFFFF870;
	if (a0 <= (char *) 0x0080)
	{
		byte * a5_n = fp + -0x00B8;
		int64 a4_n = (int64) (0x08 - (word32) a0);
		if (a0 != null)
		{
			do
			{
				if (a0 > (char *) 7)
					*a5_n = ~0x00;
				else
					*a5_n = ~0x00 << (byte) a4_n;
				a0 = (int64) ((word32) a0 + -8);
				++a5_n;
				a4_n = (int64) ((word32) a4_n + 8);
			} while (a0 > null);
		}
		if (inet_ntop(0x0A, fp + -0x00B8, &bLocA8, 0x0080) != null)
		{
			memcpy(a1, fp + -0x00B8, (size_t) 16);
			a0_n = __strdup(&bLocA8);
l000000000001739C:
			if (a4_n == gp->tFFFFF870)
				return a0_n;
			__stack_chk_fail();
		}
	}
	a0_n = null;
	goto l000000000001739C;
}

// 00000000000173D4: Register (ptr64 Eq_n) fn00000000000173D4(Register (ptr64 Eq_n) a0, Register (ptr64 char) a1)
// Called from:
//      fn00000000000175BC
struct Eq_n * fn00000000000173D4(struct Eq_n * a0, char * a1)
{
	struct Eq_n * a0_n;
	int64 s2_n = (word64) a0->b0000;
	ui64 s3_n = (word64) a0->b0001;
	if (a1 != (char *) 0x0080)
	{
		if (a1 <= (char *) 95)
			goto l0000000000017408;
	}
	else
	{
		if ((uint64) memcmp(a0, &g_v10880, (size_t) 16) == 0x00)
			return &g_t11858;
		if ((uint64) memcmp(a0, &g_v10898, (size_t) 16) == 0x00)
		{
			a0_n = &g_t11870;
			return a0_n;
		}
	}
	if ((uint64) memcmp(a0, &g_v108B0, (size_t) 0x0C) == 0x00)
		return &g_t11888;
	if ((uint64) memcmp(a0, &g_v108C0, (size_t) 0x0C) == 0x00)
		return &g_t118A0;
	if ((uint64) memcmp(a0, &g_v108D0, (size_t) 0x0C) == 0x00)
		return &g_t118B8;
l0000000000017408:
	ui64 a5_n = s2_n << 0x08 | s3_n;
	if ((a5_n & 0xFFFFE000) != 0x2000)
	{
		if ((s2_n & 0x00FE) != 252)
		{
			if ((a5_n & -64) != 65152)
			{
				if (s2_n != 0x00FF)
				{
					a0_n = &g_t11710;
					if ((a5_n & -2) == 0x00002002)
						a0_n = &g_t11918;
				}
				else
					a0_n = &g_t11748;
			}
			else
				a0_n = &g_t11900;
		}
		else
			a0_n = &g_t118E8;
	}
	else
		a0_n = &g_t118D8;
	return a0_n;
}

// 00000000000175BC: Register (ptr64 char) fn00000000000175BC(Register word64 ra, Register (ptr64 Eq_n) gp, Register (ptr64 char) s1, Register (ptr64 char) a0, Register (ptr64 char) a1, Register (ptr64 Eq_n) a2, Register Eq_n a3, Register out Eq_n a4Out)
// Called from:
//      fn0000000000015180
char * fn00000000000175BC(word64 ra, struct Eq_n * gp, char * s1, char * a0, char * a1, struct Eq_n * a2, Eq_n a3, union Eq_n & a4Out)
{
	ptr64 fp;
	void vLoc0198;
	void vLoc0178;
	char bLoc0168;
	char * a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	memset(a2, 0, (size_t) 200);
	struct Eq_n * s0_n = a2;
	char * s2_n = a1;
	Eq_n s6_n = a3;
	if ((uint64) inet_pton(0x0A, a0, &vLoc0198) <= 0x00)
	{
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000017770;
		__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: bad IPv6 address: %s\n", 0x00);
		a0_n = (char *) -1;
		goto l0000000000017774;
	}
	a2->qw0008 = fn00000000000163B0(gp);
	struct Eq_n * s3_n = &bLoc0168;
	if (inet_ntop(0x0A, &vLoc0198, &bLoc0168, 0x00FA) == null)
	{
l0000000000017768:
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000017770;
		fwrite(&g_v117F8, (size_t) 1, (size_t) 43, gp->ptrFFFFF880);
		a0_n = (char *) -1;
		goto l0000000000017774;
	}
	else
	{
		a2->ptr0000 = __strdup(&bLoc0168);
		char * s5_n = (char *) 0x0080;
		if (a1 <= (char *) 0x0080)
		{
			if (a1 >= null)
				s5_n = a1;
			else
				s2_n = (char *) 0x0080;
			a2->dw00A0 = (word32) s5_n;
			char * a0_n = fn000000000001730C(gp, s5_n, fp + -0x0188);
			a2->ptr0030 = a0_n;
			if (a0_n != null)
			{
				struct Eq_n * s8_n = &vLoc0178;
				byte * a5_n = &vLoc0198;
				byte * s9_n = fp + -0x0188;
				byte * a2_n = &vLoc0178;
				byte * a3_n = fp + -0x0188;
				do
				{
					*a2_n = *a5_n & *a3_n;
					++a5_n;
					++a3_n;
					++a2_n;
				} while (fp + -0x0188 != a5_n);
				if (inet_ntop(0x0A, &vLoc0178, &bLoc0168, 0x00FA) != null)
				{
					a2->ptr0020 = __strdup(&bLoc0168);
					a2->qw0010 = fn00000000000163B0(gp);
					a2->qw00B8 = fn00000000000173D4(&vLoc0178, s2_n);
					a2->qw0018 = fn0000000000018118(gp, &vLoc0178, s5_n);
					if (s2_n == (char *) 0x0080)
					{
						char * a5_n = a2->ptr0020;
						a2->ptr00A8 = a5_n;
						a2->ptr00B0 = a5_n;
						goto l0000000000017728;
					}
					a2->ptr00A8 = __strdup(&bLoc0168);
					do
					{
						++s8_n;
						s8_n[0x0FFF] = (struct Eq_n) ((byte) ~(word64) *s9_n | s8_n->b0000);
						++s9_n;
					} while (&bLoc0168 != s8_n);
					if (inet_ntop(0x0A, &vLoc0178, &bLoc0168, 0x00FA) != null)
					{
						a2->ptr00B0 = __strdup(&bLoc0168);
						if ((int64) (0x80 - (word32) s2_n) == 0x0080)
							goto l0000000000017740;
l0000000000017740:
						snprintf(&a2->b0060, (size_t) 64, "%s", 0x00);
						if (a3 << 0x31 < 0x00)
							gp = fn0000000000017D10(ra, gp, s1, &vLoc0198, &a2->qw0038 + 1, &a2->qw0038 + 2, &a2->qw0038 + 3, &a2->qw0038 + 4, a3, fp + -0x0188, out s0_n, out s3_n, out s6_n);
						if ((s6_n & 1) == 0x00)
						{
l0000000000017760:
							a0_n = null;
							goto l0000000000017774;
						}
						word64 a0_n = fn00000000000168E4(gp, (char *) 0x0A, &vLoc0198);
						s0_n->qw0038 = a0_n;
						if (a0_n != 0x00)
							goto l0000000000017760;
						if ((int64) gp->dwFFFFF814 == 0x00)
						{
							__sprintf_chk(s3_n, 1, (size_t) 0x00FA, "ipcalc: cannot find hostname for %s", 0x00);
							herror(s3_n);
						}
l0000000000017770:
						a0_n = (char *) -1;
						goto l0000000000017774;
					}
				}
				goto l0000000000017768;
			}
			if ((int64) gp->dwFFFFF814 != 0x00)
				goto l0000000000017770;
			__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: error converting IPv6 prefix: %d\n", 0x00);
			a0_n = (char *) -1;
		}
		else
		{
			if ((int64) gp->dwFFFFF814 != 0x00)
				goto l0000000000017770;
			__fprintf_chk(gp->ptrFFFFF880, 1, "ipcalc: bad IPv6 prefix: %d\n", 0x00);
			a0_n = (char *) -1;
		}
l0000000000017774:
		if (a5_n != gp->tFFFFF870)
			__stack_chk_fail();
		else
		{
			a4Out = a5_n;
			return a0_n;
		}
	}
}

// 0000000000017924: Register int64 fn0000000000017924(Register (ptr64 Eq_n) gp, Register out (ptr64 Eq_n) a1Out, Register out Eq_n a2Out, Register out Eq_n a3Out, Register out Eq_n a4Out, Register out Eq_n a6Out)
// Called from:
//      fn0000000000015180
//      fn0000000000017B40
//      fn0000000000017D10
int64 fn0000000000017924(struct Eq_n * gp, FILE & a1Out, union Eq_n & a2Out, union Eq_n & a3Out, union Eq_n & a4Out, union Eq_n & a6Out)
{
	FILE * a1;
	Eq_n a2;
	Eq_n a3;
	Eq_n a4;
	Eq_n a6;
	int64 s0_n;
	if (gp->qwFFFFF820 == 0x00)
	{
		s0_n = (int64) gp->dwFFFFF818;
		if (s0_n == 0x00)
		{
			void * a0_n = dlopen("/usr/lib64/libGeoIP.so.1", 1);
			gp->ptr0820 = a0_n;
			if (a0_n != null)
			{
				gp->ptr0868 = dlsym(a0_n, "_GeoIP_setup_dbfilename");
				void * a0_n = dlsym(a0_n, "GeoIP_open_type");
				gp->ptr0860 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_country_name_by_id");
				gp->ptr0858 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_delete");
				gp->ptr0848 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_record_by_ipnum");
				gp->ptr0840 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_id_by_ipnum");
				gp->ptr0838 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_id_by_ipnum_v6");
				gp->ptr0830 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_record_by_ipnum_v6");
				gp->ptr0828 = a0_n;
				gp->ptr0850 = dlsym(a0_n, "GeoIP_code_by_id");
				a1 = (FILE *) g_str12B38;
				if (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && a0_n != null))))))
					gp->dw0818 = 0x00;
				else
				{
					a6 = g_t12B50;
					word64 a0_n = g_qw12B58;
					a1 = g_ptr12B60;
					a2 = g_t12B68;
					a3 = g_t12B70;
					a4.u0 = (int64) g_dw12B78;
					gp->tFFFFFCE0 = a6;
					gp->qwFFFFFCE8 = a0_n;
					gp->ptrFFFFFCF0 = a1;
					gp->tFFFFFCF8 = a2;
					gp->tFFFFFD00 = a3;
					gp->dwFFFFFD08 = (word32) a4;
					gp->dw0818 = ~0x00;
					s0_n = -1;
				}
			}
			else
			{
				__snprintf_chk(&gp->tFFFFFCE0, (size_t) 0x0100, 1, (size_t) 0x0100, "ipcalc: could not open %s\n", 0x00);
				gp->dw0818 = ~0x00;
				a3.u0 = 0x0100;
				a4.u0 = 76376;
				a2.u0 = 1;
				a1 = (FILE *) 0x0100;
				s0_n = -1;
			}
l0000000000017970:
			a1Out = a1;
			a2Out = a2;
			a3Out = a3;
			a4Out = a4;
			a6Out = a6;
			return s0_n;
		}
	}
	if ((int64) gp->dwFFFFF814 == 0x00 && (word64) gp->tFFFFFCE0 != 0x00)
	{
		a1 = gp->ptrFFFFF880;
		fputs(&gp->tFFFFFCE0, a1);
	}
	s0_n = (int64) gp->dwFFFFF818;
	goto l0000000000017970;
}

// 0000000000017B40: Register (ptr64 Eq_n) fn0000000000017B40(Register word64 ra, Register (ptr64 Eq_n) gp, Register int64 a0, Register ptr64 a1, Register ptr64 a2, Register ptr64 a3, Register ptr64 a4, Register (ptr64 char) s5, Register (ptr64 Eq_n) s6, Register out (ptr64 Eq_n) s6Out)
// Called from:
//      fn0000000000016D74
struct Eq_n * fn0000000000017B40(word64 ra, struct Eq_n * gp, int64 a0, ptr64 a1, ptr64 a2, ptr64 a3, ptr64 a4, char * s5, struct Eq_n * s6, struct Eq_n & s6Out)
{
	word64 a1_n;
	word64 a2_n;
	word64 a3_n;
	word64 a4_n;
	word64 a6_n;
	if (fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) == 0x00)
	{
		word64 a3_n;
		word64 a4_n;
		int64 a0_n = fn00000000000182B4(a0, out a3_n, out a4_n);
		word64 s0_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		gp->ptrFFFFF868();
		struct Eq_n * a0_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * gp_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s0_n = a0_n;
		if (a0_n != null)
		{
			<anonymous> * a5_n = gp_n->ptrFFFFF838;
			a0_n->dw004C = 0x01;
			word64 s0_n;
			word64 s1_n;
			word64 s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s7_n;
			int64 a0_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			a5_n();
			if (a0_n < 0x00)
				goto l0000000000017B84;
			word64 s0_n;
			word64 s1_n;
			word64 s2_n;
			char ** s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s6_n;
			word64 s7_n;
			char * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF858();
			if (a0_n != null)
				*s3_n = (char **) __strdup(a0_n);
			word64 s0_n;
			word64 s1_n;
			char ** s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s6_n;
			word64 s7_n;
			char * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF850();
			if (a0_n != null)
				*s2_n = (char **) __strdup(a0_n);
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF848();
		}
		word64 a4_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		word64 s7_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		struct Eq_n * a0_n;
		word64 a2_n;
		word64 a3_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s0_n = a0_n;
		if (a0_n == null)
		{
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF860();
			s0_n = a0_n;
			if (a0_n == null)
				goto l0000000000017B84;
		}
		<anonymous> * a5_n = gp->ptrFFFFF840;
		s0_n->dw004C = 0x01;
		word64 sp_n;
		word64 s0_n;
		char ** s1_n;
		char ** s4_n;
		struct Eq_n * a0_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		int64 a1_n;
		word64 a2_n;
		a5_n();
		if (a0_n != null)
		{
			char * a0_n = a0_n->ptr0020;
			if (a0_n != null)
				*s1_n = (char **) __strdup(a0_n);
			if ((word64) (a0_n->r0034 == 0.0F) == 0x00)
			{
				__asprintf_chk(s4_n, 1, "%f,%f", 0x00);
				a2_n = 76672;
				a1_n = 1;
			}
		}
		struct Eq_n * s6_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		gp_n->ptrFFFFF848();
		s6Out = s6_n;
		return gp_n;
	}
	else
	{
l0000000000017B84:
		s6Out = s6;
		return gp;
	}
}

// 0000000000017D10: Register (ptr64 Eq_n) fn0000000000017D10(Register word64 ra, Register (ptr64 Eq_n) gp, Register (ptr64 char) s1, Register (ptr64 void) a0, Register ptr64 a1, Register ptr64 a2, Register ptr64 a3, Register ptr64 a4, Register Eq_n s6, Register ptr64 s7, Register out (ptr64 void) s0Out, Register out (ptr64 char) s3Out, Register out Eq_n s6Out)
// Called from:
//      fn00000000000175BC
struct Eq_n * fn0000000000017D10(word64 ra, struct Eq_n * gp, char * s1, void * a0, ptr64 a1, ptr64 a2, ptr64 a3, ptr64 a4, Eq_n s6, ptr64 s7, void & s0Out, char & s3Out, union Eq_n & s6Out)
{
	void * s0;
	char * s3;
	word64 a1_n;
	word64 a2_n;
	word64 a3_n;
	word64 a4_n;
	word64 a6_n;
	word64 a0_n = fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n);
	if (a0_n == 0x00)
	{
		word64 s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s1_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		gp->ptrFFFFF868();
		struct Eq_n * a0_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * gp_n;
		struct Eq_n * s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s1_n = a0_n;
		if (a0_n != null)
		{
			word64 a4_n = (word64) s0_n->dw0004;
			word64 a5_n = (word64) s0_n->dw000C;
			word64 a1_n = (word64) s0_n->dw0000;
			word64 a2_n = (word64) s0_n->dw0008;
			<anonymous> * a3_n = gp_n->ptrFFFFF830;
			a0_n->dw004C = 0x01;
			word64 s0_n;
			word64 s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			int64 a0_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			a3_n();
			if (a0_n < 0x00)
				goto l0000000000017D54;
			word64 s0_n;
			word64 s2_n;
			word64 s3_n;
			char ** s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			word64 s7_n;
			char * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF858();
			if (a0_n != null)
				*s4_n = (char **) __strdup(a0_n);
			word64 s0_n;
			word64 s2_n;
			char ** s3_n;
			word64 s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			word64 s7_n;
			char * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF850();
			if (a0_n != null)
				*s3_n = (char **) __strdup(a0_n);
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF848();
		}
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s6_n;
		word64 s7_n;
		struct Eq_n * a0_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s1_n = a0_n;
		if (a0_n == null)
		{
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF860();
			s1_n = a0_n;
			if (a0_n == null)
				goto l0000000000017D54;
		}
		word64 a4_n = (word64) s0_n->dw0004;
		word64 a5_n = (word64) s0_n->dw000C;
		word64 a1_n = (word64) s0_n->dw0000;
		word64 a2_n = (word64) s0_n->dw0008;
		<anonymous> * a3_n = gp->ptrFFFFF828;
		s1_n->dw004C = 0x01;
		word64 sp_n;
		char ** s2_n;
		char ** s5_n;
		word64 s1_n;
		struct Eq_n * a0_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		int64 a1_n;
		word64 a2_n;
		a3_n();
		if (a0_n != null)
		{
			char * a0_n = a0_n->ptr0020;
			if (a0_n != null)
				*s2_n = (char **) __strdup(a0_n);
			if ((word64) (a0_n->r0034 == 0.0F) == 0x00)
			{
				__asprintf_chk(s5_n, 1, "%f,%f", 0x00);
				a2_n = 76672;
				a1_n = 1;
			}
		}
		void * s0_n;
		char * s3_n;
		Eq_n s6_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		gp_n->ptrFFFFF848();
		s0Out = s0_n;
		s3Out = s3_n;
		s6Out = s6_n;
		return gp_n;
	}
	else
	{
l0000000000017D54:
		s0Out = s0;
		s3Out = s3;
		s6Out = s6;
		return gp;
	}
}

// 0000000000017F04: Register int64 fn0000000000017F04(Register (ptr64 Eq_n) gp, Register int64 a0, Register (ptr64 char) a1, Register int64 a2, Register int64 a3)
// Called from:
//      fn0000000000016D74
int64 fn0000000000017F04(struct Eq_n * gp, int64 a0, char * a1, int64 a2, int64 a3)
{
	char * ptrLoc50;
	int64 a0_n;
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	ptrLoc50 = 0x00;
	word64 a3_n;
	word64 a4_n;
	fn00000000000182B4(a0, out a3_n, out a4_n);
	if (a1 != (char *) 32)
	{
		if (a1 != (char *) 24)
		{
			if (a1 != (char *) 16)
			{
				if (a1 != (char *) 8)
				{
					if (a1 <= (char *) 24)
					{
						if (a1 <= (char *) 16)
						{
							if (a1 <= (char *) 8)
								goto l0000000000017F84;
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a2, out a3_n, out a4_n);
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a3, out a3_n, out a4_n);
							a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.in-addr.arpa.", 0x00);
						}
						else
						{
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a2, out a3_n, out a4_n);
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a3, out a3_n, out a4_n);
							a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.%u.in-addr.arpa.", 0x00);
						}
					}
					else
					{
						word64 a3_n;
						word64 a4_n;
						fn00000000000182B4(a2, out a3_n, out a4_n);
						word64 a3_n;
						word64 a4_n;
						fn00000000000182B4(a3, out a3_n, out a4_n);
						a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.%u.%u.in-addr.arpa.", 0x00);
					}
				}
				else
					a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.in-addr.arpa.", 0x00);
			}
			else
				a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.in-addr.arpa.", 0x00);
		}
		else
			a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.%u.in-addr.arpa.", 0x00);
	}
	else
		a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.%u.%u.in-addr.arpa.", 0x00);
	if (a0_n != -1)
	{
		a0_n = ptrLoc50;
l0000000000017F88:
		if (a5_n == gp->tFFFFF870)
			return a0_n;
		__stack_chk_fail();
	}
l0000000000017F84:
	a0_n = 0;
	goto l0000000000017F88;
}

// 0000000000018118: Register (ptr64 char) fn0000000000018118(Register (ptr64 Eq_n) gp, Register (ptr64 char) a0, Register (ptr64 char) a1)
// Called from:
//      fn00000000000175BC
char * fn0000000000018118(struct Eq_n * gp, char * a0, char * a1)
{
	ptr64 fp;
	char bLoc0118;
	char * a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	int64 t4_n = a1 & 3;
	if ((a1 & 3) == 0x00)
	{
		int64 t5_n = (int64) ((word32) a1 >> 3);
		if ((a1 & 7) == 4)
		{
			uint64 a5_n = (word64) a0[(word64) (((word32) a1 + 4 >> 3) + -1)];
			uint64 a4_n = (a5_n >> 0x04) + 87;
			if (a5_n >> 0x04 <= 9)
				a4_n = (a5_n >> 0x04) + 48;
			bLoc0118 = (byte) a4_n;
			t4_n = 2;
		}
		if (t5_n != 0x00)
		{
			int64 a1_n = (int64) ((word32) t5_n + -1);
			int64 a4_n = t4_n;
			do
			{
				uint64 a5_n = (word64) a0[(word64) (word32) a1_n];
				int64 a3_n = (int64) ((word32) a4_n + 1);
				ui64 a6_n = (a5_n & 0x0F) + 87;
				if ((a5_n & 0x0F) <= 9)
					a6_n = (a5_n & 0x0F) + 48;
				(fp + -16 + (word64) ((word32) a4_n))->b0EF8 = (byte) a6_n;
				(fp + -16 + (word64) ((word32) a3_n))->b0EF8 = 0x2E;
				int64 a2_n = (int64) ((word32) a4_n + 2);
				int64 a3_n = (int64) ((word32) a4_n + 3);
				uint64 a6_n = (a5_n >> 0x04) + 48;
				if (a5_n >> 0x04 > 9)
					a6_n = (a5_n >> 0x04) + 87;
				(fp + -16 + (word64) ((word32) a2_n))->b0EF8 = (byte) a6_n;
				(fp + -16 + (word64) ((word32) a3_n))->b0EF8 = 0x2E;
				a1_n = (int64) ((word32) a1_n + -1);
				a4_n = (int64) ((word32) a4_n + 4);
			} while (a1_n != -1);
			t4_n = (int64) ((word32) t4_n + (int64) ((word32) t5_n << 0x02));
		}
		struct Eq_n * t4_n = &bLoc0118 + (word64) ((word32) t4_n);
		t4_n->w0004 = 29281;
		t4_n->w0000 = 28777;
		t4_n->w0006 = 24944;
		t4_n->w0002 = 11830;
		t4_n->w0008 = 0x2E;
		a0_n = __strdup(&bLoc0118);
	}
	else
		a0_n = null;
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000182B4: Register int64 fn00000000000182B4(Register int64 a0, Register out Eq_n a3Out, Register out Eq_n a4Out)
// Called from:
//      fn00000000000166F4
//      fn0000000000016830
//      fn0000000000016B68
//      fn0000000000016D74
//      fn0000000000017B40
//      fn0000000000017F04
int64 fn00000000000182B4(int64 a0, union Eq_n & a3Out, union Eq_n & a4Out)
{
	Eq_n a3_n = (int64) ((word32) a0 >> 24) | (int64) ((word32) a0 << 0x18);
	a3Out = a3_n;
	Eq_n a4_n = (int64) (((word32) a0 & 0x00FF0000) >> 0x08);
	a4Out = a4_n;
	return a3_n | a4_n | (int64) (((word32) a0 & 0xFF00) << 0x08);
}

// 00000000000182E8: void fn00000000000182E8(Register word64 ra, Register word64 a0, Register word64 a1, Register word64 a2)
void fn00000000000182E8(word64 ra, word64 a0, word64 a1, word64 a2)
{
	int64 s2_n = 106016 - 106008;
	<anonymous> ** s0_n = &g_ptr19E18;
	int64 s2_n = s2_n >> 0x03;
	if (s2_n >> 0x03 != 0x00)
	{
		word64 s5_n = a0;
		word64 s4_n = a1;
		word64 s3_n = a2;
		int64 s1_n = 0;
		do
		{
			word64 s0_n;
			word64 a5_n;
			(*s0_n)();
			s0_n = s0_n + 8;
		} while (s2_n != s1_n);
	}
}

// 0000000000018378: void fn0000000000018378()
void fn0000000000018378()
{
}

