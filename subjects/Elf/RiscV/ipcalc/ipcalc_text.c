// ipcalc_text.c
// Generated by decompiling ipcalc
// using Reko decompiler version 0.11.5.0.

#include "ipcalc.h"

// 0000000000015180: void fn0000000000015180(Register word64 ra, Register (ptr64 Eq_n) gp, Register int64 a0, Register (ptr64 (ptr64 char)) a1, Register (ptr64 char) a2, Register (ptr64 char) a3, Register (ptr64 char) a4, Register word64 a7, Register word64 s5, Register word64 s11, Register real64 fa3, Register real64 fa4)
void fn0000000000015180(word64 ra, struct Eq_n * gp, int64 a0, char ** a1, char * a2, char * a3, char * a4, word64 a7, word64 s5, word64 s11, real64 fa3, real64 fa4)
{
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	word64 qwLoc01A8;
	qwLoc01A8.dw0004 = 0x00;
	Eq_n s0_n;
	s0_n.u0 = 0;
	Eq_n a0_n;
	do
	{
		a0_n.u1 = (uint64) getopt_long((int32) a0, a1, "cr:i46bho:gmnpsv", &g_t108E0, 0);
		if (a0_n == -1)
		{
			int64 a4_n = (int64) gp->dwFFFFF890;
			Eq_n s1_n;
			Eq_n s4_n;
			if (a4_n < a0)
			{
				int64 a1_n = (int64) ((word32) a4_n + 1);
				gp->dw0890 = (word32) a1_n;
				struct Eq_n * s2_n = (struct Eq_n *) ((char *) a1 + (a4_n << 0x03));
				s1_n.u0 = s2_n->t0000.u0;
				s4_n.u0 = 0;
				if (a1_n < a0)
				{
					s4_n.u0 = s2_n->t0008.u0;
					gp->dw0890 = (word32) a4_n + 2;
				}
			}
			else
			{
				s4_n.u0 = 0;
				s1_n.u0 = 0;
			}
			if (false)
			{
				__printf_chk(1, "ipcalc %s\n", a2);
				goto l00000000000153DC;
			}
			if ((int64) qwLoc01A8.dw0004 != 0x00 && false)
			{
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				fwrite(&g_v119D8, (size_t) 1, (size_t) 46, gp->tFFFFF880.u0);
				goto l00000000000153DC;
			}
			Eq_n s2_n;
			word64 a6_n;
			if (false)
			{
				s2_n.u0 = 2;
				word64 a1_n;
				word64 a2_n;
				word64 a3_n;
				word64 a4_n;
				if (fn0000000000017924(gp, a0_n, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) != 0x00 || true)
					goto l00000000000153CC;
				s0_n.u0 = 2;
				goto l0000000000015448;
			}
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			Eq_n a5_n;
			if (fn0000000000017924(gp, a0_n, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) == 0x00 && false)
			{
l0000000000015448:
				s2_n = s0_n | 0x4000;
				if (true)
				{
					s0_n = s2_n;
					goto l0000000000015458;
				}
l00000000000153CC:
				if (false)
				{
					if ((int64) gp->dwFFFFF814 == 0x00)
						fwrite(&g_v11A08, (size_t) 1, (size_t) 37, gp->tFFFFF880.u0);
					goto l00000000000153D8;
				}
				if ((int64) qwLoc01A8.dw0004 != 0x00)
				{
					Eq_n a0_n = fn00000000000169D8(gp, 0x0A, 0);
					s1_n = a0_n;
					s0_n = s2_n;
					a5_n = a0_n;
					if (a0_n == 0x00)
						goto l0000000000015964;
					goto l0000000000015510;
				}
				if (false)
				{
					Eq_n a0_n = fn00000000000169D8(gp, 2, 0);
					s1_n = a0_n;
					if (a0_n == 0x00)
						goto l0000000000015964;
					a5_n = a0_n;
					s0_n = s2_n;
					goto l00000000000155D8;
				}
				Eq_n a0_n = fn00000000000169D8(gp, 0, 0);
				s1_n = a0_n;
				if (a0_n != 0x00)
				{
					s0_n = s2_n;
					a5_n = a0_n;
					goto l0000000000015518;
				}
l0000000000015964:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->tFFFFF880.u0, 1, "ipcalc: could not resolve %s\n", a3);
				goto l00000000000153DC;
			}
l0000000000015458:
			a5_n = a0_n;
			if (true)
			{
				if (s1_n != 0x00)
					goto l0000000000015510;
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				fwrite(&g_v11A30, (size_t) 1, (size_t) 28, gp->tFFFFF880.u0);
				fn0000000000015FCC(gp, 1);
				goto l00000000000153DC;
			}
			Eq_n a0_n = fn00000000000166F4(gp, (char *) &qwLoc01A8 + 4, 0, 1);
			Eq_n a0_n;
			if (a0_n < 0x00)
			{
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				a0_n.u0 = gp->tFFFFF880.u0;
				goto l0000000000015B8C;
			}
			int64 s1_n = (int64) qwLoc01A8.dw0004;
			char * ptrLoc01A0 = 0x00;
			Eq_n tLoc0198;
			if ((uint64) clock_gettime(2, &tLoc0198) < 0x00)
			{
l0000000000015CB0:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->tFFFFF880.u0, 1, "ipcalc: cannot generate network with prefix: %u\n", (uint32) a3);
				goto l00000000000153DC;
			}
			Eq_n tLoc0188;
			int64 qwLoc0190;
			char bLocB8;
			if (s1_n != 0x00)
			{
				tLoc0188.b0000 = (byte) qwLoc0190 & 0x01 | 252;
				if (fn00000000000164D0((char *) &tLoc0188 + 1, 0x0F) >= 0x00 && inet_ntop(0x0A, &tLoc0188, &bLocB8, 64) != null)
					goto l00000000000154DC;
				goto l0000000000015CB0;
			}
			word64 qwLocC0;
			if (fn00000000000164D0(&qwLocC0, 4) < 0x00)
				goto l0000000000015CB0;
			if (a0_n > 0x0F && (qwLoc0190 | 4) <= 1)
			{
				if ((qwLoc0190 | 4) != 1)
				{
					qwLocC0 = (word64) 0xAC;
					qwLocC0.b0001 = (byte) (qwLoc0190 >> 0x04) & 0x0F | 0x10;
				}
				else
				{
					qwLocC0 = (word64) 0xC0;
					qwLocC0.b0001 = 0xA8;
				}
			}
			else
				qwLocC0 = (word64) 0x0A;
			qwLoc01A8 = qwLocC0;
			if (inet_ntop(2, &qwLoc01A8, &bLocB8, 64) == null)
				goto l0000000000015CB0;
l00000000000154DC:
			a5_n = a0_n;
			if ((uint64) __asprintf_chk(&ptrLoc01A0, 1, "%s/%u", a3, (uint32) a4) == -1)
				goto l0000000000015CB0;
			s1_n.u1 = ptrLoc01A0;
			if (s1_n == 0x00)
				goto l0000000000015CB0;
l0000000000015510:
			Eq_n a4_n;
			char * a0_n;
			Eq_n a5_n;
			if (true)
			{
l0000000000015518:
				if (strchr(s1_n, ':') == null)
					goto l00000000000155D8;
				qwLoc01A8.dw0004 = 0x01;
				a4_n.u0 = 1;
				if (s4_n != 0x00)
					goto l000000000001553C;
				a0_n = strchr(s1_n, '/');
				a5_n = a5_n;
				if (a0_n == null)
					goto l0000000000015604;
				goto l0000000000015BB8;
			}
l00000000000155D8:
			if (s4_n != 0x00)
			{
				if ((int64) qwLoc01A8.dw0004 == 0x00)
					goto l00000000000155E4;
l000000000001553C:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->tFFFFF880.u0, 1, "ipcalc: unexpected argument: %s\n", a3);
				fn0000000000015FCC(gp, 1);
				goto l00000000000153DC;
			}
			a0_n = strchr(s1_n, '/');
			a5_n = a5_n;
			if (a0_n != null)
			{
l0000000000015BB8:
				*a0_n = 0x00;
				s4_n.u1 = a0_n + 1;
				if (s4_n == 0x00)
					goto l00000000000155FC;
l00000000000155E4:
				Eq_n a0_n = fn00000000000166F4(gp, (char *) &qwLoc01A8 + 4, s4_n, 0);
				a5_n = a0_n;
				if (a0_n >= 0x00)
					goto l00000000000155FC;
				if ((int64) gp->dwFFFFF814 == 0x00)
				{
					a0_n.u0 = gp->tFFFFF880.u0;
l0000000000015B8C:
					__fprintf_chk(a0_n, 1, "ipcalc: bad %s prefix: %s\n", a3, a4);
				}
				goto l00000000000153D8;
			}
l00000000000155FC:
			a4_n.u0 = (int64) qwLoc01A8.dw0004;
			int64 a0_n;
			Eq_n a4_n;
			if (a4_n != 0x00)
			{
l0000000000015604:
				a0_n = fn00000000000175BC(ra, gp, s1_n, s1_n, a5_n, &tLoc0188, s0_n, a4_n, fa3, fa4, out a4_n);
			}
			else
				a0_n = fn0000000000016D74(ra, gp, s1_n, a5_n, &tLoc0188, s0_n, a4_n, a5_n, a6_n, a7, fa3, fa4, out a4_n);
			if (a0_n < 0x00)
			{
l00000000000153D8:
				goto l00000000000153DC;
			}
			if ((s0_n & 0xFFFABFFF) == 0x00)
				s0_n |= 8;
			if ((uint64) isatty(1) != 0x00)
			{
				gp->dw0810 = 0x01;
				a4_n.u0 = 1;
			}
			if ((s0_n & 8) == 0x00)
			{
				if ((s0_n & 0x0080) != 0x00)
					__printf_chk(1, "NETMASK=%s\n", a2);
				if ((s0_n & 0x0200) != 0x00)
					__printf_chk(1, "PREFIX=%u\n", (uint32) a2);
				if ((s0_n & 64) != 0x00 && (int64) qwLoc01A8.dw0004 == 0x00)
					__printf_chk(1, "BROADCAST=%s\n", a2);
				if ((s0_n & 0x0100) != 0x00)
					__printf_chk(1, "NETWORK=%s\n", a2);
				if (s0_n << 0x2E < 0x00)
					__printf_chk(1, "REVERSEDNS=%s\n", a2);
				if ((s0_n & 0x0400) != 0x00 && tLoc0188.qw00A8 != 0x00)
					__printf_chk(1, "MINADDR=%s\n", a2);
				if (s0_n << 0x34 < 0x00 && tLoc0188.qw00B0 != 0x00)
					__printf_chk(1, "MAXADDR=%s\n", a2);
				if (s0_n << 0x32 < 0x00)
				{
					char * s2_n = tLoc0188.ptr00B8;
					if (s2_n != null)
					{
						if (strchr(s2_n, ' ') != null)
							__printf_chk(1, "ADDRSPACE=\"%s\"\n", a2);
						else
							__printf_chk(1, "ADDRSPACE=%s\n", a2);
					}
				}
				if (s0_n << 0x33 < 0x00)
				{
					if (strchr((char *) &tLoc0188 + 96, ' ') != null)
						__printf_chk(1, "ADDRESSES=\"%s\"\n", a2);
					else
						__printf_chk(1, "ADDRESSES=%s\n", a2);
				}
				if ((s0_n & 1) != 0x00 && tLoc0188.qw0038 != 0x00)
					__printf_chk(1, "HOSTNAME=%s\n", a2);
				if ((s0_n & 2) != 0x00)
					__printf_chk(1, "ADDRESS=%s\n", a2);
				if ((s0_n & 0xC000) == 0xC000)
				{
					if (tLoc0188.qw0048 != 0x00)
						__printf_chk(1, "COUNTRYCODE=%s\n", a2);
					char * s0_n = tLoc0188.ptr0040;
					if (s0_n != null)
					{
						if (strchr(s0_n, ' ') != null)
							__printf_chk(1, "COUNTRY=\"%s\"\n", a2);
						else
							__printf_chk(1, "COUNTRY=%s\n", a2);
					}
					char * s0_n = tLoc0188.ptr0050;
					if (s0_n != null)
					{
						if (strchr(s0_n, ' ') != null)
							__printf_chk(1, "CITY=\"%s\"\n", a2);
						else
							__printf_chk(1, "CITY=%s\n", a2);
					}
					if (tLoc0188.qw0058 != 0x00)
						__printf_chk(1, "COORDINATES=\"%s\"\n", a2);
				}
				goto l00000000000153DC;
			}
			Eq_n s2_n;
			s2_n.u0 = (int64) tLoc0188.dw00A0;
			Eq_n a5_n;
			if ((int64) qwLoc01A8.dw0004 == 0x00)
			{
				a5_n.u0 = 32;
				if (s2_n != 32)
					goto l0000000000015660;
				goto l0000000000015914;
			}
			a5_n.u0 = 0x0080;
			Eq_n a3_n;
			int64 s4_n;
			Eq_n a4_n;
			if (s2_n == 0x0080)
			{
l0000000000015914:
				a3_n.u0 = tLoc0188.t0008.u0;
				if (a3_n != 0x00)
				{
					s4_n = 1;
					goto l0000000000015880;
				}
				word64 a5_n;
				gp = fn000000000001654C(gp, tLoc0188.t0000.u0, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				goto l00000000000158B8;
			}
l0000000000015660:
			if (false)
			{
l0000000000015664:
				goto l0000000000015668;
			}
			Eq_n s3_n;
			s3_n.u0 = tLoc0188.t0000.u0;
			if ((uint64) strcmp(tLoc0188.ptr0020, s3_n) == 0x00)
				goto l0000000000015664;
			a3_n.u0 = tLoc0188.t0008.u0;
			s4_n = 0;
			if (a3_n == 0x00)
			{
				word64 a4_n;
				gp = fn000000000001654C(gp, s3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				s2_n.u0 = (int64) tLoc0188.dw00A0;
				goto l0000000000015668;
			}
l0000000000015880:
			Eq_n a4_n;
			Eq_n a5_n;
			word64 a6_n;
			word64 a7_n;
			gp = fn000000000001654C(fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n), tLoc0188.t0000.u0, a4_n, a5_n, a6_n, a7_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a5_n;
			Eq_n a3_n;
			int64 s0_n;
			if (s4_n != 0x00)
			{
l00000000000158B8:
				a5_n.u0 = 0x00010008;
				if ((s0_n & 0x00010008) != 0x00010008)
					goto l00000000000158C8;
				a3_n.u0 = tLoc0188.t0018.u0;
				s0_n = 1;
				if (a3_n == 0x00)
					goto l00000000000158C8;
				goto l0000000000015C2C;
			}
			s2_n.u0 = (int64) tLoc0188.dw00A0;
l0000000000015668:
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t0010.u0;
			if (a3_n != 0x00)
			{
				word64 a4_n;
				gp = fn000000000001654C(gp, a3_n, s2_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				s2_n.u0 = (int64) tLoc0188.dw00A0;
			}
			word64 a4_n;
			Eq_n a5_n;
			word64 a6_n;
			word64 a7_n;
			Eq_n a5_n;
			gp = fn000000000001654C(fn000000000001654C(gp, tLoc0188.t0020.u0, s2_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n), tLoc0188.t0030.u0, (int64) tLoc0188.dw00A0, a5_n, a6_n, a7_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t0028.u0;
			if (a3_n != 0x00)
			{
				word64 a5_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			a5_n.u0 = 0x00010008;
			if ((s0_n & 0x00010008) == 0x00010008)
			{
				a3_n.u0 = tLoc0188.t0018.u0;
				if (a3_n == 0x00)
					goto l00000000000156FC;
				s0_n = 0;
l0000000000015C2C:
				gp = fn000000000001654C(gp, a3_n, a4_n, 0x00010008, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				if (s0_n == 0x00)
					goto l00000000000156FC;
l00000000000158C8:
				Eq_n a3_n;
				a3_n.u0 = tLoc0188.t00B8.u0;
				if (a3_n != 0x00)
					gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				Eq_n a3_n;
				a3_n.u0 = tLoc0188.t00C0.u0;
				if (a3_n != 0x00)
				{
					word64 a5_n;
					gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
				}
				goto l00000000000157BC;
			}
l00000000000156FC:
			putchar(0x0A);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t00B8.u0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t00C0.u0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t00A8.u0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t00B0.u0;
			if (a3_n != 0x00)
			{
				word64 a5_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			Eq_n a5_n;
			a5_n.u0 = (int64) qwLoc01A8.dw0004;
			if (a5_n != 0x00)
			{
				a5_n.u0 = (int64) tLoc0188.dw00A0;
				a4_n.u0 = 111;
				if (a5_n > 111)
					goto l00000000000157A0;
				word64 a5_n;
				gp = fn000000000001654C(gp, (int64) (0x80 - (word32) a5_n), (char *) &tLoc0188 + 96, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
			else
			{
l00000000000157A0:
				word64 a5_n;
				gp = fn000000000001654C(gp, (char *) &tLoc0188 + 96, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			}
l00000000000157BC:
			Eq_n a5_n;
			a5_n.u0 = tLoc0188.t0040.u0;
			if (a5_n == 0x00)
			{
				a5_n.u0 = tLoc0188.t0050.u0;
				if (a5_n == 0x00)
				{
					a5_n.u0 = tLoc0188.t0058.u0;
					if (a5_n == 0x00)
					{
l00000000000153DC:
						if (a5_n != (gp->tFFFFF870).u0)
							__stack_chk_fail();
						else
							return;
					}
				}
			}
			putchar(0x0A);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t0048.u0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t0040.u0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t0050.u0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n;
			a3_n.u0 = tLoc0188.t0058.u0;
			if (a3_n != 0x00)
			{
				word64 a4_n;
				word64 a5_n;
				word64 a6_n;
				word64 a7_n;
				gp = fn000000000001654C(gp, a3_n, a4_n, a5_n, a6_n, a7, out a4_n, out a5_n, out a6_n, out a7_n);
			}
			goto l00000000000153DC;
		}
	} while (a0_n > 118);
	Eq_n a5_n;
	a5_n.u0 = (int64) (a0_n << 0x20 >> 0x1E).u1->dw102A0;
	a5_n();
}

// 0000000000015EB8: void fn0000000000015EB8(Register (ptr64 Eq_n) a0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void fn0000000000015EB8(void (* a0)(), word32 dwArg00, char * ptrArg08)
{
	word64 qwArg00;
	Eq_n fp;
	__libc_start_main(&g_t15180, (int32) qwArg00, &ptrArg08, &g_t182E8, &g_t18378, a0, fp & -16);
}

// 0000000000015EF0: void fn0000000000015EF0()
// Called from:
//      fn0000000000015F64
void fn0000000000015EF0()
{
	if (true || true)
		return;
	null();
}

// 0000000000015F24: void fn0000000000015F24()
// Called from:
//      fn0000000000015F94
void fn0000000000015F24()
{
	if (true || true)
		return;
	null();
}

// 0000000000015F64: void fn0000000000015F64(Register (ptr64 Eq_n) gp)
void fn0000000000015F64(struct Eq_n * gp)
{
	if ((word64) gp->bFFFFF894 == 0x00)
	{
		fn0000000000015EF0();
		gp->b0894 = 0x01;
	}
}

// 0000000000015F94: void fn0000000000015F94(Register word64 ra)
void fn0000000000015F94(word64 ra)
{
	if (g_qw19E28 != 0x00 && false)
	{
		null();
		fn0000000000015F24();
	}
	else
		fn0000000000015F24();
}

// 0000000000015FCC: void fn0000000000015FCC(Register (ptr64 Eq_n) gp, Register int64 a0)
// Called from:
//      fn0000000000015180
void fn0000000000015FCC(struct Eq_n * gp, int64 a0)
{
	Eq_n a3_n;
	a3_n.u0 = gp->tFFFFF880.u0;
	if (a0 != 0x00)
	{
		fwrite(&g_v10BE0, (size_t) 1, (size_t) 26, a3_n);
		fwrite(&g_v10C00, (size_t) 1, (size_t) 54, gp->tFFFFF880.u0);
		fwrite(&g_v10C38, (size_t) 1, (size_t) 77, gp->tFFFFF880.u0);
		fwrite(&g_v10C88, (size_t) 1, (size_t) 62, gp->tFFFFF880.u0);
		fwrite(&g_v10CC8, (size_t) 1, (size_t) 79, gp->tFFFFF880.u0);
		fwrite(&g_v10D18, (size_t) 1, (size_t) 79, gp->tFFFFF880.u0);
		fwrite(&g_v10D68, (size_t) 1, (size_t) 42, gp->tFFFFF880.u0);
		fwrite(&g_v10D98, (size_t) 1, (size_t) 76, gp->tFFFFF880.u0);
		fwrite(&g_v10DE8, (size_t) 1, (size_t) 77, gp->tFFFFF880.u0);
		fwrite(&g_v10E38, (size_t) 1, (size_t) 77, gp->tFFFFF880.u0);
		fputc();
		fwrite(&g_v10E88, (size_t) 1, (size_t) 23, gp->tFFFFF880.u0);
		fwrite(&g_v10EA0, (size_t) 1, (size_t) 71, gp->tFFFFF880.u0);
		fwrite(&g_v10EE8, (size_t) 1, (size_t) 57, gp->tFFFFF880.u0);
		fwrite(&g_v10F28, (size_t) 1, (size_t) 58, gp->tFFFFF880.u0);
		fwrite(&g_v10F68, (size_t) 1, (size_t) 57, gp->tFFFFF880.u0);
		fwrite(&g_v10FA8, (size_t) 1, (size_t) 77, gp->tFFFFF880.u0);
		fwrite(&g_v10FF8, (size_t) 1, (size_t) 77, gp->tFFFFF880.u0);
		fwrite(&g_v11048, (size_t) 1, (size_t) 77, gp->tFFFFF880.u0);
		fwrite(&g_v11098, (size_t) 1, (size_t) 46, gp->tFFFFF880.u0);
		fwrite(&g_v110C8, (size_t) 1, (size_t) 72, gp->tFFFFF880.u0);
		fwrite(&g_v11118, (size_t) 1, (size_t) 45, gp->tFFFFF880.u0);
		fwrite(&g_v11148, (size_t) 1, (size_t) 67, gp->tFFFFF880.u0);
		fwrite(&g_v11190, (size_t) 1, (size_t) 64, gp->tFFFFF880.u0);
		fwrite(&g_v111D8, (size_t) 1, (size_t) 72, gp->tFFFFF880.u0);
		fwrite(&g_v11228, (size_t) 1, (size_t) 46, gp->tFFFFF880.u0);
		fputc();
		fwrite(&g_v11258, (size_t) 1, (size_t) 0x0F, gp->tFFFFF880.u0);
		fwrite(&g_v11268, (size_t) 1, (size_t) 87, gp->tFFFFF880.u0);
		fwrite(&g_v112C0, (size_t) 1, (size_t) 60, gp->tFFFFF880.u0);
		fwrite(&g_v11300, (size_t) 1, (size_t) 0x0044, gp->tFFFFF880.u0);
		fwrite(&g_v11348, (size_t) 1, (size_t) 58, gp->tFFFFF880.u0);
		fwrite(&g_v11388, (size_t) 1, (size_t) 57, gp->tFFFFF880.u0);
		fwrite(&g_v113C8, (size_t) 1, (size_t) 62, gp->tFFFFF880.u0);
	}
	else
	{
		fwrite(&g_v11408, (size_t) 1, (size_t) 77, a3_n);
		fwrite(&g_v11458, (size_t) 1, (size_t) 62, gp->tFFFFF880.u0);
		fwrite(&g_v11498, (size_t) 1, (size_t) 65, gp->tFFFFF880.u0);
		fwrite(&g_v114E0, (size_t) 1, (size_t) 76, gp->tFFFFF880.u0);
		fwrite(&g_v11530, (size_t) 1, (size_t) 65, gp->tFFFFF880.u0);
		fwrite(&g_v11578, (size_t) 1, (size_t) 41, gp->tFFFFF880.u0);
		fwrite(&g_v115A8, (size_t) 1, (size_t) 30, gp->tFFFFF880.u0);
	}
}

// 00000000000163B0: Register (ptr64 char) fn00000000000163B0(Register (ptr64 Eq_n) gp, Register Eq_n a4)
// Called from:
//      fn00000000000175BC
char * fn00000000000163B0(struct Eq_n * gp, Eq_n a4)
{
	ptr64 fp;
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	char bLocE8;
	__sprintf_chk(&bLocE8, 1, (size_t) 0x0080, "%.2x", (uint32) a4);
	int64 s0_n = 1;
	struct Eq_n * s1_n = fp + -0x00E6;
	if (true)
	{
		do
		{
			__sprintf_chk(s1_n, 1, (size_t) 0x0080, "%.2x", (uint32) a4);
			struct Eq_n * a4_n = s1_n + 1;
			if ((s0_n & 1) != 0x00)
			{
				if (s0_n == 0x0F)
				{
					s1_n = a4_n;
					break;
				}
				s1_n[1] = (struct Eq_n) 0x3A;
				s1_n = &s1_n->b0002 + 1;
			}
			else
				s1_n = a4_n;
			s0_n = (int64) ((word32) s0_n + 1);
		} while (s0_n != 16);
	}
	s1_n->b0000 = 0x00;
	char * a0_n = __strdup(&bLocE8);
	if (a5_n == (gp->tFFFFF870).u0)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000164D0: Register Eq_n fn00000000000164D0(Register Eq_n a0, Register Eq_n a1)
// Called from:
//      fn0000000000015180
Eq_n fn00000000000164D0(Eq_n a0, Eq_n a1)
{
	Eq_n a0_n;
	a0_n.u1 = (uint64) open("/dev/urandom", 0);
	Eq_n a0_n;
	if (a0_n >= 0x00)
	{
		uint64 a0_n = (uint64) read((int32) a0_n, a0, (size_t) a1);
		close((int32) a0_n);
		a0_n.u0 = (int64) (0x00 - (word32) ((int64) ((word32) (a0_n - a1)) != 0x00));
	}
	else
		a0_n.u0 = -1;
	return a0_n;
}

// 000000000001654C: Register (ptr64 Eq_n) fn000000000001654C(Register (ptr64 Eq_n) gp, Register Eq_n a3, Register Eq_n a4, Register Eq_n a5, Register word64 a6, Register word64 a7, Register out Eq_n a4Out, Register out Eq_n a5Out, Register out ptr64 a6Out, Register out ptr64 a7Out)
// Called from:
//      fn0000000000015180
struct Eq_n * fn000000000001654C(struct Eq_n * gp, Eq_n a3, Eq_n a4, Eq_n a5, word64 a6, word64 a7, union Eq_n & a4Out, union Eq_n & a5Out, ptr64 & a6Out, ptr64 & a7Out)
{
	Eq_n t3_n;
	t3_n.u0 = gp->tFFFFF870.u0;
	ptr64 fp;
	__vasprintf_chk(fp + -112, 1, fp + -40, fp + -40, a3, a4, a5, a6, a7);
	int64 a0_n;
	struct Eq_n * gp_n;
	if (a0_n >= 0x00)
	{
		char * s2_n;
		fputs(s2_n, gp_n->ptrFFFFF888);
		if ((int64) gp_n->dwFFFFF810 != 0x00)
		{
			char * s3_n;
			fputs(s3_n, gp_n->ptrFFFFF888);
		}
		fputs(null, gp_n->ptrFFFFF888);
		if ((int64) gp_n->dwFFFFF810 != 0x00)
			fwrite(&g_v115E0, (size_t) 1, (size_t) 4, gp_n->ptrFFFFF888);
		free(null);
	}
	Eq_n a5_n;
	a5_n.u0 = gp_n->tFFFFF870.u0;
	if (t3_n != a5_n)
		__stack_chk_fail();
	else
	{
		a4Out = t3_n;
		a5Out = a5_n;
		ptr64 a6_n;
		a6Out = a6_n;
		ptr64 a7_n;
		a7Out = a7_n;
		return gp_n;
	}
}

// 0000000000016630: Register Eq_n fn0000000000016630(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 word64) a1)
// Called from:
//      fn00000000000166F4
Eq_n fn0000000000016630(struct Eq_n * gp, Eq_n a0, word64 * a1)
{
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	int32 * a0_n = __errno_location();
	*a0_n = 0x00;
	uint64 a0_n = (uint64) strtol(a0);
	Eq_n a5_n;
	if (false && (a0 != 0x00 && (word64) null == 0x00))
	{
		a5_n.u0 = (int64) *a0_n;
		if (a5_n == 0x00)
		{
			if (a0_n == a0_n)
				*a1 = (word64) (word32) a0_n;
			else
				a5_n.u0 = -0x0022;
			goto l0000000000016698;
		}
	}
	else
		a5_n.u0 = (int64) *a0_n;
	if (a5_n > 0x00)
		a5_n.u0 = (int64) (0x00 - (word32) a5_n);
	else
		a5_n.u0 = -22;
l0000000000016698:
	if (a5_n == (gp->tFFFFF870).u0)
		return a5_n;
	__stack_chk_fail();
}

// 00000000000166F4: Register Eq_n fn00000000000166F4(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1, Register int64 a2)
// Called from:
//      fn0000000000015180
Eq_n fn00000000000166F4(struct Eq_n * gp, Eq_n a0, Eq_n a1, int64 a2)
{
	word64 a4_n;
	word64 a3_n;
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	int64 s0_n = (int64) *a0.u1;
	word64 qwLoc40;
	if (s0_n == 0x00 && strchr(a1, '.') != null)
	{
		if ((uint64) inet_pton(2, a1, &qwLoc40) != 0x00)
		{
			int64 a0_n = fn00000000000182B4((int64) qwLoc40, out a3_n, out a4_n);
			while (a0_n != 0x00)
			{
				if ((a0_n & 1) != 0x00)
				{
l0000000000016778:
					do
					{
						a0_n = (int64) ((word32) a0_n >> 1);
						s0_n = (int64) ((word32) s0_n + 1);
						if (a0_n == 0x00)
							goto l0000000000016790;
					} while ((a0_n & 1) != 0x00);
					goto l000000000001678C;
				}
				int64 a5_n = (int64) ((word32) a0_n >> 1);
				if (a5_n == 0x00)
					break;
				if ((a5_n & 1) != 0x00)
				{
					a0_n = a5_n;
					goto l0000000000016778;
				}
				a0_n = (int64) ((word32) a0_n >> 2);
			}
		}
		else
		{
l000000000001678C:
			s0_n = -1;
		}
l0000000000016790:
		qwLoc40 = (word64) (word32) s0_n;
	}
	else if (fn0000000000016630(gp, a1, &qwLoc40) != 0x00)
		goto l00000000000167C0;
	Eq_n a5_n;
	a5_n.u0 = (int64) qwLoc40;
	Eq_n a0_n;
	if (a2 != 0x00 && a5_n > 32)
	{
		if ((int64) *a0.u1 == 0x00)
			*a0.u1 = 0x01;
	}
	else
	{
		a0_n = a5_n;
		if (a5_n < 0x00)
			goto l00000000000167C0;
		if ((int64) *a0.u1 == 0x00)
		{
			if (a5_n > 32)
			{
l00000000000167C0:
				a0_n.u0 = -1;
				goto l00000000000167F4;
			}
l00000000000167F4:
			if (a5_n == (gp->tFFFFF870).u0)
				return a0_n;
			__stack_chk_fail();
		}
	}
	a0_n = a5_n;
	if (a5_n > 0x0080)
		goto l00000000000167C0;
	goto l00000000000167F4;
}

// 0000000000016830: Register Eq_n fn0000000000016830(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register out Eq_n a4Out, Register out Eq_n a5Out)
// Called from:
//      fn00000000000168B8
//      fn0000000000016D74
Eq_n fn0000000000016830(struct Eq_n * gp, Eq_n a0, union Eq_n & a4Out, union Eq_n & a5Out)
{
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	word32 dwLoc20_n = 0x00;
	if (a0 != 0x00)
	{
		word64 a3_n;
		word64 a4_n;
		dwLoc20_n = (word32) fn00000000000182B4((int64) (~0x00 << (int64) (0x20 - (word32) a0)), out a3_n, out a4_n);
	}
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	Eq_n a0_n;
	a0_n.u0 = (int64) dwLoc20_n;
	if (a5_n != a5_n)
		__stack_chk_fail();
	else
	{
		a4Out = a5_n;
		a5Out = a5_n;
		return a0_n;
	}
}

// 00000000000168B8: void fn00000000000168B8(Register (ptr64 Eq_n) gp, Register Eq_n a1)
void fn00000000000168B8(struct Eq_n * gp, Eq_n a1)
{
	word64 a4_n;
	word64 a5_n;
	fn0000000000016830(gp, a1, out a4_n, out a5_n);
}

// 00000000000168E4: Register Eq_n fn00000000000168E4(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 Eq_n) a1)
// Called from:
//      fn0000000000016D74
//      fn00000000000175BC
Eq_n fn00000000000168E4(struct Eq_n * gp, Eq_n a0, struct Eq_n * a1)
{
	Eq_n a4_n;
	a4_n.u0 = gp->tFFFFF870.u0;
	uint64 a0_n;
	if (a0 != 2)
	{
		if (a0 != 0x0A)
			goto l0000000000016910;
		word64 qwLoc48 = 0x00;
		word64 qwLoc40 = 0x00;
		qwLoc48 = (word64) (word16) a0;
		memcpy(&qwLoc40, a1, (size_t) 16);
		a0_n = (uint64) getnameinfo(&qwLoc48, 28, &gp->dwFFFFF890 + 2, 0x0401, 0, 0, 0);
	}
	else
	{
		word64 t5_n = (word64) a1->qw0000;
		word64 t4_n = (word64) a1->b0001;
		word64 t3_n = (word64) a1->b0002;
		word64 t1_n = (word64) a1->b0003;
		word64 qwLoc58 = 0x00;
		qwLoc58 = (word64) (word16) a0;
		qwLoc58.b0004 = (byte) t5_n;
		qwLoc58.b0005 = (byte) t4_n;
		qwLoc58.b0006 = (byte) t3_n;
		qwLoc58.b0007 = (byte) t1_n;
		a0_n = (uint64) getnameinfo(&qwLoc58, 16, &gp->dwFFFFF890 + 2, 0x0401, 0, 0, 0);
	}
	Eq_n a0_n;
	if (a0_n == 0x00)
	{
		a0_n = __strdup(&gp->dwFFFFF890 + 2);
l0000000000016914:
		if (a4_n == (gp->tFFFFF870).u0)
			return a0_n;
		__stack_chk_fail();
	}
l0000000000016910:
	a0_n.u0 = 0;
	goto l0000000000016914;
}

// 00000000000169D8: Register Eq_n fn00000000000169D8(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1)
// Called from:
//      fn0000000000015180
Eq_n fn00000000000169D8(struct Eq_n * gp, Eq_n a0, Eq_n a1)
{
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	Eq_n tLoc68;
	tLoc68.ai_flags = (int32) 0x00;
	tLoc68.ai_family = (word32) a0;
	tLoc68.ai_socktype = (int32) 0x00;
	tLoc68.ai_addrlen = (socklen_t) 0x00;
	tLoc68.ai_canonname = null;
	struct addrinfo * ptrLoc70;
	Eq_n a0_n;
	if ((uint64) getaddrinfo(a1, 0, &tLoc68, &ptrLoc70) == 0x00)
	{
		struct addrinfo * s0_n = (struct addrinfo *) ptrLoc70;
		if (s0_n != null)
		{
			do
			{
				int64 a0_n = (int64) s0_n->ai_family;
				char * a1_n = s0_n->ai_canonname;
				if (a0_n == 2)
				{
					if (inet_ntop((int32) a0_n, a1_n + 4, &gp->dwFFFFF890 + 260, 64) != null)
						goto l0000000000016A88;
				}
				else if (inet_ntop((int32) a0_n, a1_n + 8, &gp->dwFFFFF890 + 260, 64) != null)
				{
l0000000000016A88:
					freeaddrinfo(ptrLoc70);
					a0_n = __strdup(&gp->dwFFFFF890 + 260);
					goto l0000000000016AAC;
				}
				s0_n = s0_n->ptr0028;
			} while (s0_n != null);
			s0_n = (struct addrinfo *) ptrLoc70;
		}
		freeaddrinfo(s0_n);
		a0_n.u0 = 0;
	}
	else
		a0_n.u0 = 0;
l0000000000016AAC:
	if (a5_n == (gp->tFFFFF870).u0)
		return a0_n;
	__stack_chk_fail();
}

// 0000000000016B38: void fn0000000000016B38(Register Eq_n a0)
void fn0000000000016B38(Eq_n a0)
{
	if (a0 > 0x007F)
		;
}

// 0000000000016B68: Register int64 fn0000000000016B68(Register int64 a0)
// Called from:
//      fn0000000000016D74
int64 fn0000000000016B68(int64 a0)
{
	word64 a4_n;
	word64 a3_n;
	int64 a0_n = fn00000000000182B4(a0, out a3_n, out a4_n);
	int64 a5_n = (int64) ((word32) a0_n >> 24);
	int64 a4_n;
	if (a5_n == 0x00)
	{
		a4_n = 71144;
		return a4_n;
	}
	if (a5_n == 0x0A)
		return 71176;
	int64 a4_n = (int64) ((word32) a0_n >> 16);
	if (a5_n != 100)
	{
		if (a5_n == 0x007F)
		{
			a4_n = 0x00011630;
			return a4_n;
		}
		int64 a2_n = (int64) ((word32) a0_n >> 8);
		if (a5_n != 0x00A9)
		{
			if (a5_n == 0x00AC)
			{
				if ((a4_n & 0x00F0) == 16)
					return 71176;
			}
			else if (a5_n == 0x00C0)
			{
				if (((a4_n | a2_n) & 0x00FF) == 0x00)
				{
					a4_n = 0x00011660;
					return a4_n;
				}
				if ((a4_n & 0x00FF) != 2)
				{
					if ((a4_n & 0x00FF) != 0x0033)
					{
						if ((a4_n & 0x00FF) == 88)
						{
							if ((a2_n & 0x00FF) == 99)
							{
								a4_n = 0x000116E0;
								return a4_n;
							}
l0000000000016CB8:
							if ((a5_n & 0x00F0) != 0x00F0)
								a4_n = 0x00011650;
							else
								a4_n = 0x00011710;
							return a4_n;
						}
						if ((a4_n & 0x00FF) != 52)
						{
							if ((a4_n & 0x00FF) == 0x00A8)
								return 71176;
						}
						else if ((a2_n & 0x00FF) == 0x00C1)
						{
							a4_n = 0x00011708;
							return a4_n;
						}
					}
					else if ((a2_n & 0x00FF) == 100)
					{
						a4_n = 0x000116A0;
						return a4_n;
					}
				}
				else if ((a2_n & 0x00FF) == 0x00)
				{
					a4_n = 0x00011680;
					return a4_n;
				}
			}
			else if (a5_n == 0x00CB)
			{
				if ((a4_n & 0x00FF) == 0x00 && (a2_n & 0x00FF) == 113)
				{
					a4_n = 0x000116C0;
					return a4_n;
				}
			}
			else
			{
				if (a5_n == 0x00FF)
				{
					a4_n = 0x00011710;
					if ((a4_n & 0x00FF) == a5_n)
					{
						a4_n = 0x00011710;
						if ((a2_n & 0x00FF) == 0x00FF && (a0_n & 0x00FF) == (a2_n & 0x00FF))
							a4_n = 0x00011720;
					}
					return a4_n;
				}
				if (a5_n == 0x00C6)
				{
					a4_n = 0x00011650;
					if ((a4_n & 0x00FE) == 18)
						a4_n = 0x00011738;
					return a4_n;
				}
			}
		}
		else if ((a4_n & 0x00FF) == 0x00FE)
		{
			a4_n = 0x00011640;
			return a4_n;
		}
	}
	else if ((a4_n & 0x00C0) == 64)
	{
		a4_n = 0x00011618;
		return a4_n;
	}
	if ((int64) ((word32) a5_n + -224) <= 0x0F)
	{
		a4_n = 0x00011748;
		return a4_n;
	}
	goto l0000000000016CB8;
}

// 0000000000016D74: Register Eq_n fn0000000000016D74(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1, Register (ptr64 Eq_n) a2, Register Eq_n a3, Register Eq_n a4, Register Eq_n a5, Register word64 a6, Register word64 a7, Register real64 fa3, Register real64 fa4, Register out Eq_n a4Out)
// Called from:
//      fn0000000000015180
Eq_n fn0000000000016D74(word64 ra, struct Eq_n * gp, Eq_n a0, Eq_n a1, struct Eq_n * a2, Eq_n a3, Eq_n a4, Eq_n a5, word64 a6, word64 a7, real64 fa3, real64 fa4, union Eq_n & a4Out)
{
	word64 a4_n;
	word64 a3_n;
	word64 a5_n;
	word64 a4_n;
	word64 a5_n;
	word64 a4_n;
	word64 a5_n;
	word64 a4_n;
	word64 a4_n;
	word64 a3_n;
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	memset(a2, 0, (size_t) 200);
	struct Eq_n * s6_n = a2;
	Eq_n s5_n = a1;
	word64 qwLoc01B8;
	Eq_n a0_n;
	if ((uint64) inet_pton(2, a0, &qwLoc01B8) <= 0x00)
	{
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000016E20;
		__fprintf_chk(gp->tFFFFF880.u0, 1, "ipcalc: bad IPv4 address: %s\n", a3);
		a0_n.u0 = -1;
l0000000000016E24:
		if (a5_n != (gp->tFFFFF870).u0)
			__stack_chk_fail();
		else
		{
			a4Out = a5_n;
			return a0_n;
		}
	}
	char * ptrLoc0190;
	Eq_n a0_n;
	if (a1 >= 0x00)
	{
		ptrLoc0190 = (char *) a0;
		Eq_n a0_n = a0;
		int64 s0_n = 3;
		do
		{
			char * a0_n = strchr(a0_n, '.');
			ptrLoc0190 = a0_n;
			if (a0_n == null)
			{
				do
				{
					if ((uint64) __asprintf_chk(&ptrLoc0190, 1, "%s.0", a3) == -1)
					{
						a0_n.u0 = gp->tFFFFF880.u0;
						goto l00000000000172C4;
					}
					s0_n = (int64) ((word32) s0_n + -1);
				} while (s0_n != 0x00);
				break;
			}
			ptrLoc0190 = a0_n + 1;
			a0_n.u1 = a0_n + 1;
			s0_n = (int64) ((word32) s0_n + -1);
		} while (s0_n != 0x00);
		if (a1 > 32)
		{
			if ((int64) gp->dwFFFFF814 == 0x00)
			{
				__fprintf_chk(gp->tFFFFF880.u0, 1, "ipcalc: bad IPv4 prefix %d\n", (int32) a3);
				a0_n.u0 = -1;
				goto l0000000000016E24;
			}
			goto l0000000000016E20;
		}
	}
	else
	{
		s5_n.u0 = 32;
		if (a3 << 0x2D < 0x00)
		{
			int64 a0_n = fn00000000000182B4((int64) qwLoc01B8, out a3_n, out a4_n);
			s5_n.u0 = 8;
			int64 a5_n = (int64) ((word32) a0_n >> 24);
			if (a0_n < 0x00)
			{
				s5_n.u0 = 24;
				if ((int64) ((word32) a5_n + -0x0080) <= 63)
					s5_n.u0 = 16;
			}
		}
	}
	char bLoc0188;
	if (inet_ntop(2, &qwLoc01B8, &bLoc0188, 47) != null)
	{
		a2->ptr0000 = __strdup(&bLoc0188);
		word64 qwLoc01B0 = (word64) (word32) fn0000000000016830(gp, s5_n, out a4_n, out a5_n);
		bLoc0188 = (char) 0x00;
		if (inet_ntop(2, &qwLoc01B0, &bLoc0188, 16) == null)
		{
			a0_n.u0 = gp->tFFFFF880.u0;
			goto l00000000000172C4;
		}
		a2->ptr0030 = __strdup(&bLoc0188);
		int64 s0_n = (int64) qwLoc01B8;
		a2->dw00A0 = (word32) s5_n;
		word64 qwLoc01A0 = (word64) (word32) (~fn0000000000016830(gp, s5_n, out a4_n, out a5_n) | s0_n);
		bLoc0188 = (char) 0x00;
		if (inet_ntop(2, &qwLoc01A0, &bLoc0188, 16) == null)
		{
			a0_n.u0 = gp->tFFFFF880.u0;
			goto l00000000000172C4;
		}
		a2->ptr0028 = __strdup(&bLoc0188);
		int64 s0_n = (int64) qwLoc01B8;
		ui64 a0_n = fn0000000000016830(gp, s5_n, out a4_n, out a5_n);
		int64 a3_n = (int64) qwLoc01A0;
		int64 s0_n = a0_n & s0_n;
		word64 qwLoc01A8 = (word64) (word32) s0_n;
		a2->qw0018 = fn0000000000017F04(gp, s0_n, s5_n, s0_n, a3_n, a4_n, a5_n, a6, a7);
		bLoc0188 = (char) 0x00;
		if (inet_ntop(2, &qwLoc01A8, &bLoc0188, 16) == null)
		{
			a0_n.u0 = gp->tFFFFF880.u0;
			goto l00000000000172C4;
		}
		char * a0_n = __strdup(&bLoc0188);
		int64 s0_n = (int64) qwLoc01A8;
		a2->ptr0020 = a0_n;
		a2->qw00B8 = fn0000000000016B68(s0_n);
		int64 a0_n = fn00000000000182B4(s0_n, out a3_n, out a4_n);
		int64 a5_n = (int64) ((word32) a0_n >> 24);
		word64 a5_n;
		if (a0_n < 0x00)
		{
			if ((int64) ((word32) a5_n + -0x0080) > 63)
			{
				if ((int64) ((word32) a5_n + -0x00C0) > 31)
				{
					if ((int64) ((word32) a5_n + -224) <= 0x0E)
						a5_n = 0x00011770;
					else
						a5_n = 0x00011778;
				}
				else
					a5_n = 0x00011768;
			}
			else
				a5_n = 0x00011760;
		}
		else
			a5_n = 0x00011758;
		a2->qw00C0 = a5_n;
		struct Eq_n * a5_n;
		if (s5_n == 32)
		{
			a2->ptr00A8 = a0_n;
			a2->ptr00B0 = a0_n;
			a5_n = &g_t11780;
			goto l000000000001716C;
		}
		word64 qwLoc0198 = (word64) (word32) s0_n;
		if (s5_n != 31)
		{
			qwLoc0198 = (word64) ((word32) s0_n | 0x01000000);
			if (inet_ntop(2, &qwLoc0198, &bLoc0188, 16) != null)
			{
				char * a0_n = __strdup(&bLoc0188);
				int64 a5_n = (int64) qwLoc01B0;
				a2->ptr00A8 = a0_n;
				word64 a3_n;
				word64 a4_n;
				word64 a3_n;
				word64 a4_n;
				ptrLoc0190 = (char *) (word32) fn00000000000182B4((int64) ((word32) fn00000000000182B4(~a5_n | (int64) qwLoc01A8, out a3_n, out a4_n) + -1), out a3_n, out a4_n);
				if (inet_ntop(2, &ptrLoc0190, &bLoc0188, 47) != null)
				{
					a2->ptr00B0 = __strdup(&bLoc0188);
					__snprintf_chk(&a2->b0060, (size_t) 64, 1, (size_t) 64, "%u", (uint32) a5);
					goto l000000000001717C;
				}
				goto l0000000000017074;
			}
l00000000000172E8:
			a0_n.u0 = gp->tFFFFF880.u0;
l00000000000172C4:
			__fprintf_chk(a0_n, 1, "Memory allocation failure line %d\n", (int32) a3);
			abort();
		}
		if (inet_ntop(2, &qwLoc0198, &bLoc0188, 16) == null)
			goto l00000000000172E8;
		char * a0_n = __strdup(&bLoc0188);
		int64 a5_n = (int64) qwLoc01B0;
		int64 a4_n = (int64) qwLoc01A8;
		a2->ptr00A8 = a0_n;
		ptrLoc0190 = (char *) (word32) (~a5_n | a4_n);
		if (inet_ntop(2, &ptrLoc0190, &bLoc0188, 47) != null)
		{
			a2->ptr00B0 = __strdup(&bLoc0188);
			a5_n = &g_t12660;
l000000000001716C:
			a2->b0060 = a5_n->b0000;
			a2->b0061 = a5_n->b0001;
l000000000001717C:
			if (a3 << 0x31 < 0x00)
				gp = fn0000000000017B40(ra, gp, (int64) qwLoc01B8, &a2->qw0038 + 1, &a2->qw0038 + 2, &a2->qw0038 + 3, &a2->qw0038 + 4, a3 << 0x31, s5_n, a2, fa3, fa4, out s6_n);
			if ((a3 & 1) == 0x00)
			{
l000000000001718C:
				a0_n.u0 = 0;
				goto l0000000000016E24;
			}
			word64 a0_n = fn00000000000168E4(gp, 2, &qwLoc01B8);
			s6_n->qw0038 = a0_n;
			if (a0_n != 0x00)
				goto l000000000001718C;
			if ((int64) gp->dwFFFFF814 == 0x00)
			{
				char bLoc0158;
				__sprintf_chk(&bLoc0158, 1, (size_t) 0x00FA, "ipcalc: cannot find hostname for %s", a4);
				herror(&bLoc0158);
				a0_n.u0 = -1;
				goto l0000000000016E24;
			}
l0000000000016E20:
			a0_n.u0 = -1;
			goto l0000000000016E24;
		}
	}
l0000000000017074:
	if ((int64) gp->dwFFFFF814 == 0x00)
		fwrite(&g_v117F8, (size_t) 1, (size_t) 43, gp->tFFFFF880.u0);
	goto l0000000000016E20;
}

// 000000000001730C: Register Eq_n fn000000000001730C(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 word64) a1)
// Called from:
//      fn00000000000175BC
Eq_n fn000000000001730C(struct Eq_n * gp, Eq_n a0, word64 * a1)
{
	Eq_n a4_n;
	a4_n.u0 = gp->tFFFFF870.u0;
	Eq_n a0_n;
	if (a0 <= 0x0080)
	{
		word64 qwLocB8 = 0x00;
		union Eq_n * a5_n = &qwLocB8;
		int64 a4_n = (int64) (0x08 - (word32) a0);
		while (0x00 < a0)
		{
			if (a0 > 7)
				a5_n->u0 = ~0x00;
			else
				a5_n->u0 = ~0x00 << (byte) a4_n;
			a0.u0 = (int64) ((word32) a0 + -8);
			a5_n = (union Eq_n *) ((char *) a5_n + 1);
			a4_n = (int64) ((word32) a4_n + 8);
		}
		char bLocA8;
		if (inet_ntop(0x0A, &qwLocB8, &bLocA8, 0x0080) != null)
		{
			memcpy(a1, &qwLocB8, (size_t) 16);
			a0_n = __strdup(&bLocA8);
l000000000001739C:
			if (a4_n == (gp->tFFFFF870).u0)
				return a0_n;
			__stack_chk_fail();
		}
	}
	a0_n.u0 = 0;
	goto l000000000001739C;
}

// 00000000000173D4: Register (ptr64 Eq_n) fn00000000000173D4(Register (ptr64 Eq_n) a0, Register Eq_n a1)
// Called from:
//      fn00000000000175BC
struct Eq_n * fn00000000000173D4(struct Eq_n * a0, Eq_n a1)
{
	int64 s2_n = (word64) a0->qw0000;
	ui64 s3_n = (word64) a0->b0001;
	struct Eq_n * a0_n;
	if (a1 != 0x0080)
	{
		if (a1 <= 95)
			goto l0000000000017408;
	}
	else
	{
		if ((uint64) memcmp(a0, &g_v10880, (size_t) 16) == 0x00)
			return &g_t11858;
		if ((uint64) memcmp(a0, &g_v10898, (size_t) 16) == 0x00)
		{
			a0_n = &g_t11870;
			return a0_n;
		}
	}
	if ((uint64) memcmp(a0, &g_v108B0, (size_t) 0x0C) == 0x00)
		return &g_t11888;
	if ((uint64) memcmp(a0, &g_v108C0, (size_t) 0x0C) == 0x00)
		return &g_t118A0;
	if ((uint64) memcmp(a0, &g_v108D0, (size_t) 0x0C) == 0x00)
		return &g_t118B8;
l0000000000017408:
	ui64 a5_n = s2_n << 0x08 | s3_n;
	if ((a5_n & 0xFFFFE000) != 0x2000)
	{
		if ((s2_n & 0x00FE) != 252)
		{
			if ((a5_n & -64) != 65152)
			{
				if (s2_n != 0x00FF)
				{
					a0_n = &g_t11710;
					if ((a5_n & -2) == 0x00002002)
						a0_n = &g_t11918;
				}
				else
					a0_n = &g_t11748;
			}
			else
				a0_n = &g_t11900;
		}
		else
			a0_n = &g_t118E8;
	}
	else
		a0_n = &g_t118D8;
	return a0_n;
}

// 00000000000175BC: Register Eq_n fn00000000000175BC(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n s1, Register Eq_n a0, Register Eq_n a1, Register (ptr64 Eq_n) a2, Register Eq_n a3, Register Eq_n a4, Register real64 fa3, Register real64 fa4, Register out Eq_n a4Out)
// Called from:
//      fn0000000000015180
Eq_n fn00000000000175BC(word64 ra, struct Eq_n * gp, Eq_n s1, Eq_n a0, Eq_n a1, struct Eq_n * a2, Eq_n a3, Eq_n a4, real64 fa3, real64 fa4, union Eq_n & a4Out)
{
	word64 qwLoc0178;
	word64 qwLoc0188;
	char bLoc0168;
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	memset(a2, 0, (size_t) 200);
	struct Eq_n * s0_n = a2;
	Eq_n s2_n = a1;
	Eq_n s6_n = a3;
	word64 qwLoc0198;
	Eq_n a0_n;
	if ((uint64) inet_pton(0x0A, a0, &qwLoc0198) <= 0x00)
	{
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000017770;
		__fprintf_chk(gp->tFFFFF880.u0, 1, "ipcalc: bad IPv6 address: %s\n", a3);
		a0_n.u0 = -1;
		goto l0000000000017774;
	}
	a2->qw0008 = fn00000000000163B0(gp, a4);
	struct Eq_n * s3_n = &bLoc0168;
	if (inet_ntop(0x0A, &qwLoc0198, &bLoc0168, 0x00FA) == null)
	{
l0000000000017768:
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000017770;
		fwrite(&g_v117F8, (size_t) 1, (size_t) 43, gp->tFFFFF880.u0);
		a0_n.u0 = -1;
		goto l0000000000017774;
	}
	else
	{
		a2->ptr0000 = __strdup(&bLoc0168);
		Eq_n s5_n;
		s5_n.u0 = 0x0080;
		if (a1 <= 0x0080)
		{
			if (a1 >= 0x00)
				s5_n = a1;
			else
				s2_n.u0 = 0x0080;
			a2->dw00A0 = (word32) s5_n;
			word64 a0_n = fn000000000001730C(gp, s5_n, &qwLoc0188);
			a2->qw0030 = a0_n;
			if (a0_n != 0x00)
			{
				union Eq_n * s8_n = &qwLoc0178;
				union Eq_n * a5_n = &qwLoc0198;
				union Eq_n * s9_n = &qwLoc0188;
				union Eq_n * a2_n = &qwLoc0178;
				union Eq_n * a3_n = &qwLoc0188;
				Eq_n a4_n;
				do
				{
					a4_n = (word64) a5_n->u0 & (word64) a3_n->u0;
					a2_n->u0 = (byte) a4_n;
					a5_n = (union Eq_n *) ((char *) a5_n + 1);
					a3_n = (union Eq_n *) ((char *) a3_n + 1);
					a2_n = (union Eq_n *) ((char *) a2_n + 1);
				} while (&qwLoc0188 != a5_n);
				if (inet_ntop(0x0A, &qwLoc0178, &bLoc0168, 0x00FA) != null)
				{
					a2->ptr0020 = __strdup(&bLoc0168);
					a2->qw0010 = fn00000000000163B0(gp, a4_n);
					a2->qw00B8 = fn00000000000173D4(&qwLoc0178, s2_n);
					a2->qw0018 = fn0000000000018118(gp, &qwLoc0178, s5_n);
					if (s2_n == 0x0080)
					{
						char * a5_n = a2->ptr0020;
						a2->ptr00A8 = a5_n;
						a2->ptr00B0 = a5_n;
						goto l0000000000017728;
					}
					a2->ptr00A8 = __strdup(&bLoc0168);
					do
					{
						s8_n = (union Eq_n *) ((char *) s8_n + 1);
						(&s8_n->u2)[0x0FFF] = (struct Eq_n) ((byte) ~(word64) s9_n->u0 | s8_n->u0);
						s9_n = (union Eq_n *) ((char *) s9_n + 1);
					} while (&bLoc0168 != s8_n);
					if (inet_ntop(0x0A, &qwLoc0178, &bLoc0168, 0x00FA) != null)
					{
						a2->ptr00B0 = __strdup(&bLoc0168);
						if ((int64) (0x80 - (word32) s2_n) == 0x0080)
							goto l0000000000017740;
l0000000000017740:
						snprintf(&a2->qw0038 + 5, (size_t) 64, "%s", 0x00);
						if (a3 << 0x31 < 0x00)
							gp = fn0000000000017D10(ra, gp, s1, &qwLoc0198, &a2->qw0038 + 1, &a2->qw0038 + 2, &a2->qw0038 + 3, &a2->qw0038 + 4, a3 << 0x31, a3, &qwLoc0188, fa3, fa4, out s0_n, out s3_n, out s6_n);
						if ((s6_n & 1) == 0x00)
						{
l0000000000017760:
							a0_n.u0 = 0;
							goto l0000000000017774;
						}
						word64 a0_n = fn00000000000168E4(gp, 0x0A, &qwLoc0198);
						s0_n->qw0038 = a0_n;
						if (a0_n != 0x00)
							goto l0000000000017760;
						if ((int64) gp->dwFFFFF814 == 0x00)
						{
							__sprintf_chk(s3_n, 1, (size_t) 0x00FA, "ipcalc: cannot find hostname for %s", a4);
							herror(s3_n);
						}
l0000000000017770:
						a0_n.u0 = -1;
						goto l0000000000017774;
					}
				}
				goto l0000000000017768;
			}
			if ((int64) gp->dwFFFFF814 != 0x00)
				goto l0000000000017770;
			__fprintf_chk(gp->tFFFFF880.u0, 1, "ipcalc: error converting IPv6 prefix: %d\n", (int32) a3);
			a0_n.u0 = -1;
		}
		else
		{
			if ((int64) gp->dwFFFFF814 != 0x00)
				goto l0000000000017770;
			__fprintf_chk(gp->tFFFFF880.u0, 1, "ipcalc: bad IPv6 prefix: %d\n", (int32) a3);
			a0_n.u0 = -1;
		}
l0000000000017774:
		if (a5_n != (gp->tFFFFF870).u0)
			__stack_chk_fail();
		else
		{
			a4Out = a5_n;
			return a0_n;
		}
	}
}

// 0000000000017924: Register int64 fn0000000000017924(Register (ptr64 Eq_n) gp, Register Eq_n a5, Register out Eq_n a1Out, Register out Eq_n a2Out, Register out Eq_n a3Out, Register out Eq_n a4Out, Register out Eq_n a6Out)
// Called from:
//      fn0000000000015180
//      fn0000000000017B40
//      fn0000000000017D10
int64 fn0000000000017924(struct Eq_n * gp, Eq_n a5, union Eq_n & a1Out, union Eq_n & a2Out, union Eq_n & a3Out, union Eq_n & a4Out, union Eq_n & a6Out)
{
	int64 s0_n;
	Eq_n a1;
	if (gp->qwFFFFF820 == 0x00)
	{
		s0_n = (int64) gp->dwFFFFF818;
		if (s0_n == 0x00)
		{
			void * a0_n = dlopen("/usr/lib64/libGeoIP.so.1", 1);
			gp->ptr0820 = a0_n;
			Eq_n a6;
			Eq_n a2;
			Eq_n a3;
			Eq_n a4;
			if (a0_n != null)
			{
				gp->ptr0868 = dlsym(a0_n, "_GeoIP_setup_dbfilename");
				void * a0_n = dlsym(a0_n, "GeoIP_open_type");
				gp->ptr0860 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_country_name_by_id");
				gp->ptr0858 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_delete");
				gp->ptr0848 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_record_by_ipnum");
				gp->ptr0840 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_id_by_ipnum");
				gp->ptr0838 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_id_by_ipnum_v6");
				gp->ptr0830 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_record_by_ipnum_v6");
				gp->ptr0828 = a0_n;
				gp->ptr0850 = dlsym(a0_n, "GeoIP_code_by_id");
				a1.u0 = 76600;
				if (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && a0_n != null))))))
					gp->dw0818 = 0x00;
				else
				{
					a6.u1 = g_t12B50.u1;
					word64 a0_n = g_qw12B58;
					a1.u0 = g_t12B60.u0;
					a2.u0 = g_t12B68.u0;
					a3.u0 = g_t12B70.u0;
					a4.u0 = (int64) g_dw12B78;
					gp->tFFFFFCE0.u1 = (ptr64) a6;
					gp->qwFFFFFCE8 = a0_n;
					gp->tFFFFFCF0.u0 = (int64) a1;
					gp->tFFFFFCF8.u0 = (int64) a2;
					gp->tFFFFFD00.u0 = (int64) a3;
					gp->dwFFFFFD08 = (word32) a4;
					gp->dw0818 = ~0x00;
					s0_n = -1;
				}
			}
			else
			{
				__snprintf_chk(&gp->tFFFFFCE0.u0, (size_t) 0x0100, 1, (size_t) 0x0100, "ipcalc: could not open %s\n", a5);
				gp->dw0818 = ~0x00;
				a3.u0 = 0x0100;
				a4.u0 = 76376;
				a2.u0 = 1;
				a1.u0 = 0x0100;
				s0_n = -1;
			}
l0000000000017970:
			a1Out = a1;
			a2Out = a2;
			a3Out = a3;
			a4Out = a4;
			a6Out = a6;
			return s0_n;
		}
	}
	if ((int64) gp->dwFFFFF814 == 0x00 && (word64) (gp->tFFFFFCE0).u0 != 0x00)
	{
		a1.u0 = gp->tFFFFF880.u0;
		fputs(&gp->tFFFFFCE0.u0, a1);
	}
	s0_n = (int64) gp->dwFFFFF818;
	goto l0000000000017970;
}

// 0000000000017B40: Register (ptr64 Eq_n) fn0000000000017B40(Register word64 ra, Register (ptr64 Eq_n) gp, Register int64 a0, Register ptr64 a1, Register ptr64 a2, Register ptr64 a3, Register ptr64 a4, Register Eq_n a5, Register Eq_n s5, Register (ptr64 Eq_n) s6, Register real64 fa3, Register real64 fa4, Register out (ptr64 Eq_n) s6Out)
// Called from:
//      fn0000000000016D74
struct Eq_n * fn0000000000017B40(word64 ra, struct Eq_n * gp, int64 a0, ptr64 a1, ptr64 a2, ptr64 a3, ptr64 a4, Eq_n a5, Eq_n s5, struct Eq_n * s6, real64 fa3, real64 fa4, struct Eq_n & s6Out)
{
	struct Eq_n * a0_n;
	struct Eq_n * gp_n;
	struct Eq_n * gp_n;
	struct Eq_n * a0_n;
	struct Eq_n * gp_n;
	word64 a4_n;
	word64 a3_n;
	word64 a1_n;
	word64 a2_n;
	word64 a3_n;
	word64 a4_n;
	word64 a6_n;
	if (fn0000000000017924(gp, a5, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) == 0x00)
	{
		int64 a0_n = fn00000000000182B4(a0, out a3_n, out a4_n);
		<anonymous> * a5_n = gp->ptrFFFFF868;
		a5_n();
		<anonymous> * a5_n = gp_n->ptrFFFFF860;
		a5_n();
		struct Eq_n * s0_n = a0_n;
		struct Eq_n * gp_n;
		if (a0_n != null)
		{
			<anonymous> * a5_n = gp_n->ptrFFFFF838;
			a0_n->dw004C = 0x01;
			a5_n();
			int64 a0_n;
			if (a0_n < 0x00)
				goto l0000000000017B84;
			<anonymous> * a5_n = gp->ptrFFFFF858;
			a5_n();
			char * a0_n;
			if (a0_n != null)
			{
				char ** s3_n;
				*s3_n = (char **) __strdup(a0_n);
			}
			<anonymous> * a5_n = gp_n->ptrFFFFF850;
			a5_n();
			char * a0_n;
			if (a0_n != null)
			{
				char ** s2_n;
				*s2_n = (char **) __strdup(a0_n);
			}
			<anonymous> * a5_n = gp_n->ptrFFFFF848;
			a5_n();
		}
		<anonymous> * a5_n = gp_n->ptrFFFFF860;
		a5_n();
		struct Eq_n * s0_n = a0_n;
		if (a0_n == null)
		{
			<anonymous> * a5_n = gp->ptrFFFFF860;
			a5_n();
			s0_n = a0_n;
			if (a0_n == null)
				goto l0000000000017B84;
		}
		<anonymous> * a5_n = gp->ptrFFFFF840;
		s0_n->dw004C = 0x01;
		a5_n();
		struct Eq_n * a0_n;
		if (a0_n != null)
		{
			char * a0_n = a0_n->ptr0020;
			if (a0_n != null)
			{
				char ** s1_n;
				*s1_n = (char **) __strdup(a0_n);
			}
			word64 a5_n = (word64) (a0_n->r0034 == 0.0F);
			if (a5_n == 0x00)
			{
				char ** s4_n;
				__asprintf_chk(s4_n, 1, "%f,%f", fa3, fa4);
				word64 a2_n = 76672;
				int64 a1_n = 1;
			}
		}
		struct Eq_n * gp_n;
		gp_n->ptrFFFFF848();
		struct Eq_n * s6_n;
		s6Out = s6_n;
		struct Eq_n * gp_n;
		return gp_n;
	}
	else
	{
l0000000000017B84:
		s6Out = s6;
		return gp;
	}
}

// 0000000000017D10: Register (ptr64 Eq_n) fn0000000000017D10(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n s1, Register (ptr64 word64) a0, Register ptr64 a1, Register ptr64 a2, Register ptr64 a3, Register ptr64 a4, Register Eq_n a5, Register Eq_n s6, Register (ptr64 word64) s7, Register real64 fa3, Register real64 fa4, Register out (ptr64 void) s0Out, Register out (ptr64 char) s3Out, Register out Eq_n s6Out)
// Called from:
//      fn00000000000175BC
struct Eq_n * fn0000000000017D10(word64 ra, struct Eq_n * gp, Eq_n s1, word64 * a0, ptr64 a1, ptr64 a2, ptr64 a3, ptr64 a4, Eq_n a5, Eq_n s6, word64 * s7, real64 fa3, real64 fa4, void & s0Out, char & s3Out, union Eq_n & s6Out)
{
	struct Eq_n * s0_n;
	struct Eq_n * a0_n;
	struct Eq_n * gp_n;
	struct Eq_n * gp_n;
	struct Eq_n * s0_n;
	struct Eq_n * a0_n;
	struct Eq_n * gp_n;
	word64 a6_n;
	word64 a4_n;
	word64 a3_n;
	word64 a2_n;
	word64 a1_n;
	word64 a0_n = fn0000000000017924(gp, a5, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n);
	if (a0_n == 0x00)
	{
		<anonymous> * a5_n = gp->ptrFFFFF868;
		a5_n();
		<anonymous> * a5_n = gp_n->ptrFFFFF860;
		a5_n();
		struct Eq_n * s1_n = a0_n;
		struct Eq_n * gp_n;
		if (a0_n != null)
		{
			word64 a4_n = (word64) s0_n->dw0004;
			word64 a5_n = (word64) s0_n->dw000C;
			word64 a1_n = (word64) s0_n->dw0000;
			word64 a2_n = (word64) s0_n->dw0008;
			<anonymous> * a3_n = gp_n->ptrFFFFF830;
			a0_n->dw004C = 0x01;
			a3_n();
			int64 a0_n;
			if (a0_n < 0x00)
				goto l0000000000017D54;
			<anonymous> * a5_n = gp->ptrFFFFF858;
			a5_n();
			char * a0_n;
			if (a0_n != null)
			{
				char ** s4_n;
				*s4_n = (char **) __strdup(a0_n);
			}
			<anonymous> * a5_n = gp_n->ptrFFFFF850;
			a5_n();
			char * a0_n;
			if (a0_n != null)
			{
				char ** s3_n;
				*s3_n = (char **) __strdup(a0_n);
			}
			<anonymous> * a5_n = gp_n->ptrFFFFF848;
			a5_n();
		}
		<anonymous> * a5_n = gp_n->ptrFFFFF860;
		a5_n();
		struct Eq_n * s1_n = a0_n;
		if (a0_n == null)
		{
			<anonymous> * a5_n = gp->ptrFFFFF860;
			a5_n();
			s1_n = a0_n;
			if (a0_n == null)
				goto l0000000000017D54;
		}
		word64 a4_n = (word64) s0_n->dw0004;
		word64 a5_n = (word64) s0_n->dw000C;
		word64 a1_n = (word64) s0_n->dw0000;
		word64 a2_n = (word64) s0_n->dw0008;
		<anonymous> * a3_n = gp->ptrFFFFF828;
		s1_n->dw004C = 0x01;
		a3_n();
		struct Eq_n * a0_n;
		if (a0_n != null)
		{
			char * a0_n = a0_n->ptr0020;
			if (a0_n != null)
			{
				char ** s2_n;
				*s2_n = (char **) __strdup(a0_n);
			}
			word64 a5_n = (word64) (a0_n->r0034 == 0.0F);
			if (a5_n == 0x00)
			{
				char ** s5_n;
				__asprintf_chk(s5_n, 1, "%f,%f", fa3, fa4);
				word64 a2_n = 76672;
				int64 a1_n = 1;
			}
		}
		struct Eq_n * gp_n;
		gp_n->ptrFFFFF848();
		void * s0_n;
		s0Out = s0_n;
		char * s3_n;
		s3Out = s3_n;
		Eq_n s6_n;
		s6Out = s6_n;
		struct Eq_n * gp_n;
		return gp_n;
	}
	else
	{
l0000000000017D54:
		void * s0;
		s0Out = s0;
		char * s3;
		s3Out = s3;
		s6Out = s6;
		return gp;
	}
}

// 0000000000017F04: Register int64 fn0000000000017F04(Register (ptr64 Eq_n) gp, Register int64 a0, Register Eq_n a1, Register int64 a2, Register int64 a3, Register word64 a4, Register word64 a5, Register word64 a6, Register word64 a7)
// Called from:
//      fn0000000000016D74
int64 fn0000000000017F04(struct Eq_n * gp, int64 a0, Eq_n a1, int64 a2, int64 a3, word64 a4, word64 a5, word64 a6, word64 a7)
{
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	char * ptrLoc50 = 0x00;
	word64 a3_n;
	word64 a4_n;
	fn00000000000182B4(a0, out a3_n, out a4_n);
	Eq_n a0_n;
	switch (a1)
	{
	case 32:
		a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.%u.%u.in-addr.arpa.", (uint32) a3, (uint32) a4, (uint32) a5, (uint32) a6);
		break;
	case 24:
		a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.%u.in-addr.arpa.", (uint32) a3, (uint32) a4, (uint32) a5);
		break;
	case 16:
		a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.%u.in-addr.arpa.", (uint32) a3, (uint32) a4);
		break;
	case 8:
		a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u.in-addr.arpa.", (uint32) a3);
		break;
	default:
		if (a1 <= 24)
		{
			if (a1 <= 16)
			{
				if (a1 <= 8)
					goto l0000000000017F84;
				word64 a3_n;
				word64 a4_n;
				fn00000000000182B4(a2, out a3_n, out a4_n);
				word64 a3_n;
				word64 a4_n;
				fn00000000000182B4(a3, out a3_n, out a4_n);
				a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.in-addr.arpa.", (uint32) a3, (uint32) a4, (uint32) a5);
			}
			else
			{
				word64 a3_n;
				word64 a4_n;
				fn00000000000182B4(a2, out a3_n, out a4_n);
				word64 a3_n;
				word64 a4_n;
				fn00000000000182B4(a3, out a3_n, out a4_n);
				a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.%u.in-addr.arpa.", (uint32) a3, (uint32) a4, (uint32) a5, (uint32) a6);
			}
		}
		else
		{
			word64 a3_n;
			word64 a4_n;
			fn00000000000182B4(a2, out a3_n, out a4_n);
			word64 a3_n;
			word64 a4_n;
			fn00000000000182B4(a3, out a3_n, out a4_n);
			a0_n.u1 = (uint64) __asprintf_chk(&ptrLoc50, 1, "%u-%u.%u.%u.%u.in-addr.arpa.", (uint32) a3, (uint32) a4, (uint32) a5, (uint32) a6, (uint32) a7);
		}
		break;
	}
	int64 a0_n;
	if (a0_n != -1)
	{
		a0_n = (int64) ptrLoc50;
l0000000000017F88:
		if (a5_n == (gp->tFFFFF870).u0)
			return a0_n;
		__stack_chk_fail();
	}
l0000000000017F84:
	a0_n = 0;
	goto l0000000000017F88;
}

// 0000000000018118: Register Eq_n fn0000000000018118(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1)
// Called from:
//      fn00000000000175BC
Eq_n fn0000000000018118(struct Eq_n * gp, Eq_n a0, Eq_n a1)
{
	Eq_n a5_n;
	a5_n.u0 = gp->tFFFFF870.u0;
	int64 t4_n = a1 & 3;
	Eq_n a0_n;
	if ((a1 & 3) == 0x00)
	{
		int64 t5_n = (int64) ((word32) a1 >> 3);
		char bLoc0118;
		if ((a1 & 7) == 4)
		{
			uint64 a5_n = (word64) a0.u1[(word64) (((word32) a1 + 4 >> 3) + -1)];
			uint64 a4_n = (a5_n >> 0x04) + 87;
			if (a5_n >> 0x04 <= 9)
				a4_n = (a5_n >> 0x04) + 48;
			bLoc0118 = (byte) a4_n;
			t4_n = 2;
		}
		if (t5_n != 0x00)
		{
			int64 a1_n = (int64) ((word32) t5_n + -1);
			int64 a4_n = t4_n;
			do
			{
				uint64 a5_n = (word64) a0.u1[(word64) (word32) a1_n];
				int64 a3_n = (int64) ((word32) a4_n + 1);
				ui64 a6_n = (a5_n & 0x0F) + 87;
				if ((a5_n & 0x0F) <= 9)
					a6_n = (a5_n & 0x0F) + 48;
				ptr64 fp;
				(fp + -16 + (word64) ((word32) a4_n))->b0EF8 = (byte) a6_n;
				(fp + -16 + (word64) ((word32) a3_n))->b0EF8 = 0x2E;
				int64 a2_n = (int64) ((word32) a4_n + 2);
				int64 a3_n = (int64) ((word32) a4_n + 3);
				uint64 a6_n = (a5_n >> 0x04) + 48;
				if (a5_n >> 0x04 > 9)
					a6_n = (a5_n >> 0x04) + 87;
				(fp + -16 + (word64) ((word32) a2_n))->b0EF8 = (byte) a6_n;
				(fp + -16 + (word64) ((word32) a3_n))->b0EF8 = 0x2E;
				a1_n = (int64) ((word32) a1_n + -1);
				a4_n = (int64) ((word32) a4_n + 4);
			} while (a1_n != -1);
			t4_n = (int64) ((word32) t4_n + (int64) ((word32) t5_n << 0x02));
		}
		struct Eq_n * t4_n = (struct Eq_n *) (&bLoc0118 + (word64) ((word32) t4_n));
		t4_n->w0004 = 29281;
		t4_n->w0000 = 28777;
		t4_n->w0006 = 24944;
		t4_n->w0002 = 11830;
		t4_n->w0008 = 0x2E;
		a0_n = __strdup(&bLoc0118);
	}
	else
		a0_n.u0 = 0;
	if (a5_n == (gp->tFFFFF870).u0)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000182B4: Register int64 fn00000000000182B4(Register int64 a0, Register out Eq_n a3Out, Register out Eq_n a4Out)
// Called from:
//      fn00000000000166F4
//      fn0000000000016830
//      fn0000000000016B68
//      fn0000000000016D74
//      fn0000000000017B40
//      fn0000000000017F04
int64 fn00000000000182B4(int64 a0, union Eq_n & a3Out, union Eq_n & a4Out)
{
	Eq_n a3_n = (int64) ((word32) a0 >> 24) | (int64) ((word32) a0 << 0x18);
	a3Out = a3_n;
	Eq_n a4_n;
	a4_n.u0 = (int64) (((word32) a0 & 0x00FF0000) >> 0x08);
	a4Out = a4_n;
	return a3_n | a4_n | (int64) (((word32) a0 & 0xFF00) << 0x08);
}

// 00000000000182E8: void fn00000000000182E8(Register word64 ra, Register word64 a0, Register word64 a1, Register word64 a2)
void fn00000000000182E8(word64 ra, word64 a0, word64 a1, word64 a2)
{
	int64 s2_n = 106016 - 106008;
	Eq_n s0_n;
	s0_n.u0 = 106008;
	int64 s2_n = s2_n >> 0x03;
	if (s2_n >> 0x03 != 0x00)
	{
		word64 s5_n = a0;
		word64 s4_n = a1;
		word64 s3_n = a2;
		int64 s1_n = 0;
		do
		{
			(*s0_n.u1)();
			word64 s0_n;
			s0_n = s0_n + 8;
		} while (s2_n != s1_n);
	}
}

// 0000000000018378: void fn0000000000018378()
void fn0000000000018378()
{
}

