// simd_double.c
// Generated by decompiling simd_double
// using Reko decompiler version 0.8.1.0.

#include "simd_double.h"

// 00000000000005A0: Register ptr64 _init()
ptr64 _init()
{
	ptr64 rax_n = __gmon_start__;
	if (__gmon_start__ != 0x00)
		__gmon_start__();
	return rax_n;
}

// 0000000000000620: void _start(Register (ptr64 Eq_n) rdx, Stack Eq_n qwArg00)
void _start(void (* rdx)(), Eq_n qwArg00)
{
	__align((char *) fp + 0x08);
	__libc_start_main(&globals->t0898, qwArg00, (char *) fp + 0x08, &globals->t0A70, &globals->t0AE0, rdx, fp);
	__hlt();
}

// 0000000000000650: void deregister_tm_clones(Register ptr64 rbp)
void deregister_tm_clones(ptr64 rbp)
{
	if (2101320 == 2101320 || _ITM_deregisterTMCloneTable == null)
		return;
	_ITM_deregisterTMCloneTable();
}

// 0000000000000690: void register_tm_clones(Register word64 rbp)
void register_tm_clones(word64 rbp)
{
	int64 rsi_n = 2101320 - 2101320;
	Eq_n rsi_n = (rsi_n >> 0x03) + ((rsi_n >> 0x03) >> 0x3F);
	if (rsi_n >> 0x01 == 0x00 || _ITM_registerTMCloneTable == null)
		return;
	_ITM_registerTMCloneTable();
}

// 00000000000006E0: void __do_global_dtors_aux(Register word64 rax, Register word64 rbp)
void __do_global_dtors_aux(word64 rax, word64 rbp)
{
	if (globals->b201048 != 0x00)
		return;
	if (__cxa_finalize != 0x00)
		__cxa_finalize();
	deregister_tm_clones(fp - 0x08);
	globals->b201048 = 0x01;
}

// 0000000000000720: void frame_dummy(Register word64 rbp)
void frame_dummy(word64 rbp)
{
	register_tm_clones(rbp);
}

// 000000000000072A: Register (ptr64 void) _mm_malloc(Register ptr64 rbp, Register uint64 rsi, Register Eq_n rdi)
void * _mm_malloc(ptr64 rbp, uint64 rsi, Eq_n rdi)
{
	void * rax_n;
	uint64 qwLoc28_n = rsi;
	if (rsi == 0x01)
		rax_n = malloc(rdi);
	else
	{
		if (rsi == 0x02 || rsi == 0x04)
			qwLoc28_n = 0x08;
		word64 rax_n;
		posix_memalign();
		if ((word32) rax_n == 0x00)
			rax_n = qwLoc10;
		else
			rax_n = null;
	}
	return rax_n;
}

// 000000000000078D: void _mm_free(Register (ptr64 (arr real64)) rdi)
void _mm_free(real64 (* rdi)[])
{
	free(rdi);
}

// 00000000000007A8: void vec_add(Register word64 rdi, Stack word64 qwArg00)
void vec_add(word64 rdi, word64 qwArg00)
{
	__align(fp);
	uint64 rax_n = (uint64) ((uint128) (uint64) rdi /u globals->qw0B00);
	if (rax_n <= 0x00)
		;
}

// 0000000000000898: void main(Register Eq_n xmm0)
void main(Eq_n xmm0)
{
	real64 rax_n[] = _mm_malloc(fp - 0x08, 0x20, 0x2000);
	real64 rax_n[] = _mm_malloc(fp - 0x08, 0x20, 0x2000);
	real64 rax_n[] = _mm_malloc(fp - 0x08, 0x20, 0x2000);
	Eq_n qwLoc10_n = 0x00;
	while (qwLoc10_n < 0x0400)
	{
		real64 * rcx_n = rax_n + qwLoc10_n;
		ui32 eax_n = (word32) qwLoc10_n;
		if (qwLoc10_n >= 0x00)
			xmm0 = DPB(xmm0, (real64) qwLoc10_n, 0);
		else
		{
			real64 v26_n = (real64) (qwLoc10_n >> 0x01 | (uint64) (eax_n & 0x01));
			xmm0 = DPB(xmm0, v26_n + v26_n, 0);
		}
		*rcx_n = (real64) xmm0;
		qwLoc10_n = (word64) qwLoc10_n + 0x01;
	}
	Eq_n qwLoc18_n = 0x00;
	while (qwLoc18_n < 0x0400)
	{
		ui32 eax_n = (word32) ((word64) qwLoc18_n + 0x01);
		real64 * rcx_n = rax_n + qwLoc18_n;
		if (qwLoc18_n >= 0x01)
			xmm0 = DPB(xmm0, (real64) ((word64) qwLoc18_n + 0x01), 0);
		else
		{
			real64 v19_n = (real64) ((word64) qwLoc18_n + 0x01 >> 0x01 | (uint64) (eax_n & 0x01));
			xmm0 = DPB(xmm0, v19_n + v19_n, 0);
		}
		*rcx_n = (real64) xmm0;
		qwLoc18_n = (word64) qwLoc18_n + 0x01;
	}
	uint64 qwLoc20_n;
	for (qwLoc20_n = 0x00; qwLoc20_n < 0x0400; ++qwLoc20_n)
	{
		xmm0 = __xorpd(xmm0, xmm0);
		rax_n[qwLoc20_n] = (real64) xmm0;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word64 stackArg0 = <invalid>;
	vec_add(0x0400, stackArg0);
	up64 qwLoc28_n;
	for (qwLoc28_n = 0x00; qwLoc28_n < 0x0400; ++qwLoc28_n)
		printf("%g\n", 0x00);
	_mm_free(rax_n);
	_mm_free(rax_n);
	_mm_free(rax_n);
}

// 0000000000000A70: void __libc_csu_init(Register word64 rdx, Register word64 rbx, Register word64 rbp, Register word64 rsi, Register word32 edi, Register word64 r12, Register word64 r13, Register word64 r14, Register word64 r15)
void __libc_csu_init(word64 rdx, word64 rbx, word64 rbp, word64 rsi, word32 edi, word64 r12, word64 r13, word64 r14, word64 r15)
{
	word32 r15d_n = (word32) (uint64) edi;
	int64 rbp_n = 0x00200DF0 - 2100712;
	word64 rax_n = _init();
	if (rbp_n >> 0x03 != 0x00)
	{
		Eq_n rbx_n = 0x00;
		do
		{
			(*((char *) globals->a200DE8 + rbx_n * 0x08))();
			rbx_n = (word64) rbx_n.u1 + 0x01;
		} while (rbp_n >> 0x03 != rbx_n);
	}
}

// 0000000000000AE0: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 0000000000000AE4: void _fini()
void _fini()
{
}

