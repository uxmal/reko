// ls_text.c
// Generated by decompiling ls
// using Reko decompiler version 0.11.5.0.

#include "ls.h"

// 00000000004028C0: void fn00000000004028C0(Register (ptr64 (ptr64 char)) rsi, Register int32 edi, Register (ptr32 Eq_n) fs)
void fn00000000004028C0(char ** rsi, int32 edi, struct Eq_n * fs)
{
	Eq_n tLoc02D8;
	Eq_n tLoc0378;
	fn000000000040D6A0(*rsi);
	setlocale(6, 0x00416919);
	bindtextdomain(0x00413800, 4274204);
	textdomain(0x00413800);
	g_dw61A580 = 0x02;
	fn0000000000411EE0(0x0040A200);
	g_dw61B030 = 0x00;
	g_b61B0D0 = 0x01;
	g_qw61B180 = 0x8000000000000000;
	word32 eax_n = g_dw61A56C;
	g_t61B190.u4 = (char *) 0x00;
	g_t61B188.u4 = (char *) ~0x00;
	g_b61B0F0 = 0x00;
	switch (eax_n)
	{
	case 0x02:
		g_dw61B150 = 0x02;
		fn000000000040E640(0x05, 0x00);
		break;
	case 0x03:
		g_dw61B150 = 0x00;
		fn000000000040E640(0x05, 0x00);
		break;
	default:
		if (eax_n != 0x01)
			goto l0000000000402985;
		if (isatty(1) != 0x00)
		{
			g_dw61B150 = 0x02;
			g_b61B0F0 = 0x01;
		}
		else
			g_dw61B150 = 0x01;
		break;
	}
	g_dw61B14C = 0x00;
	g_dw61B148 = 0x00;
	g_b61B147 = 0x00;
	g_b61B145 = 0x00;
	g_b61B144 = 0x00;
	g_dw61B12C = 0x00;
	g_b61B114 = 0x00;
	g_dw61B110 = 0x01;
	g_b61B10E = 0x00;
	g_b61B10D = 0x00;
	g_dw61B108 = 0x00;
	g_t61B100.u4 = (char *) 0x00;
	g_t61B0F8.u4 = (char *) 0x00;
	g_b61B17D = 0x00;
	Eq_n rax_n = getenv(4274222);
	if (rax_n != 0x00)
	{
		int32 eax_n = (word32) fn0000000000409E50(0x04, 0x00416460, 0x00416480, rax_n);
		if (eax_n >= 0x00)
			fn000000000040E640(*((word64) 0x00416460 + (int64) eax_n * 0x04), 0x00);
		else
		{
			fn000000000040E930(rax_n, fs);
			error(0, 0, dcgettext(0x00, 0x00415B00, 5), 0x00);
		}
	}
	g_t61B0C8.u4 = (char *) 0x50;
	Eq_n rax_n = getenv(4274236);
	Eq_n qwLoc0398_n = &tLoc0378;
	if (rax_n == 0x00 || *rax_n.u4 == 0x00)
	{
l0000000000402AB1:
		if (ioctl(1, 21523, 0x00) != ~0x00)
		{
			Eq_n rax_n;
			rax_n.u4 = (uint64) tLoc0378.w0002;
			if ((word16) rax_n != 0x00)
				g_t61B0C8.u4 = (char *) rax_n;
		}
		Eq_n rax_n = getenv(4274244);
		g_qw61B0D8 = 0x08;
		if (rax_n != 0x00)
		{
			if (fn0000000000410E90(qwLoc0398_n, 0x00, 0x00, rax_n, 0x00) == 0x00)
				g_qw61B0D8 = (uint64) tLoc0378;
			else
			{
				fn000000000040E930(rax_n, fs);
				error(0, 0, dcgettext(0x00, 4283272, 5), 0x00);
			}
		}
		byte r14b_n = 0x00;
		byte r13b_n = 0x00;
		Eq_n r12_n;
		r12_n.u0 = 0x00;
l0000000000402B30:
		Eq_n tLoc0380;
		tLoc0380.dw0000 = ~0x00;
		Eq_n eax_n = getopt_long(edi, rsi, 4283336, 0x00413080, &tLoc0380);
		if (eax_n != ~0x00)
		{
			if (eax_n <= 0x8F)
			{
				switch ((word32) eax_n)
				{
				case ~0x82:
					word32 eax_n = g_dw61A56C;
					Eq_n rcx_n;
					rcx_n.u0 = g_t61A570.u0;
					Eq_n rsi_n;
					if (eax_n != 0x01)
					{
						rsi_n.u0 = 4274191;
						if (eax_n != 0x02)
							rsi_n.u0 = 0x0041380E;
					}
					else
						rsi_n.u0 = 0x00413807;
					fn0000000000410B30(0x00, rcx_n, 4274172, rsi_n, stdout.u0);
					exit(0);
				case ~0x81:
					fn0000000000409750(0x00);
				case ~0x80:
				case ~0x7F:
				case ~0x7E:
				case ~0x7D:
				case ~0x7C:
				case ~0x7B:
				case ~0x7A:
				case ~0x79:
				case ~0x78:
				case ~0x77:
				case ~0x76:
				case ~0x75:
				case ~0x74:
				case ~0x73:
				case ~0x72:
				case ~0x71:
				case ~0x70:
				case ~0x6F:
				case ~0x6E:
				case ~0x6D:
				case ~0x6C:
				case ~0x6B:
				case ~0x6A:
				case ~0x69:
				case ~0x68:
				case ~0x67:
				case ~0x66:
				case ~0x65:
				case ~0x64:
				case ~0x63:
				case ~0x62:
				case ~0x61:
				case ~0x60:
				case ~0x5F:
				case ~0x5E:
				case ~0x5D:
				case ~0x5C:
				case ~0x5B:
				case ~0x5A:
				case ~0x59:
				case ~0x58:
				case ~0x57:
				case ~0x56:
				case ~0x55:
				case ~0x54:
				case ~0x53:
				case ~0x52:
				case ~0x51:
				case ~0x50:
				case ~0x4F:
				case ~0x4E:
				case ~0x4D:
				case ~0x4C:
				case ~0x4B:
				case ~0x4A:
				case ~0x49:
				case ~0x48:
				case ~0x47:
				case ~0x46:
				case ~0x45:
				case ~0x44:
				case ~0x43:
				case ~0x42:
				case ~0x41:
				case ~0x40:
				case ~0x3F:
				case ~0x3E:
				case ~0x3D:
				case ~0x3C:
				case ~0x3B:
				case ~0x3A:
				case ~0x39:
				case ~0x38:
				case ~0x37:
				case ~0x36:
				case ~0x35:
				case ~0x34:
				case ~0x33:
				case ~0x32:
				case ~0x31:
				case ~0x30:
				case ~0x2F:
				case ~0x2E:
				case ~0x2D:
				case ~0x2C:
				case ~0x2B:
				case ~0x2A:
				case ~0x29:
				case ~0x28:
				case ~0x27:
				case ~0x26:
				case ~0x25:
				case ~0x24:
				case ~0x23:
				case ~0x22:
				case ~0x21:
				case ~0x20:
				case ~0x1F:
				case ~0x1E:
				case ~0x1D:
				case ~0x1C:
				case ~0x1B:
				case ~0x1A:
				case ~0x19:
				case ~0x18:
				case ~0x17:
				case ~0x16:
				case ~0x15:
				case ~0x14:
				case ~0x13:
				case ~0x12:
				case ~0x11:
				case ~0x10:
				case ~0x0F:
				case ~0x0E:
				case ~0x0D:
				case ~0x0C:
				case ~0x0B:
				case ~0x0A:
				case ~0x09:
				case ~0x08:
				case ~0x07:
				case ~0x06:
				case ~0x05:
				case ~0x04:
				case ~0x03:
				case ~0x02:
				case ~0x01:
				case ~0x00:
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
				case 0x0A:
				case 11:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 22:
				case 0x17:
				case 0x18:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 0x20:
				case 33:
				case 0x22:
				case 0x23:
				case 0x24:
				case 0x25:
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x29:
				case 0x2A:
				case 0x2B:
				case 44:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 55:
				case 0x38:
				case 0x39:
				case 0x3A:
				case 0x3B:
				case 0x3C:
				case 0x3D:
				case 0x3E:
				case 0x3F:
				case 0x40:
				case 0x45:
				case 0x4A:
				case 0x4B:
				case 77:
				case 0x4F:
				case 0x50:
				case 0x56:
				case 0x57:
				case 0x59:
				case 0x5B:
				case 0x5C:
				case 0x5D:
				case 0x5E:
				case 0x5F:
				case 0x60:
				case 101:
				case 0x6A:
				case 121:
				case 122:
				case 0x7B:
				case 0x7C:
				case 0x7D:
				case 0x7E:
				case 0x7F:
					goto l00000000004031F9;
				case 0x31:
					if (g_dw61B150 != 0x00)
						g_dw61B150 = 0x01;
					break;
				case 0x41:
					if (g_dw61B108 == 0x00)
						g_dw61B108 = 0x01;
					break;
				case 66:
					Eq_n rax_n = fn0000000000410C40(0x10);
					Eq_n rdx_n;
					rdx_n.u4 = g_t61B100.u4;
					*rax_n.u5 = (word64) 4274276;
					g_t61B100.u4 = (char *) rax_n;
					rax_n.u6[8] = (struct tm) rdx_n;
					Eq_n rax_n = fn0000000000410C40(0x10);
					Eq_n rdx_n;
					rdx_n.u4 = g_t61B100.u4;
					*rax_n.u5 = (word64) 4274275;
					rax_n.u6[8] = (struct tm) rdx_n;
					g_t61B100.u4 = (char *) rax_n;
					break;
				case 0x43:
					g_dw61B150 = 0x02;
					break;
				case 0x44:
					g_b61B130 = 0x01;
					break;
				case 0x46:
					g_dw61B12C = 0x03;
					break;
				case 0x47:
					g_b61A568 = 0x00;
					break;
				case 0x48:
					g_dw61B110 = 0x03;
					break;
				case 0x49:
					Eq_n r15_n;
					r15_n.u4 = optarg.u4;
					Eq_n rax_n = fn0000000000410C40(0x10);
					Eq_n rdx_n;
					rdx_n.u4 = g_t61B100.u4;
					*rax_n.u5 = (word64) r15_n;
					rax_n.u6[8] = (struct tm) rdx_n;
					g_t61B100.u4 = (char *) rax_n;
					break;
				case 0x4C:
					g_dw61B110 = 0x05;
					break;
				case 0x4E:
					fn000000000040E640(0x00, 0x00);
					break;
				case 0x51:
					fn000000000040E640(0x03, 0x00);
					break;
				case 0x52:
					g_b61B10E = 0x01;
					break;
				case 0x53:
					g_dw61B148 = 0x02;
					r13b_n = 0x01;
					break;
				case 0x54:
					if (fn0000000000410E90(qwLoc0398_n, 0x00, 0x00, optarg.u4, 0x00) != 0x00)
					{
						fn000000000040E930(optarg.u4, fs);
						error(2, 0, dcgettext(0x00, 4274279, 5), 0x00);
					}
					g_qw61B0D8 = (uint64) tLoc0378;
					break;
				case 0x55:
					g_dw61B148 = ~0x00;
					r13b_n = 0x01;
					break;
				case 88:
					g_dw61B148 = 0x01;
					r13b_n = 0x01;
					break;
				case 0x5A:
					g_b61B17D = 0x01;
					break;
				case 0x61:
					g_dw61B108 = 0x02;
					break;
				case 0x62:
					fn000000000040E640(0x05, 0x00);
					break;
				case 99:
					g_dw61B14C = 0x01;
					break;
				case 100:
					g_b61B10D = 0x01;
					break;
				case 0x66:
					g_dw61B108 = 0x02;
					g_dw61B148 = ~0x00;
					if (g_dw61B150 == 0x00)
						g_dw61B150 = 0x00 - (word32) (isatty(1) < 0x01) + 0x02;
					g_b61B144 = 0x00;
					g_b61B129 = 0x00;
					r13b_n = 0x01;
					break;
				case 0x67:
					g_dw61B150 = 0x00;
					g_b61A569 = 0x00;
					break;
				case 0x68:
					g_dw61B140 = 0xB0;
					g_dw61B134 = 0xB0;
					g_t61B138.u0 = 0x01;
					g_t61A560.u0 = 0x01;
					break;
				case 0x69:
					g_b61B114 = 0x01;
					break;
				case 0x6B:
					r14b_n = 0x01;
					break;
				case 0x6C:
					goto l0000000000402B78;
				case 0x6D:
					g_dw61B150 = 0x04;
					break;
				case 110:
					g_b61B145 = 0x01;
l0000000000402B78:
					g_dw61B150 = 0x00;
					break;
				case 111:
					g_dw61B150 = 0x00;
					g_b61A568 = 0x00;
					break;
				case 0x70:
					g_dw61B12C = 0x01;
					break;
				case 113:
					g_b61B0F0 = 0x01;
					break;
				case 114:
					g_b61B147 = 0x01;
					break;
				case 115:
					g_b61B144 = 0x01;
					break;
				case 116:
					g_dw61B148 = 0x04;
					r13b_n = 0x01;
					break;
				case 117:
					g_dw61B14C = 0x02;
					break;
				case 118:
					g_dw61B148 = 0x03;
					r13b_n = 0x01;
					break;
				case 0x77:
					if (fn0000000000410E90(qwLoc0398_n, 0x00, 0x00, optarg.u4, 0x00) != 0x00 || tLoc0378 == 0x00)
					{
						fn000000000040E930(optarg.u4, fs);
						error(2, 0, dcgettext(0x00, 4274252, 5), 0x00);
					}
					g_t61B0C8.u4 = tLoc0378.t0000.u4;
					break;
				case 0x78:
					g_dw61B150 = 0x03;
					break;
				case 0x80:
					g_b61B146 = 0x01;
					break;
				case 0x81:
					up32 eax_n = fn000000000040C810(6402360, 0x0061B140, optarg.u4);
					if (eax_n != 0x00)
						fn00000000004112D0(tLoc0380.dw0000, eax_n);
					g_dw61B134 = g_dw61B140;
					g_t61A560.u0 = g_t61B138.u0;
					break;
				case 0x82:
					Eq_n rsi_n;
					rsi_n.u4 = optarg.u4;
					if (rsi_n != 0x00)
					{
						word32 eax_n = (word32) *((word64) 4271808 + fn000000000040A120(0x00412EC0, 0x00412F00, rsi_n, 4274323, 0x04, g_ptr61A578, fs) * 0x04);
						if (eax_n == 0x01 || eax_n == 0x02 && isatty(1) != 0x00)
							goto l0000000000403A7C;
						g_b61B129 = 0x00;
					}
					else
					{
l0000000000403A7C:
						g_b61B129 = 0x01;
						g_qw61B0D8 = 0x00;
					}
					break;
				case 131:
					g_dw61B110 = 0x04;
					break;
				case 0x84:
					g_dw61B12C = 0x02;
					break;
				case 133:
					g_dw61B150 = (up32) *((word64) 4272144 + fn000000000040A120(0x00413010, 0x00413040, optarg.u4, 4274314, 0x04, g_ptr61A578, fs) * 0x04);
					break;
				case 0x86:
					g_dw61B150 = 0x00;
					r12_n.u0 = 0x00413813;
					break;
				case 0x87:
					g_b61B10C = 0x01;
					break;
				case 0x88:
					Eq_n rax_n = fn0000000000410C40(0x10);
					*rax_n.u5 = optarg.u4;
					Eq_n rdx_n;
					rdx_n.u4 = g_t61B0F8.u4;
					g_t61B0F8.u4 = (char *) rax_n;
					rax_n.u6[8] = (struct tm) rdx_n;
					break;
				case 0x89:
					g_dw61B12C = (up32) *((word64) 4273840 + fn000000000040A120(0x004136B0, 0x004136C0, optarg.u4, 4274331, 0x04, g_ptr61A578, fs) * 0x04);
					break;
				case 0x8A:
					fn000000000040E640(*((word64) 0x00416460 + fn000000000040A120(0x00416460, 0x00416480, optarg.u4, 4274349, 0x04, g_ptr61A578, fs) * 0x04), 0x00);
					break;
				case 0x8B:
					g_b61B0F0 = 0x00;
					break;
				case 0x8C:
					g_dw61B140 = 0x90;
					g_dw61B134 = 0x90;
					g_t61B138.u0 = 0x01;
					g_t61A560.u0 = 0x01;
					break;
				case 141:
					g_dw61B148 = (word32) *((word64) 4272048 + fn000000000040A120(4272048, 0x00412FE0, optarg.u4, 4274300, 0x04, g_ptr61A578, fs) * 0x04);
					r13b_n = 0x01;
					break;
				case 0x8E:
					g_dw61B14C = (up32) *((word64) 4271952 + fn000000000040A120(0x00412F50, 4272000, optarg.u4, 0x00413883, 0x04, g_ptr61A578, fs) * 0x04);
					break;
				case 0x8F:
					r12_n.u4 = optarg.u4;
					break;
				}
				goto l0000000000402B30;
			}
			goto l00000000004031F9;
		}
		if (g_t61B138.u0 == 0x00)
		{
			Eq_n rax_n = getenv(4274401);
			fn000000000040C810(6402360, 0x0061B140, rax_n);
			if (rax_n != 0x00 || getenv(4274404) != null)
			{
				g_dw61B134 = g_dw61B140;
				g_t61A560.u0 = g_t61B138.u0;
			}
			if (r14b_n != 0x00)
			{
				g_dw61B140 = 0x00;
				g_t61B138.u0 = 0x0400;
			}
		}
		Eq_n rdx_n;
		rdx_n.u4 = g_t61B0C8.u4;
		Eq_n rax_n;
		rax_n.u0 = 0x01;
		if (rdx_n > 0x02)
			rax_n = (uint128) rdx_n /u 0x03;
		g_t61B020.u4 = (char *) rax_n;
		Eq_n rax_n = fn000000000040E600(0x00);
		g_t61B0E8.u0 = (uint64) rax_n;
		if (fn000000000040E630(rax_n) == 0x05)
			fn000000000040E650(0x01, 0x20, g_t61B0E8.u0);
		Eq_n rax_n;
		rax_n.u0 = (uint64) g_dw61B12C;
		if ((word32) rax_n > 0x01)
		{
			Eq_n r14_n;
			r14_n.u1 = &rax_n.u1->b4138ED;
			byte al_n = rax_n.u1->b4138ED;
			while (al_n != 0x00)
			{
				fn000000000040E650(0x01, (int32) al_n, g_t61B0E8.u0);
				r14_n.u1 = (word32) r14_n + 1;
				al_n = *r14_n.u1;
			}
		}
		Eq_n rax_n = fn000000000040E600(0x00);
		g_t61B0E0.u0 = (uint64) rax_n;
		fn000000000040E650(0x01, 0x3A, rax_n);
		if (g_b61B130 != 0x00 && g_dw61B150 != 0x00)
			g_b61B130 = 0x00;
		if (g_dw61B14C <= 0x02 && r13b_n == 0x00)
		{
			if (g_dw61B150 == 0x00)
			{
l000000000040380D:
				if (r12_n == 0x00)
				{
					Eq_n rax_n = getenv(4274421);
					r12_n = rax_n;
					if (rax_n == 0x00)
						r12_n.u0 = 4274215;
				}
				while (memcmp(r12_n, 4271264, 0x06) == 0x00)
				{
					if (fn000000000040AB70(0x02) == 0x00)
						goto l0000000000403301;
					r12_n.u4 = (word32) r12_n + 6;
				}
				if (*r12_n.u4 == 0x2B)
				{
					Eq_n r12_n;
					r12_n.u6 = r12_n.u6 + 1;
					char * rax_n = strchr(r12_n, '\n');
					Eq_n r13_n;
					if (rax_n != null)
					{
						r13_n.u4 = rax_n + 1;
						if (strchr(rax_n + 1, '\n') != null)
						{
							word64 r8_n;
							word64 r9_n;
							fn000000000040EC10(r12_n, fs, out r8_n, out r9_n);
							error(2, 0, dcgettext(0x00, 4274432, 5), 0x00);
						}
						*rax_n = 0x00;
					}
					else
						r13_n = r12_n;
					g_t61A3D0.u4 = (char *) r12_n;
					g_t61A3D8.u4 = (char *) r13_n;
l00000000004038A8:
					if (strstr(g_t61A3D0.u4, 4274022) != null)
						goto l00000000004038C2;
					goto l0000000000404484;
				}
				else
				{
					int64 rax_n = fn0000000000409E50(0x04, 0x004136F0, 0x00413700, r12_n);
					if (rax_n < 0x00)
					{
						fn0000000000409F80(rax_n, r12_n, 4274461, fs);
						fputs_unlocked(dcgettext(0x00, 4274472, 5), stderr.u0);
						Eq_n rbx_n;
						rbx_n.u0 = 0x00413700;
						while (true)
						{
							char * rcx_n = *rbx_n.u1;
							if (rcx_n == null)
								break;
							__fprintf_chk(stderr.u0, 1, "  - [posix-]%s\n", rcx_n);
							rbx_n.u1 = (word32) rbx_n + 8;
						}
						fputs_unlocked(dcgettext(0x00, 4283384, 5), stderr.u0);
l00000000004031F9:
						fn0000000000409750(0x02);
					}
					if (rax_n != 0x01)
					{
						if (rax_n > 0x01)
						{
							if (rax_n != 0x02)
							{
								if (rax_n == 0x03 && fn000000000040AB70(0x02) != 0x00)
								{
									Eq_n rax_n = dcgettext(0x00, g_t61A3D0.u4, 2);
									Eq_n rsi_n;
									rsi_n.u4 = g_t61A3D8.u4;
									g_t61A3D0.u4 = (char *) rax_n;
									g_t61A3D8.u4 = (char *) dcgettext(0x00, rsi_n, 2);
								}
							}
							else
							{
								g_t61A3D0.u4 = (char *) 4274549;
								g_t61A3D8.u4 = (char *) 4274537;
							}
							goto l00000000004038A8;
						}
						if (rax_n != 0x00)
							goto l00000000004038A8;
						g_t61A3D8.u4 = (char *) 0x0041394E;
						g_t61A3D0.u4 = (char *) 0x0041394E;
					}
					else
					{
						g_t61A3D8.u4 = (char *) 4274534;
						g_t61A3D0.u4 = (char *) 4274534;
					}
l0000000000404484:
					if (strstr(g_t61A3D8.u4, 4274022) == null)
						goto l0000000000403301;
l00000000004038C2:
					g_qw61A748 = 0x05;
					up64 r14_n;
					up64 rax_n;
					do
					{
						r14_n = g_qw61A748;
						g_qw61A748 = 0x00;
						Eq_n r13_n;
						r13_n.u0 = 0x0061A760;
						Eq_n r12d_n = 0x0002000E;
						do
						{
							tLoc0378 = (Eq_n) r14_n;
							if (fn000000000040CDC0(qwLoc0398_n, 161, r13_n, nl_langinfo(r12d_n), 0x00, 0x00) > 0xA0)
							{
								g_qw61A748 = 0x00;
								goto l0000000000404361;
							}
							rax_n = (up64) tLoc0378;
							if (g_qw61A748 >= rax_n)
								rax_n = g_qw61A748;
							g_qw61A748 = rax_n;
							r12d_n = (Eq_n) ((word32) r12d_n + 1);
							r13_n.u1 = (word64) r13_n.u0 + 161;
						} while (r12d_n != 0x0002001A);
					} while (rax_n < r14_n);
					if (rax_n == 0x00)
					{
l0000000000404361:
						error(0, 0, dcgettext(0x00, 4283440, 5), 0x00);
					}
l0000000000403301:
					Eq_n r12_n;
					r12_n.u4 = (uint64) g_dw61A620;
					int32 r12d_n = (word32) r12_n;
					word64 qwLoc0370;
					if (g_b61B129 != 0x00)
					{
						Eq_n rax_n = getenv(4274559);
						tLoc0380.dw0000 = (int32) rax_n;
						if (rax_n != 0x00 && *rax_n.u4 != 0x00)
						{
							char bLoc0388 = (char) 16191;
							Eq_n rax_n = fn0000000000410E30(rax_n);
							g_t61B118.u4 = (char *) rax_n;
							tLoc0378.t0000.u4 = (char *) rax_n;
							Eq_n r13_n;
							r13_n.u0 = 0x00;
							uint32 edx_n = 0x00;
l000000000040451F:
							if (edx_n > 0x05)
							{
l0000000000402985:
								abort();
							}
							while (true)
							{
								switch (edx_n)
								{
								case 0x00:
									Eq_n rax_n;
									rax_n.u0 = tLoc0380.dw0000;
									byte cl_n = *rax_n.u1;
									if (cl_n == 0x2A)
									{
										Eq_n rax_n = fn0000000000410C40(0x28);
										Eq_n rax_n;
										rax_n.u4 = g_t61B120.u4;
										tLoc0380.dw0000 = tLoc0380.dw0000 + 0x01;
										g_t61B120.u4 = (char *) rax_n;
										rax_n.u6[32] = (struct tm) rax_n;
										rax_n.u6[8] = (struct tm) tLoc0378.t0000.u4;
										r13_n = rax_n;
										edx_n = (0x00 - (word32) (fn00000000004049E0(rax_n, 0x01, &tLoc0380, qwLoc0398_n) < 0x01) & 0x02) + 0x03;
										goto l000000000040451F;
									}
									if (cl_n == 0x3A)
									{
										tLoc0380.dw0000 = (word32) rax_n + 1;
										goto l000000000040451F;
									}
									if (cl_n == 0x00)
										goto l000000000040478E;
									tLoc0380.dw0000 = (word32) rax_n + 1;
									bLoc0388 = *rax_n.u1;
									edx_n = 0x01;
									break;
								case 0x01:
									Eq_n rax_n;
									rax_n.u0 = tLoc0380.dw0000;
									edx_n = 0x05;
									if (*rax_n.u1 != 0x00)
									{
										tLoc0380.dw0000 = (word32) rax_n + 1;
										edx_n = 0x02;
									}
									break;
								case 0x02:
									Eq_n rax_n;
									rax_n.u0 = tLoc0380.dw0000;
									tLoc0380.dw0000 = (word32) rax_n + 1;
									uint64 r15_n = 0x00;
									edx_n = 0x05;
									if (*rax_n.u1 == 0x3D)
									{
										char * rsi_n;
										int64 r14_n;
										do
										{
											rsi_n = (char *) *((word64) 4273632 + r15_n * 0x08);
											r14_n = (int64) (word32) r15_n;
											if (rsi_n == null)
												goto l0000000000404857;
											++r15_n;
										} while (strcmp(&bLoc0388, rsi_n) != 0x00);
										Eq_n rcx_n = (r14_n << 0x04) + 6398944;
										rcx_n.u6[8] = (struct tm) tLoc0378.t0000.u4;
										edx_n = 0x00;
										if (fn00000000004049E0(rcx_n, 0x00, &tLoc0380, qwLoc0398_n) == 0x00)
										{
l0000000000404857:
											fn000000000040E930(&bLoc0388, fs);
											error(0, 0, dcgettext(0x00, 4274683, 5), 0x00);
											edx_n = 0x05;
										}
									}
									break;
								case 0x03:
									Eq_n rax_n;
									rax_n.u0 = tLoc0380.dw0000;
									tLoc0380.dw0000 = (word32) rax_n + 1;
									edx_n = 0x05;
									if (*rax_n.u1 == 0x3D)
									{
										r13_n.u6[24] = (struct tm) tLoc0378.t0000.u4;
										edx_n = 0x00 - (word32) (fn00000000004049E0(r13_n.u6 + 16, 0x00, &tLoc0380, qwLoc0398_n) < 0x01) & 0x05;
										goto l000000000040451F;
									}
									break;
								case 0x04:
									goto l0000000000402985;
								case 0x05:
									error(0, 0, dcgettext(0x00, 4283800, 5), 0x00);
									free(g_t61B118.u4);
									Eq_n rdi_n;
									rdi_n.u4 = g_t61B120.u4;
									while (rdi_n != 0x00)
									{
										Eq_n r13_n;
										r13_n.u4 = rdi_n.u6[32];
										free(rdi_n);
										rdi_n = r13_n;
									}
									g_b61B129 = 0x00;
l000000000040478E:
									if (g_qw61A450 == 0x06 && strncmp(g_ptr61A458, 0x00413989, 6) == 0x00)
										g_b61B198 = 0x01;
									goto l0000000000403AE2;
								}
							}
						}
l0000000000403AE2:
						if (g_b61B129 != 0x00)
						{
							if ((byte) fn0000000000404CD0(0x0D) != 0x00 || (byte) fn0000000000404CD0(0x0E) != 0x00 && g_b61B198 != 0x00 || (byte) fn0000000000404CD0(0x0C) != 0x00 && g_dw61B150 == 0x00)
								g_b61B115 = 0x01;
							if (tcgetpgrp(1) >= 0x00)
							{
								sigemptyset(0x0061B040);
								Eq_n r13_n;
								r13_n.u0 = 0x00412CC0;
								word56 r13_56_8_n;
								do
								{
									int32 r14d_n = *r13_n.u1;
									sigaction(r14d_n, 0x00, qwLoc0398_n);
									if (tLoc0378 != 0x01)
										sigaddset(0x0061B040, r14d_n);
									r13_n.u1 = (word32) r13_n + 4;
									r13_56_8_n = SLICE(r13_n, word56, 8);
								} while (r13_n != ~0x00412C8F);
								memcpy(&qwLoc0370, 0x0061B040, 0x80);
								word32 * r13_n = SEQ(r13_56_8_n, 0x00) + 0x00412CC0;
								do
								{
									int32 r15d_n = *r13_n;
									if (sigismember(0x0061B040, r15d_n) != 0x00)
									{
										uint64 rax_n = 0x004057F0;
										if (r15d_n != 0x14)
											rax_n = 0x004049B0;
										tLoc0378 = (Eq_n) rax_n;
										sigaction(r15d_n, qwLoc0398_n, 0x00);
									}
									++r13_n;
								} while (r13_n != (word32 *) ~0x00412C8F);
							}
						}
					}
					if (g_dw61B110 == 0x01)
					{
						uint32 eax_n = 0x02;
						if (g_b61B10D == 0x00 && g_dw61B12C != 0x03)
							eax_n = (0x00 - (word32) (g_dw61B150 < 0x01) & ~0x01) + 0x04;
						g_dw61B110 = eax_n;
					}
					if (g_b61B10E != 0x00)
					{
						struct Eq_n * rax_n = fn000000000040B400(0x00404990, 0x00404980, 0x00, 0x1E, 0x004049D0);
						g_ptr61B1C8 = rax_n;
						if (rax_n == null)
							goto l00000000004043BB;
						_obstack_begin(0x0061AF00, 0, 0, 0x00402640, 4202992);
					}
					word32 eax_n = g_dw61B148;
					byte al_n;
					if (eax_n != 0x04 && (eax_n != 0x02 && (g_dw61B150 != 0x00 && (g_b61B17D == 0x00 && g_b61B144 == 0x00))))
					{
						g_b61B0C1 = 0x00;
						al_n = 0x01;
						if (g_b61B10E != 0x00 || (g_b61B129 != 0x00 || (g_dw61B12C != 0x00 || g_b61B10C != 0x00)))
							goto l00000000004033A0;
					}
					else
						g_b61B0C1 = 0x01;
					al_n = 0x00;
l00000000004033A0:
					g_b61B0C0 = al_n;
					g_b61B0C0 &= 0x01;
					if (g_b61B130 != 0x00)
					{
						_obstack_begin(0x0061AFC0, 0, 0, 0x00402640, 4202992);
						_obstack_begin(6401888, 0, 0, 0x00402640, 4202992);
					}
					g_t61B1B8.u4 = (char *) 100;
					Eq_n rax_n = fn0000000000410C40(0x4B00);
					g_t61B1B0.u4 = (char *) 0x00;
					g_t61B1C0.u4 = (char *) rax_n;
					fn0000000000404DD0();
					int32 r13d_n = edi - r12d_n;
					Eq_n r12_n = r12_n;
					if (r13d_n > 0x00)
					{
						word64 * rbp_n = (word64 *) ((char *) rsi + (int64) r12d_n * 0x08);
						do
						{
							fn0000000000407EA0(0x00416919, 0x01, 0x00, *rbp_n, fs);
							r12_n.u4 = (uint64) (r12d_n + 0x01);
							r12d_n = (word32) r12_n;
							++rbp_n;
						} while (edi > r12d_n);
					}
					else if (g_b61B10D != 0x00)
						fn0000000000407EA0(0x00416919, 0x01, 0x03, 0x00413990, fs);
					else
						fn0000000000404D20(0x01, 0x00, 0x00413990);
					Eq_n qwLoc03A0_n;
					if (g_t61B1B0.u4 != 0x00)
					{
						fn0000000000404E80();
						if (g_b61B10D == 0x00)
							fn0000000000405090(0x01, 0x00);
						if (g_t61B1B0.u4 != 0x00)
						{
							fn00000000004079F0(r12_n, fs);
							if (g_t61B190.u4 != 0x00)
							{
								Eq_n rdi_n;
								rdi_n.u0 = stdout.u0;
								byte * rax_n = (byte *) *((word32) rdi_n + 40);
								if (rax_n < *((word32) rdi_n + 48))
								{
									*((word32) rdi_n + 40) = rax_n + 1;
									*rax_n = 0x0A;
								}
								else
									__overflow(rdi_n, 0x0A);
								Eq_n rax_n;
								rax_n.u4 = g_t61B190.u4;
								g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x01);
								qwLoc03A0_n = rax_n;
							}
							else
								qwLoc03A0_n.u0 = 0x00;
l00000000004034D2:
							if (qwLoc03A0_n == 0x00)
							{
								if (g_b61B129 != 0x00)
								{
									if (g_b61B128 != 0x00 && (g_qw61A3E0 != 0x02 || (memcmp(g_ptr61A3E8, 4274657, 0x02) != 0x00 || (g_qw61A3F0 != 0x01 || *g_ptr61A3F8 != 0x6D))))
									{
										word64 rcx_n;
										fn0000000000406440(6398944, out rcx_n);
										word64 rcx_n;
										fn0000000000406440(6398960, out rcx_n);
									}
									fflush_unlocked(stdout.u0);
									Eq_n rbx_n;
									rbx_n.u0 = 0x00412CC0;
									do
									{
										int32 ebp_n = *rbx_n.u1;
										if (sigismember(0x0061B040, ebp_n) != 0x00)
											signal(ebp_n, 0x00);
										rbx_n.u1 = (word32) rbx_n + 4;
									} while (rbx_n != 4271344);
									word32 ebx_n;
									for (ebx_n = g_dw61B034; ebx_n != 0x00; --ebx_n)
										raise(19);
									uint64 rdi_n = (uint64) g_dw61B038;
									if ((word32) rdi_n != 0x00)
										raise((int32) rdi_n);
								}
								if (g_b61B130 != 0x00)
								{
									fn0000000000405630(0x0061AFC0, 4274660);
									fn0000000000405630(6401888, 4274670);
									__printf_chk(1, "//DIRED-OPTIONS// --quoting-style=%s\n", *((word64) 4285568 + (uint64) fn000000000040E630(g_t61B0E8.u0) * 0x08));
								}
								struct Eq_n * rbx_n = g_ptr61B1C8;
								if (rbx_n != null)
								{
									if (fn000000000040AFB0(rbx_n) != 0x00)
										__assert_fail(4283752, 4273974, 1500, 4271271);
									fn000000000040B640(rbx_n);
								}
								exit(g_dw61B030);
							}
							g_t61B190.u4 = (char *) qwLoc03A0_n.u6[24];
							Eq_n r14_n;
							if (g_ptr61B1C8 != null)
							{
								r14_n.u4 = *qwLoc03A0_n.u5;
								if (r14_n == 0x00)
								{
									Eq_n rax_n;
									rax_n.u4 = g_t61AF18.u4;
									if ((word32) rax_n - g_dw61AF10 <= 0x0F)
										__assert_fail(4283480, 4273974, 0x03D5, 4271160);
									if (g_qw61AF20 - rax_n < ~0x0F)
									{
										_obstack_newchunk(0x0061AF00, -16);
										rax_n.u4 = g_t61AF18.u4;
									}
									struct Eq_n * rdi_n = g_ptr61B1C8;
									g_t61AF18.u4 = (char *) (rax_n - 16);
									word64 rax_n = (word64) *((word32) rax_n - 8);
									tLoc0378 = (Eq_n) *((word32) rax_n - 16);
									qwLoc0370 = rax_n;
									void * rax_n = fn000000000040BB90(qwLoc0398_n, rdi_n);
									if (rax_n == null)
										__assert_fail(4274578, 4273974, 0x059D, 4271271);
									free(rax_n);
									free(*qwLoc03A0_n.u5);
									free(qwLoc03A0_n.u6[8]);
									free(qwLoc03A0_n);
l00000000004034C6:
									qwLoc03A0_n.u4 = g_t61B190.u4;
									goto l00000000004034D2;
								}
							}
							else
								r14_n.u4 = *qwLoc03A0_n.u5;
							byte cl_n = (byte) qwLoc03A0_n.u6[16];
							Eq_n rbx_n;
							rbx_n.u4 = qwLoc03A0_n.u6[8];
							Eq_n rax_n = __errno_location();
							rax_n.u9->u1.t0000.u0 = 0x00;
							Eq_n rax_n = opendir(r14_n);
							if (rax_n == 0x00)
							{
								fn0000000000405810(r14_n, dcgettext(0x00, 4274584, 5), (word32) cl_n, fs);
								goto l00000000004034A1;
							}
							Eq_n rax_n = rax_n;
							if (g_ptr61B1C8 == null)
							{
l00000000004035FF:
								if (g_b61B10E != 0x00 || g_b61B0D0 != 0x00)
								{
									if (g_b61A3C0 == 0x00)
									{
										Eq_n rdi_n;
										rdi_n.u0 = stdout.u0;
										rax_n.u4 = *((word32) rdi_n + 40);
										word32 rax_32_32_n = SLICE(rax_n, word32, 32);
										if (rax_n < *((word32) rdi_n + 48))
										{
											*((word32) rdi_n + 40) = rax_n.u6 + 1;
											*rax_n.u4 = 0x0A;
										}
										else
											rax_n = SEQ(rax_32_32_n, __overflow(rdi_n, 0x0A));
										g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x01);
									}
									g_b61A3C0 = 0x00;
									if (g_b61B130 != 0x00)
									{
										rax_n = fwrite_unlocked(0x00413771, 0x01, 0x02, stdout.u0);
										g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x02);
										if (g_b61B130 != 0x00)
										{
											rax_n.u4 = g_t61AF78.u4;
											if (g_t61AF80.u0 < rax_n.u6 + 8)
											{
												_obstack_newchunk(6401888, 8);
												rax_n.u4 = g_t61AF78.u4;
											}
											*rax_n.u5 = g_t61B018.u0;
											g_t61AF78.u4 += 8;
										}
									}
									Eq_n rdx_n;
									rdx_n.u0 = g_t61B0E0.u0;
									Eq_n rdi_n;
									rdi_n.u0 = stdout.u0;
									if (rbx_n == 0x00)
										rbx_n = r14_n;
									fn00000000004052D0(0x00, rdx_n, rbx_n, rdi_n, rax_n, fs);
									g_t61B018.u0 = (int64) (rax_n.u4 + g_t61B018.u0);
									if (g_b61B130 != 0x00)
									{
										Eq_n rax_n;
										rax_n.u4 = g_t61AF78.u4;
										if (g_t61AF80.u0 < rax_n.u6 + 8)
										{
											_obstack_newchunk(6401888, 8);
											rax_n.u4 = g_t61AF78.u4;
										}
										*rax_n.u5 = g_t61B018.u0;
										g_t61AF78.u4 += 8;
									}
									fwrite_unlocked(4274491, 0x01, 0x02, stdout.u0);
									g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x02);
								}
								fn0000000000404DD0();
								word32 eax_n = (word32) cl_n;
								Eq_n qwLoc03B0_n;
								qwLoc03B0_n.u0 = 0x00;
l00000000004036F0:
								rax_n.u9->u1.t0000.u0 = 0x00;
								struct dirent * rax_n = readdir(rax_n);
								if (rax_n != null)
								{
									word32 eax_n = g_dw61B108;
									if (eax_n != 0x02)
									{
										if (rax_n->b0013 != 0x2E)
										{
											if (eax_n == 0x00)
											{
												Eq_n r15_n;
												r15_n.u4 = g_t61B0F8.u4;
												while (r15_n != 0x00)
												{
													if (fnmatch(*r15_n.u5, &rax_n->b0013, 4) == 0x00)
														goto l0000000000403770;
													r15_n.u4 = r15_n.u6[8];
												}
											}
										}
										else if (eax_n == 0x00 || (rax_n->a0014)[(uint64) ((rax_n->a0014)[0] == 0x2E)] == 0x00)
											goto l0000000000403770;
									}
									Eq_n r15_n;
									r15_n.u4 = g_t61B100.u4;
									while (r15_n != 0x00)
									{
										if (fnmatch(*r15_n.u5, &rax_n->b0013, 4) == 0x00)
											goto l0000000000403770;
										r15_n.u4 = r15_n.u6[8];
									}
									word32 esi_n = 0x00;
									cu8 al_n = rax_n->b0012 - 0x01;
									if (al_n <= 0x0D)
										esi_n = (word32) *((word64) 4271104 + (uint64) al_n * 0x04);
									qwLoc03B0_n = (word32) qwLoc03B0_n + fn0000000000407EA0(r14_n, 0x00, esi_n, &rax_n->b0013, fs);
									if (g_dw61B150 == 0x01 && (g_dw61B148 == ~0x00 && (g_b61B144 == 0x00 && g_b61B10E == 0x00)))
									{
										fn0000000000404E80();
										fn00000000004079F0(rax_n, fs);
										fn0000000000404DD0();
									}
l0000000000403770:
									fn0000000000406490();
									goto l00000000004036F0;
								}
								if (rax_n.u9->u1.t0000.u0 != 0x00)
								{
									fn0000000000405810(r14_n, dcgettext(0x00, 0x004139B1, 5), eax_n, fs);
									if (rax_n.u9->u1.t0000.u0 == 0x4B)
										goto l0000000000403770;
								}
								if (closedir(rax_n) != 0x00)
									fn0000000000405810(r14_n, dcgettext(0x00, 4274630, 5), (word32) cl_n, fs);
								fn0000000000404E80();
								if (g_b61B10E != 0x00)
									fn0000000000405090(cl_n, r14_n);
								if (g_dw61B150 == 0x00 || g_b61B144 != 0x00)
								{
									if (g_b61B130 != 0x00)
									{
										fwrite_unlocked(0x00413771, 0x01, 0x02, stdout.u0);
										g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x02);
									}
									char * rax_n = dcgettext(0x00, 4274651, 5);
									fputs_unlocked(rax_n, stdout.u0);
									Eq_n rax_n = strlen(rax_n);
									Eq_n rdi_n;
									rdi_n.u0 = stdout.u0;
									g_t61B018.u0 = (int64) (rax_n.u4 + g_t61B018.u0);
									byte * rax_n = (byte *) *((word32) rdi_n + 40);
									if (rax_n < *((word32) rdi_n + 48))
									{
										*((word32) rdi_n + 40) = rax_n + 1;
										*rax_n = 0x20;
									}
									else
										__overflow(rdi_n, 32);
									Eq_n r8_n;
									r8_n.u0 = g_t61B138.u0;
									ui32 edx_n = g_dw61B140;
									g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x01);
									Eq_n rax_n = fn000000000040BD70(0x0200, edx_n, &tLoc02D8, qwLoc03B0_n, r8_n, fs);
									fputs_unlocked(rax_n, stdout.u0);
									Eq_n rax_n = strlen(rax_n);
									Eq_n rdi_n;
									rdi_n.u0 = stdout.u0;
									g_t61B018.u0 = (int64) (rax_n.u4 + g_t61B018.u0);
									byte * rax_n = (byte *) *((word32) rdi_n + 40);
									if (rax_n < *((word32) rdi_n + 48))
									{
										*((word32) rdi_n + 40) = rax_n + 1;
										*rax_n = 0x0A;
									}
									else
										__overflow(rdi_n, 0x0A);
									g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x01);
								}
								if (g_t61B1B0.u4 != 0x00)
									fn00000000004079F0(rax_n, fs);
l00000000004034A1:
								free(*qwLoc03A0_n.u5);
								free(qwLoc03A0_n.u6[8]);
								free(qwLoc03A0_n);
								g_b61B0D0 = 0x01;
								goto l00000000004034C6;
							}
							int32 eax_n = dirfd(rax_n);
							byte al_n;
							if (eax_n >= 0x00)
								al_n = (byte) (__fxstat(1, eax_n, qwLoc0398_n) >> 0x1F);
							else
								al_n = (byte) (__xstat(1, r14_n, qwLoc0398_n) >> 0x1F);
							if (al_n != 0x00)
							{
								fn0000000000405810(r14_n, dcgettext(0x00, 4283624, 5), (word32) cl_n, fs);
								closedir(rax_n);
								goto l00000000004034A1;
							}
							Eq_n rcx_n;
							rcx_n.u4 = qwLoc0370;
							Eq_n rdx_n;
							rdx_n.u4 = tLoc0378.t0000.u4;
							Eq_n rax_n = fn0000000000410C40(0x10);
							struct Eq_n * rdi_n = g_ptr61B1C8;
							*rax_n.u5 = (word64) rcx_n;
							rax_n.u6[8] = (struct tm) rdx_n;
							Eq_n rax_n = fn000000000040BB50(rax_n, rdi_n);
							if (rax_n != 0x00)
							{
								if (rax_n != rax_n)
								{
									free(rax_n);
									fn000000000040EAB0(r14_n, fs);
									error(0, 0, dcgettext(0x00, 0x00415D10, 5), 0x00);
									closedir(rax_n);
									g_dw61B030 = 0x02;
									goto l00000000004034A1;
								}
								rax_n.u4 = g_t61AF18.u4;
								if (g_qw61AF20 - rax_n <= 0x0F)
								{
									_obstack_newchunk(0x0061AF00, 16);
									rax_n.u4 = g_t61AF18.u4;
								}
								g_t61AF18.u4 = (char *) (rax_n.u6 + 16);
								rax_n.u6[8] = (struct tm) tLoc0378;
								*rax_n.u5 = qwLoc0370;
								goto l00000000004035FF;
							}
l00000000004043BB:
							fn0000000000410E50();
						}
					}
					Eq_n rax_n;
					rax_n.u4 = g_t61B190.u4;
					qwLoc03A0_n = rax_n;
					if (r13d_n <= 0x01 && (rax_n != 0x00 && (rax_n.u6)[24] == 0x00))
						g_b61B0D0 = 0x00;
					goto l00000000004034D2;
				}
			}
			g_dw61B148 = 0x04;
		}
		if (g_dw61B150 != 0x00)
			goto l0000000000403301;
		goto l000000000040380D;
	}
	else
	{
		if (fn0000000000410E90(&tLoc0378, 0x00, 0x00, rax_n, 0x00) == 0x00)
		{
			Eq_n rax_n;
			rax_n.u4 = tLoc0378.t0000.u4;
			if (rax_n != 0x00)
			{
				g_t61B0C8.u4 = (char *) rax_n;
				goto l0000000000402AB1;
			}
		}
		fn000000000040E930(rax_n, fs);
		error(0, 0, dcgettext(0x00, 4283208, 5), 0x00);
		goto l0000000000402AB1;
	}
}

// 0000000000404890: void fn0000000000404890(Register (ptr64 Eq_n) rdx, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void fn0000000000404890(void (* rdx)(), word32 dwArg00, char * ptrArg08)
{
	__align_stack<word64>(&ptrArg08);
	word64 qwArg00;
	void * fp;
	__libc_start_main(&g_t4028C0, (int32) qwArg00, &ptrArg08, &g_t411E60, &g_t411ED0, rdx, fp);
	__halt();
}

// 00000000004048C0: void fn00000000004048C0()
void fn00000000004048C0()
{
	if (false || true)
		return;
	0x00();
}

// 00000000004049E0: Register byte fn00000000004049E0(Register Eq_n rcx, Register byte dl, Register (ptr64 Eq_n) rsi, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
byte fn00000000004049E0(Eq_n rcx, byte dl, struct Eq_n * rsi, Eq_n rdi)
{
	byte * r8_n = (byte *) rsi->dw0000;
	up32 eax_n = 0x00;
	Eq_n r9_n;
	r9_n.u4 = *rdi.u5;
	Eq_n r10_n;
	r10_n.u0 = 0x00;
	uint64 r11_n = 0x00;
	uint64 rax_n;
	do
	{
		if (eax_n == 0x02)
		{
			while (true)
			{
				uint64 rax_n = (uint64) *r8_n;
				if ((byte) rax_n > 55)
					break;
				r11_n = (uint64) ((word32) rax_n - 0x30 + (word32) r11_n * 0x08);
				++r8_n;
			}
			goto l0000000000404A65;
		}
		if (eax_n > 0x02)
		{
			word32 eax_n;
			byte al_n;
			if (eax_n != 0x03)
			{
				if (eax_n != 0x04)
					goto l0000000000404A70;
				uint64 rax_n = (uint64) *r8_n;
				eax_n = (word32) rax_n;
				al_n = (byte) rax_n;
				if ((byte) rax_n > 0x7E)
					goto l0000000000404A2E;
				goto l0000000000404AA0;
			}
l0000000000404AE0:
			uint64 rax_n = (uint64) *r8_n;
			word56 r11_56_8_n = SLICE(r11_n, word56, 8);
			uint64 rcx_n = (uint64) ((word32) rax_n - 0x30);
			word32 r11_32_32_n = SLICE(r11_56_8_n, word32, 24);
			ui32 r11d_n = SEQ((word24) r11_56_8_n, (byte) r11_n);
			while ((byte) rcx_n <= 0x36)
			{
				ui64 r14_n = 0x01 << (byte) rcx_n;
				byte r11b_n = (byte) r11d_n;
				word24 r11d_24_8_n = SLICE(r11d_n, word24, 8);
				ui32 r14d_n = (word32) r14_n;
				if ((r14d_n & 0x007E0000) == 0x00)
				{
					if ((r14_n & 0x7E000000000000) != 0x00)
					{
						++r8_n;
						r11_n = (uint64) ((word32) rax_n - 0x57 + (r11d_n << 0x04));
						goto l0000000000404AE0;
					}
					else
					{
						r11_n = SEQ(r11_32_32_n, r11d_24_8_n, r11b_n);
						if ((r14d_n & 0x03FF) == 0x00)
							break;
						++r8_n;
						r11_n = (uint64) ((word32) rax_n - 0x30 + (r11d_n << 0x04));
						goto l0000000000404AE0;
					}
				}
				++r8_n;
				rax_n = (uint64) *r8_n;
				r11_n = (uint64) ((word32) rax_n - 55 + (r11d_n << 0x04));
				rcx_n = (uint64) ((word32) rax_n - 0x30);
				r11_32_32_n = SLICE(r11_n, word32, 32);
				r11d_n = (word32) r11_n;
			}
l0000000000404A65:
			*r9_n.u4 = (byte) r11_n;
			++r10_n.u6;
			++r9_n.u6;
l0000000000404A70:
			while (true)
			{
l0000000000404A70:
				ci8 al_n = *r8_n;
				bool v47_n = al_n <= 0x3D;
				while (al_n != 0x3D)
				{
					if (v47_n)
					{
						if (al_n == 0x00 || al_n == 0x3A)
						{
							eax_n = 0x05;
							break;
						}
						goto l0000000000404B60;
					}
					if (al_n == 0x5C)
					{
						++r8_n;
						goto l0000000000404B29;
					}
					if (al_n != 0x5E)
						goto l0000000000404B60;
					++r8_n;
					uint64 rax_n = (uint64) *r8_n;
					eax_n = (word32) rax_n;
					al_n = (byte) rax_n;
					if ((byte) rax_n > 0x7E || (byte) rax_n < 0x40)
					{
l0000000000404A2E:
						if (al_n != 0x3F)
						{
							rax_n = 0x00;
							goto l0000000000404A38;
						}
						*r9_n.u4 = 0x7F;
						++r10_n.u6;
						++r9_n.u6;
						goto l0000000000404A70;
					}
l0000000000404AA0:
					*r9_n.u4 = (byte) eax_n & 0x1F;
					++r8_n;
					al_n = *r8_n;
					++r10_n.u6;
					++r9_n.u6;
					v47_n = al_n <= 0x3D;
				}
				if (dl != 0x00)
				{
					rax_n = 0x01;
					goto l0000000000404A38;
				}
l0000000000404B60:
				*r9_n.u4 = al_n;
				++r8_n;
				++r10_n.u6;
				++r9_n.u6;
			}
		}
		if (eax_n != 0x01)
			goto l0000000000404A70;
l0000000000404B29:
		uint64 rax_n = (uint64) *r8_n;
		cu8 al_n = (byte) rax_n;
		word32 eax_n = (word32) rax_n;
		uint64 r11_n;
		if (al_n <= 0x78)
		{
			switch (al_n)
			{
			case 0x00:
				eax_n = 0x06;
				goto l0000000000404BB0;
			case 0x01:
			case 0x02:
			case 0x03:
			case 0x04:
			case 0x05:
			case 0x06:
			case 0x07:
			case 0x08:
			case 0x09:
			case 0x0A:
			case 11:
			case 0x0C:
			case 0x0D:
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 22:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
			case 0x1B:
			case 0x1C:
			case 0x1D:
			case 0x1E:
			case 0x1F:
			case 0x20:
			case 33:
			case 0x22:
			case 0x23:
			case 0x24:
			case 0x25:
			case 0x26:
			case 0x27:
			case 0x28:
			case 0x29:
			case 0x2A:
			case 0x2B:
			case 44:
			case 0x2D:
			case 0x2E:
			case 0x2F:
			case 0x38:
			case 0x39:
			case 0x3A:
			case 0x3B:
			case 0x3C:
			case 0x3D:
			case 0x3E:
			case 0x40:
			case 0x41:
			case 66:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x46:
			case 0x47:
			case 0x48:
			case 0x49:
			case 0x4A:
			case 0x4B:
			case 0x4C:
			case 77:
			case 0x4E:
			case 0x4F:
			case 0x50:
			case 0x51:
			case 0x52:
			case 0x53:
			case 0x54:
			case 0x55:
			case 0x56:
			case 0x57:
			case 0x59:
			case 0x5A:
			case 0x5B:
			case 0x5C:
			case 0x5D:
			case 0x5E:
			case 0x60:
			case 99:
			case 100:
			case 0x67:
			case 0x68:
			case 0x69:
			case 0x6A:
			case 0x6B:
			case 0x6C:
			case 0x6D:
			case 111:
			case 0x70:
			case 113:
			case 115:
			case 117:
			case 0x77:
				goto l0000000000404C90;
			case 0x30:
			case 0x31:
			case 0x32:
			case 0x33:
			case 0x34:
			case 0x35:
			case 0x36:
			case 55:
				r11_n = (uint64) ((word32) rax_n - 0x30);
				eax_n = 0x02;
				goto l0000000000404BB0;
			case 0x3F:
				r11_n = 0x7F;
				break;
			case 88:
			case 0x78:
				eax_n = 0x03;
				r11_n = 0x00;
				goto l0000000000404BB0;
			case 0x5F:
				r11_n = 0x20;
				break;
			case 0x61:
				r11_n = 0x07;
				break;
			case 0x62:
				r11_n = 0x08;
				break;
			case 101:
				r11_n = 0x1B;
				break;
			case 0x66:
				r11_n = 0x0C;
				break;
			case 110:
				r11_n = 0x0A;
				break;
			case 114:
				r11_n = 0x0D;
				break;
			case 116:
				r11_n = 0x09;
				break;
			case 118:
				r11_n = 11;
				break;
			}
		}
		else
		{
l0000000000404C90:
			r11_n = (uint64) eax_n;
		}
		*r9_n.u4 = (byte) r11_n;
		++r10_n.u6;
		++r9_n.u6;
		eax_n = 0x00;
		r11_n = r11_n;
l0000000000404BB0:
		++r8_n;
	} while (eax_n <= 0x04);
	rax_n = SEQ(0x00, SLICE(eax_n, word24, 8), (int8) (eax_n != 0x06));
l0000000000404A38:
	*rdi.u5 = (word64) r9_n;
	rsi->dw0000 = (int32) r8_n;
	*rcx.u5 = (word64) r10_n;
	return (byte) rax_n;
}

// 0000000000404CD0: Register uint64 fn0000000000404CD0(Register word32 edi)
// Called from:
//      fn00000000004028C0
//      fn0000000000406540
//      fn0000000000406A30
//      fn0000000000407EA0
uint64 fn0000000000404CD0(word32 edi)
{
	uint64 rdi_n = (uint64) edi;
	uint64 rax_n = 0x00;
	word64 rdx_n = *((word64) 6398944 + rdi_n * 0x10);
	byte * rsi_n = (byte *) *((word64) 6398952 + rdi_n * 0x10);
	if (rdx_n == 0x00)
		return rax_n;
	if (rdx_n == 0x01)
		return (uint64) (*rsi_n != 0x30);
	rax_n = 0x01;
	if (rdx_n == 0x02)
		return (uint64) (memcmp(rsi_n, 0x00413733, 0x02) != 0x00);
	return rax_n;
}

// 0000000000404D20: void fn0000000000404D20(Register word32 edx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
//      fn0000000000405090
void fn0000000000404D20(word32 edx, Eq_n rsi, Eq_n rdi)
{
	word64 rdx;
	edx = (word32) rdx;
	byte r13b_n = (byte) edx;
	Eq_n rax_n = fn0000000000410C40(0x20);
	Eq_n rax_n;
	rax_n.u0 = 0x00;
	if (rsi != 0x00)
		rax_n = fn0000000000410E30(rsi);
	rax_n.u6[8] = (struct tm) rax_n;
	Eq_n rax_n;
	rax_n.u0 = 0x00;
	if (rdi != 0x00)
		rax_n = fn0000000000410E30(rdi);
	*rax_n.u5 = (word64) rax_n;
	Eq_n rax_n;
	rax_n.u4 = g_t61B190.u4;
	rax_n.u6[16] = (struct tm) r13b_n;
	g_t61B190.u4 = (char *) rax_n;
	rax_n.u6[24] = (struct tm) rax_n;
}

// 0000000000404D90: void fn0000000000404D90(Register Eq_n rdi)
// Called from:
//      fn0000000000404DD0
//      fn0000000000405090
void fn0000000000404D90(Eq_n rdi)
{
	free(*rdi.u5);
	free(rdi.u6[8]);
	Eq_n rdi_n = (Eq_n) rdi.u6[0x00A8];
	if (rdi_n == &g_b61A56A)
		return;
	freecon(rdi_n);
}

// 0000000000404DD0: void fn0000000000404DD0()
// Called from:
//      fn00000000004028C0
void fn0000000000404DD0()
{
	Eq_n rbx_n;
	rbx_n.u0 = 0x00;
	while (rbx_n < g_t61B1B0.u4)
	{
		fn0000000000404D90(g_t61B1A8.u4[rbx_n *64 0x08]);
		++rbx_n.u6;
	}
	g_t61B1B0.u4 = (char *) 0x00;
	g_b61B17C = 0x00;
	g_dw61B178 = 0x00;
	g_dw61B174 = 0x00;
	g_dw61B170 = 0x00;
	g_dw61B168 = 0x00;
	g_dw61B164 = 0x00;
	g_dw61B160 = 0x00;
	g_dw61B16C = 0x00;
	g_dw61B15C = 0x00;
	g_dw61B158 = 0x00;
	g_dw61B154 = 0x00;
}

// 0000000000404E80: void fn0000000000404E80()
// Called from:
//      fn00000000004028C0
void fn0000000000404E80()
{
	Eq_n rbx_n;
	rbx_n.u4 = g_t61B1B0.u4;
	Eq_n rbp_n = rbx_n;
	if (rbx_n.u4 + (rbx_n >> 0x01) > g_qw61B1A0)
	{
		free(g_t61B1A8.u4);
		if (rbx_n > 0xAAAAAAAAAAAAAAA)
			fn0000000000410E50();
		Eq_n rax_n = fn0000000000410C40(rbx_n *64 0x18);
		rbp_n.u4 = g_t61B1B0.u4;
		g_t61B1A8.u4 = (char *) rax_n;
		g_qw61B1A0 = rbp_n *64 0x03;
	}
	if (rbp_n != 0x00)
	{
		Eq_n rax_n;
		rax_n.u4 = g_t61B1A8.u4;
		Eq_n rdx_n;
		rdx_n.u4 = g_t61B1C0.u4;
		Eq_n rcx_n;
		rcx_n.u4 = rax_n.u4 + rbp_n *64 0x08;
		do
		{
			*rax_n.u5 = (word64) rdx_n;
			rax_n.u6 += 8;
			rdx_n.u4 = (word32) rdx_n + 0x00C0;
		} while (rax_n != rcx_n);
	}
	if (g_dw61B148 == ~0x00)
		return;
	int32 eax_n = _setjmp(6399616);
	Eq_n rsi_n;
	Eq_n rdi_n;
	word32 ecx_n;
	if (eax_n != 0x00)
	{
		word32 r8d_n = g_dw61B148;
		if (r8d_n == 0x03)
			__assert_fail(0x0041373F, 4273974, 0x0DDB, 4271253);
		rsi_n.u4 = g_t61B1B0.u4;
		rdi_n.u4 = g_t61B1A8.u4;
		if (rsi_n != 0x00)
		{
			Eq_n rdx_n;
			rdx_n.u4 = g_t61B1C0.u4;
			Eq_n rcx_n;
			rcx_n.u4 = rdi_n.u4 + rsi_n *64 0x08;
			Eq_n rax_n = rdi_n;
			do
			{
				*rax_n.u5 = (word64) rdx_n;
				rax_n.u6 += 8;
				rdx_n.u4 = (word32) rdx_n + 0x00C0;
			} while (rax_n != rcx_n);
		}
		ecx_n = r8d_n;
		eax_n = 0x01;
	}
	else
	{
		ecx_n = g_dw61B148;
		rsi_n.u4 = g_t61B1B0.u4;
		rdi_n.u4 = g_t61B1A8.u4;
	}
	up32 edx_n = 0x00;
	if (ecx_n == 0x04)
		edx_n = g_dw61B14C;
	fn000000000040D690(*((word64) 0x00412D00 + ((uint64) g_b61B10C + ((uint64) g_b61B147 + ((int64) eax_n + (uint64) (edx_n + ecx_n) * 0x02) * 0x02) * 0x02) * 0x08), rbx_n, rsi_n, rdi_n);
}

// 0000000000405090: void fn0000000000405090(Register byte sil, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
void fn0000000000405090(byte sil, Eq_n rdi)
{
	word64 rsi;
	sil = (byte) rsi;
	word32 r14d_n = (word32) sil;
	if (rdi != 0x00 && g_ptr61B1C8 != null)
		fn0000000000404D20(0x00, rdi, 0x00);
	Eq_n rbx_n;
	rbx_n.u4 = g_t61B1B0.u4;
	for (; rbx_n != 0x00; --rbx_n)
	{
		Eq_n rbp_n;
		rbp_n.u4 = *g_t61B1A8.u4;
		word32 eax_n = (word32) rbp_n.u6[0x00A0];
		if (eax_n == 0x09 || eax_n == 0x03)
		{
			Eq_n r15_n;
			r15_n.u4 = *rbp_n.u5;
			if (rdi != 0x00)
			{
				Eq_n rax_n = fn000000000040A390(r15_n);
				if (*rax_n.u1 == 0x2E)
				{
					byte al_n = rax_n.u2->a0001[(uint64) (*((word32) rax_n + 1) == 0x2E)];
					if (al_n != 0x2F && al_n != 0x00)
						goto l00000000004050D8;
					goto l0000000000405100;
				}
l00000000004050D8:
				if (*r15_n.u4 == 0x2F)
					goto l00000000004050E2;
				Eq_n rax_n = fn000000000040A610(0x00, r15_n, rdi);
				fn0000000000404D20(r14d_n, rbp_n.u6[8], rax_n);
				free(rax_n);
				if (rbp_n.u6[0x00A0] == 0x09)
					goto l0000000000405194;
			}
			else
			{
l00000000004050E2:
				fn0000000000404D20(r14d_n, rbp_n.u6[8], r15_n);
				if (rbp_n.u6[0x00A0] == 0x09)
				{
l0000000000405194:
					fn0000000000404D90(rbp_n);
				}
			}
		}
l0000000000405100:
	}
	Eq_n rdi_n;
	rdi_n.u4 = g_t61B1B0.u4;
	Eq_n rdx_n;
	if (rdi_n != 0x00)
	{
		Eq_n rsi_n;
		rsi_n.u4 = g_t61B1A8.u4;
		rdx_n.u0 = 0x00;
		Eq_n rax_n;
		rax_n.u0 = 0x00;
		do
		{
			Eq_n rcx_n;
			rcx_n.u4 = rsi_n.u5[rax_n];
			rsi_n.u5[rdx_n] = (word64) rcx_n;
			++rax_n.u6;
			rdx_n.u4 += (uint64) (rcx_n.u6[0x00A0] != 0x09);
		} while (rax_n != rdi_n);
	}
	else
		rdx_n.u0 = 0x00;
	g_t61B1B0.u4 = (char *) rdx_n;
}

// 0000000000405200: void fn0000000000405200(Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn00000000004079F0
void fn0000000000405200(Eq_n rsi, Eq_n rdi)
{
	Eq_n rbx_n = rdi;
	if (rdi < rsi)
	{
		do
		{
			uint64 rcx_n = g_qw61B0D8;
			if (rcx_n == 0x00)
			{
				++rbx_n.u6;
				goto l000000000040527B;
			}
			Eq_n rsi_n;
			rsi_n.u6 = rbx_n.u6 + 1;
			if ((uint128) rsi /u rcx_n > (uint128) rsi_n /u rcx_n)
			{
				Eq_n rdi_n;
				rdi_n.u0 = stdout.u0;
				byte * rax_n = (byte *) *((word32) rdi_n + 40);
				if (rax_n < *((word32) rdi_n + 48))
				{
					*((word32) rdi_n + 40) = rax_n + 1;
					*rax_n = 0x09;
				}
				else
				{
					__overflow(rdi_n, 9);
					rcx_n = g_qw61B0D8;
				}
				rbx_n = rbx_n.u4 + rcx_n - (uint128) rbx_n % rcx_n;
				goto l0000000000405266;
			}
			rbx_n = rsi_n;
l000000000040527B:
			Eq_n rdi_n;
			rdi_n.u0 = stdout.u0;
			byte * rdx_n = (byte *) *((word32) rdi_n + 40);
			if (rdx_n >= *((word32) rdi_n + 48))
			{
				__overflow(rdi_n, 32);
l0000000000405266:
				if (rsi > rbx_n)
					continue;
				return;
			}
			*((word32) rdi_n + 40) = rdx_n + 1;
			*rdx_n = 0x20;
		} while (rsi > rbx_n);
	}
}

// 00000000004052D0: Register Eq_n fn00000000004052D0(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi, Register Eq_n r12, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
//      fn0000000000405D50
//      fn0000000000406540
Eq_n fn00000000004052D0(Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi, Eq_n r12, struct Eq_n * fs)
{
	wchar_t wLoc205C;
	Eq_n fp;
	word64 rax_n = fs->qw0028;
	Eq_n rax_n = fn000000000040E6F0(~0x00, rsi, 0x2000, fp - 8264, rdx, fs);
	Eq_n rbx_n = rax_n;
	Eq_n qwLoc2070_n = fp - 8264;
	if (rax_n > 0x1FFF)
	{
		Eq_n v26_n = (word64) (fp - 0x2088 - ((word32) rax_n + 31 & ~0x0F)) + 0x0F & ~0x0F;
		fn000000000040E6F0(~0x00, rsi, rax_n.u6 + 1, v26_n, rdx, fs);
		qwLoc2070_n = v26_n;
	}
	if (g_b61B0F0 == 0x00)
	{
		if (rcx != 0x00)
		{
			if (__ctype_get_mb_cur_max() > 0x01)
				r12.u4 = (int64) fn000000000040D240(0x00, rax_n, qwLoc2070_n, fs);
			else
			{
				Eq_n r13_n = qwLoc2070_n + rax_n;
				if (qwLoc2070_n < r13_n)
				{
					r12.u0 = 0x00;
					cui16 rcx_n[] = (cui16 (*)[]) *__ctype_b_loc();
					Eq_n rax_n = qwLoc2070_n;
					do
					{
						r12 = r12 - ~0x00 - (word64) ((rcx_n[(uint64) (*rax_n.u4)] & 0x4000) < 0x01);
						++rax_n;
					} while (rax_n != r13_n);
				}
				else
					r12.u0 = 0x00;
			}
		}
	}
	else if (__ctype_get_mb_cur_max() > 0x01)
	{
		Eq_n r15_n = qwLoc2070_n;
		Eq_n r13_n = qwLoc2070_n + rax_n;
		if (qwLoc2070_n < r13_n)
		{
			Eq_n rbx_n = qwLoc2070_n;
			r12.u0 = 0x00;
			do
			{
l0000000000405440:
				uint64 rax_n = (uint64) *r15_n.u4;
				ci8 al_n = (byte) rax_n;
				if (al_n <= 0x3F)
				{
					if (al_n < 0x25 && (byte) rax_n > 0x23)
						goto l0000000000405460;
				}
				else if (al_n < 0x41 || al_n > 0x5F && ((byte) rax_n > 0x7E || (byte) rax_n < 0x61))
				{
l0000000000405460:
					Eq_n tLoc2058 = (Eq_n) 0x00;
					do
					{
						Eq_n rax_n = mbrtowc(&wLoc205C, r15_n, r13_n - r15_n, &tLoc2058);
						Eq_n r14_n = rax_n;
						if (rax_n == ~0x00)
						{
							*rbx_n.u4 = 0x3F;
							++r15_n;
							++r12.u6;
							++rbx_n;
							if (r15_n >= r13_n)
								goto l0000000000405502;
							goto l0000000000405440;
						}
						if (rax_n == ~0x01)
						{
							*rbx_n.u4 = 0x3F;
							r15_n = r13_n;
							++r12.u6;
							++rbx_n;
							if (r13_n >= r13_n)
								goto l0000000000405502;
							goto l0000000000405440;
						}
						uint64 rdi_n = (uint64) wLoc205C;
						if (rax_n == 0x00)
							r14_n.u0 = 0x01;
						int32 eax_n = wcwidth((wchar_t) rdi_n);
						if (eax_n >= 0x00)
						{
							Eq_n rsi_n = r15_n + r14_n;
							Eq_n rdx_n = rbx_n;
							do
							{
								++r15_n;
								++rdx_n;
								rdx_n.u6->bFFFFFFFF = r15_n.u6->bFFFFFFFF;
							} while (r15_n != rsi_n);
							rbx_n += r14_n;
							r12.u4 += (int64) eax_n;
						}
						else
						{
							*rbx_n.u4 = 0x3F;
							r15_n += r14_n;
							++r12.u6;
							++rbx_n;
						}
					} while (mbsinit(&tLoc2058) == 0x00);
					if (r15_n >= r13_n)
						break;
					continue;
				}
				*rbx_n.u4 = al_n;
				++r15_n;
				++r12.u6;
				++rbx_n;
			} while (r15_n < r13_n);
l0000000000405502:
			rbx_n = rbx_n - qwLoc2070_n;
		}
		else
		{
			rbx_n.u0 = 0x00;
			r12.u0 = 0x00;
		}
	}
	else
	{
		Eq_n r12_n = qwLoc2070_n + rax_n;
		if (qwLoc2070_n < r12_n)
		{
			uint16 ** rax_n = __ctype_b_loc();
			Eq_n rdx_n = qwLoc2070_n;
			do
			{
				if ((*((char *) *rax_n + ((uint64) (*rdx_n.u4) * 0x02 + 1)) & 0x40) == 0x00)
					*rdx_n.u4 = 0x3F;
				++rdx_n;
			} while (rdx_n != r12_n);
		}
		r12 = rax_n;
	}
	if (rdi != 0x00)
		fwrite_unlocked(qwLoc2070_n, 0x01, rbx_n, rdi);
	if (rcx != 0x00)
		*rcx = r12;
	if ((rax_n ^ fs->qw0028) == 0x00)
		return rdi;
	__stack_chk_fail();
}

// 0000000000405630: void fn0000000000405630(Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
void fn0000000000405630(Eq_n rsi, Eq_n rdi)
{
	Eq_n rax_n;
	rax_n.u0 = rsi.u1->t0018.u0;
	Eq_n rbp_n;
	rbp_n.u0 = rsi.u1->t0010.u0;
	uint64 r12_n = (uint64) ((word32) (rax_n - rbp_n) >> 0x03);
	if (r12_n == 0x00)
		return;
	if (rax_n == rbp_n)
		rsi.u1->b0050 |= 0x02;
	int64 rcx_n = (int64) rsi.u1->dw0030;
	Eq_n rcx_n;
	rcx_n.u0 = rsi.u1->t0020.u0;
	Eq_n rdx_n = (int64) ~(word32) rcx_n & (char *) (&(rax_n.u1)->dw0000) + rcx_n;
	int64 rax_n = rsi.u1->qw0008;
	rsi.u1->t0018.u0 = (int64) rdx_n;
	if (rdx_n - rax_n > rcx_n - rax_n)
		rsi.u1->t0018.u0 = (int64) rcx_n;
	rsi.u1->t0010.u0 = rsi.u1->t0018.u0;
	fputs_unlocked(rdi, stdout.u0);
	uint64 rbx_n = 0x00;
	do
	{
		__printf_chk(1, " %lu", *((word32) rbp_n + rbx_n * 0x08));
		++rbx_n;
	} while (r12_n > rbx_n);
	Eq_n rdi_n;
	rdi_n.u0 = stdout.u0;
	byte * rax_n = (byte *) *((word32) rdi_n + 40);
	if (rax_n >= *((word32) rdi_n + 48))
		__overflow(rdi_n, 0x0A);
	else
	{
		*((word32) rdi_n + 40) = rax_n + 1;
		*rax_n = 0x0A;
	}
}

// 0000000000405700: void fn0000000000405700(Register int32 edx, Register word32 esi, Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004057B0
//      fn0000000000406B70
void fn0000000000405700(int32 edx, word32 esi, Eq_n rdi, struct Eq_n * fs)
{
	word64 rdx;
	edx = (word32) rdx;
	Eq_n rbp_n;
	if (rdi != 0x00)
	{
		int32 eax_n = fn000000000040D420(0x00, rdi, fs);
		Eq_n rsi_n;
		rsi_n.u0 = stdout.u0;
		int32 ebx_n = edx - eax_n;
		if (ebx_n < 0x00)
			ebx_n = 0x00;
		fputs_unlocked(rdi, rsi_n);
		rbp_n = strlen(rdi).u4 + (int64) ebx_n;
		do
		{
			Eq_n rdi_n;
			rdi_n.u0 = stdout.u0;
			byte * rcx_n = (byte *) *((word32) rdi_n + 40);
			if (rcx_n < *((word32) rdi_n + 48))
			{
				*((word32) rdi_n + 40) = rcx_n + 1;
				*rcx_n = 0x20;
			}
			else
				__overflow(rdi_n, 32);
			--ebx_n;
		} while (ebx_n != ~0x00);
	}
	else
	{
		word64 rsi;
		__printf_chk(1, "%*lu ", edx, (uint32) rsi);
		rbp_n.u0 = (int64) edx;
	}
	g_t61B018.u0 = (int64) ((word32) rbp_n + 1 + g_t61B018.u0);
}

// 00000000004057B0: void fn00000000004057B0(Register byte dl, Register int32 esi, Register uint64 rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn0000000000406B70
void fn00000000004057B0(byte dl, int32 esi, uint64 rdi, struct Eq_n * fs)
{
	word32 edi = (word32) rdi;
	Eq_n rax_n;
	rax_n.u0 = 4274020;
	uint64 rbx_n = (uint64) edi;
	if (dl != 0x00)
	{
		rax_n.u0 = 0x00;
		if (g_b61B145 == 0x00)
			rax_n = fn000000000040C9B0((word32) rdi);
	}
	uint64 rdx_n = (uint64) esi;
	fn0000000000405700((word32) rdx_n, (word32) rbx_n, rax_n, fs);
}

// 0000000000405810: void fn0000000000405810(Register Eq_n rdx, Register (ptr64 char) rsi, Register word32 edi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
//      fn0000000000407EA0
void fn0000000000405810(Eq_n rdx, char * rsi, word32 edi, struct Eq_n * fs)
{
	fn000000000040EAB0(rdx, fs);
	error(0, *__errno_location(), rsi, 0x00);
	if ((byte) edi == 0x00)
	{
		if (g_dw61B030 != 0x00)
			return;
		g_dw61B030 = 0x01;
	}
	else
		g_dw61B030 = 0x02;
}

// 0000000000405C20: Register ui32 fn0000000000405C20(Register word32 ecx, Register word32 edx, Register Eq_n esi, Register byte dil)
// Called from:
//      fn0000000000405D00
//      fn0000000000405D50
ui32 fn0000000000405C20(word32 ecx, word32 edx, Eq_n esi, byte dil)
{
	word64 rcx;
	ui24 ecx_24_n = SLICE(rcx, word24, 8);
	word64 rsi;
	esi = (word32) rsi;
	word56 rcx_56_8_n = SLICE(rcx, word56, 8);
	uint64 rax_n;
	uint64 rcx_n;
	if (dil != 0x00)
	{
		if ((esi & 0xF000) == 0x8000)
		{
			rax_n = 0x00;
			if (g_dw61B12C == 0x03)
				return (word32) ((esi & 0x49) < 0x01) - 1 & 0x2A;
			return (word32) rax_n;
		}
		rcx_n = SEQ(rcx_56_8_n, (int8) ((esi & 0xF000) == 0x4000));
	}
	else
	{
		rax_n = 0x00;
		if (edx == 0x05)
			return (word32) rax_n;
		rcx_n = (uint64) (SEQ(ecx_24_n, (int8) (edx == 0x09)) | (uint32) (edx == 0x03));
	}
	rax_n = 0x2F;
	if ((byte) rcx_n != 0x00)
		return (word32) rax_n;
	if (g_dw61B12C == 0x01)
		return 0x00;
	uint32 eax_n;
	if (dil == 0x00)
	{
		rax_n = 0x40;
		if (edx == 0x06)
			return (word32) rax_n;
		rax_n = 0x7C;
		if (edx == 0x01)
			return (word32) rax_n;
		eax_n = (uint32) (edx == 0x07);
		return -eax_n & 0x3D;
	}
	else
	{
		rax_n = 0x40;
		if ((esi & 0xF000) == 0xA000)
			return (word32) rax_n;
		rax_n = 0x7C;
		if ((esi & 0xF000) == 0x1000)
			return (word32) rax_n;
		eax_n = (uint32) ((esi & 0xF000) == 0xC000);
		return -eax_n & 0x3D;
	}
}

// 0000000000405D00: Register int8 fn0000000000405D00(Register word64 rcx, Register word32 edx, Register uint64 rsi, Register byte dil)
// Called from:
//      fn0000000000406B70
//      fn0000000000407870
int8 fn0000000000405D00(word64 rcx, word32 edx, uint64 rsi, byte dil)
{
	word64 rdx;
	edx = (word32) rdx;
	uint64 rax_n = (uint64) fn0000000000405C20((word32) rcx, edx, (word32) rsi, dil);
	byte bl_n = (byte) rax_n;
	if ((byte) rax_n != 0x00)
	{
		Eq_n rdi_n;
		rdi_n.u0 = stdout.u0;
		byte * rax_n = (byte *) *((word32) rdi_n + 40);
		word32 rax_32_32_n = SLICE(rax_n, word32, 32);
		if (rax_n < *((word32) rdi_n + 48))
		{
			*((word32) rdi_n + 40) = rax_n + 1;
			*rax_n = bl_n;
		}
		else
			__overflow(rdi_n, (int32) bl_n);
		g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x01);
	}
	return (int8) (bl_n != 0x00);
}

// 0000000000405D50: Register Eq_n fn0000000000405D50(Register Eq_n rdi, Register Eq_n r12, Register (ptr32 Eq_n) fs)
// Called from:
//      fn0000000000405ED0
//      fn00000000004079F0
Eq_n fn0000000000405D50(Eq_n rdi, Eq_n r12, struct Eq_n * fs)
{
	Eq_n tLoc02C0;
	Eq_n rbx_n;
	rbx_n.u1 = 0x00;
	word64 rax_n = fs->qw0028;
	Eq_n tLoc02B8;
	if (g_b61B114 != 0x00)
	{
		if (g_dw61B150 != 0x04)
			rbx_n = (int64) g_dw61B178 + 0x01;
		else
			rbx_n = strlen(fn000000000040CD70(&tLoc02B8, rdi.u6[24])).u6 + 1;
	}
	if (g_b61B144 != 0x00)
	{
		Eq_n rax_n;
		if (g_dw61B150 != 0x04)
			rax_n = (int64) g_dw61B174 + 0x01;
		else
		{
			rax_n.u0 = 0x02;
			if (rdi.u6[0x00B0] != 0x00)
				rax_n = strlen(fn000000000040BD70(0x0200, g_dw61B140, &tLoc02B8, rdi.u6[80], g_t61B138.u0, fs)).u6 + 1;
		}
		rbx_n += rax_n;
	}
	if (g_b61B17D != 0x00)
	{
		Eq_n rax_n;
		if (g_dw61B150 != 0x04)
			rax_n = (int64) g_dw61B16C + 0x01;
		else
			rax_n = strlen(rdi.u6[0x00A8]).u6 + 1;
		rbx_n += rax_n;
	}
	Eq_n rcx_n = fn00000000004052D0(&tLoc02C0, g_t61B0E8.u0, *rdi.u5, 0x00, r12, fs);
	Eq_n rbx_n = (word32) rbx_n + (tLoc02C0.t0000).u0;
	if (g_dw61B12C != 0x00)
		rbx_n = (word32) rbx_n + (uint64) ((byte) fn0000000000405C20((word32) rcx_n, (rdi.u6)[0x00A0], (rdi.u6)[40], (rdi.u6)[0x00B0]) != 0x00);
	if ((rax_n ^ fs->qw0028) == 0x00)
		return rbx_n;
	__stack_chk_fail();
}

// 0000000000405ED0: Register Eq_n fn0000000000405ED0(Register word32 edi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004079F0
Eq_n fn0000000000405ED0(word32 edi, struct Eq_n * fs)
{
	word64 rdi;
	edi = (word32) rdi;
	Eq_n rdx_n;
	rdx_n.u4 = g_t61B1B0.u4;
	Eq_n rax_n;
	rax_n.u4 = g_t61B020.u4;
	Eq_n r12_n;
	r12_n.u4 = (uint64) edi;
	Eq_n rbx_n = rdx_n;
	if (rax_n <= rdx_n)
		rbx_n = rax_n;
	Eq_n rax_n;
	Eq_n r8_n;
	Eq_n rsi_n;
	if (rbx_n <= g_t61A660.u4)
	{
		rax_n.u0 = 0x00;
		r8_n = rdx_n;
		rsi_n.u4 = g_t61B028.u4;
		if (rbx_n == 0x00)
			goto l0000000000406004;
		goto l00000000004060E0;
	}
	Eq_n rdi_n;
	rdi_n.u4 = g_t61B028.u4;
	Eq_n rbp_n;
	if (rbx_n >= rax_n >> 0x01)
	{
		if (rax_n > 0xAAAAAAAAAAAAAAA)
			goto l000000000040619D;
		Eq_n rax_n = fn0000000000410C90(rax_n *64 0x18, rdi_n);
		rbp_n.u4 = g_t61B020.u4;
		g_t61B028.u4 = (char *) rax_n;
	}
	else
	{
		if (rbx_n > 0x555555555555555)
			goto l000000000040619D;
		rbp_n = rbx_n *64 0x02;
		Mem60[0x000000000061B028<p64>:word64] = fn0000000000410C90(rbp_n + rbx_n << 0x04, rdi_n);
	}
	Eq_n rax_n;
	rax_n.u4 = g_t61A660.u4;
	Eq_n rsi_n = rbp_n + 1 + rax_n;
	Eq_n rdi_n = rbp_n - rax_n;
	Eq_n rcx_n = rsi_n *s64 rdi_n;
	if (rbp_n <= rsi_n && (rsi_n == (uint128) rcx_n /u rdi_n && rcx_n >> 0x01 <= 0x1FFFFFFFFFFFFFFF))
	{
		Eq_n rax_n = fn0000000000410C40((rcx_n >> 0x01) * 0x08);
		Eq_n rcx_n;
		rcx_n.u4 = g_t61A660.u4;
		if (rbp_n > rcx_n)
		{
			Eq_n rsi_n;
			rsi_n.u4 = g_t61B028.u4;
			ui64 rcx_n = rcx_n *64 0x08 + 8;
			struct Eq_n * rdx_n = (struct Eq_n *) (rsi_n.u4 + rcx_n *64 0x18 + 16);
			struct Eq_n * rsi_n = (struct Eq_n *) (rsi_n.u4 + rbp_n *64 0x18);
			do
			{
				rdx_n->qw0000 = (word64) rax_n;
				++rdx_n;
				rax_n.u4 += rcx_n;
				rcx_n += 0x08;
			} while (rdx_n != rsi_n);
		}
		g_t61A660.u4 = (char *) rbp_n;
		rax_n.u0 = 0x00;
		r8_n.u4 = g_t61B1B0.u4;
		rsi_n.u4 = g_t61B028.u4;
		if (rbx_n == 0x00)
		{
l0000000000406004:
			Eq_n rbp_n;
			rbp_n.u0 = 0x00;
			if (r8_n != 0x00)
			{
				Eq_n r14_n;
				do
				{
					Eq_n rax_n = fn0000000000405D50(g_t61B1A8.u4[rbp_n *64 0x08], r12_n, fs);
					r14_n.u4 = g_t61B1B0.u4;
					if (rbx_n != 0x00)
					{
						Eq_n r13_n;
						r13_n.u4 = g_t61B0C8.u4;
						Eq_n rsi_n;
						rsi_n.u4 = g_t61B028.u4;
						Eq_n rcx_n;
						rcx_n.u0 = 0x01;
						Eq_n rcx_n;
						do
						{
							byte r12b_n = (byte) r12_n;
							uint64 r9_n = rcx_n - 1;
							if (*rsi_n.u4 != 0x00)
							{
								uint64 r10_n;
								if (r12b_n == 0x00)
									r10_n = (uint128) rbp_n % rcx_n;
								else
									r10_n = (uint128) rbp_n /u ((uint128) (rcx_n.u4 + (r14_n - 1)) /u rcx_n);
								up64 * rax_n = rsi_n.u7->qw0010 + r10_n * 0x08;
								up64 rdx_n = rax_n.u4 + (uint64) (r9_n != r10_n) * 0x02;
								up64 r9_n = *rax_n;
								if (rdx_n > r9_n)
								{
									rsi_n.u6[8] = (struct tm) (rsi_n.u6[8].a0000.u4.u4 + (rdx_n - r9_n));
									*rax_n = rdx_n;
									*rsi_n.u4 = (char) (int8) (rsi_n.u6[8] < r13_n);
								}
							}
							rsi_n.u6 += 24;
							rcx_n.u6 = rcx_n.u6 + 1;
							rcx_n = rcx_n;
						} while (rbx_n > rcx_n);
					}
					++rbp_n.u6;
				} while (rbp_n < r14_n);
			}
			if (rbx_n > 0x01)
			{
				Eq_n rdx_n;
				rdx_n.u4 = g_t61B028.u4;
				ui64 rax_n = rbx_n *64 0x03;
				if ((rdx_n - 24)[rax_n].b0000 == 0x00)
				{
					Eq_n rax_n = rdx_n.u4 + (rax_n << 0x03);
					do
					{
						--rbx_n;
						if (rbx_n == 0x01)
							return rbx_n;
						rax_n -= 0x18;
					} while (rax_n.u1->bFFFFFFE8 == 0x00);
				}
			}
			return rbx_n;
		}
l00000000004060E0:
		while (true)
		{
			word64 rcx_n[] = rsi_n.u7->qw0010;
			*rsi_n.u4 = 0x01;
			Eq_n rdi_n;
			rdi_n.u6 = rax_n.u6 + 1;
			rsi_n.u6[8] = (struct tm) (rdi_n *64 0x03);
			Eq_n rdx_n;
			rdx_n.u0 = 0x00;
			do
			{
				rcx_n[rdx_n] = 0x03;
				++rdx_n.u6;
			} while (rdx_n <= rax_n);
			rsi_n.u6 += 24;
			if (rdi_n == rbx_n)
				break;
			rax_n = rdi_n;
		}
		goto l0000000000406004;
	}
l000000000040619D:
	fn0000000000410E50();
}

// 00000000004061B0: Register word32 fn00000000004061B0(Register uint64 rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn0000000000405ED0
//      fn0000000000407EA0
word32 fn00000000004061B0(uint64 rdi, struct Eq_n * fs)
{
	ptr64 fp;
	uint32 edi = (word32) rdi;
	word64 rax_n = fs->qw0028;
	uint64 rdx_n;
	if (g_b61B145 == 0x00)
	{
		Eq_n rax_n = fn000000000040C9B0((word32) rdi);
		if (rax_n != 0x00)
		{
			int32 eax_n = fn000000000040D420(0x00, rax_n, fs);
			int32 edx_n = 0x00;
			if (eax_n >= 0x00)
				edx_n = eax_n;
			rdx_n = (uint64) edx_n;
l000000000040622B:
			uint64 rax_n = (uint64) (word32) rdx_n;
			if ((rax_n ^ fs->qw0028) == 0x00)
				return (word32) rax_n;
			__stack_chk_fail();
		}
	}
	char bLoc38;
	__sprintf_chk(&bLoc38, 1, 0x15, "%lu", edi);
	word32 ebx_n = (word32) fp - 0x38;
	union Eq_n * rax_n = &bLoc38;
	uint32 edx_n;
	bui8 dl_n;
	do
	{
		uint64 rcx_n = (uint64) rax_n->u1;
		uint64 rdx_n = (uint64) ((word32) rcx_n - 0x01010101 & ~((word32) rcx_n) & 0x80808080);
		rax_n = (union Eq_n *) ((char *) rax_n + 4);
		edx_n = (word32) rdx_n;
		dl_n = (byte) rdx_n;
	} while (edx_n == 0x00);
	if ((edx_n & 0x8080) == 0x00)
		dl_n = (byte) (edx_n >> 0x10);
	if ((edx_n & 0x8080) == 0x00)
		rax_n = (union Eq_n *) ((char *) rax_n + 2);
	rdx_n = (uint64) ((word32) rax_n - 0x03 - (word32) (dl_n * 0x02 < 0x00) - ebx_n);
	goto l000000000040622B;
}

// 0000000000406400: void fn0000000000406400()
// Called from:
//      fn0000000000406440
//      fn0000000000406540
void fn0000000000406400()
{
	Eq_n rdi;
	if (g_qw61A408 == 0x00)
	{
		word64 rcx_n;
		fn0000000000406440(6398944, out rcx_n);
		word64 rcx_n;
		fn0000000000406440(6398992, out rcx_n);
		word64 rcx_n;
		fn0000000000406440(rdi, out rcx_n);
	}
	else
	{
		word64 rcx_n;
		fn0000000000406440(rdi, out rcx_n);
	}
}

// 0000000000406440: Register Eq_n fn0000000000406440(Register Eq_n rdi, Register out Eq_n rcxOut)
// Called from:
//      fn00000000004028C0
//      fn0000000000406400
//      fn0000000000406490
//      fn0000000000406540
//      fn0000000000406A30
Eq_n fn0000000000406440(Eq_n rdi, union Eq_n & rcxOut)
{
	if (g_b61B128 == 0x00)
	{
		g_b61B128 = 0x01;
		fn0000000000406400();
	}
	Eq_n rcx_n;
	rcx_n.u0 = stdout.u0;
	Eq_n rax_n = fwrite_unlocked(rdi.u1->t0008.u4, rdi.u1->t0000.u4, 0x01, rcx_n);
	rcxOut = rcx_n;
	return rax_n;
}

// 0000000000406490: void fn0000000000406490()
// Called from:
//      fn00000000004028C0
//      fn0000000000406540
void fn0000000000406490()
{
	while (g_dw61B038 != 0x00 || g_dw61B034 != 0x00)
	{
		if (g_b61B128 != 0x00)
		{
			word64 rcx_n;
			fn0000000000406440(6398944, out rcx_n);
			word64 rcx_n;
			fn0000000000406440(6398960, out rcx_n);
		}
		fflush_unlocked(stdout.u0);
		word64 qwLoc88;
		sigprocmask(0, 0x0061B040, &qwLoc88);
		int32 ebx_n = g_dw61B038;
		word32 eax_n = g_dw61B034;
		if (eax_n != 0x00)
		{
			g_dw61B034 = eax_n - 0x01;
			ebx_n = 0x13;
		}
		else
			signal(ebx_n, 0x00);
		raise(ebx_n);
		sigprocmask(2, &qwLoc88, 0x00);
	}
}

// 0000000000406540: Register Eq_n fn0000000000406540(Register Eq_n rax, Register Eq_n rcx, Register Eq_n rdx, Register byte sil, Register Eq_n rdi, Register (ptr32 Eq_n) fs, Register out Eq_n rcxOut)
// Called from:
//      fn0000000000406B70
//      fn0000000000407870
Eq_n fn0000000000406540(Eq_n rax, Eq_n rcx, Eq_n rdx, byte sil, Eq_n rdi, struct Eq_n * fs, union Eq_n & rcxOut)
{
	Eq_n rdx_n;
	rdx_n.u4 = *rdi.u5;
	Eq_n r12_n;
	r12_n.u4 = rdi.u6[8];
	byte r14b_n;
	ui32 r14d_n;
	Eq_n r15d_n;
	if (sil != 0x00)
	{
		if (g_b61B129 == 0x00)
		{
			r14b_n = 0x00;
			goto l00000000004066FF;
		}
		uint64 r14_n = (uint64) rdi.u6[177];
		r14d_n = (word32) r14_n;
		r15d_n.u4 = rdi.u6[0x00A4];
		ui32 edx_n;
		if ((byte) r14_n == 0x00)
		{
			edx_n = 0x0C;
			if ((byte) fn0000000000404CD0(0x0C) != 0x00)
				goto l00000000004066B0;
		}
l00000000004065B0:
		byte r14b_n = (byte) r14d_n;
		byte r15b_n = (byte) r15d_n;
		if (rdi.u6[0x00B0] == 0x00)
		{
			uint64 rax_n = (uint64) rdi.u6[0x00A0];
			edx_n = (ui32) *((word64) 4271200 + rax_n * 0x04);
			if (edx_n == 0x05)
				goto l00000000004065CF;
			r14b_n = (byte) r14d_n & (int8) (edx_n == 0x07);
		}
		else
		{
			ui32 eax_n = r15d_n & 0xF000;
			if (eax_n == 0x8000)
			{
				if ((r15d_n & 0x0800) != 0x00 && (byte) fn0000000000404CD0(0x10) != 0x00)
				{
					edx_n = 0x10;
					goto l00000000004066B0;
				}
				if ((r15d_n & 0x0400) != 0x00 && (byte) fn0000000000404CD0(0x11) != 0x00)
				{
					edx_n = 0x11;
					goto l00000000004066B0;
				}
				if ((byte) fn0000000000404CD0(0x15) != 0x00 && (rdi.u6)[0x00B8] != 0x00)
				{
					edx_n = 0x15;
					goto l00000000004066B0;
				}
				if ((r15d_n & 0x49) != 0x00 && (byte) fn0000000000404CD0(0x0E) != 0x00)
				{
					edx_n = 0x0E;
					goto l00000000004066B0;
				}
				if (rdi.u6[32] > 0x01 && (byte) fn0000000000404CD0(22) != 0x00)
				{
					edx_n = 22;
					goto l00000000004066B0;
				}
l00000000004065CF:
				Eq_n rax_n = strlen(r12_n);
				Eq_n rbp_n;
				rbp_n.u4 = g_t61B120.u4;
				ptr64 r15_n = r12_n + rax_n;
				Eq_n rbp_n;
				while (rbp_n != 0x00)
				{
					Eq_n rdx_n;
					rdx_n.u4 = *rbp_n.u5;
					if (rax_n >= rdx_n && strncmp(r15_n - rdx_n, (rbp_n.u6)[8], (int32) rdx_n) == 0x00)
					{
						if (rbp_n == 0x00)
							break;
						rbp_n.u1 = rbp_n.u6 + 16;
						goto l00000000004066C0;
					}
					rbp_n.u4 = rbp_n.u6[32];
				}
				edx_n = 0x05;
l00000000004066B0:
				rbp_n = ((uint64) edx_n << 0x04) + 6398944;
l00000000004066C0:
				if (rbp_n.u1->t0008.u4 != 0x00)
				{
					if ((byte) fn0000000000404CD0(0x04) != 0x00)
					{
						word64 rcx_n;
						fn0000000000406440(6398944, out rcx_n);
						word64 rcx_n;
						fn0000000000406440(6398960, out rcx_n);
					}
					word64 rcx_n;
					fn0000000000406440(6398944, out rcx_n);
					word64 rcx_n;
					fn0000000000406440(rbp_n, out rcx_n);
					r14b_n = 0x01;
					word64 rcx_n;
					rax = fn0000000000406440(6398960, out rcx_n);
				}
				else
				{
					rax = fn0000000000404CD0(0x04);
					r14b_n = (byte) rax;
				}
l00000000004066FF:
				Eq_n rcx_n;
				Eq_n rbp_n;
				if (rdx != 0x00)
				{
					if (g_b61B130 != 0x00)
					{
						rax.u4 = rdx.u1->t0018.u4;
						if (rdx.u1->ptr0020 < rax.u6 + 8)
						{
							_obstack_newchunk(rdx, 8);
							rax.u4 = rdx.u1->t0018.u4;
						}
						*rax.u5 = g_t61B018.u0;
						rdx.u1->t0018.u4 += 8;
					}
					rcx_n = fn00000000004052D0(0x00, g_t61B0E8.u0, r12_n, stdout.u0, r12_n, fs);
					Eq_n rdx_n = rax.u4 + g_t61B018.u0;
					g_t61B018.u0 = (int64) rdx_n;
					rbp_n = rax;
					if (g_b61B130 != 0x00)
					{
						Eq_n rax_n;
						rax_n.u4 = rdx.u1->t0018.u4;
						rcx_n.u6 = rax_n.u6 + 8;
						if (rdx.u1->ptr0020 < rax_n.u6 + 8)
						{
							_obstack_newchunk(rdx, 8);
							rax_n.u4 = rdx.u1->t0018.u4;
							rdx_n.u0 = g_t61B018.u0;
						}
						*rax_n.u5 = (word64) rdx_n;
						rdx.u1->t0018.u4 += 8;
					}
				}
				else
				{
					rcx_n = fn00000000004052D0(0x00, g_t61B0E8.u0, r12_n, stdout.u0, r12_n, fs);
					g_t61B018.u0 = (int64) (rax.u4 + g_t61B018.u0);
					rbp_n = rax;
				}
				fn0000000000406490();
				if (r14b_n != 0x00)
				{
					fn0000000000406400();
					rcx_n.u4 = g_t61B0C8.u4;
					if ((uint128) rcx /u rcx_n != (uint128) (rcx.u4 + (rbp_n - 1)) /u rcx_n)
						fn0000000000406440(0x0061A550, out rcx_n);
				}
				rcxOut = rcx_n;
				return rbp_n;
			}
			if (eax_n == 0x4000)
			{
				if ((r15d_n & 0x0202) == 0x0202)
				{
					edx_n = 0x14;
					if ((byte) fn0000000000404CD0(0x14) != 0x00)
						goto l00000000004066B0;
				}
				if ((r15b_n & 0x02) != 0x00)
				{
					edx_n = 0x13;
					if ((byte) fn0000000000404CD0(0x13) != 0x00)
						goto l00000000004066B0;
				}
				edx_n = 0x06;
				if ((r15d_n & 0x0200) != 0x00)
					edx_n = (0x00 - (word32) ((byte) fn0000000000404CD0(0x12) < 0x01) & ~0x0B) + 0x12;
				goto l00000000004066B0;
			}
			if (eax_n != 0xA000)
			{
				edx_n = 0x08;
				if (eax_n != 0x1000)
				{
					edx_n = 0x09;
					if (eax_n != 0xC000)
					{
						edx_n = 0x0A;
						if (eax_n != 0x6000)
						{
							uint64 rdx_n = (uint64) (eax_n != 0x2000);
							edx_n = (word32) rdx_n + 11 + (word32) rdx_n;
						}
					}
				}
				goto l00000000004066B0;
			}
			edx_n = 0x07;
		}
		if (r14b_n != 0x00)
		{
			edx_n = 0x0D;
			if (g_b61B198 == 0x00)
				edx_n = (0x00 - (word32) ((byte) fn0000000000404CD0(0x0D) < 0x01) & ~0x05) + 0x0D;
		}
		goto l00000000004066B0;
	}
	if (g_b61B129 == 0x00)
	{
		r12_n = rdx_n;
		r14b_n = 0x00;
		goto l00000000004066FF;
	}
	word32 r14d_n;
	if (g_b61B198 != 0x00)
	{
		if (rdi.u6[177] != 0x00)
		{
			r15d_n.u4 = rdi.u6[0x00A4];
			r14d_n = 0x01;
			goto l00000000004069F7;
		}
		r14d_n = 0x00;
	}
	else
		r14d_n = (word32) rdi.u6[177];
	r15d_n.u4 = rdi.u6[40];
l00000000004069F7:
	r14d_n = r14d_n ^ 0x01;
	r12_n = rdx_n;
	goto l00000000004065B0;
}

// 0000000000406A30: Register Eq_n fn0000000000406A30()
// Called from:
//      fn0000000000407870
//      fn00000000004079F0
Eq_n fn0000000000406A30()
{
	Eq_n rax;
	if (g_b61B129 == 0x00)
		return rax;
	rax = fn0000000000404CD0(0x04);
	if ((byte) rax == 0x00)
		return rax;
	word64 rcx_n;
	fn0000000000406440(6398944, out rcx_n);
	word64 rcx_n;
	fn0000000000406440(6399008, out rcx_n);
	word64 rcx_n;
	return fn0000000000406440(6398960, out rcx_n);
}

// 0000000000406A80: Register word64 fn0000000000406A80(Register Eq_n ecx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn0000000000406B70
word64 fn0000000000406A80(Eq_n ecx, Eq_n rdx, Eq_n rsi, Eq_n rdi, struct Eq_n * fs)
{
	word64 qwLoc0138;
	Eq_n rbx_n = rsi;
	word64 rax_n = fs->qw0028;
	if (g_qw61A748 != 0x00)
	{
		Eq_n rax_n = strstr(rsi, 4274022);
		if (rax_n != 0x00 && strlen(rsi) <= 101)
		{
			char * rax_n = __mempcpy_chk(&qwLoc0138, rsi, rax_n - rsi, 0x0105);
			int64 rcx_n = (int64) rdx.u9->u1.dw0010;
			strcpy(stpcpy(rax_n, rcx_n + 0x0061A760 + rcx_n * 0xA0), (word32) rax_n + 2);
			rbx_n = &qwLoc0138;
		}
	}
	word64 rax_n = fn0000000000410600(rdx, rbx_n, 1001, rdi, 0x00, ecx, fs);
	if ((rax_n ^ fs->qw0028) == 0x00)
		return rax_n;
	__stack_chk_fail();
}

// 0000000000406B70: void fn0000000000406B70(Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004079F0
void fn0000000000406B70(Eq_n rdi, struct Eq_n * fs)
{
	word64 rcx_n;
	ptr64 fp;
	Eq_n tLoc1298;
	Eq_n qwLoc12D0;
	char bLoc0E88;
	word64 rax_n = fs->qw0028;
	Eq_n tLoc12A8;
	if (rdi.u6[0x00B0] != 0x00)
	{
		fn000000000040A600(&tLoc12A8, rdi.u6 + 16);
		if (g_b61B17C == 0x00)
		{
l0000000000406BC2:
			tLoc12A8.b000A = 0x00;
			goto l0000000000406BC7;
		}
	}
	else
	{
		tLoc12A8.b0000 = (byte) *((word64) (uint64) rdi.u6[0x00A0] + 0x00413728);
		tLoc12A8.qw0001 = 0x3F3F3F3F3F3F3F3F;
		tLoc12A8.w0009 = 16191;
		tLoc12A8.b000B = 0x00;
		if (g_b61B17C == 0x00)
			goto l0000000000406BC2;
	}
	word32 eax_n = (word32) rdi.u6[0x00B4];
	up32 eax_n;
	bool v57_n;
	switch (eax_n)
	{
	case 0x01:
		tLoc12A8.b000A = 0x2E;
		break;
	case 0x02:
		eax_n = g_dw61B14C;
		tLoc12A8.b000A = 0x2B;
		v57_n = eax_n < 0x01;
		word64 qwLoc12B0_n;
		int64 qwLoc12B8_n;
		if (eax_n != 0x01)
		{
l0000000000406BD6:
			if (!v57_n)
			{
				if (eax_n != 0x02)
					abort();
				qwLoc12B0_n = (word64) rdi.u6[96];
				qwLoc12B8_n = (int64) rdi.u6[88];
			}
			else
			{
				qwLoc12B0_n = (word64) rdi.u6[112];
				qwLoc12B8_n = (int64) rdi.u6[0x0068];
			}
l0000000000406BF7:
			Eq_n rbp_n = &bLoc0E88;
			Eq_n tLoc1278;
			if (g_b61B114 != 0x00)
			{
				Eq_n r9_n;
				r9_n.u0 = 4274020;
				if (rdi.u6[0x00B0] != 0x00)
				{
					Eq_n rdi_n;
					rdi_n.u4 = rdi.u6[24];
					if (rdi_n != 0x00)
						r9_n = fn000000000040CD70(&tLoc1278, rdi_n);
				}
				__sprintf_chk(&bLoc0E88, 1, 3643, "%*s ", g_dw61B178, r9_n);
				union Eq_n * rdx_n = &bLoc0E88;
				uint32 eax_n;
				bui8 al_n;
				do
				{
					uint64 rcx_n = (uint64) rdx_n->u1;
					uint64 rax_n = (uint64) ((word32) rcx_n - 0x01010101 & ~((word32) rcx_n) & 0x80808080);
					rdx_n = (union Eq_n *) ((char *) rdx_n + 4);
					eax_n = (word32) rax_n;
					al_n = (byte) rax_n;
				} while (eax_n == 0x00);
				union Eq_n * rbp_n = (union Eq_n *) ((char *) rdx_n + 2);
				if ((eax_n & 0x8080) == 0x00)
					al_n = (byte) (eax_n >> 0x10);
				if ((eax_n & 0x8080) != 0x00)
					rbp_n = rdx_n;
				rbp_n = rbp_n - 0x03 - (word64) (al_n * 0x02 < 0x00);
			}
			if (g_b61B144 == 0x00)
			{
l0000000000406C8F:
				Eq_n qwLoc12D0_n = qwLoc12D0;
				Eq_n rax_n;
				rax_n.u0 = 4274020;
				if (rdi.u6[0x00B0] != 0x00)
					rax_n = fn000000000040CD70(&tLoc1278, rdi.u6[32]);
				__sprintf_chk(rbp_n, 1, ~0x00, "%s %*s ", &tLoc12A8, g_dw61B170, rax_n);
				Eq_n rbp_n = rbp_n + strlen(rbp_n);
				if (g_b61B130 != 0x00)
				{
					fwrite_unlocked(0x00413771, 0x01, 0x02, stdout.u0);
					g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x02);
				}
				if (g_b61A569 != 0x00 || (g_b61A568 != 0x00 || (g_b61B146 != 0x00 || g_b61B17D != 0x00)))
				{
					fputs_unlocked(&bLoc0E88, stdout.u0);
					g_t61B018.u0 = (int64) (g_t61B018.u0 + (rbp_n - &bLoc0E88));
					if (g_b61A569 != 0x00)
						fn00000000004057B0(rdi.u6[0x00B0], g_dw61B168, (uint64) rdi.u6[44], fs);
					if (g_b61A568 != 0x00)
					{
						uint64 rdx_n = (uint64) g_dw61B164;
						Eq_n eax_n;
						eax_n.u4 = rdi.u6[48];
						Eq_n rdi_n;
						rdi_n.u0 = 4274020;
						word32 edx_n = (word32) rdx_n;
						Eq_n rsi_n;
						rsi_n.u0 = (uint64) eax_n;
						if (rdi.u6[0x00B0] != 0x00)
						{
							rdi_n.u0 = 0x00;
							if (g_b61B145 == 0x00)
							{
								qwLoc12D0_n = rsi_n;
								rdi_n = fn000000000040CB40(eax_n);
								rdx_n = (uint64) edx_n;
							}
						}
						fn0000000000405700((word32) rdx_n, (word32) rsi_n, rdi_n, fs);
					}
					if (g_b61B146 == 0x00)
					{
						rbp_n = &bLoc0E88;
						if (g_b61B17D == 0x00)
							goto l0000000000406D58;
					}
					else
					{
						fn00000000004057B0(rdi.u6[0x00B0], g_dw61B160, (uint64) rdi.u6[44], fs);
						rbp_n = &bLoc0E88;
						if (g_b61B17D == 0x00)
							goto l0000000000406D58;
					}
					fn0000000000405700(g_dw61B16C, 0x00, rdi.u6[0x00A8], fs);
					rbp_n = &bLoc0E88;
				}
l0000000000406D58:
				Eq_n r13_n;
				Eq_n r14_n;
				if (rdi.u6[0x00B0] != 0x00)
				{
					if ((rdi.u6[40] & 0xB000) == 0x2000)
					{
						uint64 rax_n = (uint64) rdi.u6[56];
						int32 r13d_n = ~0x01 - g_dw61B15C - g_dw61B158 + g_dw61B154;
						Eq_n rax_n = fn000000000040CD70(&tLoc1278, (uint64) (SEQ(SLICE(rax_n >> 0x0C, word24, 8), 0x00) | (word32) ((byte) rax_n)));
						uint64 rdx_n = (uint64) rdi.u6[56];
						int32 r14d_n = g_dw61B158;
						Eq_n rax_n = fn000000000040CD70(&tLoc1298, (uint64) ((word32) (rdx_n >> 0x20) & ~0x0FFF | (word32) (rdx_n >> 0x08) & 0x0FFF));
						int32 r8d_n = 0x00;
						if (r13d_n >= 0x00)
							r8d_n = r13d_n;
						__sprintf_chk(rbp_n, 1, ~0x00, "%*s, %*s ", r8d_n + g_dw61B15C, rax_n, r14d_n, rax_n);
						r13_n = (word32) rbp_n + 1 + (int64) g_dw61B154;
l0000000000406E9C:
						Eq_n rax_n = localtime((time_t) fp - 4792);
						*r13_n.u1 = 0x01;
						Eq_n r9_n;
						if (rdi.u6[0x00B0] == 0x00)
						{
l0000000000406F80:
							r9_n.u0 = 4274020;
							goto l0000000000406F86;
						}
						word32 rax_32_32_n;
						Eq_n r13_n;
						if (rax_n == 0x00)
						{
l0000000000407364:
							r9_n = fn000000000040CCD0(&tLoc1298, qwLoc12B8_n);
l0000000000406F86:
							uint64 r8_n = (uint64) g_dw61A3C4;
							if ((word32) r8_n < 0x00)
							{
								Eq_n rax_n = localtime((time_t) fp - 4800);
								if (rax_n != 0x00)
								{
									Eq_n rax_n = fn0000000000406A80(0x00, rax_n, g_t61A3D0.u4, &tLoc1278, fs);
									uint64 r8_n = (uint64) g_dw61A3C4;
									if (rax_n != 0x00)
									{
										word32 eax_n = fn000000000040D240(0x00, rax_n, &tLoc1278, fs);
										g_dw61A3C4 = eax_n;
										r9_n = qwLoc12D0_n;
										r8_n = (uint64) eax_n;
									}
									r8_n = r8_n;
									if ((word32) r8_n >= 0x00)
										goto l0000000000406F96;
								}
								g_dw61A3C4 = 0x00;
								r8_n = 0x00;
								goto l0000000000406F96;
							}
							else
							{
l0000000000406F96:
								__sprintf_chk(r13_n, 1, ~0x00, "%*s ", (int32) r8_n, r9_n);
								Eq_n rax_n = strlen(r13_n);
								rax_32_32_n = SLICE(rax_n, word32, 32);
								r13_n = r13_n + rax_n;
l0000000000406FBC:
								Eq_n r13_n = r13_n - &bLoc0E88;
								int32 eax_n = fputs_unlocked(&bLoc0E88, stdout.u0);
								g_t61B018.u0 = (int64) (r13_n.u4 + g_t61B018.u0);
								word64 rax_n = fn0000000000406540(SEQ(rax_32_32_n, eax_n), r13_n, 0x0061AFC0, 0x00, rdi, fs, out rcx_n);
								uint64 rdx_n = (uint64) rdi.u6[0x00A0];
								if ((word32) rdx_n != 0x06)
								{
									if (g_dw61B12C != 0x00)
										fn0000000000405D00(rcx_n, (word32) rdx_n, (uint64) rdi.u6[40], rdi.u6[0x00B0]);
								}
								else if (rdi.u6[8] != 0x00)
								{
									Eq_n rax_n = fwrite_unlocked(4274046, 0x01, 0x04, stdout.u0);
									g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x04);
									word64 rcx_n;
									fn0000000000406540(rax_n, (char *) &r13_n.u9->u1.t0004.u0 + rax_n, 0x00, 0x01, rdi, fs, out rcx_n);
									if (g_dw61B12C != 0x00)
										fn0000000000405D00(rcx_n, 0x00, (uint64) rdi.u6[0x00A4], 0x01);
								}
								if ((rax_n ^ fs->qw0028) == 0x00)
									return;
								__stack_chk_fail();
							}
						}
						Eq_n rdi_n;
						rdi_n.u4 = g_t61B188.u4;
						int64 rdx_n = g_qw61B180;
						Eq_n edi_n = (word32) rdi_n;
						Eq_n ecx_n = (word32) qwLoc12B0_n;
						Eq_n r8d_n;
						if (qwLoc12B8_n <= rdx_n && (qwLoc12B8_n < rdx_n || edi_n >= ecx_n))
							r8d_n = (word32) rdi_n;
						else
						{
							fn000000000040AB30(0x0061B180);
							rdx_n = g_qw61B180;
							r8d_n.u0 = g_t61B188.u0;
							ecx_n = (word32) qwLoc12B0_n;
						}
						int64 rdi_n = rdx_n - 0x00F0C2AC;
						uint32 edi_n;
						if (rdi_n >= qwLoc12B8_n)
						{
							edi_n = 0x00;
							if (rdi_n > qwLoc12B8_n || r8d_n >= ecx_n)
								goto l0000000000406F20;
						}
						edi_n = 0x01;
						if (rdx_n <= qwLoc12B8_n)
						{
							edi_n = 0x00;
							if (rdx_n >= qwLoc12B8_n)
								edi_n = ecx_n - r8d_n >> 0x1F;
						}
l0000000000406F20:
						Eq_n rax_n = fn0000000000406A80(ecx_n, rax_n, *((word64) 6398928 + (int64) edi_n * 0x08), r13_n, fs);
						if (rax_n != 0x00 || *r13_n.u1 == 0x00)
						{
							struct Eq_n * rax_n = rax_n + r13_n;
							rax_n->b0000 = 0x20;
							rax_n->b0001 = 0x00;
							rax_32_32_n = SLICE(rax_n, word32, 32);
							r13_n.u1 = &rax_n->b0001;
							goto l0000000000406FBC;
						}
						if (rdi.u6[0x00B0] == 0x00)
							goto l0000000000406F80;
						goto l0000000000407364;
					}
					r14_n = fn000000000040BD70(0x01, g_dw61B134, &tLoc1278, rdi.u6[64], g_t61A560.u0, fs);
				}
				else
					r14_n.u0 = 4274020;
				int32 r13d_n = g_dw61B154 - fn000000000040D420(0x00, r14_n, fs);
				if (r13d_n > 0x00)
				{
					Eq_n rcx_n = (word32) rbp_n + 1 + (uint64) (r13d_n - 0x01);
					Eq_n rdx_n = rbp_n;
					do
					{
						rdx_n.u1 = (word32) rdx_n + 1;
						rdx_n.u2->bFFFFFFFF = 0x20;
					} while (rdx_n != rcx_n);
					rbp_n = (word32) rbp_n + 1 + (int64) (r13d_n - 0x01);
				}
				while (true)
				{
					++r14_n.u6;
					byte al_n = r14_n.u6->bFFFFFFFF;
					r13_n.u1 = (word32) rbp_n + 1;
					r13_n.u2->bFFFFFFFF = al_n;
					if (al_n == 0x00)
						break;
					rbp_n = r13_n;
				}
				*rbp_n.u1 = 0x20;
				goto l0000000000406E9C;
			}
			Eq_n r14_n;
			r14_n.u0 = 4274020;
			if (rdi.u6[0x00B0] != 0x00)
				r14_n = fn000000000040BD70(0x0200, g_dw61B140, &tLoc1278, rdi.u6[80], g_t61B138.u0, fs);
			int32 r15d_n = g_dw61B174 - fn000000000040D420(0x00, r14_n, fs);
			Eq_n rdx_n;
			if (r15d_n > 0x00)
			{
				Eq_n rcx_n = (word32) rbp_n + 1 + (uint64) (r15d_n - 0x01);
				Eq_n rdx_n = rbp_n;
				do
				{
					rdx_n.u1 = (word32) rdx_n + 1;
					rdx_n.u2->bFFFFFFFF = 0x20;
				} while (rdx_n != rcx_n);
				rdx_n = (word32) rbp_n + 1 + (int64) (r15d_n - 0x01);
l0000000000406C74:
				++r14_n.u6;
				byte al_n = r14_n.u6->bFFFFFFFF;
				rbp_n.u1 = (word32) rdx_n + 1;
				rbp_n.u2->bFFFFFFFF = al_n;
				if (al_n == 0x00)
				{
					*rdx_n.u1 = 0x20;
					goto l0000000000406C8F;
				}
			}
			rdx_n = rbp_n;
			goto l0000000000406C74;
		}
l0000000000406E70:
		qwLoc12B0_n = (word64) rdi.u6[0x0080];
		qwLoc12B8_n = (int64) rdi.u6[0x0078];
		goto l0000000000406BF7;
	}
l0000000000406BC7:
	eax_n = g_dw61B14C;
	v57_n = eax_n < 0x01;
	if (eax_n != 0x01)
		goto l0000000000406BD6;
	goto l0000000000406E70;
}

// 0000000000407870: void fn0000000000407870(Register Eq_n rsi, Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004079F0
void fn0000000000407870(Eq_n rsi, Eq_n rdi, struct Eq_n * fs)
{
	word64 rax_n = fs->qw0028;
	Eq_n rax_n = fn0000000000406A30();
	Eq_n tLoc02B8;
	if (g_b61B114 != 0x00)
	{
		Eq_n rcx_n;
		rcx_n.u0 = 4274020;
		if (rdi.u6[0x00B0] != 0x00)
		{
			Eq_n rdi_n;
			rdi_n.u4 = rdi.u6[24];
			if (rdi_n != 0x00)
				rcx_n = fn000000000040CD70(&tLoc02B8, rdi_n);
		}
		uint64 rdx_n = 0x00;
		if (g_dw61B150 != 0x04)
			rdx_n = (uint64) g_dw61B178;
		rax_n.u4 = (uint64) __printf_chk(1, "%*s ", (int32) rdx_n, rcx_n);
	}
	if (g_b61B144 != 0x00)
	{
		Eq_n rcx_n;
		rcx_n.u0 = 4274020;
		if (rdi.u6[0x00B0] != 0x00)
			rcx_n = fn000000000040BD70(0x0200, g_dw61B140, &tLoc02B8, rdi.u6[80], g_t61B138.u0, fs);
		uint64 rdx_n = 0x00;
		if (g_dw61B150 != 0x04)
			rdx_n = (uint64) g_dw61B174;
		rax_n.u4 = (uint64) __printf_chk(1, "%*s ", (int32) rdx_n, rcx_n);
	}
	if (g_b61B17D != 0x00)
	{
		uint64 rdx_n = 0x00;
		Eq_n rcx_n;
		rcx_n.u4 = rdi.u6[0x00A8];
		if (g_dw61B150 != 0x04)
			rdx_n = (uint64) g_dw61B16C;
		rax_n.u4 = (uint64) __printf_chk(1, "%*s ", (int32) rdx_n, rcx_n);
	}
	word64 rcx_n;
	fn0000000000406540(rax_n, rsi, 0x00, 0x00, rdi, fs, out rcx_n);
	if (g_dw61B12C != 0x00)
		fn0000000000405D00(rcx_n, rdi.u6[0x00A0], (uint64) rdi.u6[40], rdi.u6[0x00B0]);
	if ((rax_n ^ fs->qw0028) == 0x00)
		return;
	__stack_chk_fail();
}

// 00000000004079F0: void fn00000000004079F0(Register Eq_n r12, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
void fn00000000004079F0(Eq_n r12, struct Eq_n * fs)
{
	up32 v14_n = g_dw61B150;
	if (g_dw61B150 <= 0x04)
	{
		switch (v14_n)
		{
		case 0x00:
			Eq_n rbx_n;
			rbx_n.u0 = 0x00;
			if (g_t61B1B0.u4 != 0x00)
			{
				do
				{
					fn0000000000406A30();
					fn0000000000406B70(g_t61B1A8.u4[rbx_n *64 0x08], fs);
					Eq_n rdi_n;
					rdi_n.u0 = stdout.u0;
					byte * rax_n = (byte *) *((word32) rdi_n + 40);
					if (rax_n < *((word32) rdi_n + 48))
					{
						*((word32) rdi_n + 40) = rax_n + 1;
						*rax_n = 0x0A;
					}
					else
						__overflow(rdi_n, 0x0A);
					g_t61B018.u0 = (int64) (g_t61B018.u0 + 0x01);
					++rbx_n.u6;
				} while (g_t61B1B0.u4 > rbx_n);
				return;
			}
			break;
		case 0x01:
			Eq_n rbx_n;
			rbx_n.u0 = 0x00;
			if (g_t61B1B0.u4 != 0x00)
			{
				do
				{
					fn0000000000407870(0x00, g_t61B1A8.u4[rbx_n *64 0x08], fs);
					Eq_n rdi_n;
					rdi_n.u0 = stdout.u0;
					byte * rax_n = (byte *) *((word32) rdi_n + 40);
					if (rax_n < *((word32) rdi_n + 48))
					{
						*((word32) rdi_n + 40) = rax_n + 1;
						*rax_n = 0x0A;
					}
					else
						__overflow(rdi_n, 0x0A);
					++rbx_n.u6;
				} while (g_t61B1B0.u4 > rbx_n);
				return;
			}
			break;
		case 0x02:
			uint64 rax_n = fn0000000000405ED0(0x01, fs);
			uint128 rdx_rax_n = (uint128) g_t61B1B0.u4;
			struct Eq_n * r15_n = g_t61B028.u4 - 24 + rax_n * 0x18;
			Eq_n rdx_n = (uint64) (rdx_rax_n % rax_n != 0x00) + rdx_rax_n /u rax_n;
			if (rdx_n != 0x00)
			{
				Eq_n qwLoc40_n;
				qwLoc40_n.u0 = 0x00;
				Eq_n v36_n;
				do
				{
					Eq_n rbp_n;
					rbp_n.u1 = 0x00;
					Eq_n rbx_n;
					rbx_n.u0 = 0x00;
					int64 r13_n = qwLoc40_n *64 0x08;
					Eq_n r12_n = qwLoc40_n;
					while (true)
					{
						Eq_n r14_n;
						r14_n.u4 = g_t61B1A8.u4[r13_n];
						Eq_n rax_n = fn0000000000405D50(r14_n, r12_n, fs);
						word64 rcx_n = (word64) *((word32) rbp_n + r15_n->ptr0010);
						fn0000000000407870(rbx_n, r14_n, fs);
						rbp_n = (word32) rbp_n + 8;
						r12_n += rdx_n;
						r13_n += rdx_n *64 0x08;
						if (r12_n >= g_t61B1B0.u4)
							break;
						Eq_n r14_n;
						r14_n.u4 = rbx_n.u4 + rcx_n;
						fn0000000000405200(r14_n, rax_n + rbx_n);
						rbx_n = r14_n;
					}
					Eq_n rdi_n;
					rdi_n.u0 = stdout.u0;
					byte * rax_n = (byte *) *((word32) rdi_n + 40);
					if (rax_n < *((word32) rdi_n + 48))
					{
						*((word32) rdi_n + 40) = rax_n + 1;
						*rax_n = 0x0A;
					}
					else
						__overflow(rdi_n, 0x0A);
					v36_n.u6 = qwLoc40_n.u6 + 1;
					qwLoc40_n = v36_n;
				} while (v36_n != rdx_n);
				return;
			}
			break;
		case 0x03:
			uint64 rax_n = fn0000000000405ED0(0x00, fs);
			struct Eq_n * r14_n = g_t61B028.u4 - 24 + rax_n * 0x18;
			Eq_n rbx_n;
			rbx_n.u4 = *g_t61B1A8.u4;
			Eq_n rax_n = fn0000000000405D50(rbx_n, r12, fs);
			word64 r12_n = r14_n->ptr0010[0];
			fn0000000000407870(0x00, rbx_n, fs);
			Eq_n r15_n;
			r15_n.u0 = 0x00;
			Eq_n rbx_n;
			rbx_n.u0 = 0x01;
			Eq_n rcx_n = rax_n;
			if (g_t61B1B0.u4 > 0x01)
			{
				do
				{
					uint64 rdx_n = (uint128) rbx_n % rax_n;
					if (rdx_n != 0x00)
					{
						Eq_n r12_n;
						r12_n.u4 = r15_n.u4 + r12_n;
						fn0000000000405200(r12_n, rcx_n + r15_n);
						r15_n = r12_n;
					}
					else
					{
						Eq_n rdi_n;
						rdi_n.u0 = stdout.u0;
						byte * rax_n = (byte *) *((word32) rdi_n + 40);
						if (rax_n < *((word32) rdi_n + 48))
						{
							*((word32) rdi_n + 40) = rax_n + 1;
							*rax_n = 0x0A;
							r15_n.u0 = 0x00;
						}
						else
						{
							__overflow(rdi_n, 0x0A);
							r15_n.u0 = 0x00;
						}
					}
					Eq_n r12_n;
					r12_n.u4 = g_t61B1A8.u4[rbx_n *64 0x08];
					fn0000000000407870(r15_n, r12_n, fs);
					rcx_n = fn0000000000405D50(r12_n, r12_n, fs);
					++rbx_n.u6;
					r12_n = r14_n->ptr0010[rdx_n];
				} while (rbx_n < g_t61B1B0.u4);
			}
			goto l0000000000407A18;
		case 0x04:
			if (g_t61B1B0.u4 != 0x00)
			{
				Eq_n r13_n;
				r13_n.u4 = *g_t61B1A8.u4;
				Eq_n rbx_n;
				rbx_n.u0 = 0x00;
				Eq_n r12_n;
				r12_n.u0 = 0x00;
				Eq_n rbp_n = fn0000000000405D50(r13_n, 0x00, fs);
				while (true)
				{
					fn0000000000407870(r12_n, r13_n, fs);
					++rbx_n.u6;
					r12_n = rbp_n;
					if (rbx_n >= g_t61B1B0.u4)
						break;
					r13_n.u4 = g_t61B1A8.u4[rbx_n *64 0x08];
					Eq_n rax_n = fn0000000000405D50(r13_n, rbp_n, fs);
					if (rbx_n != 0x00)
					{
						r12_n.u6 = rbp_n.u6 + 2;
						int32 r15d_n;
						byte r14b_n;
						if (rax_n < g_t61B0C8.u4)
						{
							r15d_n = 0x20;
							r14b_n = 0x20;
						}
						else
						{
							r15d_n = 0x0A;
							r14b_n = 0x0A;
							r12_n.u0 = 0x00;
						}
						Eq_n rdi_n;
						rdi_n.u0 = stdout.u0;
						rbp_n = rax_n;
						byte * rax_n = (byte *) *((word32) rdi_n + 40);
						if (rax_n < *((word32) rdi_n + 48))
						{
							*((word32) rdi_n + 40) = rax_n + 1;
							*rax_n = 44;
						}
						else
							__overflow(rdi_n, 44);
						Eq_n rdi_n;
						rdi_n.u0 = stdout.u0;
						byte * rax_n = (byte *) *((word32) rdi_n + 40);
						if (rax_n < *((word32) rdi_n + 48))
						{
							*((word32) rdi_n + 40) = rax_n + 1;
							*rax_n = r14b_n;
						}
						else
							__overflow(rdi_n, r15d_n);
					}
					else
						rbp_n += rax_n;
				}
			}
l0000000000407A18:
			Eq_n rdi_n;
			rdi_n.u0 = stdout.u0;
			byte * rax_n = (byte *) *((word32) rdi_n + 40);
			if (rax_n >= *((word32) rdi_n + 48))
			{
				__overflow(rdi_n, 0x0A);
				return;
			}
			*((word32) rdi_n + 40) = rax_n + 1;
			*rax_n = 0x0A;
			break;
		}
	}
}

// 0000000000407EA0: Register Eq_n fn0000000000407EA0(Register Eq_n rcx, Register word32 edx, Register word32 esi, Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
Eq_n fn0000000000407EA0(Eq_n rcx, word32 edx, word32 esi, Eq_n rdi, struct Eq_n * fs)
{
	Eq_n tLoc02F8;
	byte bLoc038C_n = (byte) edx;
	word64 rax_n = fs->qw0028;
	Eq_n rcx_n;
	rcx_n.u4 = g_t61B1B0.u4;
	Eq_n r9_n;
	r9_n.u4 = g_t61B1C0.u4;
	if (rcx_n == g_t61B1B8.u4)
	{
		Eq_n rdi_n;
		rdi_n.u4 = g_t61B1C0.u4;
		if (rcx_n > 0xAAAAAAAAAAAAAA)
			fn0000000000410E50();
		Eq_n rax_n = fn0000000000410C90(rcx_n *64 0x0180, rdi_n);
		g_t61B1B8.u4 = (char *) (g_t61B1B8.u4 << 0x01);
		g_t61B1C0.u4 = (char *) rax_n;
		r9_n = rax_n;
		rcx_n.u4 = g_t61B1B0.u4;
	}
	ui64 rcx_n = rcx_n *64 0x03;
	struct Eq_n * r14_n = (struct Eq_n *) (r9_n.u4 + (rcx_n << 0x06));
	uint32 esi_n = 0xC0;
	struct Eq_n * rdi_n = r14_n;
	if (((byte) r14_n & 0x01) != 0x00)
	{
		r14_n->w0000 = (word16) 0x00;
		esi_n = 191;
		rdi_n = SEQ(SLICE((char *) &r14_n->w0000 + 1, word56, 8), (byte) r14_n + 0x01);
	}
	byte dil_n = (byte) rdi_n;
	struct Eq_n * rdi_n;
	if ((dil_n & 0x02) == 0x00)
	{
		rdi_n = rdi_n;
		if ((dil_n & 0x04) == 0x00)
			goto l0000000000407F1F;
	}
	else
	{
		rdi_n->w0000 = 0x00;
		rdi_n = &rdi_n->w0000 + 1;
		esi_n -= 0x02;
		if ((dil_n + 0x02 & 0x04) == 0x00)
			goto l0000000000407F1F;
	}
	rdi_n->w0000 = (word16) 0x00;
	esi_n -= 0x04;
	rdi_n = &rdi_n->w0000 + 2;
l0000000000407F1F:
	byte sil_n = (byte) esi_n;
	uint64 rcx_n;
	for (rcx_n = (uint64) (esi_n >> 0x03); rcx_n != 0x00; --rcx_n)
	{
		rdi_n->w0000 = (word16) 0x00;
		++rdi_n;
	}
	if ((sil_n & 0x04) == 0x00)
	{
		if ((sil_n & 0x02) == 0x00)
		{
l0000000000407F3D:
			if ((esi_n & 0x01) == 0x00)
				goto l0000000000407F46;
l0000000000408338:
			rdi_n->w0000 = (word16) 0x00;
l0000000000407F46:
			r14_n[3] = (struct Eq_n) 0x00;
			r14_n[20] = (struct Eq_n) esi;
			uint32 ecx_n;
			if (bLoc038C_n != 0x00 || (g_b61B0C1 != 0x00 || esi == 0x03 && (g_b61B129 != 0x00 && ((byte) fn0000000000404CD0(0x13) != 0x00 || ((byte) fn0000000000404CD0(0x12) != 0x00 || (byte) fn0000000000404CD0(0x14) != 0x00)))))
			{
l0000000000407F62:
				ecx_n = g_dw61B110;
				goto l0000000000407F68;
			}
			byte al_n = g_b61B114;
			Eq_n r12_n;
			if (al_n == 0x00 && g_b61B0C0 == 0x00)
			{
l0000000000408825:
				r12_n.u1 = 0x00;
				goto l00000000004081E1;
			}
			int8 sil_n = (int8) (esi == 0x00);
			if (esi == 0x00 || esi == 0x06)
			{
				ecx_n = g_dw61B110;
				if (ecx_n != 0x05)
				{
					if (g_b61B198 == 0x00 && g_b61B115 == 0x00)
						goto l0000000000408280;
				}
				else
					ecx_n = 0x05;
l0000000000407F68:
				uint64 rsi_n = (uint64) *rdi.u4;
				word32 esi_n = (word32) rsi_n;
				Eq_n r12_n = rdi;
				Eq_n fp;
				if ((byte) rsi_n != 0x2F)
				{
					char r15b_n = *rcx.u4;
					if (r15b_n != 0x00)
					{
						Eq_n rax_n = fp - 0x03A8 - ((strlen(rdi) + 32) + strlen(rcx) & ~0x0F) + 0x0F & ~0x0F;
						char sil_n = (byte) esi_n;
						r12_n = rax_n;
						if (r15b_n != 0x2E || (rcx.u6)[1] != 0x00)
						{
							Eq_n rsi_n = rcx;
							do
							{
								++rax_n.u6;
								rax_n.u6->bFFFFFFFF = r15b_n;
								++rsi_n.u6;
								r15b_n = *rsi_n.u4;
							} while (r15b_n != 0x00);
							if (rcx < rsi_n && (rsi_n.u6)->bFFFFFFFF != 0x2F)
							{
								*rax_n.u4 = 0x2F;
								++rax_n.u6;
							}
							sil_n = *rdi.u4;
						}
						if (sil_n != 0x00)
						{
							Eq_n rdx_n = rdi;
							do
							{
								++rax_n.u6;
								rax_n.u6->bFFFFFFFF = sil_n;
								++rdx_n.u6;
								sil_n = *rdx_n.u4;
							} while (sil_n != 0x00);
						}
						*rax_n.u4 = 0x00;
					}
				}
				if (ecx_n >= 0x03)
				{
					struct stat * r15_n;
					Eq_n edx_n;
					word32 esi_n;
					if (ecx_n > 0x04)
					{
						if (ecx_n == 0x05)
						{
							r15_n = (struct stat *) (r14_n + 2);
							edx_n = __xstat(1, r12_n, r14_n + 2);
							esi_n = 0x01;
							if (edx_n != 0x00)
								goto l0000000000407FB1;
							goto l0000000000408019;
						}
					}
					else if (bLoc038C_n != 0x00)
					{
						Eq_n eax_n = __xstat(1, r12_n, r14_n + 2);
						r15_n = (struct stat *) (r14_n + 2);
						edx_n = eax_n;
						esi_n = 0x01;
						if (ecx_n == 0x03)
							goto l0000000000408015;
						int8 al_n;
						if (eax_n >= 0x00)
							al_n = (int8) ((r14_n[5] & 0xF000) != 0x4000);
						else
							al_n = (int8) (*__errno_location() == 0x02);
						edx_n = eax_n;
						esi_n = 0x01;
						if (al_n == 0x00)
						{
l0000000000408015:
							if (edx_n != 0x00)
							{
l0000000000407FB1:
								byte r15b_n = (byte) edx;
								fn0000000000405810(r12_n, dcgettext(0x00, 0x00413783, 5), (word32) r15b_n, fs);
								r12_n.u1 = 0x00;
								if (r15b_n != 0x00)
									goto l00000000004081F4;
								goto l00000000004081E1;
							}
l0000000000408019:
							r14_n[22] = (struct Eq_n) 0x01;
							byte sil_n = (byte) esi_n;
							if ((esi == 0x05 || (r14_n[5] & 0xF000) == 0x8000) && g_b61B129 != 0x00)
							{
								uint64 rsi_n = (uint64) esi_n;
								word32 esi_n = (word32) rsi_n;
								sil_n = (byte) rsi_n;
								if ((byte) fn0000000000404CD0(0x15) != 0x00)
								{
									word64 r13_n = (word64) r14_n[2];
									if (r13_n != g_qw61A678)
									{
										*__errno_location() = 0x5F;
										g_qw61A678 = r13_n;
										sil_n = (byte) esi_n;
									}
									else
									{
										*__errno_location() = 0x5F;
										sil_n = (byte) esi_n;
									}
									r14_n[23] = (struct Eq_n) 0x00;
								}
							}
							ui32 eax_n;
							if (g_dw61B150 != 0x00 && g_b61B17D == 0x00)
							{
l00000000004080EF:
								eax_n = r14_n[5] & 0xF000;
								if (eax_n != 0xA000)
									goto l0000000000408103;
								goto l0000000000408500;
							}
							int8 r13b_n;
							if (r14_n[2] == g_qw61A670)
							{
								*__errno_location() = 0x5F;
								r14_n[21] = (struct Eq_n) &g_b61A56A;
								r13b_n = 0x00;
								goto l00000000004080AA;
							}
							if (sil_n != 0x00)
							{
								if (fn0000000000411820(r14_n + 21, r12_n) >= 0x00)
								{
l0000000000408093:
									r13b_n = (int8) (memcmp(4274097, r14_n[21], 0x0A) != 0x00);
									goto l00000000004080AA;
								}
							}
							else if (fn0000000000411840(r14_n + 21, r12_n) >= 0x00)
								goto l0000000000408093;
							word32 eax_n = *__errno_location();
							if (eax_n == 22 || (eax_n == 0x26 || eax_n == 0x5F))
								g_qw61A670 = (word64) r14_n[2];
							r14_n[21] = (struct Eq_n) &g_b61A56A;
							if (eax_n != 0x5F && eax_n != 0x3D)
							{
								r14_n->dw00B4 = 0x00;
								goto l00000000004084BF;
							}
							r13b_n = 0x00;
l00000000004080AA:
							Eq_n edx_n = edx_n;
							word32 ecx_n;
							if (g_dw61B150 == 0x00)
							{
								if (r14_n[2] != g_qw61A668)
								{
									int32 * rax_n = __errno_location();
									*rax_n = 0x00;
									Eq_n eax_n = fn0000000000409CC0(r15_n, r12_n);
									ecx_n = 0x01;
									edx_n = edx_n;
									if (eax_n <= 0x00)
									{
										int32 edx_n = *rax_n;
										if (edx_n != 22 && (edx_n != 0x26 && edx_n != 0x5F))
										{
											edx_n = eax_n >> 0x1F;
											goto l00000000004080B8;
										}
										g_qw61A668 = (word64) r14_n[2];
										ecx_n = 0x00;
										edx_n = eax_n >> 0x1F;
									}
								}
								else
								{
									*__errno_location() = 0x5F;
									ecx_n = 0x00;
									edx_n = edx_n;
								}
l00000000004080BA:
								word32 eax_n = 0x00;
								byte sil_n = (byte) ecx_n | r13b_n;
								if (sil_n != 0x00)
								{
									byte r13b_n = r13b_n & ((byte) ecx_n ^ 0x01);
									if (r13b_n != 0x00)
										sil_n = r13b_n;
									eax_n = (word32) (bool) r13b_n + 0x02;
								}
								g_b61B17C |= sil_n;
								r14_n->dw00B4 = eax_n;
								if (edx_n == 0x00)
									goto l00000000004080EF;
l00000000004084BF:
								fn000000000040EAB0(r12_n, fs);
								error(0, *__errno_location(), 4283988, 0x00);
								eax_n = r14_n[5] & 0xF000;
								if (eax_n != 0xA000)
									goto l0000000000408103;
l0000000000408500:
								up32 r13d_n = g_dw61B150;
								if (r13d_n != 0x00 && g_b61B115 == 0x00)
								{
l000000000040862A:
									r14_n[20] = (struct Eq_n) 0x06;
									goto l0000000000408120;
								}
								Eq_n rax_n = fn0000000000409D20(r14_n[8], r12_n);
								r14_n[1] = (struct Eq_n) rax_n;
								Eq_n r13_n = rax_n;
								if (rax_n == 0x00)
								{
									fn0000000000405810(r12_n, dcgettext(0x00, 0x00413794, 5), (word32) bLoc038C_n, fs);
									r13_n.u4 = r14_n[1];
									if (r13_n == 0x00)
										goto l0000000000408607;
								}
								if (*r13_n.u4 != 0x2F)
								{
									Eq_n rax_n = fn000000000040A2B0(r12_n);
									if (rax_n != 0x00)
									{
										Eq_n rax_n = fn0000000000410C40(strlen(r13_n).u4 + ((word32) rax_n + 2));
										strcpy(stpncpy(rax_n, r12_n, rax_n + CONVERT(Mem1290[(r12_n - 1) + rax_n:byte] != 0x2F, bool, uint64)), r13_n);
										r13_n = rax_n;
									}
									else
										r13_n = fn0000000000410E30(r13_n);
								}
								else
									r13_n = fn0000000000410E30(r13_n);
								word64 qwLoc0388;
								if (r13_n != 0x00 && (g_dw61B12C > 0x01 || g_b61B115 != 0x00) && __xstat(1, r13_n, &qwLoc0388) == 0x00)
								{
									r14_n->b00B1 = 0x01;
									ui32 dwLoc0370;
									if (bLoc038C_n == 0x00 || (g_dw61B150 == 0x00 || (dwLoc0370 & 0xF000) != 0x4000))
										r14_n->dw00A4 = dwLoc0370;
								}
l0000000000408607:
								free(r13_n);
								eax_n = r14_n[5] & 0xF000;
								if (eax_n == 0xA000)
								{
									r13d_n = g_dw61B150;
									goto l000000000040862A;
								}
l0000000000408103:
								if (eax_n != 0x4000)
								{
									r13d_n = g_dw61B150;
									r14_n[20] = (struct Eq_n) 0x05;
								}
								else if (bLoc038C_n != 0x00 && g_b61B10D == 0x00)
								{
									r14_n[20] = (struct Eq_n) 0x09;
									r13d_n = g_dw61B150;
								}
								else
								{
									r14_n[20] = (struct Eq_n) 0x03;
									r13d_n = g_dw61B150;
								}
l0000000000408120:
								r12_n = r14_n[0x0A];
								Eq_n tLoc02D8;
								if (r13d_n != 0x00 && g_b61B144 == 0x00)
								{
l00000000004081A8:
									if (g_b61B17D != 0x00)
									{
										int32 eax_n = (word32) strlen(r14_n[21]);
										if (eax_n > g_dw61B16C)
										{
											g_dw61B16C = eax_n;
											if (r13d_n != 0x00)
												goto l00000000004081D2;
l000000000040873F:
											int32 eax_n = (word32) strlen(fn000000000040CD70(&tLoc02F8, r14_n[4]));
											if (eax_n > g_dw61B170)
												g_dw61B170 = eax_n;
											int32 eax_n;
											if ((r14_n[5] & 0xB000) == 0x2000)
											{
												uint64 rax_n = (uint64) r14_n[7];
												int32 eax_n = (word32) strlen(fn000000000040CD70(&tLoc02D8, (uint64) ((word32) (rax_n >> 0x20) & ~0x0FFF | (word32) (rax_n >> 0x08) & 0x0FFF)));
												if (eax_n > g_dw61B15C)
													g_dw61B15C = eax_n;
												uint64 rax_n = (uint64) r14_n[7];
												int32 eax_n = (word32) strlen(fn000000000040CD70(&tLoc02D8, (uint64) (SEQ(SLICE(rax_n >> 0x0C, word24, 8), 0x00) | (word32) ((byte) rax_n))));
												uint64 rdx_n = (uint64) g_dw61B158;
												if (eax_n > (word32) rdx_n)
												{
													g_dw61B158 = eax_n;
													rdx_n = (uint64) eax_n;
												}
												eax_n = (word32) rdx_n + 0x02 + g_dw61B15C;
												if (eax_n <= g_dw61B154)
												{
l00000000004081D2:
													if (g_b61B114 != 0x00)
													{
														int32 eax_n = (word32) strlen(fn000000000040CD70(&tLoc02D8, r14_n[3]));
														if (eax_n > g_dw61B178)
															g_dw61B178 = eax_n;
													}
l00000000004081E1:
													Eq_n rax_n = fn0000000000410E30(rdi);
													++g_t61B1B0.u4;
													r14_n->w0000 = (word16) rax_n;
l00000000004081F4:
													if ((rax_n ^ fs->qw0028) == 0x00)
														return r12_n;
													__stack_chk_fail();
												}
											}
											else
											{
												eax_n = fn000000000040D420(0x00, fn000000000040BD70(0x01, g_dw61B134, &tLoc02D8, r14_n[8], g_t61A560.u0, fs), fs);
												if (eax_n <= g_dw61B154)
													goto l00000000004081D2;
											}
											g_dw61B154 = eax_n;
											goto l00000000004081D2;
										}
									}
									if (r13d_n != 0x00)
										goto l00000000004081D2;
									goto l000000000040873F;
								}
								word32 r15d_n = (word32) fp - 0x02D8;
								int32 eax_n = fn000000000040D420(0x00, fn000000000040BD70(0x0200, g_dw61B140, &tLoc02D8, r12_n, g_t61B138.u0, fs), fs);
								if (eax_n > g_dw61B174)
									g_dw61B174 = eax_n;
								r13d_n = g_dw61B150;
								if (r13d_n != 0x00)
									goto l00000000004081A8;
								if (g_b61A569 != 0x00)
								{
									int32 eax_n = fn00000000004061B0((uint64) r14_n->dw002C, fs);
									if (eax_n > g_dw61B168)
										g_dw61B168 = eax_n;
								}
								if (g_b61A568 == 0x00)
								{
l0000000000408194:
									if (g_b61B146 != 0x00)
									{
										int32 eax_n = fn00000000004061B0((uint64) r14_n->dw002C, fs);
										if (eax_n > g_dw61B160)
											g_dw61B160 = eax_n;
									}
									r13d_n = g_dw61B150;
									goto l00000000004081A8;
								}
								Eq_n r13d_n;
								r13d_n.u4 = r14_n[6];
								int32 edx_n;
								if (g_b61B145 == 0x00)
								{
									Eq_n rax_n = fn000000000040CB40(r13d_n);
									if (rax_n != 0x00)
									{
										int32 eax_n = fn000000000040D420(0x00, rax_n, fs);
										edx_n = 0x00;
										if (eax_n >= 0x00)
											edx_n = eax_n;
l0000000000408AF5:
										if (g_dw61B164 < edx_n)
											g_dw61B164 = edx_n;
										goto l0000000000408194;
									}
								}
								__sprintf_chk(&tLoc02D8, 1, 0x15, "%lu", r13d_n);
								union Eq_n * rdx_n = &tLoc02D8;
								uint32 eax_n;
								bui8 al_n;
								do
								{
									uint64 rcx_n = (uint64) rdx_n->u1.u1;
									uint64 rax_n = (uint64) ((word32) rcx_n - 0x01010101 & ~((word32) rcx_n) & 0x80808080);
									rdx_n = (union Eq_n *) ((char *) rdx_n + 4);
									eax_n = (word32) rax_n;
									al_n = (byte) rax_n;
								} while (eax_n == 0x00);
								if ((eax_n & 0x8080) == 0x00)
									al_n = (byte) (eax_n >> 0x10);
								if ((eax_n & 0x8080) == 0x00)
									rdx_n = (union Eq_n *) ((char *) rdx_n + 2);
								edx_n = (word32) rdx_n - 0x03 - (word32) (al_n * 0x02 < 0x00) - r15d_n;
								goto l0000000000408AF5;
							}
							else
							{
l00000000004080B8:
								ecx_n = 0x00;
								goto l00000000004080BA;
							}
						}
l0000000000408001:
						r15_n = (struct stat *) (r9_n.u4 + (rcx_n << 0x06) + 16);
						esi_n = 0x00;
						edx_n = __lxstat(1, r12_n, r15_n);
						goto l0000000000408015;
					}
				}
				goto l0000000000408001;
			}
			else
			{
l0000000000408280:
				if (al_n != 0x00)
					goto l0000000000407F62;
				if (g_b61B0C0 != 0x00)
				{
					if (sil_n == 0x00)
					{
						r12_n.u1 = 0x00;
						if (esi != 0x05 || g_dw61B12C != 0x03 && (g_b61B129 == 0x00 || (byte) fn0000000000404CD0(0x0E) == 0x00 && ((byte) fn0000000000404CD0(0x10) == 0x00 && ((byte) fn0000000000404CD0(0x11) == 0x00 && (byte) fn0000000000404CD0(0x15) == 0x00))))
							goto l00000000004081E1;
					}
					goto l0000000000407F62;
				}
				goto l0000000000408825;
			}
		}
	}
	else
	{
		rdi_n->w0000 = (word16) 0x00;
		rdi_n = &rdi_n->w0000 + 2;
		if ((sil_n & 0x02) == 0x00)
			goto l0000000000407F3D;
	}
	rdi_n = &rdi_n->w0000 + 1;
	rdi_n->wFFFFFFFE = 0x00;
	if ((esi_n & 0x01) == 0x00)
		goto l0000000000407F46;
	goto l0000000000408338;
}

// 0000000000409750: void fn0000000000409750(Register int32 edi)
// Called from:
//      fn00000000004028C0
void fn0000000000409750(int32 edi)
{
	if (edi != 0x00)
		__fprintf_chk(stderr.u0, 1, dcgettext(0x00, 4275552, 5), 0x00);
	else
	{
		__printf_chk(1, dcgettext(0x00, 4275592, 5), 0x00);
		fputs_unlocked(dcgettext(0x00, 0x00413DB0, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4275776, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00413E90, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00413FA0, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x004141E8, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4277144, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00414540, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00414580, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4277872, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4278144, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00414928, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00414AC0, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00414C28, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00414DA0, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00414F58, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00415020, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x004151F0, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4281328, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00415480, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4281832, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4282184, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4282232, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4282288, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 4282448, 5), stdout.u0);
		fputs_unlocked(dcgettext(0x00, 0x00415970, 5), stdout.u0);
		fn000000000040A390(g_t61B200.u4);
		__printf_chk(1, dcgettext(0x00, 4274107, 5), 0x00);
		__printf_chk(1, dcgettext(0x00, 4274152, 5), 0x00);
		fputs_unlocked(dcgettext(0x00, 4282928, 5), stdout.u0);
		char * rax_n = setlocale(5, 0x00);
		if (rax_n != null && strncmp(rax_n, 0x0041380A, 3) != 0x00)
		{
			fn000000000040A390(g_t61B200.u4);
			__printf_chk(1, dcgettext(0x00, 4282992, 5), 0x00);
		}
		fn000000000040A390(g_t61B200.u4);
		__printf_chk(1, dcgettext(0x00, 4283064, 5), 0x00);
	}
	exit(edi);
}

// 0000000000409CC0: Register word32 fn0000000000409CC0(Register (ptr64 Eq_n) rsi, Register Eq_n rdi)
// Called from:
//      fn0000000000407EA0
word32 fn0000000000409CC0(struct stat * rsi, Eq_n rdi)
{
	uint64 rax_n = (uint64) (rsi->dw0018 & 0xF000);
	word32 rax_32_32_n = SLICE(rax_n, word32, 32);
	if ((word32) rax_n == 0xA000)
		return 0x00;
	int32 eax_n = acl_extended_file(rdi);
	uint64 rax_n = SEQ(rax_32_32_n, eax_n);
	if (eax_n >= 0x00)
		return (word32) rax_n;
	word32 eax_n = *__errno_location();
	if (eax_n == 0x5F || (eax_n == 0x26 || eax_n == 22))
		return 0x00;
	rax_n = (uint64) -(word32) (eax_n != 0x10);
	return (word32) rax_n;
}

// 0000000000409D20: Register Eq_n fn0000000000409D20(Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn0000000000407EA0
Eq_n fn0000000000409D20(Eq_n rsi, Eq_n rdi)
{
	Eq_n rbx_n;
	rbx_n.u0 = 0x0401;
	if (rsi <= 0x0400)
		rbx_n.u4 = (word32) rsi + 1;
l0000000000409D60:
	Eq_n rax_n = malloc(rbx_n);
	Eq_n rbp_n = rax_n;
	while (rax_n != 0x00)
	{
		Eq_n rax_n = readlink(rdi, rax_n, rbx_n);
		if (rax_n < 0x00)
		{
			int32 * rax_n = __errno_location();
			int32 edx_n = *rax_n;
			if (edx_n != 0x22)
			{
				free(rbp_n);
				*rax_n = edx_n;
				return 0x00;
			}
		}
		if (rbx_n > rax_n)
		{
			*rbp_n.u1 = 0x00;
			return rbp_n;
		}
		free(rbp_n);
		if (rbx_n > 0x3FFFFFFFFFFFFFFF)
		{
			if (rbx_n > 0x7FFFFFFFFFFFFFFE)
			{
				*__errno_location() = 0x0C;
				return 0x00;
			}
			else
			{
				rbx_n.u0 = 0x7FFFFFFFFFFFFFFF;
				goto l0000000000409D60;
			}
		}
		rbx_n *= 0x02;
		rax_n = malloc(rbx_n);
		rbp_n = rax_n;
	}
	return 0x00;
}

<anonymous> g_t409E40 = <code>; // 0000000000409E40
// 0000000000409E50: Register Eq_n fn0000000000409E50(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
//      fn000000000040A120
//      fn000000000040C810
Eq_n fn0000000000409E50(Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi)
{
	Eq_n rax_n = strlen(rdi);
	Eq_n rbp_n = rdx;
	char * r14_n = (char *) *rsi;
	Eq_n qwLoc50_n;
	Eq_n rax_n;
	if (r14_n != null)
	{
		byte bLoc41_n = 0x00;
		qwLoc50_n.u0 = ~0x00;
		Eq_n rbx_n;
		rbx_n.u1 = 0x00;
		do
		{
			if (strncmp(r14_n, rdi, (int32) rax_n) == 0x00)
			{
				if (strlen(r14_n) == rax_n)
					return rbx_n;
				if (qwLoc50_n == ~0x00)
				{
					rbx_n = (word64) rbx_n.u1 + 1;
					qwLoc50_n = rbx_n;
					rbp_n += rcx;
					r14_n = (char *) *((word32) rsi + rbx_n *64 0x08);
					if (r14_n == null)
						break;
					continue;
				}
				if (rdx != 0x00)
				{
					uint64 rcx_n = (uint64) bLoc41_n;
					word32 rcx_32_32_n = SLICE(rcx_n, word32, 32);
					if (memcmp((char *) rdx.u1 + qwLoc50_n *s64 rcx, rbp_n, rcx) != 0x00)
						rcx_n = SEQ(rcx_32_32_n, 0x00, 0x01);
					bLoc41_n = (byte) rcx_n;
				}
				else
					bLoc41_n = 0x01;
			}
			rbx_n = (word64) rbx_n.u1 + 1;
			rbp_n += rcx;
			r14_n = (char *) *((word32) rsi + rbx_n *64 0x08);
		} while (r14_n != null);
		rax_n.u0 = ~0x01;
		if (bLoc41_n != 0x00)
			return rax_n;
	}
	else
		qwLoc50_n.u0 = ~0x00;
	rax_n = qwLoc50_n;
	return rax_n;
}

// 0000000000409F80: void fn0000000000409F80(Register int64 rdx, Register Eq_n rsi, Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
//      fn000000000040A120
void fn0000000000409F80(int64 rdx, Eq_n rsi, Eq_n rdi, struct Eq_n * fs)
{
	char * r12_n;
	if (rdx != ~0x00)
		r12_n = dcgettext(0x00, 4283928, 5);
	else
		r12_n = dcgettext(0x00, 0x00415DFD, 5);
	fn000000000040EBF0(rdi, 0x01, fs);
	fn000000000040E970(rsi, 0x06, 0x00, fs);
	error(0, 0, r12_n, 0x00);
}

// 000000000040A000: Register Eq_n fn000000000040A000(Register Eq_n rdx, Register Eq_n rsi, Register (arr Eq_n) rdi, Register (ptr32 Eq_n) fs, Register out Eq_n rdxOut, Register out Eq_n rsiOut, Register out Eq_n rdiOut, Register out Eq_n r8Out, Register out Eq_n r9Out)
// Called from:
//      fn000000000040A120
Eq_n fn000000000040A000(Eq_n rdx, Eq_n rsi, Eq_n rdi[], struct Eq_n * fs, union Eq_n & rdxOut, union Eq_n & rsiOut, union Eq_n & rdiOut, union Eq_n & r8Out, union Eq_n & r9Out)
{
	Eq_n rbx_n;
	rbx_n.u0 = stderr.u0;
	fputs_unlocked(dcgettext(0x00, 0x00415E35, 5), rbx_n);
	Eq_n r14_n;
	r14_n.u0 = 0x00;
	Eq_n rdx_n;
	rdx_n.u0 = 0x05;
	Eq_n rbp_n = rsi;
	Eq_n rsi_n = rbx_n;
	uint64 rbx_n = 0x00;
	Eq_n r12_n;
	r12_n.u4 = rdi[0].u4;
	while (r12_n != 0x00)
	{
		if (rbx_n != 0x00 && memcmp(r14_n, rbp_n, rdx) == 0x00)
		{
			word64 r8_n;
			word64 r9_n;
			__fprintf_chk(stderr.u0, 1, ", %s", fn000000000040EC10(r12_n, fs, out r8_n, out r9_n));
			++rbx_n;
			rbp_n += rdx;
			rdx_n.u0 = 0x00415E52;
			rsi_n.u0 = 0x01;
			r12_n.u4 = rdi[rbx_n *64 2].u4;
			if (r12_n == 0x00)
				break;
			continue;
		}
		word64 r8_n;
		word64 r9_n;
		__fprintf_chk(stderr.u0, 1, "\n  - %s", fn000000000040EC10(r12_n, fs, out r8_n, out r9_n));
		++rbx_n;
		r14_n = rbp_n;
		rdx_n.u0 = 0x00415E4A;
		rsi_n.u0 = 0x01;
		rbp_n += rdx;
		r12_n.u4 = rdi[rbx_n *64 2].u4;
	}
	Eq_n rdi_n;
	rdi_n.u0 = stderr.u0;
	Eq_n rax_n;
	rax_n.u1 = *((word32) rdi_n + 40);
	if (rax_n >= *((word32) rdi_n + 48))
	{
		__overflow(rdi_n, 0x0A);
		rdxOut = rdx_n;
		rsiOut.u0 = 0x0A;
		rdiOut.u0 = <invalid>;
		r8Out.u0 = <invalid>;
		r9Out.u0 = <invalid>;
		return <invalid>;
	}
	else
	{
		*((word32) rdi_n + 40) = (word32) rax_n + 1;
		*rax_n.u1 = 0x0A;
		rdxOut = (word32) rax_n + 1;
		rsiOut = rsi_n;
		rdiOut.u0 = <invalid>;
		r8Out.u0 = <invalid>;
		r9Out.u0 = <invalid>;
		return <invalid>;
	}
}

// 000000000040A120: Register int64 fn000000000040A120(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi, Register Eq_n r8, Register (ptr64 code) r9, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
int64 fn000000000040A120(Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi, Eq_n r8, <anonymous> * r9, struct Eq_n * fs)
{
	int64 rax_n = fn0000000000409E50(r8, rcx, rdx, rsi);
	if (rax_n < 0x00)
	{
		fn0000000000409F80(rax_n, rsi, rdi, fs);
		r9();
		rax_n = ~0x00;
	}
	return rax_n;
}

// 000000000040A2B0: Register Eq_n fn000000000040A2B0(Register Eq_n rdi)
// Called from:
//      fn0000000000407EA0
Eq_n fn000000000040A2B0(Eq_n rdi)
{
	int8 bpl_n = (int8) (*rdi.u4 == 0x2F);
	Eq_n rax_n = fn000000000040A390(rdi);
	Eq_n rcx_n = rax_n - rdi;
	Eq_n rbp_n;
	rbp_n.u1 = (uint64) bpl_n;
	Eq_n rdx_n;
	if (rcx_n > rbp_n)
	{
		rdx_n = rcx_n - 1;
		if (rax_n.u2->bFFFFFFFF == 0x2F)
		{
			while (rbp_n < rdx_n)
			{
				Eq_n rax_n = rdx_n - 1;
				if (Mem11[rdi - 1 + rdx_n:byte] != 0x2F)
					return rdx_n;
				rdx_n = rax_n;
			}
			return rdx_n;
		}
	}
	rdx_n = rcx_n;
	return rdx_n;
}

// 000000000040A390: Register Eq_n fn000000000040A390(Register Eq_n rdi)
// Called from:
//      fn0000000000405090
//      fn0000000000409750
//      fn000000000040A2B0
//      fn000000000040A630
Eq_n fn000000000040A390(Eq_n rdi)
{
	uint64 rdx_n = (uint64) *rdi.u4;
	word32 edx_n = (word32) rdx_n;
	Eq_n rax_n = rdi;
	if ((byte) rdx_n == 0x2F)
	{
		uint64 rdx_n;
		do
		{
			++rax_n.u6;
			rdx_n = (uint64) *rax_n.u4;
			edx_n = (word32) rdx_n;
		} while ((byte) rdx_n == 0x2F);
	}
	Eq_n rdx_n = rax_n;
	if ((byte) edx_n == 0x00)
		return rax_n;
	uip64 rsi_n = 0x00;
l000000000040A3C0:
	++rdx_n.u6;
	byte cl_n = *rdx_n.u4;
	while (cl_n != 0x00)
	{
		byte sil_n = (byte) rsi_n;
		if (cl_n == 0x2F)
		{
			rsi_n = 0x01;
			goto l000000000040A3C0;
		}
		if (sil_n == 0x00)
			goto l000000000040A3C0;
		++rdx_n.u6;
		rax_n = rdx_n;
		cl_n = *rdx_n.u4;
		rsi_n = 0x00;
	}
	return rax_n;
}

// 000000000040A400: Register Eq_n fn000000000040A400(Register Eq_n rdi)
// Called from:
//      fn000000000040A630
Eq_n fn000000000040A400(Eq_n rdi)
{
	Eq_n rax_n = strlen(rdi);
	if (rax_n <= 0x01)
		return rax_n;
	Eq_n rdx_n;
	do
	{
		rdx_n = rax_n - 1;
		if (Mem6[rdi - 1 + rax_n:byte] != 0x2F)
			return rax_n;
		rax_n = rdx_n;
	} while (rdx_n != 0x01);
	return rdx_n;
}

// 000000000040A600: void fn000000000040A600(Register (ptr64 Eq_n) rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn0000000000406B70
void fn000000000040A600(struct Eq_n * rsi, struct Eq_n * rdi)
{
	ui32 edi_n = rdi->dw0018;
	byte dl_n;
	switch (edi_n & 0xF000)
	{
	case 0x8000:
		dl_n = 0x2D;
		break;
	case 0x4000:
		dl_n = 100;
		break;
	case 0x6000:
		dl_n = 0x62;
		break;
	case 0x2000:
		dl_n = 99;
		break;
	case 0xA000:
		dl_n = 0x6C;
		break;
	case 0x1000:
		dl_n = 0x70;
		break;
	default:
		dl_n = 115;
		if ((edi_n & 0xF000) != 0xC000)
			dl_n = 0x3F;
		break;
	}
	rsi->b0000 = dl_n;
	rsi->b0001 = (0x00 - (byte) ((edi_n & 0x0100) < 0x01) & ~0x44) + 114;
	rsi->b0002 = (0x00 - (byte) ((edi_n & 0x80) < 0x01) & ~0x49) + 0x77;
	word32 eax_n = 0x00 - (word32) ((edi_n & 0x40) < 0x01);
	byte al_n;
	if ((edi_n & 0x0800) != 0x00)
		al_n = ((byte) eax_n & 0xE0) + 115;
	else
		al_n = ((byte) eax_n & 181) + 0x78;
	rsi->b0003 = al_n;
	rsi->b0004 = (0x00 - (byte) ((edi_n & 0x20) < 0x01) & ~0x44) + 114;
	rsi->b0005 = (0x00 - (byte) ((edi_n & 0x10) < 0x01) & ~0x49) + 0x77;
	word32 eax_n = 0x00 - (word32) ((edi_n & 0x08) < 0x01);
	byte al_n;
	if ((edi_n & 0x0400) != 0x00)
		al_n = ((byte) eax_n & 0xE0) + 115;
	else
		al_n = ((byte) eax_n & 181) + 0x78;
	rsi->b0006 = al_n;
	rsi->b0007 = (0x00 - (byte) ((edi_n & 0x04) < 0x01) & ~0x44) + 114;
	rsi->b0008 = (0x00 - (byte) ((edi_n & 0x02) < 0x01) & ~0x49) + 0x77;
	if ((edi_n & 0x0200) == 0x00)
	{
		rsi->b000A = 0x20;
		rsi->b000B = 0x00;
		rsi->b0009 = (0x00 - (byte) ((edi_n & 0x01) < 0x01) & 181) + 0x78;
	}
	else
	{
		rsi->b000A = 0x20;
		rsi->b000B = 0x00;
		rsi->b0009 = (0x00 - (byte) ((edi_n & 0x01) < 0x01) & 0xE0) + 116;
	}
}

// 000000000040A610: Register word64 fn000000000040A610(Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn0000000000405090
word64 fn000000000040A610(Eq_n rdx, Eq_n rsi, Eq_n rdi)
{
	word64 rax_n = fn000000000040A630(rdx, rsi, rdi);
	if (rax_n != 0x00)
		return rax_n;
	fn0000000000410E50();
}

// 000000000040A630: Register Eq_n fn000000000040A630(Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn000000000040A610
Eq_n fn000000000040A630(Eq_n rdx, Eq_n rsi, Eq_n rdi)
{
	Eq_n rax_n = fn000000000040A390(rdi);
	int64 rax_n = fn000000000040A400(rax_n);
	Eq_n r14_n;
	r14_n.u1 = 0x00;
	Eq_n rsi_n = rax_n - rdi + rax_n;
	if (rax_n != 0x00)
		r14_n.u1 = (uint64) (*((word64) (rax_n - 1) + rax_n) != 0x2F);
	Eq_n rbx_n = rsi;
	if (*rsi.u4 == 0x2F)
	{
		do
		{
			++rbx_n.u6;
			if (*rbx_n.u4 != 0x2F)
				break;
			++rbx_n.u6;
		} while (rbx_n.u6[1] == 0x2F);
	}
	Eq_n rax_n = strlen(rbx_n);
	Eq_n rax_n = malloc(rsi_n + 1 + r14_n + rax_n);
	Eq_n rax_n;
	if (rax_n != 0x00)
	{
		byte * rax_n = mempcpy(rax_n, rdi, rsi_n);
		*rax_n = 0x2F;
		void * rdi_n = rax_n + r14_n;
		if (rdx != 0x00)
			*rdx.u1 = rdi_n - (uint64) (*rsi.u4 == 0x2F);
		*mempcpy(rdi_n, rbx_n, rax_n) = 0x00;
		rax_n = rax_n;
	}
	else
		rax_n.u0 = 0x00;
	return rax_n;
}

// 000000000040A730: void fn000000000040A730(Register (ptr64 Eq_n) rdi)
void fn000000000040A730(union Eq_n * rdi)
{
	Eq_n rdx_n;
	rdx_n.u0 = rdi->u0;
	byte cl_n = *rdx_n.u1;
	if (cl_n == 0x00)
		return;
	Eq_n rax_n;
	rax_n.u0 = 0x00;
	uip64 r8_n = 0x00;
	do
	{
		if ((byte) r8_n == 0x00)
		{
			if (cl_n != 0x2E)
			{
				Eq_n esi_n;
				esi_n.u0 = (int32) cl_n;
				if (esi_n <= 0x39)
					goto l000000000040A768;
				if ((esi_n & ~0x20) <= 0x5A && (esi_n & ~0x20) >= 0x41)
				{
					rdx_n.u1 = (word32) rdx_n + 1;
					rdi->u0 = (uint64) rdx_n;
					cl_n = *rdx_n.u1;
					if (cl_n == 0x00)
						return;
					continue;
				}
				goto l000000000040A761;
			}
			if (rax_n == 0x00)
				rax_n = rdx_n;
			r8_n = 0x01;
		}
		else
		{
			r8_n = 0x00;
			r8_n = 0x00;
			if (((int32) cl_n & ~0x20) > 0x5A)
			{
l000000000040A761:
				if (cl_n != 0x7E)
					rax_n.u0 = 0x00;
			}
		}
l000000000040A768:
		rdx_n.u1 = (word32) rdx_n + 1;
		rdi->u0 = (uint64) rdx_n;
		cl_n = *rdx_n.u1;
	} while (cl_n != 0x00);
}

// 000000000040AB30: void fn000000000040AB30(Register Eq_n rdi)
// Called from:
//      fn0000000000406B70
void fn000000000040AB30(Eq_n rdi)
{
	if (clock_gettime(0, rdi) != 0x00)
	{
		word64 qwLoc18;
		gettimeofday(&qwLoc18, 0x00);
		rdi->u1 = qwLoc18;
		int64 qwLoc10;
		rdi.u1[1] = (struct timespec) (qwLoc10 *s 1000);
	}
}

// 000000000040AB70: Register int8 fn000000000040AB70(Register word32 edi)
// Called from:
//      fn00000000004028C0
int8 fn000000000040AB70(word32 edi)
{
	word64 rdi;
	struct Eq_n * rax_n = setlocale((int32) rdi, 0x00);
	if (rax_n == null)
		return 0x01;
	if (rax_n->b0000 != 0x43 || rax_n->b0001 != 0x00)
		return (int8) (memcmp(rax_n, 4284010, 0x06) != 0x00);
	return 0x00;
}

// 000000000040ABC0: Register uint64 fn000000000040ABC0(Register Eq_n rdi)
// Called from:
//      fn000000000040B400
//      fn000000000040B710
uint64 fn000000000040ABC0(Eq_n rdi)
{
	uint64 rdi_n;
	if (rdi <= 0x09)
		rdi_n = 11;
	else
	{
		rdi_n = rdi | 0x01;
		if ((rdi | 0x01) == ~0x00)
			return rdi_n;
	}
	do
	{
		uint64 rcx_n;
		if (rdi_n > 0x09)
		{
			uint64 rdx_n = SLICE(rdi_n *128 ~0x5555555555555554, word64, 64);
			if (rdi_n != (rdx_n >> 0x01) + (rdx_n >> 0x01) * 0x02)
			{
				uint64 r8_n = 0x10;
				uint64 rsi_n = 0x09;
				rcx_n = 0x03;
				do
				{
					rsi_n += r8_n;
					rcx_n += 0x02;
					if (rsi_n >= rdi_n)
						goto l000000000040AC2D;
					r8_n += 0x08;
				} while ((uint128) rdi_n % rcx_n != 0x00);
			}
		}
		else
		{
			rcx_n = 0x03;
l000000000040AC2D:
			if ((uint128) rdi_n % rcx_n != 0x00)
				return rdi_n;
		}
		rdi_n += 0x02;
	} while (rdi_n != ~0x00);
	return rdi_n;
}

// 000000000040AC80: Register ui64 fn000000000040AC80(Register Eq_n rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn000000000040ACB0
//      fn000000000040AE40
ui64 fn000000000040AC80(Eq_n rsi, struct Eq_n * rdi)
{
	rdi->ptr0030();
	Eq_n rax_n;
	if (rax_n < (rdi->t0010).u4)
		return rdi->ptr0000 + rax_n;
	abort();
}

// 000000000040ACB0: Register Eq_n fn000000000040ACB0(Register word32 ecx, Register (ptr64 (ptr64 Eq_n)) rdx, Register Eq_n rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn000000000040B8F0
//      fn000000000040BB90
Eq_n fn000000000040ACB0(word32 ecx, struct Eq_n ** rdx, Eq_n rsi, struct Eq_n * rdi)
{
	word64 rcx_n;
	word64 rcx;
	ecx = (word32) rcx;
	uint64 r13_n = (uint64) ecx;
	struct Eq_n * rax_n = fn000000000040AC80(rsi, rdi);
	*rdx = (struct Eq_n **) rax_n;
	byte r13b_n = (byte) r13_n;
	Eq_n rsi_n;
	rsi_n.u4 = rax_n->t0000.u4;
	struct Eq_n * rbx_n = rax_n;
	if (rsi_n == 0x00)
		return 0x00;
	if (rsi != rsi_n)
	{
		rdi->ptr0038();
		word32 rcx_32_32_n = SLICE(rcx_n, word32, 32);
		word64 rax_n;
		if ((byte) rax_n == 0x00)
		{
			while (true)
			{
				word32 ecx_n = (word32) rcx_n;
				byte r13b_n = (byte) r13_n;
				struct Eq_n * rax_n = rbx_n->ptr0008;
				if (rax_n == null)
					break;
				rsi_n.u4 = rax_n->t0000.u4;
				if (rsi_n == rsi)
				{
l000000000040AD67:
					if (r13b_n == 0x00)
						return rsi_n;
					rbx_n->ptr0008 = rax_n->ptr0008;
					rax_n->t0000.u4 = (char *) 0x00;
					rax_n->ptr0008 = rdi->ptr0048;
					rdi->ptr0048 = rax_n;
					return rsi_n;
				}
				rdi->ptr0038();
				word32 rcx_32_32_n = SLICE(rcx_n, word32, 32);
				word64 rax_n;
				if ((byte) rax_n != 0x00)
				{
					rax_n = rbx_n->ptr0008;
					rsi_n.u4 = rax_n->t0000.u4;
					goto l000000000040AD67;
				}
				rbx_n = rbx_n->ptr0008;
			}
			return 0x00;
		}
		rsi_n.u4 = rax_n->t0000.u4;
	}
	if (r13b_n != 0x00)
	{
		struct Eq_n * rax_n = rax_n->ptr0008;
		if (rax_n != null)
		{
			struct Eq_n * r10_n = rax_n->ptr0008;
			rax_n->t0000.u4 = rax_n->t0000.u4;
			rax_n->ptr0008 = r10_n;
			rax_n->t0000.u4 = (char *) 0x00;
			rax_n->ptr0008 = rdi->ptr0048;
			rdi->ptr0048 = rax_n;
		}
		else
			rax_n->t0000.u4 = (char *) 0x00;
	}
	return rsi_n;
}

// 000000000040ADB0: Register byte fn000000000040ADB0(Register (ptr64 word64) rdi)
// Called from:
//      fn000000000040B400
//      fn000000000040B8F0
//      fn000000000040BB90
byte fn000000000040ADB0(word64 * rdi)
{
	struct Eq_n * rax_n = *rdi;
	if (rax_n == &g_t415EE0)
		return 0x01;
	if (rax_n->t0008.u0 > g_t415EF4.u0 && (g_t415EF8.u0 > (rax_n->t0008).u0 && ((rax_n->t000C).u0 > g_t415EFC.u0 && (rax_n->t0000).u0 >= g_t415F00.u0)))
	{
		Eq_n v15_n = rax_n->t0000.u0 + g_t415EF4.u0;
		if (rax_n->t0004.u0 > v15_n && (g_t415F04.u0 >= (rax_n->t0004).u0 && (rax_n->t0008).u0 > v15_n))
			return 0x01;
	}
	*rdi = &g_t415EE0;
	return 0x00;
}

// 000000000040AE40: Register word32 fn000000000040AE40(Register word32 edx, Register (ptr64 Eq_n) rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn000000000040B710
word32 fn000000000040AE40(word32 edx, struct Eq_n * rsi, struct Eq_n * rdi)
{
	word64 rdx;
	edx = (word32) rdx;
	byte r15b_n = (byte) edx;
	struct Eq_n * r13_n = rsi->ptr0000;
	if (r13_n >= rsi->ptr0008)
		return 0x01;
l000000000040AE68:
	Eq_n rbp_n;
	rbp_n.u4 = r13_n->qw0000;
	if (rbp_n == 0x00)
	{
l000000000040AEE1:
		++r13_n;
		if (rsi->ptr0008 <= r13_n)
			return 0x01;
		goto l000000000040AE68;
	}
	struct Eq_n * rbx_n = r13_n->qw0008;
	if (rbx_n == null)
	{
l000000000040AED4:
		r13_n->qw0008 = 0x00;
		if (r15b_n != 0x00)
			goto l000000000040AEE1;
		struct Eq_n * rax_n = fn000000000040AC80(rbp_n, rdi);
		if (rax_n->t0000.u4 != 0x00)
		{
			struct Eq_n * rax_n = rdi->ptr0048;
			if (rax_n != null)
				rdi->ptr0048 = rax_n->ptr0008;
			else
			{
				rax_n = malloc(0x10);
				if (rax_n == null)
					return 0x00;
			}
			struct Eq_n * rdx_n = rax_n->ptr0008;
			rax_n->t0000.u4 = (char *) rbp_n;
			rax_n->ptr0008 = rdx_n;
			rax_n->ptr0008 = rax_n;
		}
		else
		{
			rax_n->t0000.u4 = (char *) rbp_n;
			rdi->t0018.u0 = (int64) (rdi->t0018.u0 + 0x01);
		}
		r13_n->qw0000 = 0x00;
		rsi->t0018.u0 = (int64) (rsi->t0018.u0 - 0x01);
		++r13_n;
		if (rsi->ptr0008 <= r13_n)
			return 0x01;
		goto l000000000040AE68;
	}
	while (true)
	{
		Eq_n rbp_n;
		rbp_n.u4 = rbx_n->t0000.u4;
		struct Eq_n * rax_n = fn000000000040AC80(rbp_n, rdi);
		struct Eq_n * rdx_n = rbx_n->ptr0008;
		if (rax_n->t0000.u4 == 0x00)
		{
			rax_n->t0000.u4 = (char *) rbp_n;
			rdi->t0018.u0 = (int64) (rdi->t0018.u0 + 0x01);
			rbx_n->t0000.u4 = (char *) 0x00;
			rbx_n->ptr0008 = rdi->ptr0048;
			rdi->ptr0048 = rbx_n;
			if (rdx_n == null)
			{
l000000000040AED0:
				rbp_n.u4 = r13_n->qw0000;
				goto l000000000040AED4;
			}
		}
		else
		{
			rbx_n->ptr0008 = rax_n->ptr0008;
			rax_n->ptr0008 = rbx_n;
			if (rdx_n == null)
				goto l000000000040AED0;
		}
		rbx_n = rdx_n;
	}
}

// 000000000040AFB0: Register word64 fn000000000040AFB0(Register (ptr64 Eq_n) rdi)
// Called from:
//      fn00000000004028C0
word64 fn000000000040AFB0(struct Eq_n * rdi)
{
	return rdi->qw0020;
}

// 000000000040B400: Register Eq_n fn000000000040B400(Register uint64 rcx, Register uint64 rdx, Register Eq_n rsi, Register Eq_n rdi, Register uint64 r8)
// Called from:
//      fn00000000004028C0
Eq_n fn000000000040B400(uint64 rcx, uint64 rdx, Eq_n rsi, Eq_n rdi, uint64 r8)
{
	Eq_n r15_n = rdi;
	ui32 r15d_n = (word32) rdi;
	uint64 r13_n = rdx;
	uint64 r12_n = rcx;
	Eq_n rbp_n = rsi;
	if (rdx == 0x00)
		r13_n = 4238432;
	if (rcx == 0x00)
		r12_n = 4238448;
	Eq_n rax_n = malloc(0x50);
	Eq_n rax_n;
	if (rax_n == 0x00)
	{
		rax_n.u0 = 0x00;
		return rax_n;
	}
	if (rsi == 0x00)
		rbp_n.u0 = 4284128;
	rax_n.u1->t0028.u0 = (uint64) rbp_n;
	if (fn000000000040ADB0(&rax_n.u1->t0028.u0) == 0x00)
	{
l000000000040B548:
		free(rax_n);
		return 0x00;
	}
	if (rbp_n.u1->b0010 == 0x00)
	{
		word128 xmm0_n;
		word128 xmm0_n;
		if (rdi >= 0x00)
			xmm0_n = SEQ(SLICE(xmm0_n, word96, 32), (real32) rdi);
		else
		{
			real32 v37_n = (real32) (rdi >> 0x01 | (uint64) (r15d_n & 0x01));
			xmm0_n = SEQ(SLICE(xmm0_n, word96, 32), v37_n + v37_n);
		}
		Eq_n v29_n = (real32) xmm0_n / (rbp_n.u1)->r0008;
		if (v29_n >= g_t415F08.u0)
		{
l000000000040B540:
			rax_n.u1->t0010.u4 = (char *) 0x00;
			goto l000000000040B548;
		}
		if (v29_n >= g_t415F0C.u0)
			r15_n = (int64) (v29_n - g_t415F0C.u0) ^ 0x8000000000000000;
		else
			r15_n.u0 = (int64) v29_n;
	}
	Eq_n rax_n = fn000000000040ABC0(r15_n);
	if (rax_n <= 0x1FFFFFFFFFFFFFFF)
	{
		rax_n.u1->t0010.u4 = (char *) rax_n;
		if (rax_n != 0x00)
		{
			void * rax_n = calloc(rax_n, 0x10);
			rax_n.u1->ptr0000 = rax_n;
			if (rax_n != null)
			{
				rax_n.u1->qw0018 = 0x00;
				rax_n.u1->qw0020 = 0x00;
				rax_n.u1->qw0030 = r13_n;
				rax_n.u1->qw0038 = r12_n;
				rax_n.u1->ptr0008 = (char *) rax_n + (rax_n << 0x04);
				rax_n.u1->qw0040 = r8;
				rax_n.u1->qw0048 = 0x00;
				rax_n = rax_n;
				return rax_n;
			}
		}
		goto l000000000040B548;
	}
	goto l000000000040B540;
}

// 000000000040B640: void fn000000000040B640(Register (ptr64 Eq_n) rdi)
// Called from:
//      fn00000000004028C0
void fn000000000040B640(struct Eq_n * rdi)
{
	struct Eq_n * rax_n;
	if (rdi->ptr0040 != null && rdi->qw0020 != 0x00)
	{
		struct Eq_n * r12_n = rdi->ptr0000;
		if (r12_n >= rdi->ptr0008)
			goto l000000000040B693;
		do
		{
			word64 rdi_n = r12_n->qw0000;
			struct Eq_n * rbx_n = r12_n;
			if (rdi_n != 0x00)
			{
				while (true)
				{
					rdi->ptr0040();
					rbx_n = rbx_n->qw0008;
					if (rbx_n == null)
						break;
					rdi_n = rbx_n->qw0000;
				}
			}
			rax_n = rdi->ptr0008;
			++r12_n;
		} while (rax_n > r12_n);
	}
	else
		rax_n = rdi->ptr0008;
	struct Eq_n * r12_n = (struct Eq_n *) &rdi->ptr0000->qw0008;
	if (r12_n < rax_n)
	{
		do
		{
			struct Eq_n * rdi_n = r12_n->qw0000;
			if (rdi_n != null)
			{
				while (true)
				{
					struct Eq_n * rbx_n = rdi_n->ptr0008;
					free(rdi_n);
					if (rbx_n == null)
						break;
					rdi_n = rbx_n;
				}
			}
			++r12_n;
		} while (rdi->ptr0008 > r12_n);
	}
l000000000040B693:
	struct Eq_n * rdi_n = rdi->ptr0048;
	if (rdi_n != null)
	{
		while (true)
		{
			struct Eq_n * rbx_n = rdi_n->ptr0008;
			free(rdi_n);
			if (rbx_n == null)
				break;
			rdi_n = rbx_n;
		}
	}
	free(rdi->ptr0000);
	free(rdi);
}

// 000000000040B710: Register word32 fn000000000040B710(Register Eq_n rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn000000000040B8F0
//      fn000000000040BB90
word32 fn000000000040B710(Eq_n rsi, struct Eq_n * rdi)
{
	ui32 esi_n = (word32) rsi;
	struct Eq_n * rbp_n = rdi->ptr0028;
	if (rbp_n->b0010 == 0x00)
	{
		word128 xmm0_n;
		word128 xmm0;
		if (rsi >= 0x00)
			xmm0_n = SEQ(SLICE(xmm0, word96, 32), (real32) rsi);
		else
		{
			real32 v32_n = (real32) (rsi >> 0x01 | (uint64) (esi_n & 0x01));
			xmm0_n = SEQ(SLICE(xmm0, word96, 32), v32_n + v32_n);
		}
		Eq_n v18_n = (real32) xmm0_n / rbp_n->r0008;
		if (v18_n >= g_t415F08.u0)
			return 0x00;
		if (v18_n >= g_t415F0C.u0)
			rsi = (int64) (v18_n - g_t415F0C.u0) ^ 0x8000000000000000;
		else
			rsi.u0 = (int64) v18_n;
	}
	Eq_n rax_n = fn000000000040ABC0(rsi);
	if (rax_n > 0x1FFFFFFFFFFFFFFF || rax_n < 1)
		return 0x00;
	if (rdi->t0010.u4 == rax_n)
		return 0x01;
	void * rax_n = calloc(rax_n, 0x10);
	Eq_n tLoc68;
	tLoc68.ptr0000 = rax_n;
	if (rax_n == null)
		return 0x00;
	tLoc68.t0010.u4 = (char *) rax_n;
	tLoc68.ptr0008 = (char *) rax_n + (rax_n << 0x04);
	<anonymous> * rax_n = rdi->ptr0030;
	tLoc68.ptr0028 = rbp_n;
	tLoc68.qw0018 = 0x00;
	tLoc68.qw0020 = 0x00;
	tLoc68.ptr0030 = rax_n;
	tLoc68.ptr0038 = rdi->ptr0038;
	tLoc68.ptr0040 = rdi->ptr0040;
	tLoc68.ptr0048 = rdi->ptr0048;
	uint64 rax_n = (uint64) fn000000000040AE40(0x00, rdi, &tLoc68);
	word32 ebp_n = (word32) rax_n;
	if ((byte) rax_n != 0x00)
	{
		free(rdi->ptr0000);
		rdi->ptr0000 = tLoc68.ptr0000;
		rdi->ptr0008 = tLoc68.ptr0008;
		rdi->t0010.u4 = tLoc68.t0010.u4;
		rdi->t0018.u0 = tLoc68.t0018.u0;
		rdi->ptr0048 = tLoc68.ptr0048;
		return ebp_n;
	}
	else
	{
		rdi->ptr0048 = tLoc68.ptr0048;
		if ((byte) fn000000000040AE40(0x01, &tLoc68, rdi) == 0x00 || (byte) fn000000000040AE40(0x00, &tLoc68, rdi) == 0x00)
			abort();
		else
		{
			free(tLoc68.ptr0000);
			return ebp_n;
		}
	}
}

// 000000000040B8F0: Register word32 fn000000000040B8F0(Register (ptr64 uint64) rdx, Register Eq_n rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn000000000040BB50
word32 fn000000000040B8F0(uint64 * rdx, Eq_n rsi, struct Eq_n * rdi)
{
	Eq_n tLoc20;
	if (rsi != 0x00)
	{
		uint64 rax_n = fn000000000040ACB0(0x00, &tLoc20, rsi, rdi);
		uint64 rax_n;
		if (rax_n != 0x00)
		{
			if (rdx == null)
				return 0x00;
			*rdx = rax_n;
			rax_n = 0x00;
			return (word32) rax_n;
		}
		Eq_n rax_n;
		rax_n.u0 = rdi->t0018.u0;
		ui32 eax_n = (word32) rax_n;
		word128 xmm0_n;
		word128 xmm0;
		if (rax_n >= 0x00)
			xmm0_n = SEQ(SLICE(xmm0, word96, 32), (real32) rax_n);
		else
		{
			real32 v30_n = (real32) (rax_n >> 0x01 | (uint64) (eax_n & 0x01));
			xmm0_n = SEQ(SLICE(xmm0, word96, 32), v30_n + v30_n);
		}
		Eq_n rax_n;
		rax_n.u4 = rdi->t0010.u4;
		ui32 eax_n = (word32) rax_n;
		struct Eq_n * rdx_n = rdi->ptr0028;
		word128 xmm1_n;
		word128 xmm1;
		if (rax_n >= 0x00)
			xmm1_n = SEQ(SLICE(xmm1, word96, 32), (real32) rax_n);
		else
		{
			real32 v55_n = (real32) (rax_n >> 0x01 | (uint64) (eax_n & 0x01));
			xmm1_n = SEQ(SLICE(xmm1, word96, 32), v55_n + v55_n);
		}
		if ((real32) xmm0_n <= (real32) xmm1_n * rdx_n->r0008)
		{
l000000000040B96A:
			struct Eq_n * r12_n = (struct Eq_n *) tLoc20;
			if (r12_n->t0000.u4 == 0x00)
			{
				r12_n->t0000.u4 = (char *) rsi;
				++rdi->qw0020;
				rdi->t0018.u0 = (int64) (rdi->t0018.u0 + 0x01);
				rax_n = 0x01;
				return (word32) rax_n;
			}
			struct Eq_n * rax_n = rdi->ptr0048;
			if (rax_n != null)
			{
				rdi->ptr0048 = rax_n->ptr0008;
l000000000040B98F:
				struct Eq_n * rdx_n = r12_n->ptr0008;
				rax_n->t0000.u4 = (char *) rsi;
				rax_n->ptr0008 = rdx_n;
				r12_n->ptr0008 = rax_n;
				++rdi->qw0020;
				return 0x01;
			}
			rax_n = malloc(0x10);
			if (rax_n != null)
				goto l000000000040B98F;
l000000000040BB2E:
			rax_n = 0xFFFFFFFF;
			return (word32) rax_n;
		}
		fn000000000040ADB0(&rdi->ptr0028);
		Eq_n rax_n;
		rax_n.u4 = rdi->t0010.u4;
		ui32 eax_n = (word32) rax_n;
		struct Eq_n * rdx_n = rdi->ptr0028;
		word128 xmm0_n;
		word128 xmm0_n;
		if (rax_n >= 0x00)
			xmm0_n = SEQ(SLICE(xmm0_n, word96, 32), (real32) rax_n);
		else
		{
			real32 v52_n = (real32) (rax_n >> 0x01 | (uint64) (eax_n & 0x01));
			xmm0_n = SEQ(SLICE(xmm0_n, word96, 32), v52_n + v52_n);
		}
		Eq_n rax_n;
		rax_n.u0 = rdi->t0018.u0;
		ui32 eax_n = (word32) rax_n;
		word128 xmm1_n;
		word128 xmm1_n;
		if (rax_n >= 0x00)
			xmm1_n = SEQ(SLICE(xmm1_n, word96, 32), (real32) rax_n);
		else
		{
			real32 v47_n = (real32) (rax_n >> 0x01 | (uint64) (eax_n & 0x01));
			xmm1_n = SEQ(SLICE(xmm1_n, word96, 32), v47_n + v47_n);
		}
		if ((real32) xmm1_n <= rdx_n->r0008 * (real32) xmm0_n)
			goto l000000000040B96A;
		real32 v42_n = (real32) xmm0_n * rdx_n->r000C;
		word96 v43_n = SLICE(xmm0_n, word96, 32);
		word128 xmm0_n = SEQ(v43_n, v42_n);
		if (rdx_n->b0010 == 0x00)
			xmm0_n = SEQ(v43_n, v42_n * rdx_n->r0008);
		if ((real32) xmm0_n >= g_t415F08.u0)
			goto l000000000040BB2E;
		Eq_n rsi_n;
		if ((real32) xmm0_n < g_t415F0C.u0)
			rsi_n.u0 = (int64) (real32) xmm0_n;
		else
			rsi_n = (int64) ((real32) xmm0_n - g_t415F0C.u0) ^ 0x8000000000000000;
		if ((byte) fn000000000040B710(rsi_n, rdi) == 0x00)
			goto l000000000040BB2E;
		if (fn000000000040ACB0(0x00, &tLoc20, rsi, rdi) == 0x00)
			goto l000000000040B96A;
	}
	abort();
}

// 000000000040BB50: Register Eq_n fn000000000040BB50(Register Eq_n rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn00000000004028C0
Eq_n fn000000000040BB50(Eq_n rsi, struct Eq_n * rdi)
{
	Eq_n tLoc10;
	word32 eax_n = fn000000000040B8F0(&tLoc10, rsi, rdi);
	Eq_n rax_n;
	if (eax_n != ~0x00)
	{
		rax_n = rsi;
		if (eax_n == 0x00)
			rax_n.u4 = tLoc10.t0000.u4;
	}
	else
		rax_n.u0 = 0x00;
	return rax_n;
}

// 000000000040BB90: Register uint64 fn000000000040BB90(Register Eq_n rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn00000000004028C0
uint64 fn000000000040BB90(Eq_n rsi, struct Eq_n * rdi)
{
	Eq_n tLoc20;
	uint64 rax_n = fn000000000040ACB0(0x01, &tLoc20, rsi, rdi);
	if (rax_n == 0x00)
	{
		rax_n = 0x00;
		return rax_n;
	}
	else
	{
		word64 * rdx_n = (word64 *) tLoc20;
		--rdi->qw0020;
		if (*rdx_n != 0x00)
			return rax_n;
		Eq_n rax_n;
		rax_n.u0 = rdi->t0018.u0;
		rdi->t0018.u0 = (int64) (rax_n - 0x01);
		ui32 eax_n = (word32) rax_n - 0x01;
		word128 xmm0_n;
		word128 xmm0;
		if (rax_n >= 0x01)
			xmm0_n = SEQ(SLICE(xmm0, word96, 32), (real32) (rax_n - 0x01));
		else
		{
			real32 v29_n = (real32) (rax_n - 0x01 >> 0x01 | (uint64) (eax_n & 0x01));
			xmm0_n = SEQ(SLICE(xmm0, word96, 32), v29_n + v29_n);
		}
		Eq_n rax_n;
		rax_n.u4 = rdi->t0010.u4;
		ui32 eax_n = (word32) rax_n;
		struct Eq_n * rdx_n = rdi->ptr0028;
		word128 xmm1_n;
		word128 xmm1;
		if (rax_n >= 0x00)
			xmm1_n = SEQ(SLICE(xmm1, word96, 32), (real32) rax_n);
		else
		{
			real32 v41_n = (real32) (rax_n >> 0x01 | (uint64) (eax_n & 0x01));
			xmm1_n = SEQ(SLICE(xmm1, word96, 32), v41_n + v41_n);
		}
		if ((real32) xmm1_n * rdx_n->r0000 <= (real32) xmm0_n)
			return rax_n;
		fn000000000040ADB0(&rdi->ptr0028);
		Eq_n rdx_n;
		rdx_n.u4 = rdi->t0010.u4;
		ui32 edx_n = (word32) rdx_n;
		struct Eq_n * rax_n = rdi->ptr0028;
		word128 xmm0_n;
		word128 xmm0_n;
		if (rdx_n >= 0x00)
			xmm0_n = SEQ(SLICE(xmm0_n, word96, 32), (real32) rdx_n);
		else
		{
			real32 v45_n = (real32) (rdx_n >> 0x01 | (uint64) (edx_n & 0x01));
			xmm0_n = SEQ(SLICE(xmm0_n, word96, 32), v45_n + v45_n);
		}
		Eq_n rdx_n;
		rdx_n.u0 = rdi->t0018.u0;
		ui32 edx_n = (word32) rdx_n;
		word128 xmm1_n;
		word128 xmm1_n;
		if (rdx_n >= 0x00)
			xmm1_n = SEQ(SLICE(xmm1_n, word96, 32), (real32) rdx_n);
		else
		{
			real32 v48_n = (real32) (rdx_n >> 0x01 | (uint64) (edx_n & 0x01));
			xmm1_n = SEQ(SLICE(xmm1_n, word96, 32), v48_n + v48_n);
		}
		if (rax_n->r0000 * (real32) xmm0_n <= (real32) xmm1_n)
			return rax_n;
		real32 v37_n = (real32) xmm0_n * rax_n->r0004;
		word96 v38_n = SLICE(xmm0_n, word96, 32);
		word128 xmm0_n = SEQ(v38_n, v37_n);
		if (rax_n->b0010 == 0x00)
			xmm0_n = SEQ(v38_n, v37_n * rax_n->r0008);
		Eq_n rsi_n;
		if ((real32) xmm0_n < g_t415F0C.u0)
			rsi_n.u0 = (int64) (real32) xmm0_n;
		else
			rsi_n = (int64) ((real32) xmm0_n - g_t415F0C.u0) ^ 0x8000000000000000;
		if ((byte) fn000000000040B710(rsi_n, rdi) == 0x00)
		{
			struct Eq_n * rdi_n = rdi->ptr0048;
			if (rdi_n != null)
			{
				while (true)
				{
					struct Eq_n * r12_n = rdi_n->ptr0008;
					free(rdi_n);
					if (r12_n == null)
						break;
					rdi_n = r12_n;
				}
			}
			rdi->ptr0048 = null;
		}
		return rax_n;
	}
}

// 000000000040BD70: Register Eq_n fn000000000040BD70(Register Eq_n rcx, Register ui32 edx, Register Eq_n rsi, Register Eq_n rdi, Register Eq_n r8, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
//      fn0000000000405D50
//      fn0000000000406B70
//      fn0000000000407870
//      fn0000000000407EA0
Eq_n fn000000000040BD70(Eq_n rcx, ui32 edx, Eq_n rsi, Eq_n rdi, Eq_n r8, struct Eq_n * fs)
{
	word64 rcx_n = fs->qw0028;
	struct lconv * rax_n = localeconv();
	Eq_n r15_n;
	r15_n.u0 = rax_n->t0000.u0;
	Eq_n rax_n = strlen(r15_n);
	byte bLocC8_n = (byte) edx;
	Eq_n v24_n = (0x00 - (word32) ((edx & 0x20) < 0x01) & ~0x17) + 0x0400;
	byte * rbp_n = rax_n->ptr0010;
	Eq_n r11_n = rax_n;
	Eq_n r13_n;
	r13_n.u0 = rax_n->t0008.u0;
	if (rax_n >= 0x11)
	{
		r11_n.u0 = 0x01;
		r15_n.u0 = 0x00413990;
	}
	if (strlen(r13_n) >= 0x11)
		r13_n.u0 = 0x00416919;
	byte * qwLocD0_n = &rsi.u4->u1.b0288;
	Eq_n r10_n;
	Eq_n ecx_n;
	uint64 rdi_n;
	Eq_n r8_n;
	ui32 ebx_n;
	Eq_n r12_n;
	if (r8 <= rcx)
	{
		uint128 rdx_rax_n = (uint128) rcx;
		Eq_n rax_n = rdx_rax_n /u r8;
		if (rdx_rax_n % r8 != 0x00)
			goto l000000000040BE59;
		r10_n = rax_n *s64 rdi;
		if ((uint128) r10_n /u rax_n == rdi)
		{
			ecx_n.u0 = 0x00;
			rdi_n = 0x00;
			goto l000000000040C12D;
		}
	}
	else
	{
		if (rcx == 0x00)
			goto l000000000040BE59;
		uint128 rdx_rax_n = (uint128) r8;
		uint64 rax_n = rdx_rax_n /u rcx;
		if (rdx_rax_n % rcx == 0x00)
		{
			uint128 rdx_rax_n = (uint128) rdi;
			uint128 rdx_rax_n = (uint128) (rdx_rax_n % rax_n * 0x0A);
			r10_n = rdx_rax_n /u rax_n;
			uint64 rdx_n = rdx_rax_n % rax_n;
			rdi_n = (uint64) (word32) (rdx_rax_n /u rax_n);
			if (rax_n > rdx_n * 0x02)
				ecx_n.u1 = (uint32) (rdx_n * 0x02 != 0x00);
			else
				ecx_n = (word32) (rax_n < rdx_n * 0x02) + 0x02;
l000000000040C12D:
			uint64 r9_n = (uint64) (edx & 0x10);
			Eq_n edi_n = (word32) rdi_n;
			r8_n.u1 = &rsi.u4->u1.b0288;
			ebx_n = ~0x00;
			word32 r9d_n = (word32) r9_n;
			if (r9d_n != 0x00)
			{
				Eq_n rsi_n;
				rsi_n.u1 = (uint64) v24_n;
				uint64 rdi_n = rdi_n;
				if (r10_n >= rsi_n)
				{
					ebx_n = 0x00;
					do
					{
						uint128 rdx_rax_n = (uint128) r10_n;
						uint64 rdx_n = rdx_rax_n % rsi_n;
						uint64 edx_eax_n = (uint64) ((word32) rdi_n + ((word32) rdx_n + (word32) rdx_n * 0x04) * 0x02);
						uint32 eax_n = edx_eax_n /u v24_n;
						uint32 edx_n = edx_eax_n % v24_n;
						Eq_n rax_n = rdx_rax_n /u rsi_n;
						uint64 rdi_n = (uint64) eax_n;
						Eq_n r14d_n = (ecx_n >> 0x01) + edx_n * 0x02;
						r10_n = rax_n;
						edi_n = (word32) rdi_n;
						Eq_n ecx_n = ecx_n + r14d_n;
						if (v24_n <= r14d_n)
							ecx_n = (word32) (v24_n < ecx_n) + 0x02;
						else
							ecx_n = (word32) (ecx_n != 0x00);
						++ebx_n;
						rdi_n = rdi_n;
						if (rsi_n > rax_n)
						{
							if (rax_n > 0x09)
								break;
							int8 dl_n;
							if ((edx & 0x03) != 0x01)
								dl_n = (int8) (ecx_n > 0x00) & (int8) ((edx & 0x03) == 0x00);
							else
								dl_n = (int8) ((word32) ecx_n + (eax_n & 0x01) > 0x02);
							if (dl_n == 0x00)
							{
								if (eax_n == 0x00)
								{
l000000000040C790:
									if ((bLocC8_n & 0x08) != 0x00)
									{
										r8_n.u1 = &rsi.u4->u1.b0288;
										edi_n.u0 = 0x00;
										goto l000000000040C530;
									}
									edi_n.u0 = 0x00;
								}
l000000000040C4DB:
								rsi.u4->u1.b0287 = (byte) edi_n + 0x30;
								r8_n = memcpy(&rsi.u4->u1.b0287 - r11_n, r15_n, r11_n);
								r9_n = (uint64) r9d_n;
								ecx_n.u0 = 0x00;
								edi_n.u0 = 0x00;
								goto l000000000040C530;
							}
							else
							{
								edi_n = eax_n + 0x01;
								if (eax_n != 0x09)
									goto l000000000040C4DB;
								r10_n = (word64) rax_n.u1 + 1;
								if (rax_n == 0x09)
								{
									r8_n.u1 = &rsi.u4->u1.b0288;
									ecx_n.u0 = 0x00;
									edi_n.u0 = 0x00;
									goto l000000000040C530;
								}
								ecx_n.u0 = 0x00;
								goto l000000000040C790;
							}
						}
					} while (ebx_n != 0x08);
					r8_n.u1 = &rsi.u4->u1.b0288;
				}
				else
				{
					r8_n.u1 = &rsi.u4->u1.b0288;
					ebx_n = 0x00;
				}
			}
l000000000040C530:
			word32 r9d_n = (word32) r9_n;
			int8 al_n;
			if ((edx & 0x03) != 0x01)
			{
				al_n = 0x00;
				if ((edx & 0x03) == 0x00)
					al_n = CONVERT(ecx_n + edi_n > 0x00, bool, int8);
			}
			else
				al_n = (int8) ((word32) edi_n + (word32) ((uint64) ((word32) r10_n & 0x01) + (int64) ecx_n != 0x00) > 0x05);
			if (al_n != 0x00)
			{
				r10_n = (word32) r10_n + 1;
				if (r9d_n != 0x00 && ((uint64) v24_n == r10_n && ebx_n != 0x08))
				{
					++ebx_n;
					r10_n.u1 = 0x01;
					if ((bLocC8_n & 0x08) == 0x00)
					{
						r8_n.u2->bFFFFFFFF = 0x30;
						r10_n.u1 = 0x01;
						r8_n = memcpy(r8_n - 1 - r11_n, r15_n, r11_n);
					}
				}
			}
			r12_n = r8_n;
			uint64 rdx_n;
			do
			{
				rdx_n = SLICE(r10_n *128 ~0x3333333333333332, word64, 64);
				--r12_n;
				*r12_n.u1 = (byte) r10_n - ((byte) (rdx_n >> 0x03) + (byte) (rdx_n >> 0x03) * 0x04) * 0x02 + 0x30;
				r10_n = rdx_n >> 0x03;
			} while (rdx_n >> 0x03 != 0x00);
l000000000040C237:
			if ((bLocC8_n & 0x04) != 0x00)
			{
				Eq_n r8_n = r8_n - r12_n;
				Eq_n rax_n = strlen(r13_n);
				word64 qwLoc78;
				__memcpy_chk(&qwLoc78, r12_n, r8_n, 0x29);
				Eq_n r15_n;
				r15_n.u0 = ~0x00;
				Eq_n r14_n = r8_n;
				Eq_n r9_n = r12_n + r8_n;
				Eq_n rax_n;
				while (true)
				{
					cu8 dl_n = *rbp_n;
					if (dl_n != 0x00)
					{
						r15_n.u4 = (uint64) dl_n;
						if (dl_n > 0x7E)
							r15_n = r14_n;
						++rbp_n;
					}
					if (r15_n > r14_n)
						r15_n = r14_n;
					r14_n -= r15_n;
					rax_n = memcpy(r9_n - r15_n, &qwLoc78 + r14_n, r15_n);
					if (r14_n == 0x00)
						break;
					r9_n = memcpy(rax_n - rax_n, r13_n, rax_n);
				}
				r12_n = rax_n;
			}
			byte bLocC8_n = (byte) edx;
			if ((bLocC8_n & 0x80) != 0x00)
			{
				if (ebx_n == ~0x00)
				{
					if (r8 > 0x01)
					{
						Eq_n r14_n;
						r14_n.u1 = (uint64) v24_n;
						Eq_n rax_n;
						rax_n.u1 = 0x01;
						for (ebx_n = 0x01; ebx_n != 0x08; ++ebx_n)
						{
							rax_n *= r14_n;
							if (r8 <= rax_n)
								break;
						}
					}
					else
						ebx_n = 0x00;
				}
				if ((ebx_n | edx & 0x0100) != 0x00)
				{
					if ((bLocC8_n & 0x40) != 0x00)
					{
						rsi.u4->u1.b0288 = 0x20;
						qwLocD0_n = (byte *) ((word32) rsi + 649);
					}
					byte * rdx_n;
					if (ebx_n != 0x00)
					{
						rdx_n = qwLocD0_n + 1;
						uint64 rcx_n;
						if ((edx & 0x20) != 0x00 || ebx_n != 0x01)
							rcx_n = (uint64) *((word64) (int64) ebx_n + 4284280);
						else
							rcx_n = 0x6B;
						*qwLocD0_n = (byte) rcx_n;
					}
					else
						rdx_n = qwLocD0_n;
					if ((edx & 0x0100) != 0x00)
					{
						if ((edx & 0x20) != 0x00 && ebx_n != 0x00)
						{
							*rdx_n = 0x69;
							++rdx_n;
						}
						*rdx_n = 66;
						qwLocD0_n = rdx_n + 1;
					}
					else
						qwLocD0_n = rdx_n;
				}
			}
			ui64 rdi_n = rcx_n ^ fs->qw0028;
			*qwLocD0_n = 0x00;
			if (rdi_n == 0x00)
				return r12_n;
			__stack_chk_fail();
		}
	}
l000000000040BE59:
	real64 rLoc1_n = (real64) rdi;
	real64 rLoc2_n;
	if (rdi >= 0x00)
	{
		rLoc2_n = (real64) rcx;
		if (rcx >= 0x00)
			goto l000000000040BE7D;
	}
	else
	{
		rLoc1_n += (real64) g_t415F08.u0;
		rLoc2_n = (real64) rcx;
		if (rcx >= 0x00)
			goto l000000000040BE7D;
	}
	rLoc2_n += (real64) g_t415F08.u0;
l000000000040BE7D:
	real64 rLoc3_n = (real64) r8;
	if (r8 < 0x00)
		rLoc3_n += (real64) g_t415F08.u0;
	Eq_n rLoc1_n = rLoc1_n * (rLoc2_n / rLoc3_n);
	Eq_n r15_n;
	Eq_n r14_n;
	if ((bLocC8_n & 0x10) != 0x00)
	{
		Eq_n rLoc2_n;
		rLoc2_n.u0 = (real64) v24_n;
		ebx_n = 0x00;
		Eq_n rLoc3_n = rLoc2_n;
		while (true)
		{
			++ebx_n;
			Eq_n rLoc4_n = rLoc3_n *64 rLoc2_n;
			if (rLoc1_n < rLoc4_n || ebx_n == 0x08)
				break;
			rLoc3_n = rLoc4_n;
		}
		Eq_n rLoc1_n = rLoc1_n /64 rLoc3_n;
		Eq_n rLoc1_n;
		if ((edx & 0x03) != 0x01)
		{
			if ((real64) g_r415F90 > rLoc1_n)
			{
				Eq_n rLoc2_n;
				rLoc2_n.u0 = (real64) g_t415F0C.u0;
				int64 rax_n;
				if (rLoc1_n < rLoc2_n)
				{
					Eq_n wLoc82_n = __fstcw();
					uint64 rax_n = (uint64) wLoc82_n;
					__fldcw(SEQ(SLICE(rax_n, byte, 8) | 0x0C, (byte) rax_n));
					__fldcw(wLoc82_n);
					rax_n = (int64) rLoc1_n;
				}
				else
				{
					Eq_n wLoc82_n = __fstcw();
					uint64 rax_n = (uint64) wLoc82_n;
					__fldcw(SEQ(SLICE(rax_n, byte, 8) | 0x0C, (byte) rax_n));
					__fldcw(wLoc82_n);
					rax_n = (int64) (rLoc1_n - rLoc2_n) ^ 0x8000000000000000;
				}
				uint64 rdx_n = 0x00;
				if ((edx & 0x03) == 0x00)
				{
					Eq_n rLoc2_n;
					rLoc2_n.u0 = (real64) rax_n;
					if (rax_n < 0x00)
						rLoc2_n += (real64) g_t415F08.u0;
					rdx_n = 0x01;
					uint64 rcx_n = (uint64) PARITY_EVEN(rLoc2_n - rLoc1_n);
					if (rLoc2_n == rLoc1_n)
						rdx_n = rcx_n;
				}
				int64 rax_n = rax_n + rdx_n;
				Eq_n rLoc2_n;
				rLoc2_n.u0 = (real64) rax_n;
				if (rax_n >= 0x00)
					rLoc1_n = rLoc2_n;
				else
					rLoc1_n = rLoc2_n + (real64) g_t415F08.u0;
			}
			else
				rLoc1_n = rLoc1_n;
		}
		else
			rLoc1_n = rLoc1_n;
		__sprintf_chk(rsi, 1, ~0x00, "%.1Lf", (real80) rLoc1_n);
		Eq_n rax_n = strlen(rsi);
		r15_n = rax_n;
		r14_n.u1 = r11_n.u6 + 1;
		if (rax_n > (r11_n.u6 + 2) + (uint64) ((edx & 0x20) == 0x00) || (bLocC8_n & 0x08) != 0x00 && Mem1008[(rsi - 1) + rax_n:byte] == 0x30)
		{
			Eq_n rLoc1_n = rLoc1_n *64 (real64) 10.0F;
			if ((edx & 0x03) != 0x01 && (real64) g_r415F90 > rLoc1_n)
			{
				Eq_n rLoc2_n;
				rLoc2_n.u0 = (real64) g_t415F0C.u0;
				int64 rax_n;
				if (rLoc1_n < rLoc2_n)
				{
					Eq_n wLoc82_n = __fstcw();
					uint64 rax_n = (uint64) wLoc82_n;
					__fldcw(SEQ(SLICE(rax_n, byte, 8) | 0x0C, (byte) rax_n));
					__fldcw(wLoc82_n);
					rax_n = (int64) rLoc1_n;
				}
				else
				{
					Eq_n wLoc82_n = __fstcw();
					uint64 rax_n = (uint64) wLoc82_n;
					__fldcw(SEQ(SLICE(rax_n, byte, 8) | 0x0C, (byte) rax_n));
					__fldcw(wLoc82_n);
					rax_n = (int64) (rLoc1_n - rLoc2_n) ^ 0x8000000000000000;
				}
				uint64 rdx_n = 0x00;
				if ((edx & 0x03) == 0x00)
				{
					Eq_n rLoc2_n;
					rLoc2_n.u0 = (real64) rax_n;
					if (rax_n < 0x00)
						rLoc2_n += (real64) g_t415F08.u0;
					rdx_n = 0x01;
					uint64 rcx_n = (uint64) PARITY_EVEN(rLoc2_n - rLoc1_n);
					if (rLoc2_n == rLoc1_n)
						rdx_n = rcx_n;
				}
				Eq_n rax_n = rax_n + rdx_n;
				rLoc1_n.u0 = (real64) rax_n;
				if (rax_n < 0x00)
					rLoc1_n += (real64) g_t415F08.u0;
			}
			__sprintf_chk(rsi, 1, ~0x00, "%.0Lf", (real80) (rLoc1_n /64 (real64) 10.0F));
			r14_n.u0 = 0x00;
			r15_n = strlen(rsi);
		}
	}
	else
	{
		if ((edx & 0x03) != 0x01 && (real64) g_r415F90 > rLoc1_n)
		{
			Eq_n rLoc2_n;
			rLoc2_n.u0 = (real64) g_t415F0C.u0;
			int64 rax_n;
			if (rLoc1_n < rLoc2_n)
			{
				Eq_n wLoc82_n = __fstcw();
				uint64 rax_n = (uint64) wLoc82_n;
				__fldcw(SEQ(SLICE(rax_n, byte, 8) | 0x0C, (byte) rax_n));
				__fldcw(wLoc82_n);
				rax_n = (int64) rLoc1_n;
			}
			else
			{
				Eq_n wLoc82_n = __fstcw();
				uint64 rax_n = (uint64) wLoc82_n;
				__fldcw(SEQ(SLICE(rax_n, byte, 8) | 0x0C, (byte) rax_n));
				__fldcw(wLoc82_n);
				rax_n = (int64) (rLoc1_n - rLoc2_n) ^ 0x8000000000000000;
			}
			uint64 rdx_n = 0x00;
			if ((edx & 0x03) == 0x00)
			{
				Eq_n rLoc2_n;
				rLoc2_n.u0 = (real64) rax_n;
				if (rax_n < 0x00)
					rLoc2_n += (real64) g_t415F08.u0;
				rdx_n = 0x01;
				uint64 rcx_n = (uint64) PARITY_EVEN(rLoc2_n - rLoc1_n);
				if (rLoc2_n == rLoc1_n)
					rdx_n = rcx_n;
			}
			Eq_n rax_n = rax_n + rdx_n;
			rLoc1_n.u0 = (real64) rax_n;
			if (rax_n < 0x00)
				rLoc1_n += (real64) g_t415F08.u0;
		}
		__sprintf_chk(rsi, 1, ~0x00, "%.0Lf", (real80) rLoc1_n);
		r14_n.u0 = 0x00;
		ebx_n = ~0x00;
		r15_n = strlen(rsi);
	}
	r12_n = &rsi.u4->u1.b0288 - r15_n;
	memmove(r12_n, rsi, r15_n);
	r8_n = r12_n + (r15_n - r14_n);
	goto l000000000040C237;
}

// 000000000040C810: Register word32 fn000000000040C810(Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
word32 fn000000000040C810(Eq_n rdx, Eq_n rsi, Eq_n rdi)
{
	ptr64 fp;
	Eq_n rbx_n = rdi;
	ui32 ebp_n;
	Eq_n rdx_n;
	if (rdi == 0x00)
	{
		Eq_n rax_n = getenv(4274404);
		rbx_n = rax_n;
		if (rax_n == 0x00)
		{
			Eq_n rax_n = getenv(0x00415F24);
			rbx_n = rax_n;
			if (rax_n == 0x00)
			{
				uint64 rdx_n = (uint64) (0x00 - (word32) (getenv(4284206) < (char *) 0x01) & 0x0200);
				rdx.u1->u0 = (int64) (rdx_n + 0x0200);
				ebp_n = 0x00;
				rdx_n = rdx_n + 0x0200;
				goto l000000000040C864;
			}
		}
	}
	ebp_n = 0x00;
	if (*rbx_n.u4 == 0x27)
	{
		++rbx_n.u6;
		ebp_n = 0x04;
	}
	byte bpl_n = (byte) ebp_n;
	word24 ebp_24_8_n = SLICE(ebp_n, word24, 8);
	int32 eax_n = (word32) fn0000000000409E50(0x04, 4284240, 4284256, rbx_n);
	if (eax_n >= 0x00)
	{
		rdx.u1->u0 = 0x01;
		rdx_n.u1 = 0x01;
		ebp_n |= *((word64) 4284240 + (int64) eax_n * 0x04);
		goto l000000000040C864;
	}
	uint64 rax_n = (uint64) fn0000000000411360(rdx, 0x00, fp - 0x30, rbx_n, 4284222);
	if ((word32) rax_n != 0x00)
	{
		*rsi.u1 = 0x00;
		rdx_n.u0 = rdx.u1->u0;
l000000000040C86A:
		if (rdx_n == 0x00)
		{
			rdx.u1->u0 = (int64) ((uint64) (0x00 - (word32) (getenv(4284206) < (char *) 0x01) & 0x0200) + 0x0200);
			rax_n = 0x04;
		}
		return (word32) rax_n;
	}
	if (*rbx_n.u4 > 0x39)
	{
		Eq_n qwLoc30;
		while (rbx_n != qwLoc30)
		{
			++rbx_n.u6;
			if (*rbx_n.u4 <= 0x39 && *rbx_n.u4 >= 0x30)
				goto l000000000040C907;
		}
		if (qwLoc30.u6->bFFFFFFFF != 66)
			ebp_n = SEQ(ebp_24_8_n, bpl_n | 0x80);
		else
		{
			ebp_n |= 0x0180;
			if (qwLoc30.u6->bFFFFFFFE != 0x69)
				goto l000000000040C907;
		}
		ebp_n |= 0x20;
	}
l000000000040C907:
	rdx_n.u0 = rdx.u1->u0;
l000000000040C864:
	*rsi.u1 = ebp_n;
	rax_n = 0x00;
	goto l000000000040C86A;
}

// 000000000040C9B0: Register Eq_n fn000000000040C9B0(Register Eq_n edi)
// Called from:
//      fn00000000004057B0
//      fn00000000004061B0
Eq_n fn000000000040C9B0(Eq_n edi)
{
	word64 rdi;
	edi = (word32) rdi;
	Eq_n rbx_n;
	rbx_n.u4 = g_t61B1F8.u4;
	while (rbx_n != 0x00)
	{
		if (rbx_n.u9->u1.t0000.u0 == edi)
			goto l000000000040C9D5;
		rbx_n.u4 = rbx_n.u6[8];
	}
	Eq_n r12_n;
	r12_n.u0 = 0x00416919;
	struct passwd * rax_n = getpwuid(edi);
	Eq_n rdi_n;
	rdi_n.u0 = 0x11;
	if (rax_n != null)
	{
		r12_n.u1 = rax_n->pw_name;
		rdi_n.u4 = (word64) strlen(r12_n) + 0x0011;
	}
	Eq_n rax_n = fn0000000000410C40(rdi_n);
	rax_n.u9->u1.t0000.u0 = (int32) edi;
	strcpy(rax_n.u6 + 16, r12_n);
	Eq_n rax_n;
	rax_n.u4 = g_t61B1F8.u4;
	g_t61B1F8.u4 = (char *) rax_n;
	rax_n.u6[8] = (struct tm) rax_n;
	rbx_n = rax_n;
l000000000040C9D5:
	Eq_n rax_n;
	rax_n.u0 = 0x00;
	Eq_n rdx_n = rbx_n.u6 + 16;
	if (rbx_n.u6[16] != 0x00)
		rax_n = rdx_n;
	return rax_n;
}

// 000000000040CB40: Register Eq_n fn000000000040CB40(Register Eq_n edi)
// Called from:
//      fn0000000000406B70
//      fn0000000000407EA0
Eq_n fn000000000040CB40(Eq_n edi)
{
	word64 rdi;
	edi = (word32) rdi;
	Eq_n rbx_n;
	rbx_n.u4 = g_t61B1E8.u4;
	while (rbx_n != 0x00)
	{
		if (rbx_n.u9->u1.t0000.u0 == edi)
			goto l000000000040CB65;
		rbx_n.u4 = rbx_n.u6[8];
	}
	Eq_n r12_n;
	r12_n.u0 = 0x00416919;
	union Eq_n * rax_n = getgrgid(edi);
	Eq_n rdi_n;
	rdi_n.u0 = 0x11;
	if (rax_n != null)
	{
		r12_n.u0 = rax_n->u0;
		rdi_n.u4 = (word64) strlen(r12_n) + 0x0011;
	}
	Eq_n rax_n = fn0000000000410C40(rdi_n);
	rax_n.u9->u1.t0000.u0 = (int32) edi;
	strcpy(rax_n.u6 + 16, r12_n);
	Eq_n rax_n;
	rax_n.u4 = g_t61B1E8.u4;
	g_t61B1E8.u4 = (char *) rax_n;
	rax_n.u6[8] = (struct tm) rax_n;
	rbx_n = rax_n;
l000000000040CB65:
	Eq_n rax_n;
	rax_n.u0 = 0x00;
	Eq_n rdx_n = rbx_n.u6 + 16;
	if (rbx_n.u6[16] != 0x00)
		rax_n = rdx_n;
	return rax_n;
}

// 000000000040CCD0: Register (ptr64 Eq_n) fn000000000040CCD0(Register (ptr64 Eq_n) rsi, Register int64 rdi)
// Called from:
//      fn0000000000406B70
struct Eq_n * fn000000000040CCD0(struct Eq_n * rsi, int64 rdi)
{
	rsi->b0014 = 0x00;
	struct Eq_n * rcx_n = (struct Eq_n *) &rsi->b0014;
	if (rdi < 0x00)
	{
		int64 rdx_n;
		do
		{
			rdx_n = (SLICE(rdi *s128 0x6666666666666667, word64, 64) >> 0x02) - (rdi >> 0x3F);
			--rcx_n;
			rcx_n->b0000 = (byte) rdx_n * 0x0A + 0x30 - (byte) rdi;
			rdi = rdx_n;
		} while (rdx_n != 0x00);
		rcx_n->bFFFFFFFF = 0x2D;
		return rcx_n - 0x01;
	}
	else
	{
		int64 rdx_n;
		do
		{
			rdx_n = (SLICE(rdi *s128 0x6666666666666667, word64, 64) >> 0x02) - (rdi >> 0x3F);
			--rcx_n;
			rcx_n->b0000 = (byte) rdi - (byte) rdx_n * 0x0A + 0x30;
			rdi = rdx_n;
		} while (rdx_n != 0x00);
		return rcx_n;
	}
}

// 000000000040CD70: Register (ptr64 byte) fn000000000040CD70(Register (ptr64 Eq_n) rsi, Register Eq_n rdi)
// Called from:
//      fn0000000000405D50
//      fn0000000000406B70
//      fn0000000000407870
//      fn0000000000407EA0
byte * fn000000000040CD70(union Eq_n * rsi, Eq_n rdi)
{
	rsi->u1.b0014 = 0x00;
	byte * rcx_n = &rsi->u1.b0014;
	uint64 rdx_n;
	do
	{
		rdx_n = SLICE(rdi *128 ~0x3333333333333332, word64, 64);
		--rcx_n;
		*rcx_n = (byte) rdi - ((byte) (rdx_n >> 0x03) + (byte) (rdx_n >> 0x03) * 0x04) * 0x02 + 0x30;
		rdi = rdx_n >> 0x03;
	} while (rdx_n >> 0x03 != 0x00);
	return rcx_n;
}

// 000000000040CDC0: Register uint64 fn000000000040CDC0(Register Eq_n rcx, Register uint64 rdx, Register Eq_n rsi, Register Eq_n rdi, Register word32 r8d, Register word32 r9d)
// Called from:
//      fn00000000004028C0
uint64 fn000000000040CDC0(Eq_n rcx, uint64 rdx, Eq_n rsi, Eq_n rdi, word32 r8d, word32 r9d)
{
	uint64 rbx_n = (uint64) r9d;
	Eq_n rax_n = strlen(rdi);
	Eq_n r13_n = rsi;
	byte bl_n = (byte) rbx_n;
	Eq_n qwLoc60_n = rdi;
	Eq_n r14_n = rax_n;
	union Eq_n * qwLoc58_n;
	if ((bl_n & 0x02) != 0x00 || __ctype_get_mb_cur_max() <= 0x01)
	{
		qwLoc58_n = null;
		goto l000000000040CE03;
	}
	Eq_n rax_n = mbstowcs(0x00, rdi, 0x00);
	Eq_n r15_n;
	Eq_n rbp_n;
	if (rax_n == ~0x00)
	{
		if ((bl_n & 0x01) != 0x00)
		{
			r15_n = rax_n;
			qwLoc58_n = null;
			rbp_n.u0 = 0x00;
			goto l000000000040CE08;
		}
		goto l000000000040CF8C;
	}
	union Eq_n * rax_n = malloc((rax_n.u6 + 1) * 0x04);
	qwLoc58_n = rax_n;
	uint64 r12_n;
	Eq_n rax_n;
	if (rax_n == null)
	{
		if ((bl_n & 0x01) == 0x00)
		{
l000000000040CF8C:
			qwLoc58_n = null;
			rbp_n.u0 = 0x00;
			r12_n = ~0x00;
			goto l000000000040CEFF;
		}
		r15_n = rax_n;
		rbp_n.u0 = 0x00;
l000000000040CE08:
		rax_n.u4 = *rcx.u5;
		if (r15_n > rax_n)
		{
			r14_n = rax_n;
			goto l000000000040CE1A;
		}
		goto l000000000040CF2A;
	}
	if (mbstowcs(rax_n, rdi, rax_n.u6 + 1) == 0x00)
	{
l000000000040CE03:
		r15_n = rax_n;
		rbp_n.u0 = 0x00;
		goto l000000000040CE08;
	}
	(rax_n - 4)[rax_n.u6 + 1] = 0x00;
	uint64 rdi_n = (uint64) rax_n->u1;
	Eq_n qwLoc48_n;
	if ((word32) rdi_n != 0x00)
	{
		union Eq_n * r15_n = rax_n;
		byte bLoc39_n = 0x00;
		do
		{
			if (iswprint((wint_t) rdi_n) == 0x00)
			{
				r15_n->u1 = 0xFFFD;
				bLoc39_n = 0x01;
			}
			r15_n = (union Eq_n *) ((char *) r15_n + 4);
			rdi_n = (uint64) r15_n->u1;
		} while ((word32) rdi_n != 0x00);
		r15_n.u4 = (int64) wcswidth(rax_n, rax_n.u6 + 1);
		if (bLoc39_n != 0x00)
		{
			qwLoc48_n.u6 = wcstombs(0x00, rax_n, 0x00).u6 + 1;
			goto l000000000040D064;
		}
	}
	else
		r15_n.u4 = (int64) wcswidth(rax_n, rax_n.u6 + 1);
	rax_n.u4 = *rcx.u5;
	if (r15_n <= rax_n)
	{
		rbp_n.u0 = 0x00;
l000000000040CF2A:
		Eq_n rcx_n;
		if (r15_n < rax_n)
		{
			*rcx.u5 = (word64) r15_n;
			rcx_n = rax_n - r15_n;
			if (r8d != 0x00)
				goto l000000000040CE2A;
			goto l000000000040CF4C;
		}
		rax_n = r15_n;
l000000000040CE1A:
		*rcx.u5 = (word64) rax_n;
		rcx_n.u0 = 0x00;
		Eq_n r12_n;
		if (r8d != 0x00)
		{
l000000000040CE2A:
			ui32 ecx_n = (word32) rcx_n;
			r12_n.u0 = 0x00;
			if (r8d != 0x01)
			{
				r12_n = rcx_n >> 0x01;
				rcx_n = (word32) r12_n + (uint64) (ecx_n & 0x01);
			}
l000000000040CE3E:
			ui32 ebx_n = (word32) rbx_n;
			if ((bl_n & 0x04) != 0x00)
				rcx_n.u0 = 0x00;
			if ((ebx_n & 0x08) != 0x00)
				r12_n.u0 = 0x00;
			if (rdx != 0x00)
			{
				uint64 rdx_n = rcx_n - 1;
				Eq_n rbx_n = rsi - 1 + rdx;
				if (rcx_n != 0x00 && rsi < rbx_n)
				{
					uint64 rax_n = 0x00;
					do
					{
						r13_n.u1 = (word32) r13_n + 1;
						r13_n.u1->bFFFFFFFF = 0x20;
						if (rdx_n == rax_n)
							break;
						++rax_n;
					} while (r13_n != rbx_n);
				}
				r13_n.u1->b0000 = 0x00;
				Eq_n rdx_n = rbx_n - r13_n;
				if (rdx_n > r14_n)
					rdx_n = r14_n;
				Eq_n rax_n = mempcpy(r13_n, qwLoc60_n, rdx_n);
				Eq_n rdx_n = rax_n;
				uint64 rsi_n = r12_n - 1;
				if (r12_n != 0x00 && rbx_n > rax_n)
				{
					uint64 rax_n = 0x00;
					do
					{
						rdx_n.u1 = (word32) rdx_n + 1;
						rdx_n.u1->bFFFFFFFF = 0x20;
						if (rsi_n == rax_n)
							break;
						++rax_n;
					} while (rdx_n != rbx_n);
				}
				rdx_n.u1->b0000 = 0x00;
			}
			r12_n = r12_n + (rcx_n + r14_n);
l000000000040CEFF:
			free(qwLoc58_n);
			free(rbp_n);
			return r12_n;
		}
l000000000040CF4C:
		r12_n = rcx_n;
		rcx_n.u0 = 0x00;
		goto l000000000040CE3E;
	}
	qwLoc48_n.u6 = rax_n.u6 + 1;
l000000000040D064:
	Eq_n rax_n = malloc(qwLoc48_n);
	rbp_n = rax_n;
	if (rax_n != 0x00)
	{
		uint64 rdi_n = (uint64) rax_n->u1;
		Eq_n rax_n;
		rax_n.u4 = *rcx.u5;
		union Eq_n * r14_n;
		if ((word32) rdi_n != 0x00)
		{
			r14_n = rax_n;
			r15_n.u0 = 0x00;
			do
			{
				int32 eax_n = wcwidth((wchar_t) rdi_n);
				Eq_n rax_n;
				if (eax_n == ~0x00)
				{
					r14_n->u1 = 0xFFFD;
					rax_n.u6 = r15_n.u6 + 1;
					if (rax_n < rax_n)
						break;
				}
				else
				{
					rax_n.u4 = r15_n.u4 + (int64) eax_n;
					if (rax_n < rax_n)
						break;
				}
				r14_n = (union Eq_n *) ((char *) r14_n + 4);
				rdi_n = (uint64) r14_n->u1;
				r15_n = rax_n;
			} while ((word32) rdi_n != 0x00);
		}
		else
		{
			r14_n = rax_n;
			r15_n.u0 = 0x00;
		}
		r14_n->u1 = 0x00;
		qwLoc60_n = rax_n;
		r14_n = wcstombs(rax_n, rax_n, qwLoc48_n);
	}
	else if ((bl_n & 0x01) == 0x00)
	{
		r12_n = ~0x00;
		goto l000000000040CEFF;
	}
	goto l000000000040CE08;
}

// 000000000040D240: Register word32 fn000000000040D240(Register ui32 edx, Register Eq_n rsi, Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004052D0
//      fn0000000000406B70
//      fn000000000040D420
word32 fn000000000040D240(ui32 edx, Eq_n rsi, Eq_n rdi, struct Eq_n * fs)
{
	wchar_t wLoc4C;
	word64 rdx;
	edx = (word32) rdx;
	word64 rax_n = fs->qw0028;
	Eq_n r13_n = rdi + rsi;
	Eq_n rbp_n = rdi;
	uint64 rax_n;
	if (__ctype_get_mb_cur_max() > 0x01)
	{
		if (rdi < r13_n)
		{
			int32 r12d_n = 0x00;
			do
			{
l000000000040D2AC:
				uint64 rax_n = (uint64) *rbp_n.u4;
				ci8 al_n = (byte) rax_n;
				word32 eax_n = (word32) rax_n;
				if (al_n > 0x3F)
				{
					if (al_n >= 0x41 && (al_n <= 0x5F || (byte) eax_n <= 0x7E))
						goto l000000000040D29B;
					goto l000000000040D2C3;
				}
				if (al_n < 0x25 && ((byte) eax_n > 0x23 || (byte) eax_n < 0x20))
				{
l000000000040D2C3:
					Eq_n tLoc48 = (Eq_n) 0x00;
					do
					{
						Eq_n rax_n = mbrtowc(&wLoc4C, rbp_n, r13_n - rbp_n, &tLoc48);
						Eq_n rbx_n = rax_n;
						if (rax_n == ~0x00)
						{
							if ((edx & 0x01) != 0x00)
								goto l000000000040D369;
							goto l000000000040D29B;
						}
						if (rax_n == ~0x01)
						{
							if ((edx & 0x01) != 0x00)
								goto l000000000040D369;
							rbp_n = r13_n;
							++r12d_n;
							if (r13_n <= r13_n)
								goto l000000000040D401;
							goto l000000000040D2AC;
						}
						uint64 rdi_n = (uint64) wLoc4C;
						if (rax_n == 0x00)
							rbx_n.u0 = 0x01;
						int32 eax_n = wcwidth((wchar_t) rdi_n);
						if (eax_n < 0x00)
						{
							if ((edx & 0x02) != 0x00)
								goto l000000000040D369;
							if (iswcntrl(wLoc4C) == 0x00)
							{
								if (r12d_n == 0x7FFFFFFF)
									goto l000000000040D3C0;
								++r12d_n;
							}
						}
						else
						{
							if (eax_n > 0x7FFFFFFF - r12d_n)
								goto l000000000040D3C0;
							r12d_n += eax_n;
						}
						rbp_n += rbx_n;
					} while (mbsinit(&tLoc48) == 0x00);
				}
				else
				{
l000000000040D29B:
					++rbp_n;
					++r12d_n;
				}
			} while (r13_n > rbp_n);
l000000000040D401:
			rax_n = (uint64) r12d_n;
			goto l000000000040D3C5;
		}
	}
	else if (rdi < r13_n)
	{
		word16 rcx_n[] = (word16 (*)[]) *__ctype_b_loc();
		uint64 rax_n = 0x00;
		do
		{
			++rbp_n;
			uint64 rdx_n = (uint64) rcx_n[(uint64) rbp_n.u6->bFFFFFFFF];
			word32 eax_n = (word32) rax_n;
			ui32 edx_n = (word32) rdx_n;
			if ((SLICE(rdx_n, byte, 8) & 0x40) == 0x00)
			{
				if ((edx & 0x02) != 0x00)
				{
l000000000040D369:
					rax_n = 0xFFFFFFFF;
					break;
				}
				if ((edx_n & 0x02) == 0x00)
					goto l000000000040D3B2;
			}
			else
			{
l000000000040D3B2:
				if (eax_n == 0x7FFFFFFF)
				{
l000000000040D3C0:
					rax_n = 0x7FFFFFFF;
					break;
				}
				rax_n = (uint64) (eax_n + 0x01);
			}
			rax_n = rax_n;
		} while (rbp_n != r13_n);
l000000000040D3C5:
		if ((rax_n ^ fs->qw0028) == 0x00)
			return (word32) rax_n;
		__stack_chk_fail();
	}
	rax_n = 0x00;
	goto l000000000040D3C5;
}

// 000000000040D420: Register word32 fn000000000040D420(Register word32 esi, Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn0000000000405700
//      fn00000000004061B0
//      fn0000000000406B70
//      fn0000000000407EA0
word32 fn000000000040D420(word32 esi, Eq_n rdi, struct Eq_n * fs)
{
	Eq_n rax_n = strlen(rdi);
	uint64 rdx_n = (uint64) esi;
	return fn000000000040D240((word32) rdx_n, rax_n, rdi, fs);
}

// 000000000040D450: Register Eq_n fn000000000040D450(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rbx, Register Eq_n rsi, Register Eq_n rdi, Register out Eq_n rdxOut)
// Called from:
//      fn000000000040D450
//      fn000000000040D690
Eq_n fn000000000040D450(Eq_n rcx, Eq_n rdx, Eq_n rbx, Eq_n rsi, Eq_n rdi, union Eq_n & rdxOut)
{
	Eq_n qwLoc30_n = rbx;
	if (rsi <= 0x02)
	{
		if (rsi == 0x02)
		{
			Eq_n r13_n;
			r13_n.u4 = rdi.u6[8];
			Eq_n r12_n;
			r12_n.u4 = *rdi.u5;
			rcx();
			word64 rax_n;
			if ((word32) rax_n > 0x00)
			{
				*rdi.u5 = (word64) r13_n;
				rdi.u6[8] = (struct tm) r12_n;
				rdxOut = rdx;
				return rcx;
			}
		}
		goto l000000000040D479;
	}
	Eq_n rax_n;
	rax_n.u4 = rdi.u4 + (rsi >> 0x01) * 0x08;
	Eq_n qwLoc40_n = rax_n;
	rcx = fn000000000040D450(rcx, rdx, rdi, rsi - (rsi >> 0x01), rax_n, out rdx);
	Eq_n qwLoc48;
	Eq_n r12_n;
	if (rsi >> 0x01 != 0x01)
	{
		Eq_n r13_n;
		r13_n.u4 = rdi.u4 + (rsi >> 0x03) * 0x08;
		word64 qwLoc58;
		word64 rdx_n;
		fn000000000040D450(rcx, qwLoc48, rdi, qwLoc58 - (rsi >> 0x03), r13_n, out rdx_n);
		word64 rdx_n;
		rcx = fn000000000040D450(rcx, qwLoc48, rdi, rsi >> 0x03, rdi, out rdx_n);
		Eq_n r14_n = rsi >> 0x03;
		struct Eq_n * r15_n = (struct Eq_n *) (qwLoc48.u6 + 8);
		Eq_n r12_n;
		r12_n.u4 = *rdi.u5;
		Eq_n r13_n;
		r13_n.u4 = *r13_n.u5;
		qwLoc40_n.u0 = 0x00;
l000000000040D53B:
		rcx();
		word64 rax_n;
		if ((word32) rax_n <= 0x00)
		{
			Eq_n v25_n;
			v25_n.u6 = qwLoc40_n.u6 + 1;
			r15_n->qwFFFFFFF8 = (word64) r12_n;
			qwLoc40_n = v25_n;
			if (rbx != v25_n)
			{
				r12_n.u4 = rdi.u5[v25_n];
				goto l000000000040D537;
			}
			qwLoc40_n = r14_n;
			qwLoc30_n = qwLoc48;
		}
		else
		{
			r15_n->qwFFFFFFF8 = (word64) r13_n;
			++r14_n.u6;
			if (qwLoc48 != r14_n)
			{
				r13_n.u4 = rdi.u5[r14_n];
l000000000040D537:
				++r15_n;
				goto l000000000040D53B;
			}
		}
		ui64 rdx_n = qwLoc30_n - qwLoc40_n;
		memcpy(r15_n, rdi.u4 + qwLoc40_n *64 0x08, rdx_n << 0x03);
		rdx = rdx_n << 0x03;
		union Eq_n * qwLoc38;
		r12_n.u4 = qwLoc38->u4;
	}
	else
	{
		r12_n.u4 = *rdi.u5;
		*qwLoc48.u5 = (word64) r12_n;
	}
	Eq_n r14_n = rsi >> 0x01;
	uint64 r15_n = 0x01;
	uint64 qwLoc58_n = 0x00;
	Eq_n r13_n;
	r13_n.u4 = *qwLoc40_n.u5;
	while (true)
	{
		rcx();
		word64 rax_n;
		if ((word32) rax_n <= 0x00)
		{
			uint64 v26_n = qwLoc58_n + 0x01;
			(rdi - 8)[r15_n].t0000.u4 = (char *) r12_n;
			qwLoc58_n = v26_n;
			if (rsi >> 0x01 == v26_n)
			{
l000000000040D479:
				rdxOut = rdx;
				return rcx;
			}
			rcx = rdx;
			r12_n.u4 = rdx.u5[v26_n];
		}
		else
		{
			(rdi - 8)[r15_n].t0000.u4 = (char *) r13_n;
			++r14_n.u6;
			if (rsi == r14_n)
			{
				uint64 r15_n = (rsi >> 0x01) - qwLoc58_n;
				memcpy(rdi.u4 + r15_n * 0x08, rdx + qwLoc58_n * 0x08, r15_n * 0x08);
				rdxOut = r15_n * 0x08;
				return rdx;
			}
			r13_n.u4 = rdi.u5[r14_n];
		}
		++r15_n;
	}
}

// 000000000040D690: void fn000000000040D690(Register Eq_n rdx, Register Eq_n rbx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn0000000000404E80
void fn000000000040D690(Eq_n rdx, Eq_n rbx, Eq_n rsi, Eq_n rdi)
{
	Eq_n rax_n;
	rax_n.u4 = rdi.u4 + rsi *64 0x08;
	word64 rdx_n;
	fn000000000040D450(rdx, rax_n, rbx, rsi, rdi, out rdx_n);
}

// 000000000040D6A0: void fn000000000040D6A0(Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
void fn000000000040D6A0(Eq_n rdi)
{
	Eq_n rbx_n = rdi;
	if (rdi == 0x00)
	{
		fwrite(4284320, 0x01, 55, stderr.u0);
		abort();
	}
	else
	{
		Eq_n rax_n = strrchr(rdi, '/');
		if (rax_n != 0x00 && (((word32) rax_n + 1) - rdi > 0x06 && memcmp(rax_n - 6, 4284376, 0x07) == 0x00))
		{
			Eq_n cmpResult_n = memcmp((word32) rax_n + 1, 4284384, 0x03);
			rbx_n.u4 = (word32) rax_n + 1;
			if ((int8) (cmpResult_n > 0x00) == (int8) (cmpResult_n < 0x00))
			{
				__progname.u0 = (int64) ((word32) rax_n + 4);
				rbx_n.u4 = (word32) rax_n + 4;
			}
		}
		g_t61B200.u4 = (char *) rbx_n;
		__progname_full.u4 = (char *) rbx_n;
	}
}

// 000000000040D740: void fn000000000040D740(Register word32 esi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn000000000040E970
void fn000000000040D740(word32 esi, struct Eq_n * rdi)
{
	ptr64 fp;
	uint64 rcx_n;
	word64 * rdi_n = fp - 0x48;
	for (rcx_n = 0x07; rcx_n != 0x00; --rcx_n)
	{
		*rdi_n = 0x00;
		++rdi_n;
	}
	if (esi == 0x08)
		abort();
	else
	{
		word32 dwLoc44;
		rdi->qw0000 = SEQ(dwLoc44, esi);
		word64 qwLoc40;
		rdi->qw0008 = qwLoc40;
		word64 qwLoc38;
		rdi->qw0010 = qwLoc38;
		word64 qwLoc30;
		rdi->qw0018 = qwLoc30;
		word64 qwLoc28;
		rdi->qw0020 = qwLoc28;
		word64 qwLoc20;
		rdi->qw0028 = qwLoc20;
		word64 qwLoc18;
		rdi->qw0030 = qwLoc18;
	}
}

// 000000000040D7B0: Register Eq_n fn000000000040D7B0(Register up32 esi, Register Eq_n rdi, Register (ptr32 Eq_n) fs, Register out Eq_n ecxOut)
// Called from:
//      fn000000000040D8A0
Eq_n fn000000000040D7B0(up32 esi, Eq_n rdi, struct Eq_n * fs, union Eq_n & ecxOut)
{
	Eq_n rax_n = dcgettext(0x00, rdi, 5);
	Eq_n rbx_n = rax_n;
	if (rax_n == rdi)
	{
		fn0000000000411900(fs);
		byte dl_n = *rax_n.u1 & 223;
		if (dl_n == 0x55)
		{
			if ((rax_n.u2->b0001 & 223) == 0x54 && (((rax_n.u2)->b0002 & 223) == 0x46 && ((rax_n.u2)->b0003 == 0x2D && ((rax_n.u2)->b0004 == 0x38 && (rax_n.u2)->b0005 == 0x00))))
			{
				rbx_n.u0 = 4284388;
				if (*rax_n.u1 == 0x60)
					rbx_n.u0 = 4284401;
				goto l000000000040D7D7;
			}
		}
		else if (dl_n == 0x47 && (((rax_n.u2)->b0001 & 223) == 66 && ((rax_n.u2)->b0002 == 0x31 && ((rax_n.u2)->b0003 == 0x38 && ((rax_n.u2)->b0004 == 0x30 && ((rax_n.u2)->b0005 == 0x33 && ((rax_n.u2)->b0006 == 0x30 && (rax_n.u2)->b0007 == 0x00)))))))
		{
			rbx_n.u0 = 4284397;
			if (*rax_n.u1 != 0x60)
				rbx_n.u0 = 4284392;
			goto l000000000040D7D7;
		}
		rbx_n.u0 = 4284395;
		if (esi != 0x07)
			rbx_n.u0 = 4287978;
		goto l000000000040D7D7;
	}
	else
	{
l000000000040D7D7:
		ecxOut.u0 = <invalid>;
		return rbx_n;
	}
}

// 000000000040D8A0: Register Eq_n fn000000000040D8A0(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi, Register up32 r8d, Register uint32 r9d, Register (ptr32 Eq_n) fs, Stack (arr ui32) qwArg08, Stack (ptr64 (arr char)) qwArg10, Stack (ptr64 (arr char)) qwArg18)
// Called from:
//      fn000000000040D8A0
//      fn000000000040E6F0
//      fn000000000040E930
Eq_n fn000000000040D8A0(Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi, up32 r8d, uint32 r9d, struct Eq_n * fs, ui32 qwArg08[], char (* qwArg10)[], char (* qwArg18)[])
{
	wchar_t wLoc4C;
	word64 rax_n = fs->qw0028;
	byte al_n = (byte) (r9d >> 0x01) & 0x01;
	Eq_n r15_n = rcx;
	up32 dwLocC4_n = r8d;
	uint32 dwLoc68_n = r9d;
	char (* qwLoc88_n)[] = qwArg10;
	char (* qwLoc90_n)[] = qwArg18;
	Eq_n rax_n = __ctype_get_mb_cur_max();
	byte bLocC5_n = al_n;
	if (r8d > 0x08)
		abort();
	byte bLocD8_n;
	Eq_n r14_n;
	char (* qwLoc98_n)[];
	Eq_n rbx_n;
	switch (r8d)
	{
	case 0x00:
		bLocC5_n = 0x00;
		bLocD8_n = 0x00;
		r14_n.u0 = 0x00;
		qwLoc98_n = null;
		rbx_n.u1 = 0x00;
		break;
	case 0x01:
		bLocC5_n = 0x01;
		bLocD8_n = 0x00;
		r14_n.u0 = 0x01;
		qwLoc98_n = (char (*)[]) "'";
		rbx_n.u1 = 0x00;
		dwLocC4_n = 0x02;
		break;
	case 0x02:
		if (al_n == 0x00)
		{
			if (rsi != 0x00)
			{
				*rdi.u4 = (char) 0x27;
				bLocD8_n = 0x00;
				r14_n.u0 = 0x01;
				qwLoc98_n = (char (*)[]) "'";
				rbx_n.u1 = 0x01;
			}
			else
			{
				bLocD8_n = 0x00;
				r14_n.u0 = 0x01;
				qwLoc98_n = (char (*)[]) "'";
				rbx_n.u1 = 0x01;
			}
		}
		else
		{
			bLocD8_n = 0x00;
			r14_n.u0 = 0x01;
			qwLoc98_n = (char (*)[]) "'";
			rbx_n.u1 = 0x00;
		}
		break;
	case 0x03:
		if (al_n == 0x00)
		{
			if (rsi != 0x00)
			{
				*rdi.u4 = (char) 0x22;
				bLocD8_n = 0x01;
				r14_n.u0 = 0x01;
				qwLoc98_n = (char (*)[]) "\"";
				rbx_n.u1 = 0x01;
			}
			else
			{
				bLocD8_n = 0x01;
				r14_n.u0 = 0x01;
				qwLoc98_n = (char (*)[]) "\"";
				rbx_n.u1 = 0x01;
			}
		}
		else
		{
			bLocD8_n = 0x01;
			r14_n.u0 = 0x01;
			qwLoc98_n = (char (*)[]) "\"";
			rbx_n.u1 = 0x00;
		}
		break;
	case 0x04:
		bLocC5_n = 0x01;
		bLocD8_n = 0x01;
		r14_n.u0 = 0x01;
		qwLoc98_n = (char (*)[]) "\"";
		rbx_n.u1 = 0x00;
		dwLocC4_n = 0x03;
		break;
	case 0x05:
		bLocC5_n = 0x00;
		bLocD8_n = 0x01;
		r14_n.u0 = 0x00;
		qwLoc98_n = null;
		rbx_n.u1 = 0x00;
		break;
	case 0x06:
	case 0x07:
	case 0x08:
		if (r8d != 0x08)
		{
			word32 ecx_n;
			qwLoc88_n = fn000000000040D7B0(r8d, 4284405, fs, out ecx_n);
			rcx.u0 = <invalid>;
			word32 ecx_n;
			qwLoc90_n = fn000000000040D7B0(r8d, 4287978, fs, out ecx_n);
		}
		rbx_n.u1 = 0x00;
		Eq_n rcx_n = rcx;
		if (al_n == 0x00)
		{
			byte al_n = qwLoc88_n[0];
			rcx_n = rcx;
			while (al_n != 0x00)
			{
				if (rbx_n < rsi)
					Mem132[rdi + rbx_n:byte] = al_n;
				rbx_n.u2 = (word32) rbx_n + 1;
				al_n = Mem137[qwLoc88_n + rbx_n:byte];
				rcx_n = rdi;
			}
		}
		qwLoc98_n = qwLoc90_n;
		r14_n = strlen(qwLoc90_n);
		bLocD8_n = 0x01;
		rcx = rcx_n;
		break;
	}
	Eq_n r9_n = r14_n;
	Eq_n rbp_n;
	rbp_n.u0 = 0x00;
	Eq_n r14_n = rsi;
	Eq_n r8_n = rdx;
	ui8 al_n = bLocC5_n ^ 0x01;
	ui8 al_n = bLocD8_n ^ 0x01;
	Eq_n rcx_n = rcx;
l000000000040D986:
	int8 al_n = (int8) (rbp_n != r15_n);
	Eq_n rcx_n = rcx_n;
	word32 rcx_32_32_n;
	word24 ecx_24_8_n;
	if (r15_n == ~0x00)
	{
l000000000040DB76:
		rcx_32_32_n = SLICE(rcx_n, word32, 32);
		ecx_24_8_n = SLICE(rcx_n, word24, 8);
		if (CONVERT(Mem1368[r8_n + rbp_n:byte] != 0x00, bool, int8) == 0x00)
			goto l000000000040DB86;
		goto l000000000040D9A8;
	}
	Eq_n rcx_n = rcx_n;
l000000000040D9A0:
	rcx_32_32_n = SLICE(rcx_n, word32, 32);
	ecx_24_8_n = SLICE(rcx_n, word24, 8);
	Eq_n r11_n;
	Eq_n r13_n;
	Eq_n rax_n;
	if (al_n == 0x00)
	{
l000000000040DB86:
		r11_n = r14_n;
		r13_n = r8_n;
		if (rbx_n != 0x00 || (dwLocC4_n != 0x02 || bLocC5_n == 0x00))
		{
			if (bLocC5_n == 0x00 && qwLoc98_n != null)
			{
				uint8 al_n = (uint8) qwLoc98_n[0];
				if (al_n != 0x00)
				{
					int64 rdx_n = qwLoc98_n - rbx_n;
					do
					{
						if (r14_n > rbx_n)
							Mem1675[rdi + rbx_n:byte] = al_n;
						rbx_n.u2 = (word32) rbx_n + 1;
						al_n = rbx_n.u2[rdx_n];
					} while (al_n != 0x00);
				}
			}
			rax_n = rbx_n;
			if (rbx_n < r14_n)
				Mem1701[rdi + rbx_n:byte] = 0x00;
l000000000040DC86:
			if ((rax_n ^ fs->qw0028) == 0x00)
				return rax_n;
			__stack_chk_fail();
		}
		goto l000000000040DC46;
	}
l000000000040D9A8:
	int8 cl_n = (int8) (r9_n != 0x00);
	byte bLoc68_n = (byte) dwLoc68_n;
	word32 ecx_n = SEQ(ecx_24_8_n, cl_n);
	Eq_n r13_n;
	Eq_n rcx_n;
	word32 r11d_n;
	if (r9_n != 0x00 && (bLocD8_n != 0x00 && r15_n >=u rbp_n + r9_n))
	{
		r13_n = r8_n + rbp_n;
		rcx_n.u4 = (uint64) ecx_n;
		if (memcmp(r13_n, qwLoc98_n, r9_n) == 0x00)
		{
			if (bLocC5_n != 0x00)
				goto l000000000040DC40;
			r11d_n = 0x01;
		}
		else
			r11d_n = 0x00;
	}
	else
	{
		r13_n = r8_n + rbp_n;
		r11d_n = 0x00;
		rcx_n = SEQ(rcx_32_32_n, ecx_24_8_n, cl_n);
	}
	uint64 r12_n = (uint64) *r13_n.u1;
	byte r11b_n = (byte) r11d_n;
	byte cl_n = (byte) rcx_n;
	cu8 r12b_n = (byte) r12_n;
	ui32 r12d_n = (word32) r12_n;
	word32 r12_32_32_n = SLICE(r12_n, word32, 32);
	uint64 r12_n;
	Eq_n rcx_n;
	if (r12b_n <= 0x7E)
	{
		switch (r12b_n)
		{
		case 0x00:
			Eq_n rcx_n;
			if (bLocD8_n != 0x00)
			{
				if (bLocC5_n == 0x00)
				{
					if (rbx_n < r14_n)
						Mem1058[rdi + rbx_n:byte] = 0x5C;
					Eq_n rax_n;
					rax_n.u2 = (word32) rbx_n + 1;
					if (r15_n > rbp_n.u6 + 1 && (Mem1067[(r8_n + 1) + rbp_n:byte] <=u 0x39 && Mem1067[(r8_n + 1) + rbp_n:byte] >=u 0x30))
					{
						if (r14_n > rax_n)
							Mem1080[rdi + rax_n:byte] = 0x30;
						if (r14_n > (word32) rbx_n + 2)
							Mem1089[rdi + 2 + rbx_n:byte] = 0x30;
						rax_n.u2 = (word32) rbx_n + 3;
					}
					rbx_n = rax_n;
					r12d_n = 0x30;
					r12_32_32_n = 0x00;
l000000000040DB09:
					word24 r12d_24_8_n = SLICE(r12d_n, word24, 8);
					byte r12b_n = (byte) r12d_n;
					r12_n = SEQ(r12_32_32_n, r12d_24_8_n, r12b_n);
					if (qwArg08 == null)
						goto l000000000040DB2E;
					word56 r12_56_8_n = SEQ(r12_32_32_n, r12d_24_8_n);
					rcx_n.u4 = (uint64) (r12d_n & 0x1F);
					r12_n = SEQ(r12_56_8_n, r12b_n);
					r12_n = SEQ(r12_56_8_n, r12b_n);
					if ((qwArg08[(uint64) ((byte) r12d_n >> 0x05)] & 0x01 << (byte) rcx_n) == 0x00)
					{
l000000000040DB2E:
						rcx_n = rcx_n;
						if (r11b_n == 0x00)
							goto l000000000040DB50;
						goto l000000000040DB33;
					}
l000000000040DB33:
					if (bLocC5_n == 0x00)
					{
						if (rbx_n < r14_n)
							Mem1263[rdi + rbx_n:byte] = 0x5C;
						rbx_n.u2 = (word32) rbx_n + 1;
						rcx_n = rcx_n;
l000000000040DB50:
						++rbp_n.u6;
						r12_n = r12_n;
						rcx_n = rcx_n;
						goto l000000000040DB54;
					}
					goto l000000000040DC40;
				}
				goto l000000000040DC40;
			}
			if ((bLoc68_n & 0x01) != 0x00)
			{
				++rbp_n.u6;
				rcx_n = rcx_n;
				goto l000000000040D986;
			}
			break;
		case 0x01:
		case 0x02:
		case 0x03:
		case 0x04:
		case 0x05:
		case 0x06:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x17:
		case 0x18:
		case 0x19:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 0x40:
			goto l000000000040DE18;
		case 0x07:
			ui32 eax_n = 0x61;
			goto l000000000040DCC0;
		case 0x08:
			eax_n = 0x62;
			goto l000000000040DCC0;
		case 0x09:
			eax_n = 116;
			goto l000000000040DCB5;
		case 0x0A:
			eax_n = 110;
			goto l000000000040DCB5;
		case 11:
			eax_n = 118;
			goto l000000000040DCC0;
		case 0x0C:
			eax_n = 0x66;
			goto l000000000040DCC0;
		case 0x0D:
			eax_n = 114;
			goto l000000000040DCB5;
		case 0x20:
		case 33:
		case 0x22:
		case 0x24:
		case 0x26:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x3B:
		case 0x3C:
		case 0x3D:
		case 0x3E:
		case 0x5B:
		case 0x5E:
		case 0x60:
		case 0x7C:
			goto l000000000040DC22;
		case 0x23:
		case 0x7E:
			goto l000000000040DC19;
		case 0x25:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x31:
		case 0x32:
		case 0x33:
		case 0x34:
		case 0x35:
		case 0x36:
		case 55:
		case 0x38:
		case 0x39:
		case 0x3A:
		case 0x41:
		case 66:
		case 0x43:
		case 0x44:
		case 0x45:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4A:
		case 0x4B:
		case 0x4C:
		case 77:
		case 0x4E:
		case 0x4F:
		case 0x50:
		case 0x51:
		case 0x52:
		case 0x53:
		case 0x54:
		case 0x55:
		case 0x56:
		case 0x57:
		case 88:
		case 0x59:
		case 0x5A:
		case 0x5D:
		case 0x5F:
		case 0x61:
		case 0x62:
		case 99:
		case 100:
		case 101:
		case 0x66:
		case 0x67:
		case 0x68:
		case 0x69:
		case 0x6A:
		case 0x6B:
		case 0x6C:
		case 0x6D:
		case 110:
		case 111:
		case 0x70:
		case 113:
		case 114:
		case 115:
		case 116:
		case 117:
		case 118:
		case 0x77:
		case 0x78:
		case 121:
		case 122:
			break;
		case 0x27:
			if (dwLocC4_n == 0x02)
			{
				if (bLocC5_n != 0x00)
					goto l000000000040DC40;
				if (rbx_n < r14_n)
					Mem505[rdi + rbx_n:byte] = 0x27;
				if (r14_n > (word32) rbx_n + 1)
					Mem514[rdi + 1 + rbx_n:byte] = 0x5C;
				if (r14_n > (word32) rbx_n + 2)
					Mem523[rdi + 2 + rbx_n:byte] = 0x27;
				rbx_n.u2 = (word32) rbx_n + 3;
			}
			break;
		case 0x3F:
			if (dwLocC4_n == 0x02)
				goto l000000000040DC30;
			if (dwLocC4_n == 0x03 && (bLoc68_n & 0x04) != 0x00)
			{
				Eq_n rax_n;
				rax_n.u6 = rbp_n.u6 + 2;
				if (r15_n > rax_n && Mem366[(r8_n + 1) + rbp_n:byte] == 0x3F)
				{
					uint64 rsi_n = CONVERT(Mem366[r8_n + rax_n:byte], byte, uint64);
					rcx_n.u4 = (uint64) ((word32) rsi_n - 33);
					word32 esi_n = (word32) rsi_n;
					cu8 cl_n = (byte) rcx_n;
					if (cl_n <= 0x1D && (0x01 << (word32) cl_n & 939545025) != 0x00)
					{
						if (bLocC5_n != 0x00)
							goto l000000000040DC40;
						if (rbx_n < r14_n)
							Mem455[rdi + rbx_n:byte] = 0x3F;
						if (r14_n > (word32) rbx_n + 1)
							Mem464[rdi + 1 + rbx_n:byte] = 0x22;
						if (r14_n > (word32) rbx_n + 2)
							Mem473[rdi + 2 + rbx_n:byte] = 0x22;
						if (r14_n > (word32) rbx_n + 3)
							rbx_n.u2[(word32) rdi + 3] = 0x3F;
						uint64 r12_n = (uint64) esi_n;
						rbx_n.u2 = (word32) rbx_n + 4;
						r12d_n = (word32) r12_n;
						r12_32_32_n = SLICE(r12_n, word32, 32);
						rbp_n = rax_n;
					}
				}
			}
			break;
		case 0x5C:
			if (bLocD8_n != 0x00 && bLocC5_n != 0x00)
			{
				rcx_n = rcx_n;
				if (cl_n != 0x00)
					goto l000000000040DB50;
			}
			eax_n = r12d_n;
l000000000040DCB5:
			if (dwLocC4_n == 0x02 && bLocC5_n != 0x00)
				goto l000000000040DC40;
l000000000040DCC0:
			if (bLocD8_n != 0x00)
			{
				r12_n = (uint64) eax_n;
				goto l000000000040DB33;
			}
			break;
		case 0x7B:
		case 0x7D:
			int8 al_n = (int8) (r15_n != 0x01);
			if (r15_n == ~0x00)
				al_n = (int8) (r8_n.u6[1] != 0x00);
			if (al_n == 0x00)
			{
l000000000040DC19:
				if (rbp_n == 0x00)
				{
l000000000040DC22:
					if (dwLocC4_n == 0x02)
					{
l000000000040DC30:
						if (bLocC5_n != 0x00)
							goto l000000000040DC40;
					}
				}
			}
			break;
		}
l000000000040DAF8:
		byte r12b_n = (byte) r12d_n;
		word24 r12d_24_8_n = SLICE(r12d_n, word24, 8);
		if (al_n != 0x00)
		{
			r12_n = SEQ(r12_32_32_n, r12d_24_8_n, r12b_n);
			if (al_n != 0x00)
				goto l000000000040DB2E;
		}
		goto l000000000040DB09;
	}
l000000000040DE18:
	Eq_n rax_n;
	byte dl_n;
	word56 rdx_56_8_n;
	word64 rdx_n;
	uint64 r12_n;
	if (rax_n == 0x01)
	{
		uint64 rdx_n = (uint64) *((char *) *__ctype_b_loc() + (uint64) r12b_n * 0x02);
		uint64 rdx_n = (uint64) ((SEQ(SLICE(rdx_n, word16, 16), (word16) rdx_n >> 0x0E) ^ 0x01) & 0x01);
		r11b_n = (byte) r11d_n;
		rax_n.u0 = 0x01;
		dl_n = (byte) rdx_n;
		rdx_56_8_n = SLICE(rdx_n, word56, 8);
	}
	else
	{
		Eq_n tLoc48 = (Eq_n) 0x00;
		if (r15_n == ~0x00)
		{
			r15_n = strlen(r8_n);
			r11b_n = (byte) r11d_n;
		}
		Eq_n rbx_n;
		rbx_n.u0 = 0x00;
		word32 r12d_n = 0x01;
		r13_n = r8_n;
		uint64 r12_n;
		Eq_n rcx_n;
		Eq_n rcx_n;
		do
		{
			Eq_n r14_n = rbx_n + rbp_n;
			mbstate_t * rcx_n = &tLoc48;
			Eq_n r15_n = r8_n + r14_n;
			word24 ecx_24_8_n = SLICE(&tLoc48, word24, 8);
			byte cl_n = (byte) rcx_n;
			word32 rcx_32_32_n = SLICE(rcx_n, word32, 32);
			Eq_n rax_n = mbrtowc(&wLoc4C, r15_n, r15_n - r14_n, &tLoc48);
			if (rax_n == 0x00)
			{
				uint64 rdx_n = (uint64) (r12d_n ^ 0x01);
				rax_n = rbx_n;
				r12_n = (uint64) r12b_n;
				dl_n = (byte) rdx_n;
				rdx_56_8_n = SLICE(rdx_n, word56, 8);
				rcx_n = SEQ(rcx_32_32_n, ecx_24_8_n, cl_n);
				goto l000000000040E22D;
			}
			if (rax_n == ~0x00)
			{
				rax_n = rbx_n;
				r12_n = (uint64) r12b_n;
				dl_n = 0x01;
				rdx_56_8_n = 0x00;
				rcx_n = SEQ(rcx_32_32_n, ecx_24_8_n, cl_n);
				goto l000000000040E22D;
			}
			if (rax_n == ~0x01)
			{
				rax_n = rbx_n;
				r12_n = (uint64) r12b_n;
				if (r15_n > r14_n && *r15_n.u1 != 0x00)
				{
					do
						rax_n.u1 = &rax_n.u2->b0001;
					while (r15_n >u rbp_n + rax_n && Mem647[r13_n + rax_n:byte] != 0x00);
				}
				dl_n = 0x01;
				rdx_56_8_n = 0x00;
				rcx_n = SEQ(rcx_32_32_n, ecx_24_8_n, cl_n);
				goto l000000000040E22D;
			}
			rcx_n = SEQ(rcx_32_32_n, ecx_24_8_n, cl_n);
			if (bLocC5_n != 0x00)
			{
				rcx_n = SEQ(rcx_32_32_n, ecx_24_8_n, cl_n);
				if (dwLocC4_n == 0x02)
				{
					rcx_n = SEQ(rcx_32_32_n, ecx_24_8_n, cl_n);
					if (rax_n != 0x01)
					{
						Eq_n rdx_n;
						rdx_n.u0 = 0x01;
						do
						{
							rcx_n = CONVERT(CONVERT(Mem647[r15_n + rdx_n:byte], byte, word32) - 0x5B, word32, uint64);
							cu8 cl_n = (byte) rcx_n;
							if (cl_n <= 33 && (0x01 << cl_n & 0x20000002B) != 0x00)
							{
								r11_n = r14_n;
l000000000040DC46:
								rax_n = fn000000000040D8A0(r15_n, r13_n, r11_n, rdi, dwLocC4_n, dwLoc68_n & ~0x02, fs, null, qwLoc88_n, qwLoc90_n);
								goto l000000000040DC86;
							}
							++rdx_n.u6;
						} while (rdx_n != rax_n);
					}
				}
			}
			if (iswprint(wLoc4C) == 0x00)
				r12d_n = 0x00;
			rbx_n += rax_n;
		} while (mbsinit(&tLoc48) == 0x00);
		uint64 rdx_n = (uint64) (r12d_n ^ 0x01);
		r12_n = (uint64) r12b_n;
		rax_n = rbx_n;
		dl_n = (byte) rdx_n;
		rdx_56_8_n = SLICE(rdx_n, word56, 8);
		rcx_n = rcx_n;
l000000000040E22D:
		r12_n = r12_n;
		rcx_n = rcx_n;
		if (rax_n > 0x01)
		{
			rdx_n = SEQ(rdx_56_8_n, dl_n & bLocD8_n);
			r12_n = r12_n;
l000000000040DE6B:
			byte dl_n = (byte) rdx_n;
			Eq_n rax_n = rax_n + rbp_n;
			uint64 r12_n = r12_n;
			while (true)
			{
				ui32 r12d_n = (word32) r12_n;
				byte r12b_n = (byte) r12d_n;
				word56 r12_56_8_n = SEQ(SLICE(r12_n, word32, 32), SLICE(r12d_n, word24, 8));
				uint64 r12_n;
				if (dl_n == 0x00)
				{
					r12_n = SEQ(r12_56_8_n, r12b_n);
					if (r11b_n != 0x00)
					{
						if (rbx_n < r14_n)
							Mem977[rdi + rbx_n:byte] = 0x5C;
						rbx_n.u2 = (word32) rbx_n + 1;
						r11b_n = 0x00;
						r12_n = SEQ(r12_56_8_n, r12b_n);
					}
				}
				else
				{
					if (bLocC5_n != 0x00)
					{
l000000000040DC40:
						r11_n = r14_n;
						r13_n = r8_n;
						goto l000000000040DC46;
					}
					if (rbx_n < r14_n)
						Mem917[rdi + rbx_n:byte] = 0x5C;
					if (r14_n > (word32) rbx_n + 1)
					{
						uint64 rsi_n = (uint64) r12d_n;
						Mem937[rdi + 1 + rbx_n:byte] = (SLICE(rsi_n, byte, 0) >>u 0x06) + 0x30;
					}
					if (r14_n > (word32) rbx_n + 2)
					{
						uint64 rsi_n = (uint64) r12d_n;
						Mem959[rdi + 2 + rbx_n:byte] = (SLICE(rsi_n, byte, 0) >>u 0x03 & 0x07) + 0x30;
					}
					rbx_n.u2 = (word32) rbx_n + 3;
					r12_n = (uint64) ((r12d_n & 0x07) + 0x30);
				}
				uint8 r12b_n = (byte) r12_n;
				++rbp_n.u6;
				r12_n = r12_n;
				rcx_n = rdi;
				if (rax_n <= rbp_n)
				{
l000000000040DB54:
					uint8 r12b_n = (byte) r12_n;
					if (rbx_n < r14_n)
						Mem1315[rdi + rbx_n:byte] = r12b_n;
					rbx_n.u2 = (word32) rbx_n + 1;
					al_n = (int8) (rbp_n != r15_n);
					rcx_n = rcx_n;
					rcx_n = rcx_n;
					if (r15_n == ~0x00)
						goto l000000000040DB76;
					goto l000000000040D9A0;
				}
				if (rbx_n < r14_n)
					Mem1014[rdi + rbx_n:byte] = r12b_n;
				r12_n = CONVERT(Mem1023[r8_n + rbp_n:byte], byte, uint64);
				rbx_n.u2 = (word32) rbx_n + 1;
			}
		}
	}
	byte dl_n = dl_n & bLocD8_n;
	r12_32_32_n = SLICE(r12_n, word32, 32);
	r12d_n = (word32) r12_n;
	rdx_n = SEQ(rdx_56_8_n, dl_n);
	r12_n = r12_n;
	if (dl_n == 0x00)
		goto l000000000040DAF8;
	goto l000000000040DE6B;
}

// 000000000040E450: Register Eq_n fn000000000040E450(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register word32 edi, Register (ptr32 Eq_n) fs, Register out ptr64 r8Out, Register out ptr64 r9Out)
// Called from:
//      fn000000000040E930
//      fn000000000040E970
//      fn000000000040EAB0
//      fn000000000040EBF0
//      fn000000000040EC10
Eq_n fn000000000040E450(Eq_n rcx, Eq_n rdx, Eq_n rsi, word32 edi, struct Eq_n * fs, ptr64 & r8Out, ptr64 & r9Out)
{
	int64 r15_n = (int64) edi;
	int32 * rax_n = __errno_location();
	Eq_n r15d_n = (word32) r15_n;
	int32 eax_n = *rax_n;
	Eq_n r12_n;
	r12_n.u4 = g_t61A5D8.u4;
	if (r15d_n < 0x00)
		abort();
	else
	{
		if (r15d_n >= g_t61A5F0.u0)
		{
			Eq_n ebp_n = (word32) r15_n + 0x01;
			uint64 r14_n = (uint64) ebp_n;
			if (r12_n == 6399456)
			{
				Eq_n rax_n = fn0000000000410C90(r14_n << 0x04, 0x00);
				word64 rsi_n = g_qw61A5E0;
				Eq_n rdi_n;
				rdi_n.u4 = g_t61A5E8.u4;
				g_t61A5D8.u4 = (char *) rax_n;
				*rax_n.u5 = rsi_n;
				rax_n.u6[8] = (struct tm) rdi_n;
				r12_n = rax_n;
			}
			else
			{
				Eq_n rax_n = fn0000000000410C90(r14_n << 0x04, r12_n);
				g_t61A5D8.u4 = (char *) rax_n;
				r12_n = rax_n;
			}
			uint64 rdi_n = (uint64) g_t61A5F0.u0;
			memset(r12_n.u4 + (rdi_n << 0x04), 0, r14_n - rdi_n << 0x04);
			g_t61A5F0.u0 = (int32) ebp_n;
		}
		struct Eq_n * r12_n = (struct Eq_n *) (r12_n.u4 + (r15_n << 0x04));
		uint32 ebp_n = rcx.u1->dw0004 | 0x01;
		Eq_n r11_n;
		r11_n.u0 = r12_n->t0000.u0;
		Eq_n r14_n;
		r14_n.u4 = r12_n->t0008.u4;
		Eq_n rax_n = fn000000000040D8A0(rdx, rsi, r11_n, r14_n, rcx.u1->dw0000, ebp_n, fs, (word32) rcx + 8, rcx.u1->ptr0028, rcx.u1->ptr0030);
		if (r11_n <= rax_n)
		{
			r12_n->t0000.u0 = (int64) ((word32) rax_n + 1);
			if (r14_n != 0x0061B220)
				free(r14_n);
			Eq_n rax_n = fn0000000000410C40((word32) rax_n + 1);
			r12_n->t0008.u4 = (char *) rax_n;
			fn000000000040D8A0(rdx, rsi, (word32) rax_n + 1, rax_n, rcx.u1->dw0000, ebp_n, fs, (word32) rcx + 8, rcx.u1->ptr0028, rcx.u1->ptr0030);
			r14_n = rax_n;
		}
		*rax_n = eax_n;
		ptr64 r8_n;
		r8Out = r8_n;
		ptr64 r9_n;
		r9Out = r9_n;
		return r14_n;
	}
}

// 000000000040E600: Register word64 fn000000000040E600(Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
word64 fn000000000040E600(Eq_n rdi)
{
	int32 * rax_n = __errno_location();
	int32 r12d_n = *rax_n;
	Eq_n rdi_n;
	rdi_n.u0 = 6402848;
	if (rdi != 0x00)
		rdi_n = rdi;
	word64 rax_n = fn0000000000410E00(0x38, rdi_n);
	*rax_n = r12d_n;
	return rax_n;
}

// 000000000040E630: Register up32 fn000000000040E630(Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
up32 fn000000000040E630(Eq_n rdi)
{
	Eq_n rax_n;
	rax_n.u0 = 6402848;
	if (rdi != 0x00)
		rax_n = rdi;
	return rax_n.u1->dw0000;
}

// 000000000040E640: void fn000000000040E640(Register word32 esi, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
void fn000000000040E640(word32 esi, Eq_n rdi)
{
	Eq_n rax_n;
	rax_n.u0 = 6402848;
	if (rdi != 0x00)
		rax_n = rdi;
	*rax_n.u1 = esi;
}

// 000000000040E650: void fn000000000040E650(Register word32 edx, Register int32 esi, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
void fn000000000040E650(word32 edx, int32 esi, Eq_n rdi)
{
	bcu8 sil_n = (byte) esi;
	Eq_n rax_n;
	rax_n.u0 = 6402848;
	if (rdi != 0x00)
		rax_n = rdi;
	Eq_n rsi_n = (word64) rax_n.u0 + (uint64) (sil_n >> 0x05) * 0x04;
	uint32 edi_n = rsi_n.u1->dw0008;
	byte cl_n = (byte) esi & 0x1F;
	rsi_n.u1->dw0008 = ((edx ^ edi_n >> cl_n) & 0x01) << cl_n ^ edi_n;
}

// 000000000040E6B0: void fn000000000040E6B0(Register word64 rdx, Register word64 rsi, Register Eq_n rdi)
void fn000000000040E6B0(word64 rdx, word64 rsi, Eq_n rdi)
{
	if (rdi == 0x00)
		rdi.u0 = 6402848;
	rdi.u1->dw0000 = 0x08;
	if (rsi == 0x00 || rdx == 0x00)
		abort();
	else
	{
		rdi.u1->qw0028 = rsi;
		rdi.u1->qw0030 = rdx;
	}
}

// 000000000040E6F0: Register Eq_n fn000000000040E6F0(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi, Register Eq_n r8, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004052D0
Eq_n fn000000000040E6F0(Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi, Eq_n r8, struct Eq_n * fs)
{
	Eq_n rbx_n = r8;
	if (r8 == 0x00)
		rbx_n.u0 = 6402848;
	int32 * rax_n = __errno_location();
	int32 r12d_n = *rax_n;
	Eq_n rax_n = fn000000000040D8A0(rcx, rdx, rsi, rdi, rbx_n.u1->dw0000, rbx_n.u1->dw0004, fs, (word32) rbx_n + 8, rbx_n.u1->ptr0028, rbx_n.u1->ptr0030);
	*rax_n = r12d_n;
	return rax_n;
}

// 000000000040E930: void fn000000000040E930(Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
void fn000000000040E930(Eq_n rdi, struct Eq_n * fs)
{
	word64 r8_n;
	word64 r9_n;
	fn000000000040E450(6402848, ~0x00, rdi, 0x00, fs, out r8_n, out r9_n);
}

// 000000000040E970: void fn000000000040E970(Register Eq_n rdx, Register word32 esi, Register word32 edi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn0000000000409F80
void fn000000000040E970(Eq_n rdx, word32 esi, word32 edi, struct Eq_n * fs)
{
	Eq_n tLoc58;
	fn000000000040D740(esi, &tLoc58);
	word64 r8_n;
	word64 r9_n;
	fn000000000040E450(&tLoc58, ~0x00, rdx, edi, fs, out r8_n, out r9_n);
}

// 000000000040EAB0: void fn000000000040EAB0(Register Eq_n rdi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn00000000004028C0
//      fn0000000000405810
//      fn0000000000407EA0
void fn000000000040EAB0(Eq_n rdi, struct Eq_n * fs)
{
	Eq_n tLoc48;
	tLoc48.qw0000 = g_qw61B320;
	tLoc48.qw0008 = g_qw61B328;
	tLoc48.qw0010 = g_qw61B330;
	tLoc48.qw0018 = g_qw61B338;
	tLoc48.qw0020 = g_qw61B340;
	uint32 r9d_n = tLoc48.dw000C;
	tLoc48.qw0028 = g_qw61B348;
	tLoc48.qw0030 = g_qw61B350;
	tLoc48.dw000C = ((r9d_n >> 0x1A ^ 0x01) & 0x01) << 0x1A ^ r9d_n;
	word64 r8_n;
	word64 r9_n;
	fn000000000040E450(&tLoc48, ~0x00, rdi, 0x00, fs, out r8_n, out r9_n);
}

// 000000000040EBF0: void fn000000000040EBF0(Register Eq_n rsi, Register word32 edi, Register (ptr32 Eq_n) fs)
// Called from:
//      fn0000000000409F80
void fn000000000040EBF0(Eq_n rsi, word32 edi, struct Eq_n * fs)
{
	word64 r8_n;
	word64 r9_n;
	fn000000000040E450(6399392, ~0x00, rsi, edi, fs, out r8_n, out r9_n);
}

// 000000000040EC10: Register word64 fn000000000040EC10(Register Eq_n rdi, Register (ptr32 Eq_n) fs, Register out ptr64 r8Out, Register out ptr64 r9Out)
// Called from:
//      fn00000000004028C0
//      fn000000000040A000
word64 fn000000000040EC10(Eq_n rdi, struct Eq_n * fs, ptr64 & r8Out, ptr64 & r9Out)
{
	ptr64 r9_n;
	ptr64 r8_n;
	word64 rax_n = fn000000000040E450(6399392, ~0x00, rdi, 0x00, fs, out r8_n, out r9_n);
	r8Out = r8_n;
	r9Out = r9_n;
	return rax_n;
}

// 000000000040EC30: void fn000000000040EC30(Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn000000000040ECD0
void fn000000000040EC30(Eq_n rdx, Eq_n rsi, Eq_n rdi)
{
	int64 rbx_n = rdx - 1;
	if (rdx != 0x00)
	{
		int32_t ** rax_n = __ctype_tolower_loc();
		do
		{
			rdi.u1[rbx_n] = (char) *((char *) *rax_n + (uint64) (rsi.u4)[rbx_n] * 0x04);
			--rbx_n;
		} while (rbx_n != ~0x00);
	}
}

// 000000000040EC80: void fn000000000040EC80(Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn000000000040ECD0
void fn000000000040EC80(Eq_n rdx, Eq_n rsi, Eq_n rdi)
{
	int64 rbx_n = rdx - 1;
	if (rdx != 0x00)
	{
		int32_t ** rax_n = __ctype_toupper_loc();
		do
		{
			rdi.u1[rbx_n] = (char) *((char *) *rax_n + (uint64) (rsi.u4)[rbx_n] * 0x04);
			--rbx_n;
		} while (rbx_n != ~0x00);
	}
}

// 000000000040ECD0: Register uint64 fn000000000040ECD0(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register byte dil, Register Eq_n r8, Register word32 r9d, Register (ptr32 Eq_n) fs, Stack Eq_n dwArg08)
// Called from:
//      fn000000000040ECD0
//      fn0000000000410600
uint64 fn000000000040ECD0(Eq_n rcx, Eq_n rdx, Eq_n rsi, byte dil, Eq_n r8, word32 r9d, struct Eq_n * fs, Eq_n dwArg08)
{
	char bLoc0448;
	word64 r9;
	r9d = (word32) r9;
	word64 rdi;
	dil = (byte) rdi;
	Eq_n r10_n = rdx;
	Eq_n r12_n = rsi;
	Eq_n rbx_n = rcx;
	word64 rsi_n = fs->qw0028;
	Eq_n esi_n;
	esi_n.u4 = r8.u6[8];
	Eq_n qwLoc04C0_n;
	qwLoc04C0_n.u4 = r8.u6[48];
	Eq_n dwLoc04C8_n;
	if (esi_n > 0x0C)
		dwLoc04C8_n = esi_n - 0x0C;
	else
	{
		Eq_n eax_n;
		eax_n.u0 = 0x0C;
		if (esi_n != 0x00)
			eax_n = esi_n;
		dwLoc04C8_n = eax_n;
	}
	Eq_n al_n;
	al_n.u4 = *rcx.u4;
	uint64 r13_n = 0x00;
	uint64 rax_n;
	if (al_n != 0x00)
	{
		do
		{
l000000000040ED85:
			word32 rcx_32_32_n = SLICE(rcx, word32, 32);
			Eq_n r8_n;
			if (al_n == 0x25)
			{
				uint64 r9_n = (uint64) dil;
				cu8 al_n = 0x00;
				int32 r11d_n = 0x00;
				while (true)
				{
l000000000040ED94:
					++rbx_n.u6;
					uint64 rdi_n = (uint64) *rbx_n.u4;
					ci8 dil_n = (byte) rdi_n;
					word32 r9_32_32_n = SLICE(r9_n, word32, 32);
					word32 r9d_n = (word32) r9_n;
					bool v132_n = dil_n > 0x30;
					while (dil_n != 0x30)
					{
						byte r9b_n = (byte) r9d_n;
						dil_n = (byte) rdi_n;
						if (v132_n)
						{
							if (dil_n == 0x5E)
							{
								r9_n = 0x01;
								goto l000000000040ED94;
							}
							if (dil_n == 0x5F)
							{
								r11d_n = (int32) dil_n;
								goto l000000000040ED94;
							}
							goto l000000000040EDEE;
						}
						if (dil_n != 0x23)
						{
							if (dil_n == 0x2D)
								break;
l000000000040EDEE:
							uint64 rbp_n = 0xFFFFFFFF;
							uint64 rdi_n = rdi_n;
							if ((int32) dil_n <= 0x39 && (int32) dil_n >= 0x30)
							{
								uint64 rbp_n = 0x00;
								do
								{
									int32 ebp_n = (word32) rbp_n;
									uint64 rbp_n;
									if (ebp_n > 0x0CCCCCCC)
										rbp_n = 0x7FFFFFFF;
									else
									{
										int32 edx_n = (int32) *rbx_n.u4;
										ci8 dl_n = (byte) edx_n;
										if (ebp_n != 0x0CCCCCCC || dl_n <= 55)
										{
											uint64 rcx_n = (uint64) (ebp_n * 0x05);
											rcx_32_32_n = SLICE(rcx_n, word32, 32);
											rbp_n = (uint64) (edx_n - 0x30 + (word32) rcx_n * 0x02);
										}
										else
											rbp_n = 0x7FFFFFFF;
									}
									++rbx_n.u6;
									rdi_n = (uint64) *rbx_n.u4;
									rbp_n = rbp_n;
									rbp_n = rbp_n;
								} while ((int32) (byte) rdi_n <= 0x39 && (int32) ((byte) rdi_n) >= 0x30);
							}
							int32 ebp_n = (word32) rbp_n;
							byte dil_n = (byte) rdi_n;
							Eq_n rcx_n;
							uint64 rdi_n;
							if (dil_n != 0x45)
							{
								rcx_32_32_n = 0x00;
								rcx_n.u0 = 0x00;
								rdi_n = rdi_n;
								if (dil_n != 0x4F)
									goto l000000000040EE52;
							}
							++rbx_n.u6;
							rdi_n = (uint64) *rbx_n.u4;
							rcx_n = SEQ(rcx_32_32_n, (int32) dil_n);
l000000000040EE52:
							cu8 dil_n = (byte) rdi_n;
							word56 r10_56_8_n = SLICE(r10_n, word56, 8);
							int32 ecx_n = (word32) rcx_n;
							int32 esi_n = (int32) dil_n;
							Eq_n r8_n;
							if (dil_n > 122)
							{
l000000000040FF4D:
								r8_n = rbx_n;
l000000000040F39F:
								Eq_n r15_n;
								Eq_n rcx_n;
								if ((byte) rdi_n == 0x25)
								{
l000000000040F3A9:
									r15_n = r8_n;
									rcx_n.u0 = 0x01;
								}
								else
								{
									rbx_n = r8_n;
l000000000040F0B8:
									Eq_n rax_n = rbx_n - 1;
									word32 ecx_n = 0x01;
									do
									{
										r15_n = rax_n;
										--rax_n;
										++ecx_n;
									} while (rax_n.u6[1] != 0x25);
									rcx_n.u4 = (int64) ecx_n;
									r8_n = rbx_n;
								}
								byte r9b_n = (byte) r9d_n;
								word24 r9d_24_8_n = SLICE(r9d_n, word24, 8);
								int32 eax_n = 0x00;
								if (ebp_n >= 0x00)
									eax_n = ebp_n;
								Eq_n rax_n;
								rax_n.u4 = (int64) eax_n;
								Eq_n rbx_n = rax_n;
								if (rcx_n >= rax_n)
									rbx_n = rcx_n;
								if (rbx_n >= rdx - r13_n)
									goto l000000000040EE98;
								if (r12_n != 0x00)
								{
									uint64 r9_n = SEQ(r9_32_32_n, r9d_24_8_n, r9b_n);
									if (rax_n > rcx_n)
									{
										Eq_n rbp_n = (int64) ebp_n - rcx_n;
										if (r11d_n != 0x30)
										{
											memset(r12_n, 32, rbp_n);
											r12_n += rbp_n;
											r9_n = (uint64) r9d_n;
										}
										else
										{
											memset(r12_n, 48, rbp_n);
											r12_n += rbp_n;
											r9_n = (uint64) r9d_n;
										}
									}
									if ((byte) r9_n != 0x00)
										fn000000000040EC80(rcx_n, r15_n, r12_n);
									else
										memcpy(r12_n, r15_n, rcx_n);
									r12_n += rcx_n;
								}
								rcx = rcx_n;
								r8_n = r8_n;
								r13_n = (uint64) (rbx_n.u4 + r13_n);
								goto l000000000040ED74;
							}
							else
							{
								switch (dil_n)
								{
								case 0x00:
									r8_n = rbx_n - 1;
									rdi_n = (uint64) rbx_n.u6->bFFFFFFFF;
									goto l000000000040F39F;
								case 0x01:
								case 0x02:
								case 0x03:
								case 0x04:
								case 0x05:
								case 0x06:
								case 0x07:
								case 0x08:
								case 0x09:
								case 0x0A:
								case 11:
								case 0x0C:
								case 0x0D:
								case 0x0E:
								case 0x0F:
								case 0x10:
								case 0x11:
								case 0x12:
								case 0x13:
								case 0x14:
								case 0x15:
								case 22:
								case 0x17:
								case 0x18:
								case 0x19:
								case 0x1A:
								case 0x1B:
								case 0x1C:
								case 0x1D:
								case 0x1E:
								case 0x1F:
								case 0x20:
								case 33:
								case 0x22:
								case 0x23:
								case 0x24:
								case 0x26:
								case 0x27:
								case 0x28:
								case 0x29:
								case 0x2A:
								case 0x2B:
								case 44:
								case 0x2D:
								case 0x2E:
								case 0x2F:
								case 0x30:
								case 0x31:
								case 0x32:
								case 0x33:
								case 0x34:
								case 0x35:
								case 0x36:
								case 55:
								case 0x38:
								case 0x39:
								case 0x3B:
								case 0x3C:
								case 0x3D:
								case 0x3E:
								case 0x3F:
								case 0x40:
								case 0x45:
								case 0x4A:
								case 0x4B:
								case 0x4C:
								case 0x4F:
								case 0x51:
								case 0x5B:
								case 0x5C:
								case 0x5D:
								case 0x5E:
								case 0x5F:
								case 0x60:
								case 0x66:
								case 0x69:
								case 111:
								case 113:
								case 118:
									goto l000000000040FF4D;
								case 0x25:
									Eq_n r15_n;
									if (ecx_n != 0x00)
									{
										r8_n = rbx_n;
										goto l000000000040F3A9;
									}
									else
									{
										int32 eax_n = ecx_n;
										r15_n.u1 = 0x01;
										if (ebp_n >= 0x00)
											eax_n = ebp_n;
										Eq_n rax_n;
										rax_n.u0 = (int64) eax_n;
										if (rax_n != 0x00)
											r15_n = rax_n;
										if (r15_n >= rdx - r13_n)
											goto l000000000040EE98;
										if (r12_n != 0x00)
										{
											if (rax_n > 0x01)
											{
												Eq_n rbp_n;
												rbp_n.u0 = (int64) ebp_n;
												if (r11d_n != 0x30)
												{
													memset(r12_n, 32, rbp_n - 0x01);
													r12_n += rbp_n - 0x01;
													rdi_n = (uint64) *rbx_n.u4;
												}
												else
												{
													memset(r12_n, 48, rbp_n - 0x01);
													r12_n += rbp_n - 0x01;
													rdi_n = (uint64) *rbx_n.u4;
												}
											}
											*r12_n.u1 = (byte) rdi_n;
											r12_n.u1 = (word32) r12_n + 1;
										}
										goto l000000000040FA58;
									}
								case 0x3A:
									byte al_n = (byte) rbx_n.u6[1];
									Eq_n rdx_n;
									uint64 r15_n;
									if (al_n != 0x3A)
									{
										rdx_n.u6 = rbx_n.u6 + 1;
										r15_n = 0x01;
									}
									else
									{
										Eq_n rdi_n;
										rdi_n.u6 = rbx_n.u6 + 2;
										r15_n = 0x01;
										do
										{
											++rdi_n.u6;
											rdx_n = rdi_n;
											al_n = rdi_n.u6->bFFFFFFFF;
											++r15_n;
										} while (al_n == 0x3A);
									}
									if (al_n == 122)
									{
										rbx_n = rdx_n;
										goto l000000000040F300;
									}
									break;
								case 0x41:
								case 66:
								case 0x61:
									if (ecx_n == 0x00)
									{
										if (al_n != 0x00)
											r9d_n = 0x01;
										goto l000000000040F087;
									}
									break;
								case 0x43:
									char bLoc0458;
									byte r15b_n;
									int32 dwLoc04F0_n;
									int8 r10b_n;
									Eq_n r8d_n;
									if (ecx_n != 0x4F)
									{
										if (ecx_n == 0x45)
										{
											bLoc0458 = 0x20;
											r15b_n = 0x00;
											dwLoc04F0_n = 0x00;
											goto l000000000040F25D;
										}
										else
										{
											int32 ecx_n = (int32) r8.u6[20];
											uint64 rdx_n = (uint64) ((SLICE(ecx_n *s64 1374389535, word32, 32) >> 0x05) - (ecx_n >> 0x1F));
											Eq_n eax_n;
											eax_n.u0 = 0x00;
											int32 r8d_n = (word32) rdx_n + 0x13;
											if (ecx_n < (word32) rdx_n *s 100)
												eax_n.u1 = (uint32) (r8d_n > 0x00);
											dwLoc04F0_n = 0x02;
											r10b_n = (int8) (ecx_n < ~0x076B);
											r8d_n = r8d_n - eax_n;
											goto l000000000040F50A;
										}
									}
									break;
								case 0x44:
									Eq_n qwLoc04F0_n;
									if (ecx_n == 0x00)
									{
										qwLoc04F0_n.u0 = 0x004164C8;
										goto l000000000040F7FC;
									}
									break;
								case 0x46:
									if (ecx_n == 0x00)
									{
										qwLoc04F0_n.u0 = 0x004164D1;
										goto l000000000040F7FC;
									}
									break;
								case 0x47:
								case 0x56:
								case 0x67:
									byte bLoc04E0_n;
									byte dil_n;
									Eq_n r10_n;
									if (ecx_n != 0x45)
									{
										int32 eax_n = (int32) r8.u6[20];
										uint64 r15_n = (uint64) r8.u6[28];
										word32 r15d_n = (word32) r15_n;
										Eq_n edx_n;
										edx_n.u4 = r8.u6[24];
										uint64 r8_n = (uint64) (r15d_n - edx_n + 0x017E);
										int32 r8d_n = (word32) r8_n;
										uint64 r10_n = (uint64) ((eax_n >> 0x1F & 400) - 100 + eax_n);
										uint64 rax_n = (uint64) ((SLICE(r8d_n *s64 0x92492493, word32, 32) + (word32) r8_n >> 0x02) - (r8d_n >> 0x1F));
										Eq_n r10d_n = (word32) r10_n;
										byte r10b_n = (byte) r10_n;
										int32 r8d_n = r15d_n - r8d_n + 0x03 + ((word32) rax_n * 0x08 - (word32) rax_n);
										uint64 r10_n;
										int32 r15d_n;
										if (r8d_n >= 0x00)
										{
											uint64 rax_n = 0xFFFFFE93;
											if ((r10b_n & 0x03) == 0x00)
											{
												int32 edx_n = SLICE(r10d_n *s64 1374389535, word32, 32);
												rax_n = 0xFFFFFE92;
												if (r10d_n == ((edx_n >> 0x05) - (r10d_n >> 0x1F)) *s 100)
													rax_n = (uint64) (0x00 - (word32) (r10d_n - ((edx_n >> 0x07) - (r10d_n >> 0x1F)) *s 400 < 0x01) - 0x016D);
											}
											word32 r10d_n = (word32) (r15_n + rax_n);
											uint64 r15_n = (uint64) (r10d_n - edx_n + 0x017E);
											int32 r15d_n = (word32) r15_n;
											uint64 rax_n = (uint64) ((SLICE(r15d_n *s64 0x92492493, word32, 32) + (word32) r15_n >> 0x02) - (r15d_n >> 0x1F));
											r10_n = (uint64) (r10d_n - r15d_n + 0x03 + ((word32) rax_n * 0x08 - (word32) rax_n));
											r15d_n = 0x01;
											if ((word32) r10_n < 0x00)
											{
												r10_n = (uint64) r8d_n;
												r15d_n = 0x00;
											}
										}
										else
										{
											uint64 r10_n = (uint64) (r10d_n - 0x01);
											Eq_n r10d_n = (word32) r10_n;
											uint64 rax_n = 0x016D;
											if (((byte) r10_n & 0x03) == 0x00)
											{
												int32 edx_n = SLICE(r10d_n *s64 1374389535, word32, 32);
												rax_n = 366;
												if (r10d_n == ((edx_n >> 0x05) - (r10d_n >> 0x1F)) *s 100)
													rax_n = (uint64) ((word32) (r10d_n - ((edx_n >> 0x07) - (r10d_n >> 0x1F)) *s 400 < 0x01) + 0x016D);
											}
											word32 r10d_n = (word32) (r15_n + rax_n);
											uint64 r8_n = (uint64) (r10d_n - edx_n + 0x017E);
											int32 r8d_n = (word32) r8_n;
											uint64 rax_n = (uint64) ((SLICE(r8d_n *s64 0x92492493, word32, 32) + (word32) r8_n >> 0x02) - (r8d_n >> 0x1F));
											r15d_n = ~0x00;
											r10_n = (uint64) (r10d_n - r8d_n + 0x03 + ((word32) rax_n * 0x08 - (word32) rax_n));
										}
										int32 r10d_n = (word32) r10_n;
										word56 r10_56_8_n = SEQ(SLICE(r10_n, word32, 32), SLICE(r10d_n, word24, 8));
										if (dil_n == 0x47)
										{
											uint64 rdi_n = (uint64) eax_n;
											bLoc04E0_n = 0x00;
											dwLoc04F0_n = 0x04;
											r8d_n = r15d_n + 1900 + (word32) rdi_n;
											dil_n = 0x00;
											r10_n = SEQ(r10_56_8_n, (int8) ((word32) rdi_n < ~0x076B - r15d_n));
											goto l000000000040F238;
										}
										else
										{
											if (dil_n == 0x67)
											{
												int32 edi_n = eax_n - ((SLICE(eax_n *s64 1374389535, word32, 32) >> 0x05) - (eax_n >> 0x1F)) *s 100 + r15d_n;
												Eq_n edi_n = edi_n - ((SLICE(edi_n *s64 1374389535, word32, 32) >> 0x05) - (edi_n >> 0x1F)) *s 100;
												dwLoc04F0_n = 0x02;
												r8d_n = edi_n;
												if (edi_n < 0x00)
												{
													Eq_n edx_n = -edi_n;
													r8d_n.u4 = (word32) edi_n.u0 + 100;
													if (eax_n < ~0x076B - r15d_n)
														r8d_n = edx_n;
												}
											}
											else
											{
												dwLoc04F0_n = 0x02;
												r8d_n = (SLICE(r10d_n *s64 0x92492493, word32, 32) + r10d_n >> 0x02) - (r10d_n >> 0x1F) + 0x01;
											}
											goto l000000000040F228;
										}
									}
									break;
								case 0x48:
									if (ecx_n != 0x45)
									{
										dwLoc04F0_n = 0x02;
										r8d_n.u4 = r8.u6[8];
										goto l000000000040F228;
									}
									break;
								case 0x49:
									if (ecx_n != 0x45)
									{
										r8d_n = dwLoc04C8_n;
										dwLoc04F0_n = 0x02;
										goto l000000000040F228;
									}
									break;
								case 77:
									if (ecx_n != 0x45)
									{
										dwLoc04F0_n = 0x02;
										r8d_n.u0 = r8.u9->u1.t0004.u0;
										goto l000000000040F228;
									}
									break;
								case 0x4E:
									if (ecx_n != 0x45)
									{
										if (ebp_n != ~0x00)
										{
											if (ebp_n <= 0x08)
											{
												r8d_n = dwArg08;
												int32 edi_n = ebp_n;
												do
												{
													++edi_n;
													r8d_n = (SLICE(r8d_n *s64 0x66666667, word32, 32) >> 0x02) - (r8d_n >> 0x1F);
												} while (edi_n != 0x09);
												dwLoc04F0_n = ebp_n;
											}
											else
											{
												r8d_n = dwArg08;
												dwLoc04F0_n = ebp_n;
											}
										}
										else
										{
											r8d_n = dwArg08;
											ebp_n = 0x09;
											dwLoc04F0_n = 0x09;
										}
										goto l000000000040F228;
									}
									break;
								case 0x50:
									dil_n = 0x70;
									esi_n = 0x70;
									r15b_n = 0x01;
									goto l000000000040F90C;
								case 0x52:
									qwLoc04F0_n.u0 = 4274543;
									goto l000000000040F7FC;
								case 0x53:
									if (ecx_n != 0x45)
									{
										dwLoc04F0_n = 0x02;
										r8d_n.u0 = r8.u9->u1.t0000.u0;
										goto l000000000040F228;
									}
									break;
								case 0x54:
									qwLoc04F0_n.u0 = 4285658;
l000000000040F7FC:
									word32 eax_n = (word32) r9b_n;
									Eq_n rax_n = fn000000000040ECD0(qwLoc04F0_n, ~0x00, 0x00, (byte) eax_n, r8, r9d, fs, dwArg08);
									rcx.u0 = <invalid>;
									int32 eax_n = 0x00;
									if (ebp_n >= 0x00)
										eax_n = ebp_n;
									Eq_n rax_n;
									rax_n.u4 = (int64) eax_n;
									Eq_n rsi_n = rax_n;
									if (rax_n >= rax_n)
										rsi_n = rax_n;
									r10_n = rdx - r13_n;
									if (rsi_n >= r10_n)
										goto l000000000040EE98;
									if (r12_n != 0x00)
									{
										if (rax_n < rax_n)
										{
											Eq_n rbp_n = (int64) ebp_n - rax_n;
											if (r11d_n != 0x30)
											{
												memset(r12_n, 32, rbp_n);
												r12_n += rbp_n;
											}
											else
											{
												memset(r12_n, 48, rbp_n);
												r12_n += rbp_n;
											}
										}
										fn000000000040ECD0(qwLoc04F0_n, r10_n, r12_n, (byte) eax_n, r8, r9d, fs, dwArg08);
										r12_n += rax_n;
										rcx.u0 = <invalid>;
										Eq_n r10_n;
										r10_n = r10_n;
									}
									r13_n = (uint64) (rsi_n.u4 + r13_n);
									r8_n = rbx_n;
									goto l000000000040ED74;
								case 0x55:
									uint64 rdi_n;
									uint64 rdx_n;
									if (ecx_n != 0x45)
									{
										rdi_n = (uint64) (r8.u6[28] - (r8.u6)[24] + 0x07);
										rdx_n = (uint64) SLICE((word32) rdi_n *s64 0x92492493, word32, 32);
										goto l000000000040F7B6;
									}
									break;
								case 0x57:
									if (ecx_n != 0x45)
									{
										uint64 rdi_n = (uint64) ((byte) r8.u6[24].b0002 + 4);
										int32 edi_n = (word32) rdi_n;
										uint64 rax_n = (uint64) ((SLICE(edi_n *s64 0x92492493, word32, 32) + (word32) rdi_n >> 0x02) - (edi_n >> 0x1F));
										uint64 rdx_n = (uint64) ((word32) rax_n * 0x08 - (word32) rax_n - edi_n);
										rdi_n = (uint64) (r8.u6[28].a0000.u4.u4 + ((word32) rdx_n + 0x07));
										rdx_n = SEQ(SLICE(rdx_n, word32, 32), SLICE((word32) rdi_n *s64 0x92492493, word32, 32));
l000000000040F7B6:
										dwLoc04F0_n = 0x02;
										r8d_n = ((word32) (rdx_n + rdi_n) >> 0x02) - ((word32) rdi_n >> 0x1F);
										goto l000000000040F228;
									}
									break;
								case 88:
								case 99:
								case 0x78:
									if (ecx_n != 0x4F)
										goto l000000000040EF09;
									break;
								case 0x59:
									if (ecx_n == 0x45)
										goto l000000000041028D;
									if (ecx_n != 0x4F)
									{
										int32 r8d_n = (int32) r8.u6[20];
										dwLoc04F0_n = 0x04;
										r10b_n = (int8) (r8d_n < ~0x076B);
										r8d_n = r8d_n + 1900;
l000000000040F50A:
										dil_n = 0x00;
										bLoc04E0_n = 0x00;
										goto l000000000040F518;
									}
									break;
								case 0x5A:
									Eq_n rcx_n;
									rcx_n.u4 = (uint64) (0x00 - (word32) (al_n < 0x01) + 0x01);
									word32 ecx_n = (word32) rcx_n;
									if (al_n != 0x00)
										r9d_n = 0x00;
									uint64 r11_n;
									uint64 r9_n;
									Eq_n r15_n;
									if (qwLoc04C0_n != 0x00)
									{
										r11_n = (uint64) r11d_n;
										r9_n = (uint64) r9d_n;
										r15_n = strlen(qwLoc04C0_n);
										rcx_n.u4 = (uint64) ecx_n;
									}
									else
									{
										r15_n.u0 = 0x00;
										qwLoc04C0_n.u0 = 0x00416919;
										r11_n = (uint64) r11d_n;
										r9_n = SEQ(r9_32_32_n, r9d_n);
									}
									word32 r9d_n = (word32) r9_n;
									word32 ecx_n = (word32) rcx_n;
									word32 rcx_32_32_n = SLICE(rcx_n, word32, 32);
									word32 r9_32_32_n = SLICE(r9_n, word32, 32);
									byte r9b_n = (byte) r9d_n;
									word24 r9d_24_8_n = SLICE(r9d_n, word24, 8);
									word32 r11d_n = (word32) r11_n;
									byte cl_n = (byte) ecx_n;
									word24 ecx_24_8_n = SLICE(ecx_n, word24, 8);
									int32 eax_n = 0x00;
									if (ebp_n >= 0x00)
										eax_n = ebp_n;
									Eq_n rax_n;
									rax_n.u4 = (int64) eax_n;
									Eq_n r8_n = rax_n;
									if (r15_n >= rax_n)
										r8_n = r15_n;
									if (r8_n >= rdx - r13_n)
										goto l000000000040EE98;
									rcx = rcx_n;
									if (r12_n != 0x00)
									{
										uint64 r9_n = SEQ(r9_32_32_n, r9d_24_8_n, r9b_n);
										Eq_n rcx_n = SEQ(rcx_32_32_n, ecx_24_8_n, cl_n);
										if (rax_n > r15_n)
										{
											Eq_n rbp_n = (int64) ebp_n - r15_n;
											if (r11d_n != 0x30)
											{
												memset(r12_n, 32, rbp_n);
												r12_n += rbp_n;
												rcx_n.u4 = (uint64) ecx_n;
												r9_n = (uint64) r9d_n;
											}
											else
											{
												memset(r12_n, 48, rbp_n);
												r12_n += rbp_n;
												r9_n = (uint64) r9d_n;
												rcx_n.u4 = (uint64) ecx_n;
											}
										}
										byte r9b_n = (byte) r9_n;
										rcx = rcx_n;
										if ((byte) rcx_n == 0x00)
										{
											if (r9b_n != 0x00)
											{
												fn000000000040EC80(r15_n, qwLoc04C0_n, r12_n);
												Eq_n rcx_n;
												rcx = rcx_n;
											}
											else
												memcpy(r12_n, qwLoc04C0_n, r15_n);
										}
										else
										{
											fn000000000040EC30(r15_n, qwLoc04C0_n, r12_n);
											Eq_n rcx_n;
											rcx = rcx_n;
										}
										r12_n += r15_n;
									}
									r13_n = (uint64) (r8_n.u4 + r13_n);
									r8_n = rbx_n;
									goto l000000000040ED74;
								case 0x62:
								case 0x68:
									if (al_n != 0x00)
										r9d_n = 0x01;
									Eq_n r8_n;
									Eq_n rax_n;
									Eq_n fp;
									if (ecx_n == 0x00)
									{
l000000000040F087:
										bLoc0458 = 0x20;
										r8_n = rbx_n;
										r15b_n = 0x00;
										dwLoc04F0_n = 0x00;
										rax_n = fp - 1110;
										goto l000000000040EF37;
									}
									break;
								case 100:
									if (ecx_n != 0x45)
									{
										dwLoc04F0_n = 0x02;
										r8d_n.u4 = r8.u6[0x0C];
										goto l000000000040F228;
									}
									break;
								case 101:
									if (ecx_n != 0x45)
									{
										r8d_n.u4 = r8.u6[0x0C];
										goto l000000000040F2B7;
									}
									break;
								case 0x6A:
									if (ecx_n != 0x45)
									{
										int32 r8d_n = (int32) r8.u6[28];
										bLoc04E0_n = 0x00;
										dwLoc04F0_n = 0x03;
										r8d_n = r8d_n + 0x01;
										dil_n = 0x00;
										r10_n = SEQ(r10_56_8_n, (int8) (r8d_n < ~0x00));
										goto l000000000040F238;
									}
									break;
								case 0x6B:
									if (ecx_n != 0x45)
									{
										r8d_n.u4 = r8.u6[8];
										goto l000000000040F2B7;
									}
									break;
								case 0x6C:
									if (ecx_n != 0x45)
									{
										r8d_n = dwLoc04C8_n;
l000000000040F2B7:
										dwLoc04F0_n = 0x02;
										if (r11d_n != 0x2D && r11d_n != 0x30)
											r11d_n = 0x5F;
										goto l000000000040F228;
									}
									break;
								case 0x6D:
									if (ecx_n != 0x45)
									{
										int32 r8d_n = r8.u9->u1.dw0010;
										bLoc04E0_n = 0x00;
										dwLoc04F0_n = 0x02;
										r8d_n = r8d_n + 0x01;
										dil_n = 0x00;
										r10_n = SEQ(r10_56_8_n, (int8) (r8d_n < ~0x00));
										goto l000000000040F238;
									}
									break;
								case 110:
									int32 eax_n = 0x00;
									r15_n.u1 = 0x01;
									if (ebp_n >= 0x00)
										eax_n = ebp_n;
									Eq_n rax_n;
									rax_n.u0 = (int64) eax_n;
									if (rax_n != 0x00)
										r15_n = rax_n;
									if (r15_n >= rdx - r13_n)
										goto l000000000040EE98;
									if (r12_n != 0x00)
									{
										if (rax_n > 0x01)
										{
											Eq_n rbp_n;
											rbp_n.u0 = (int64) ebp_n;
											if (r11d_n != 0x30)
											{
												memset(r12_n, 32, rbp_n - 0x01);
												r12_n += rbp_n - 0x01;
											}
											else
											{
												memset(r12_n, 48, rbp_n - 0x01);
												r12_n += rbp_n - 0x01;
											}
										}
										*r12_n.u1 = 0x0A;
										r12_n.u1 = (word32) r12_n + 1;
									}
									goto l000000000040FA58;
								case 0x70:
									r15b_n = 0x00;
l000000000040F90C:
									if (al_n != 0x00)
									{
										r9d_n = 0x00;
										r15b_n = 0x01;
									}
									goto l000000000040EF0C;
								case 114:
l000000000040EF09:
									r15b_n = 0x00;
l000000000040EF0C:
									bLoc0458 = 0x20;
									if (ecx_n != 0x00)
									{
										dwLoc04F0_n = 0x00;
										goto l000000000040F25D;
									}
									else
									{
										rax_n = fp - 1110;
										r8_n = rbx_n;
										dwLoc04F0_n = 0x00;
										goto l000000000040EF37;
									}
								case 115:
									word64 qwLoc0498 = *r8.u5;
									uint64 r11_n = (uint64) r11d_n;
									Eq_n rax_n = SEQ(r8.u6[52], mktime(&qwLoc0498));
									Eq_n r15_n = fp - 0x0431;
									word32 r11d_n = (word32) r11_n;
									r9_n = (uint64) r9d_n;
									byte r8b_n = (byte) (rax_n >> 0x3F);
									Eq_n rcx_n = rax_n;
									byte sil_n = (byte) (rax_n >> 0x3F);
									Eq_n rdx_n;
									do
									{
										rdx_n = (SLICE(rcx_n *s128 0x6666666666666667, word64, 64) >> 0x02) - (rcx_n >> 0x3F);
										word32 eax_n = (word32) rcx_n - (word32) rdx_n * 0x0A;
										uint64 rdx_n = (uint64) (0x30 - eax_n);
										--r15_n;
										rcx_n = rdx_n;
										if (sil_n == 0x00)
											rdx_n = SEQ(SLICE(rdx_n, word32, 32), eax_n + 0x30);
										*r15_n.u4 = (byte) rdx_n;
									} while (rdx_n != 0x00);
									int32 eax_n = 0x01;
									if (ebp_n > 0x00)
										eax_n = ebp_n;
									int32 dwLoc04F0_n = eax_n;
									if (r8b_n == 0x00)
										goto l000000000040F591;
									word32 r10d_n;
									word32 eax_n;
									byte bLoc04D8_n;
									if (r11d_n == 0x2D)
									{
										r10d_n = 0x2D;
										goto l000000000040FF92;
									}
									else
									{
										eax_n = 0x01;
										bLoc04D8_n = 0x01;
										r10d_n = 0x2D;
										goto l000000000040F5A8;
									}
								case 116:
									int32 eax_n = 0x00;
									r15_n.u1 = 0x01;
									if (ebp_n >= 0x00)
										eax_n = ebp_n;
									Eq_n rax_n;
									rax_n.u0 = (int64) eax_n;
									if (rax_n != 0x00)
										r15_n = rax_n;
									if (r15_n >= rdx - r13_n)
										goto l000000000040EE98;
									if (r12_n != 0x00)
									{
										if (rax_n > 0x01)
										{
											int64 rbp_n = (int64) ebp_n;
											if (r11d_n != 0x30)
											{
												memset(r12_n, 32, rbp_n - 0x01);
												r12_n.u1 += rbp_n - 0x01;
											}
											else
											{
												memset(r12_n, 48, rbp_n - 0x01);
												r12_n.u1 += rbp_n - 0x01;
											}
										}
										*r12_n.u1 = 0x09;
										r12_n.u1 = (word32) r12_n + 1;
									}
l000000000040FA58:
									rcx = rcx_n;
									r13_n = (uint64) ((word32) r15_n + r13_n);
									r8_n = rbx_n;
									goto l000000000040ED74;
								case 117:
									int32 r8d_n = (int32) ((byte) r8.u6[24].b0002 + 4);
									uint64 rdx_n = (uint64) ((SLICE(r8d_n *s64 0x92492493, word32, 32) + r8d_n >> 0x02) - (r8d_n >> 0x1F));
									dwLoc04F0_n = 0x01;
									r8d_n = r8d_n - ((word32) rdx_n * 0x08 - (word32) rdx_n) + 0x01;
									goto l000000000040F228;
								case 0x77:
									if (ecx_n != 0x45)
									{
										dwLoc04F0_n = 0x01;
										r8d_n.u4 = r8.u6[24];
										goto l000000000040F228;
									}
									break;
								case 121:
									if (ecx_n == 0x45)
									{
l000000000041028D:
										dwLoc04F0_n = 0x00;
										goto l000000000040F24A;
									}
									else
									{
										int32 edi_n = (int32) r8.u6[20];
										Eq_n eax_n = edi_n - ((SLICE(edi_n *s64 1374389535, word32, 32) >> 0x05) - (edi_n >> 0x1F)) *s 100;
										dwLoc04F0_n = 0x02;
										r8d_n = eax_n;
										if (eax_n < 0x00)
										{
											Eq_n eax_n = -eax_n;
											r8d_n.u4 = (word32) eax_n.u0 + 100;
											if (edi_n <= ~0x076C)
												r8d_n = eax_n;
										}
l000000000040F228:
										dil_n = 0x00;
										bLoc04E0_n = 0x00;
										r10_n.u4 = (uint64) (r8d_n >> 0x1F);
										goto l000000000040F238;
									}
								case 122:
									r15_n = 0x00;
l000000000040F300:
									rcx = rcx_n;
									if (r8.u6[32] < 0x00)
									{
										r8_n = rbx_n;
										goto l000000000040ED74;
									}
									r10_n.u4 = r8.u6[40];
									Eq_n r10d_n = (word32) r10_n;
									uint64 rdi_n = (uint64) ((SLICE(r10d_n *s64 0x88888889, word32, 32) + (word32) r10_n >> 0x05) - (r10d_n >> 0x1F));
									int32 edi_n = (word32) rdi_n;
									r8d_n = (SLICE(r10d_n *s64 2443359173, word32, 32) + (word32) r10_n >> 11) - (r10d_n >> 0x1F);
									int32 eax_n = edi_n - ((SLICE(edi_n *s64 0x88888889, word32, 32) + (word32) rdi_n >> 0x05) - (edi_n >> 0x1F)) *s 0x3C;
									int32 edx_n = r10d_n - edi_n *s 0x3C;
									if (r15_n == 0x01)
									{
l0000000000410355:
										r10_n.u4 = (uint64) (r10d_n >> 0x1F);
										dil_n = 0x04;
										bLoc04E0_n = 0x01;
										dwLoc04F0_n = 0x06;
										r8d_n = r8d_n *s 100 + eax_n;
										goto l000000000040F238;
									}
									if (r15_n < 0x01)
									{
										r10_n.u4 = (uint64) (r10d_n >> 0x1F);
										dil_n = 0x00;
										bLoc04E0_n = 0x01;
										dwLoc04F0_n = 0x05;
										r8d_n = r8d_n *s 100 + eax_n;
										goto l000000000040F238;
									}
									if (r15_n != 0x02)
									{
										if (r15_n != 0x03)
										{
											rdi_n = (uint64) *rbx_n.u4;
											r8_n = rbx_n;
											goto l000000000040F39F;
										}
										if (edx_n != 0x00)
											goto l00000000004102D3;
										if (eax_n != 0x00)
											goto l0000000000410355;
										r10_n.u4 = (uint64) (r10d_n >> 0x1F);
										dil_n = 0x00;
										bLoc04E0_n = 0x01;
										dwLoc04F0_n = 0x03;
									}
									else
									{
l00000000004102D3:
										r10_n.u4 = (uint64) (r10d_n >> 0x1F);
										bLoc04E0_n = 0x01;
										dwLoc04F0_n = 0x09;
										dil_n = 0x14;
										r8d_n = r8d_n *s 10000 + eax_n *s 100 + edx_n;
									}
l000000000040F238:
									r10b_n = (byte) r10_n;
									if (r10b_n == 0x00)
									{
										r10_n = r10_n;
										if (ecx_n == 0x4F)
										{
l000000000040F24A:
											bLoc0458 = 0x20;
											r15b_n = 0x00;
l000000000040F25D:
											dil_n = (byte) esi_n;
											r8_n = rbx_n;
											rax_n = fp - 0x0455;
l000000000040EF37:
											rax_n.u1->b0000 = dil_n;
											rax_n.u1[1] = (struct Eq_n) 0x00;
											uint64 r9_n = (uint64) r9d_n;
											word32 r9d_n = (word32) r9_n;
											rcx = r8;
											Eq_n rax_n = strftime(&bLoc0448, 0x0400, &bLoc0458, r8);
											r8_n = r8_n;
											byte r9b_n = (byte) r9d_n;
											word32 r9_32_32_n = SLICE(r9_n, word32, 32);
											word24 r9d_24_8_n = SLICE(r9d_n, word24, 8);
											if (rax_n == 0x00)
												goto l000000000040ED74;
											int32 eax_n = 0x00;
											if (ebp_n >= 0x00)
												eax_n = ebp_n;
											Eq_n rax_n;
											rax_n.u4 = (int64) eax_n;
											rcx = rax_n - 1;
											if (rax_n >= rax_n - 1)
												rcx = rax_n;
											word56 r9_56_8_n = SEQ(r9_32_32_n, r9d_24_8_n);
											if (rcx >= rdx - r13_n)
												goto l000000000040EE98;
											if (r12_n != 0x00)
											{
												uint64 r9_n = SEQ(r9_56_8_n, r9b_n);
												if (rax_n - 1 < rax_n)
												{
													r9_n = SEQ(r9_56_8_n, r9b_n);
													if (dwLoc04F0_n == 0x00)
													{
														Eq_n rbp_n = (int64) ebp_n - (rax_n - 1);
														if (r11d_n != 0x30)
														{
															memset(r12_n, 32, rbp_n);
															r12_n += rbp_n;
															r9_n = (uint64) r9d_n;
														}
														else
														{
															memset(r12_n, 48, rbp_n);
															r12_n += rbp_n;
															r9_n = (uint64) r9d_n;
														}
													}
												}
												byte r9b_n = (byte) r9_n;
												if (r15b_n == 0x00)
												{
													if (r9b_n != 0x00)
														fn000000000040EC80(rax_n - 1, fp - 0x0447, r12_n);
													else
														memcpy(r12_n, fp - 0x0447, rax_n - 1);
												}
												else
													fn000000000040EC30(rax_n - 1, fp - 0x0447, r12_n);
												r12_n += rax_n - 1;
											}
											al_n.u4 = r8_n.u6[1];
											r13_n = (uint64) (rcx.u4 + r13_n);
											rbx_n.u6 = r8_n.u6 + 1;
											if (al_n == 0x00)
												goto l000000000040F050;
											goto l000000000040ED85;
										}
									}
l000000000040F518:
									Eq_n rcx_n = fp - 0x0431;
									Eq_n eax_n = -r8d_n;
									if (r10b_n != 0x00)
										r8d_n = eax_n;
									Eq_n edi_n;
									edi_n.u1 = (uint32) dil_n;
									while (true)
									{
										if (((byte) edi_n & 0x01) != 0x00)
										{
											rcx_n.u6->bFFFFFFFF = 0x3A;
											--rcx_n;
										}
										uint64 rdx_n = (uint64) (SLICE(r8d_n *64 ~0x33333332, word32, 32) >> 0x03);
										rcx_n.u6->bFFFFFFFF = (byte) r8d_n - ((byte) rdx_n + (byte) rdx_n * 0x04) * 0x02 + 0x30;
										Eq_n edx_n = (word32) rdx_n;
										edi_n.u2 = (uint64) (edi_n >> 0x01);
										r15_n = rcx_n - 1;
										r8d_n = edx_n;
										if ((word32) edi_n == 0x00 && edx_n == 0x00)
											break;
										rcx_n = r15_n;
									}
									int32 eax_n = dwLoc04F0_n;
									if (dwLoc04F0_n < ebp_n)
										eax_n = ebp_n;
									dwLoc04F0_n = eax_n;
									if (r10b_n != 0x00)
									{
										r10d_n = 0x2D;
										goto l000000000040FF5E;
									}
									r11_n = (uint64) r11d_n;
									if (bLoc04E0_n != 0x00)
									{
										r10d_n = 0x2B;
l000000000040FF5E:
										Eq_n r8_n;
										uint64 r11_n;
										uint64 r9_n;
										if (r11d_n != 0x2D)
										{
											eax_n = 0x01;
											bLoc04D8_n = 0x01;
											r11_n = (uint64) r11d_n;
l000000000040F5A8:
											word32 r9d_n = (word32) r9_n;
											word32 r11d_n = (word32) r11_n;
											byte r10b_n = (byte) r10d_n;
											int32 r8d_n = dwLoc04F0_n - eax_n + ((word32) r15_n - ((word32) fp - 0x0431));
											if (r8d_n > 0x00)
											{
												if (r11d_n != 0x5F)
												{
													Eq_n rax_n = rdx - r13_n;
													if ((int64) dwLoc04F0_n >= rax_n)
														goto l000000000040EE98;
													if (bLoc04D8_n != 0x00)
													{
														int32 edx_n = 0x00;
														Eq_n rcx_n;
														rcx_n.u1 = 0x01;
														if (ebp_n >= 0x00)
															edx_n = ebp_n;
														Eq_n rdx_n;
														rdx_n.u0 = (int64) edx_n;
														if (rdx_n != 0x00)
															rcx_n = rdx_n;
														if (rax_n <= rcx_n)
															goto l000000000040EE98;
														if (r12_n != 0x00)
														{
															if (rdx_n > 0x01 && dwLoc04F0_n == 0x00)
															{
																Eq_n rbp_n;
																rbp_n.u0 = (int64) ebp_n;
																if (r11d_n != 0x30)
																{
																	memset(r12_n, 32, rbp_n - 0x01);
																	r12_n += rbp_n - 0x01;
																	r10b_n = (byte) r10d_n;
																	r9_n = (uint64) r9d_n;
																	r11_n = (uint64) r11d_n;
																}
																else
																{
																	memset(r12_n, 48, rbp_n - 0x01);
																	r12_n += rbp_n - 0x01;
																	r11_n = (uint64) r11d_n;
																	r9_n = (uint64) r9d_n;
																	r10b_n = (byte) r10d_n;
																}
															}
															*r12_n.u1 = r10b_n;
															r12_n.u1 = (word32) r12_n + 1;
														}
														r13_n = (uint64) ((word32) rcx_n + r13_n);
													}
													word32 r11d_n = (word32) r11_n;
													word32 r9d_n = (word32) r9_n;
													Eq_n rbp_n;
													rbp_n.u4 = (int64) r8d_n;
													uint64 r11_n = r11_n;
													uint64 r9_n = r9_n;
													if (r12_n != 0x00)
													{
														rbp_n.u4 = (int64) r8d_n;
														memset(r12_n, 48, rbp_n);
														r9_n = (uint64) r9d_n;
														r11_n = (uint64) r11d_n;
														r12_n += rbp_n;
													}
													r13_n = (uint64) (rbp_n.u4 + r13_n);
													r8_n = rbx_n;
													rcx.u0 = 0x00;
													ebp_n = 0x00;
													r11_n = r11_n;
													r9_n = r9_n;
												}
												else
												{
													Eq_n rcx_n;
													rcx_n.u4 = (int64) r8d_n;
													if (rcx_n >= rdx - r13_n)
														goto l000000000040EE98;
													uint64 r10_n = (uint64) r10d_n;
													if (r12_n != 0x00)
													{
														memset(r12_n, 32, rcx_n);
														r10_n = (uint64) r10d_n;
														r9_n = (uint64) r9d_n;
														r11_n = (uint64) r11d_n;
														r12_n += rcx_n;
													}
													word32 r10d_n = (word32) r10_n;
													word32 r11d_n = (word32) r11_n;
													word32 r9d_n = (word32) r9_n;
													byte r10b_n = (byte) r10d_n;
													r13_n = (uint64) (rcx_n.u4 + r13_n);
													if (r8d_n < ebp_n)
													{
														int32 ecx_n = 0x00;
														ebp_n -= r8d_n;
														if (ebp_n >= 0x00)
															ecx_n = ebp_n;
														rcx.u4 = (int64) ecx_n;
													}
													else
													{
														rcx.u0 = 0x00;
														ebp_n = 0x00;
													}
													if (bLoc04D8_n != 0x00)
													{
														Eq_n r8_n;
														r8_n.u0 = 0x01;
														if (rcx != 0x00)
															r8_n = rcx;
														if (r8_n >= rdx - r13_n)
															goto l000000000040EE98;
														if (r12_n != 0x00)
														{
															if (rcx > 0x01 && dwLoc04F0_n == 0x00)
															{
																Eq_n rax_n;
																rax_n.u0 = (int64) ebp_n;
																memset(r12_n, 32, rax_n - 0x01);
																r12_n += rax_n - 0x01;
																r10b_n = (byte) r10d_n;
																r9_n = (uint64) r9d_n;
																r11_n = (uint64) r11d_n;
															}
															*r12_n.u1 = r10b_n;
															r12_n.u1 = (word32) r12_n + 1;
														}
														r13_n = (uint64) (r8_n.u4 + r13_n);
														r8_n = rbx_n;
														r11_n = r11_n;
														r9_n = r9_n;
													}
													else
													{
														r8_n = rbx_n;
														r11_n = r11_n;
														r9_n = r9_n;
													}
												}
											}
											else if (bLoc04D8_n != 0x00)
											{
												int32 r8d_n = 0x00;
												Eq_n rcx_n;
												rcx_n.u0 = 0x01;
												if (ebp_n >= 0x00)
													r8d_n = ebp_n;
												Eq_n r8_n;
												r8_n.u4 = (int64) r8d_n;
												if (r8_n != 0x00)
													rcx_n = r8_n;
												if (rcx_n >= rdx - r13_n)
													goto l000000000040EE98;
												if (r12_n != 0x00)
												{
													if (r8_n > 0x01 && dwLoc04F0_n == 0x00)
													{
														Eq_n rax_n;
														rax_n.u0 = (int64) ebp_n;
														if (r11d_n != 0x30)
														{
															memset(r12_n, 32, rax_n - 0x01);
															r12_n += rax_n - 0x01;
															r10b_n = (byte) r10d_n;
															r9_n = (uint64) r9d_n;
															r11_n = (uint64) r11d_n;
														}
														else
														{
															memset(r12_n, 48, rax_n - 0x01);
															r12_n += rax_n - 0x01;
															r11_n = (uint64) r11d_n;
															r9_n = (uint64) r9d_n;
															r10b_n = (byte) r10d_n;
														}
													}
													*r12_n.u1 = r10b_n;
													r12_n.u1 = (word32) r12_n + 1;
												}
												r13_n = (uint64) (rcx_n.u4 + r13_n);
												rcx = r8_n;
												r8_n = rbx_n;
												r11_n = r11_n;
												r9_n = r9_n;
											}
											else
											{
l000000000041026A:
												int32 ecx_n = 0x00;
												r8_n = rbx_n;
												if (ebp_n >= 0x00)
													ecx_n = ebp_n;
												rcx.u4 = (int64) ecx_n;
												r11_n = r11_n;
												r9_n = r9_n;
											}
										}
										else
										{
l000000000040FF92:
											word32 r9d_n = (word32) r9_n;
											byte r10b_n = (byte) r10d_n;
											int32 ecx_n = 0x00;
											Eq_n r8_n;
											r8_n.u0 = 0x01;
											if (ebp_n >= 0x00)
												ecx_n = ebp_n;
											Eq_n rcx_n;
											rcx_n.u4 = (int64) ecx_n;
											if (rcx_n != 0x00)
												r8_n = rcx_n;
											if (r8_n >= rdx - r13_n)
												goto l000000000040EE98;
											if (r12_n != 0x00)
											{
												if (rcx_n > 0x01 && dwLoc04F0_n == 0x00)
												{
													Eq_n rax_n;
													rax_n.u0 = (int64) ebp_n;
													memset(r12_n, 32, rax_n - 1);
													r10b_n = (byte) r10d_n;
													r9_n = (uint64) r9d_n;
													r12_n += rax_n - 1;
												}
												*r12_n.u1 = r10b_n;
												r12_n.u1 = (word32) r12_n + 1;
											}
											rcx = rcx_n;
											r13_n = (uint64) (r8_n.u4 + r13_n);
											r8_n = rbx_n;
											r11_n = 0x2D;
											r9_n = r9_n;
										}
										word32 r9d_n = (word32) r9_n;
										word32 r9_32_32_n = SLICE(r9_n, word32, 32);
										word32 r11d_n = (word32) r11_n;
										byte r9b_n = (byte) r9d_n;
										word24 r9d_24_8_n = SLICE(r9d_n, word24, 8);
										Eq_n r10_n = rcx;
										Eq_n rbx_n = fp - 0x0431 - r15_n;
										if (rbx_n >= rcx)
											r10_n = rbx_n;
										if (r10_n >= rdx - r13_n)
											goto l000000000040EE98;
										if (r12_n != 0x00)
										{
											uint64 r9_n = SEQ(r9_32_32_n, r9d_24_8_n, r9b_n);
											if (rbx_n < rcx)
											{
												r9_n = SEQ(r9_32_32_n, r9d_24_8_n, r9b_n);
												if (dwLoc04F0_n == 0x00)
												{
													Eq_n rbp_n = (int64) ebp_n - rbx_n;
													if (r11d_n != 0x30)
													{
														memset(r12_n, 32, rbp_n);
														r12_n += rbp_n;
														r9_n = (uint64) r9d_n;
													}
													else
													{
														memset(r12_n, 48, rbp_n);
														r12_n += rbp_n;
														r9_n = (uint64) r9d_n;
													}
												}
											}
											if ((byte) r9_n != 0x00)
											{
												fn000000000040EC80(rbx_n, r15_n, r12_n);
												Eq_n rcx_n;
												rcx = rcx_n;
											}
											else
												memcpy(r12_n, r15_n, rbx_n);
											r12_n += rbx_n;
										}
										r8_n = r8_n;
										r10_n = r10_n;
										r13_n = (uint64) (r10_n.u4 + r13_n);
										goto l000000000040ED74;
									}
									else
									{
l000000000040F591:
										if ((word32) r11_n == 0x2D)
											goto l000000000041026A;
										eax_n = 0x00;
										bLoc04D8_n = 0x00;
										r10d_n = 0x00;
										goto l000000000040F5A8;
									}
								}
								goto l000000000040F0B8;
							}
						}
						++rbx_n.u6;
						rdi_n = (uint64) *rbx_n.u4;
						dil_n = (byte) rdi_n;
						al_n = 0x01;
						v132_n = dil_n > 0x30;
					}
					r11d_n = (int32) dil_n;
				}
			}
			if (rdx - r13_n <= 0x01)
			{
l000000000040EE98:
				rax_n = 0x00;
				goto l000000000040EE9A;
			}
			if (r12_n != 0x00)
			{
				*r12_n.u1 = (char) al_n;
				r12_n.u1 = (word32) r12_n + 1;
			}
			++r13_n;
			r8_n = rbx_n;
l000000000040ED74:
			al_n.u4 = r8_n.u6[1];
			rbx_n.u6 = r8_n.u6 + 1;
		} while (al_n != 0x00);
l000000000040F050:
	}
	if (r12_n != 0x00 && rdx != 0x00)
	{
		*r12_n.u1 = 0x00;
		rax_n = r13_n;
	}
	else
		rax_n = r13_n;
l000000000040EE9A:
	if ((rsi_n ^ fs->qw0028) == 0x00)
		return rax_n;
	__stack_chk_fail();
}

// 0000000000410600: Register Eq_n fn0000000000410600(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi, Register word32 r8d, Register Eq_n r9d, Register (ptr32 Eq_n) fs)
// Called from:
//      fn0000000000406A80
Eq_n fn0000000000410600(Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi, word32 r8d, Eq_n r9d, struct Eq_n * fs)
{
	return fn000000000040ECD0(rdx, rsi, rdi, 0x00, rcx, r8d, fs, r9d);
}

// 0000000000410630: void fn0000000000410630(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi, Register Eq_n r9)
// Called from:
//      fn0000000000410AC0
void fn0000000000410630(Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi, Eq_n r9)
{
	Eq_n r9_n;
	if (rsi != 0x00)
	{
		__fprintf_chk(rdi, 1, "%s (%s) %s\n", rsi, rdx, rcx);
		r9_n = rcx;
	}
	else
	{
		__fprintf_chk(rdi, 1, "%s %s\n", rdx, rcx);
		r9_n = r9;
	}
	char * rax_n = dcgettext(0x00, 4286675, 5);
	__fprintf_chk(rdi, 1, "Copyright %s %d Free Software Foundation, Inc.", rax_n, 0x07DD);
	char * rax_n = dcgettext(0x00, 4286768, 5);
	fputs_unlocked(rax_n, rdi);
	if (r9 > 0x09)
		__fprintf_chk(rdi, 1, dcgettext(0x00, 4287240, 5), 0x00);
	else
		g_ptr416B48();
}

<anonymous> g_t410800 = <code>; // 0000000000410800
// 0000000000410AC0: void fn0000000000410AC0(Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi, Register (ptr64 Eq_n) r8)
// Called from:
//      fn0000000000410B30
void fn0000000000410AC0(Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi, struct Eq_n * r8)
{
	Eq_n r9_n;
	r9_n.u0 = 0x00;
	do
	{
		up32 eax_n = r8->dw0000;
		Eq_n tLoc58;
		if (eax_n >= 0x30)
		{
			word64 * r10_n = r8->ptr0008;
			r8->ptr0008 = r10_n + 1;
			word64 rax_n = *r10_n;
			tLoc58.a0000[r9_n] = rax_n;
			if (rax_n == 0x00)
				break;
		}
		else
		{
			Eq_n r10_n = (uint64) eax_n + r8->qw0010;
			r8->dw0000 = eax_n + 0x08;
			word64 rax_n = *r10_n.u1;
			tLoc58.a0000[r9_n] = rax_n;
			if (rax_n == 0x00)
				break;
		}
		r9_n.u1 = (word64) r9_n.u0 + 1;
	} while (r9_n != 0x0A);
	fn0000000000410630(rcx, rdx, rsi, rdi, r9_n);
}

// 0000000000410B30: void fn0000000000410B30(Register byte al, Register Eq_n rcx, Register Eq_n rdx, Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
void fn0000000000410B30(byte al, Eq_n rcx, Eq_n rdx, Eq_n rsi, Eq_n rdi)
{
	Eq_n tLocD0;
	ptr64 fp;
	tLocD0.ptr0008 = fp + 0x08;
	tLocD0.dw0000 = 0x20;
	tLocD0.dw0004 = 0x30;
	tLocD0.ptr0010 = fp - 0xB8;
	fn0000000000410AC0(rcx, rdx, rsi, rdi, &tLocD0);
}

// 0000000000410C40: Register (ptr64 void) fn0000000000410C40(Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
//      fn0000000000404D20
//      fn0000000000404E80
//      fn0000000000405ED0
//      fn0000000000407EA0
//      fn000000000040C9B0
//      fn000000000040CB40
//      fn000000000040E930
//      fn0000000000410C90
//      fn0000000000410E30
void * fn0000000000410C40(Eq_n rdi)
{
	void * rax_n = malloc(rdi);
	if (rax_n != null || rdi == 0x00)
		return rax_n;
	fn0000000000410E50();
}

// 0000000000410C90: Register Eq_n fn0000000000410C90(Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn0000000000405ED0
//      fn0000000000407EA0
//      fn000000000040E930
Eq_n fn0000000000410C90(Eq_n rsi, Eq_n rdi)
{
	if (rsi == 0x00 && rdi != 0x00)
	{
		free(rdi);
		return 0x00;
	}
	else
	{
		Eq_n rax_n = realloc(rdi, rsi);
		if (rax_n != 0x00 || rsi == 0x00)
			return rax_n;
		fn0000000000410E50();
	}
}

// 0000000000410E00: Register (ptr64 void) fn0000000000410E00(Register Eq_n rsi, Register Eq_n rdi)
// Called from:
//      fn000000000040E600
//      fn0000000000410E30
void * fn0000000000410E00(Eq_n rsi, Eq_n rdi)
{
	return memcpy(fn0000000000410C40(rsi), rdi, rsi);
}

// 0000000000410E30: Register word64 fn0000000000410E30(Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
//      fn0000000000404D20
//      fn0000000000407EA0
word64 fn0000000000410E30(Eq_n rdi)
{
	Eq_n rax_n = strlen(rdi);
	return fn0000000000410E00(rax_n.u6 + 1, rdi);
}

// 0000000000410E50: void fn0000000000410E50()
// Called from:
//      fn00000000004028C0
//      fn0000000000404E80
//      fn0000000000405ED0
//      fn0000000000407EA0
//      fn000000000040A610
//      fn0000000000410C40
//      fn0000000000410C90
void fn0000000000410E50()
{
	dcgettext(0x00, 4287439, 5);
	error(g_dw61A580, 0, 4283988, 0x00);
	abort();
}

// 0000000000410E90: Register ui32 fn0000000000410E90(Register Eq_n rcx, Register Eq_n edx, Register Eq_n rsi, Register Eq_n rdi, Register Eq_n r8)
// Called from:
//      fn00000000004028C0
ui32 fn0000000000410E90(Eq_n rcx, Eq_n edx, Eq_n rsi, Eq_n rdi, Eq_n r8)
{
	if (edx > 0x24)
		__assert_fail(4287472, 0x00416BE0, 0x60, 4287944);
	Eq_n r15_n = rsi;
	if (rsi == 0x00)
	{
		ptr64 fp;
		r15_n = fp - 0x40;
	}
	byte bl_n = *rdi.u4;
	struct Eq_n * rdx_n = (struct Eq_n *) *__ctype_b_loc();
	Eq_n rax_n = rdi;
	while ((rdx_n->a0001[(uint64) bl_n].b0000 & 0x20) != 0x00)
	{
		++rax_n.u6;
		bl_n = *rax_n.u4;
	}
	uint64 rax_n;
	if (bl_n == 0x2D)
	{
l0000000000410EF0:
		rax_n = 0x04;
		return (word32) rax_n;
	}
	int32 * rax_n = __errno_location();
	*rax_n = 0x00;
	uint32 eax_n = strtoul(rdi, r15_n, edx);
	Eq_n r14_n;
	r14_n.u4 = *r15_n.u1;
	Eq_n rbx_n = SEQ(SLICE(rax_n, word32, 32), eax_n);
	ui32 ebp_n;
	word32 edx_n;
	if (r14_n != rdi)
	{
		int32 eax_n = *rax_n;
		if (eax_n == 0x00)
			ebp_n = 0x00;
		else
		{
			ebp_n = 0x01;
			if (eax_n != 0x22)
				goto l0000000000410EF0;
		}
		if (r8 == 0x00)
		{
l0000000000410F4F:
			*rcx.u5 = (word64) rbx_n;
			return ebp_n;
		}
		uint64 rdx_n = (uint64) *r14_n.u4;
		char dl_n = (byte) rdx_n;
		word32 edx_n = (word32) rdx_n;
		if (dl_n == 0x00)
			goto l0000000000410F4F;
		edx_n = edx_n;
		if (strchr(r8, dl_n) == null)
		{
l0000000000411028:
			*rcx.u5 = (word64) rbx_n;
			rax_n = (uint64) (ebp_n | 0x02);
			return (word32) rax_n;
		}
	}
	else
	{
		if (r8 == 0x00)
			goto l0000000000410EF0;
		uint64 rdx_n = (uint64) *rdi.u4;
		char dl_n = (byte) rdx_n;
		word32 edx_n = (word32) rdx_n;
		if (dl_n == 0x00)
			goto l0000000000410EF0;
		ebp_n = 0x00;
		rbx_n.u0 = 0x01;
		edx_n = edx_n;
		if (strchr(r8, dl_n) == null)
			goto l0000000000410EF0;
	}
	word32 eax_n;
	uint64 rcx_n;
	if (strchr(r8, '0') == null)
	{
l0000000000410FCB:
		eax_n = 0x0400;
		rcx_n = 0x01;
		goto l0000000000410FD5;
	}
	byte al_n = (byte) r14_n.u6[1];
	if (al_n != 0x44)
	{
		if (al_n == 0x69)
		{
			uint64 rcx_n = (uint64) (r14_n.u6[2] == 66);
			eax_n = 0x0400;
			rcx_n = (uint64) ((word32) rcx_n + 0x01 + (word32) rcx_n);
l0000000000410FD5:
			word32 ecx_n = (word32) rcx_n;
			cu8 dl_n = (byte) edx_n - 66;
			if (dl_n <= 0x35)
			{
				uint64 rdx_n;
				switch (dl_n)
				{
				case 0x00:
					if (rbx_n > 0x3FFFFFFFFFFFFF)
						goto l0000000000411283;
					rbx_n <<= 0x0A;
					rdx_n = 0x00;
					break;
				case 0x01:
				case 0x02:
				case 0x04:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x0A:
				case 0x0C:
				case 0x0D:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x13:
				case 0x14:
				case 0x15:
				case 22:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 0x22:
				case 0x23:
				case 0x24:
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x2A:
				case 44:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x33:
				case 0x34:
					goto l0000000000411028;
				case 0x03:
					Eq_n rdi_n;
					rdi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rdi_n;
					word32 esi_n;
					ui32 edx_n = 0x00;
					for (esi_n = 0x06; esi_n != 0x00; --esi_n)
					{
						ui32 r8d_n;
						if (rax_n < rbx_n)
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						else
						{
							rbx_n *= rdi_n;
							r8d_n = 0x00;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x05:
				case 0x25:
					Eq_n rsi_n;
					rsi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rsi_n;
					word32 edi_n;
					ui32 edx_n = 0x00;
					for (edi_n = 0x03; edi_n != 0x00; --edi_n)
					{
						ui32 r8d_n;
						if (rax_n >= rbx_n)
						{
							rbx_n *= rsi_n;
							r8d_n = 0x00;
						}
						else
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x09:
				case 0x29:
					Eq_n rdi_n;
					rdi_n.u0 = (int64) eax_n;
					if (rbx_n <= 0FFFFFFFFFFFFFFFF /u rdi_n)
						goto l0000000000411193;
					rbx_n.u0 = ~0x00;
					rdx_n = 0x01;
					break;
				case 11:
				case 0x2B:
					rdi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rdi_n;
					if (rbx_n <= rax_n)
					{
						rbx_n *= rdi_n;
						if (rax_n < rbx_n)
							goto l00000000004112A3;
l0000000000411193:
						rbx_n *= rdi_n;
						rdx_n = 0x00;
					}
					else
					{
l00000000004112A3:
						rbx_n.u0 = ~0x00;
						rdx_n = 0x01;
					}
					break;
				case 0x0E:
					Eq_n rsi_n;
					rsi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rsi_n;
					word32 edi_n;
					ui32 edx_n = 0x00;
					for (edi_n = 0x05; edi_n != 0x00; --edi_n)
					{
						ui32 r8d_n;
						if (rax_n < rbx_n)
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						else
						{
							rbx_n *= rsi_n;
							r8d_n = 0x00;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x12:
				case 0x32:
					Eq_n rsi_n;
					rsi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rsi_n;
					word32 edi_n;
					ui32 edx_n = 0x00;
					for (edi_n = 0x04; edi_n != 0x00; --edi_n)
					{
						ui32 r8d_n;
						if (rax_n >= rbx_n)
						{
							rbx_n *= rsi_n;
							r8d_n = 0x00;
						}
						else
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x17:
					Eq_n rdi_n;
					rdi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rdi_n;
					word32 esi_n;
					ui32 edx_n = 0x00;
					for (esi_n = 0x08; esi_n != 0x00; --esi_n)
					{
						ui32 r8d_n;
						if (rax_n < rbx_n)
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						else
						{
							rbx_n *= rdi_n;
							r8d_n = 0x00;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x18:
					Eq_n rdi_n;
					rdi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rdi_n;
					word32 esi_n;
					ui32 edx_n = 0x00;
					for (esi_n = 0x07; esi_n != 0x00; --esi_n)
					{
						ui32 r8d_n;
						if (rax_n < rbx_n)
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						else
						{
							rbx_n *= rdi_n;
							r8d_n = 0x00;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x20:
					if (rbx_n > 0x7FFFFFFFFFFFFF)
						goto l0000000000411283;
					rbx_n <<= 0x09;
					rdx_n = 0x00;
					break;
				case 33:
					rdx_n = 0x00;
					break;
				case 0x35:
					if (rbx_n >= 0x00)
					{
						rbx_n *= 0x02;
						rdx_n = 0x00;
					}
					else
					{
l0000000000411283:
						rbx_n.u0 = ~0x00;
						rdx_n = 0x01;
					}
					break;
				}
				char * r14_n = r14_n.u4 + (int64) ecx_n;
				r15_n.u1->u1 = r14_n;
				ebp_n |= (word32) rdx_n;
				if (*r14_n != 0x00)
					ebp_n |= 0x02;
				goto l0000000000410F4F;
			}
			goto l0000000000411028;
		}
		if (al_n != 66)
			goto l0000000000410FCB;
	}
	eax_n = 1000;
	rcx_n = 0x02;
	goto l0000000000410FD5;
}

// 00000000004112D0: void fn00000000004112D0(Register int32 esi, Register up32 edi)
// Called from:
//      fn00000000004028C0
void fn00000000004112D0(int32 esi, up32 edi)
{
	int32 ebp_n = g_dw61A580;
	Eq_n rsi_n;
	if (edi <= 0x03)
	{
		if (edi < 0x02)
		{
			rsi_n.u0 = 4287980;
			if (edi != 0x01)
				goto l000000000041132F;
		}
		else
			rsi_n.u0 = 0x00416E10;
	}
	else
	{
		rsi_n.u0 = 0x00416DD1;
		if (edi != 0x04)
			goto l000000000041132F;
	}
	error(ebp_n, 0, dcgettext(0x00, rsi_n, 5), 0x00);
l000000000041132F:
	abort();
}

// 0000000000411360: Register ui32 fn0000000000411360(Register Eq_n rcx, Register Eq_n edx, Register (ptr64 (ptr64 char)) rsi, Register Eq_n rdi, Register Eq_n r8)
// Called from:
//      fn000000000040C810
ui32 fn0000000000411360(Eq_n rcx, Eq_n edx, char ** rsi, Eq_n rdi, Eq_n r8)
{
	if (edx > 0x24)
		__assert_fail(4287472, 0x00416BE0, 0x60, 4288488);
	char ** r15_n = rsi;
	if (rsi == null)
	{
		ptr64 fp;
		r15_n = fp - 0x40;
	}
	byte bl_n = *rdi.u4;
	struct Eq_n * rdx_n = (struct Eq_n *) *__ctype_b_loc();
	Eq_n rax_n = rdi;
	while ((rdx_n->a0001[(uint64) bl_n].b0000 & 0x20) != 0x00)
	{
		++rax_n.u6;
		bl_n = *rax_n.u4;
	}
	uint64 rax_n;
	if (bl_n == 0x2D)
	{
l00000000004113C0:
		rax_n = 0x04;
		return (word32) rax_n;
	}
	int32 * rax_n = __errno_location();
	*rax_n = 0x00;
	uint32 eax_n = __strtoul_internal(rdi, r15_n, edx, 0);
	Eq_n r14_n;
	r14_n.u4 = *r15_n;
	Eq_n rbx_n = SEQ(SLICE(rax_n, word32, 32), eax_n);
	ui32 ebp_n;
	word32 edx_n;
	if (r14_n != rdi)
	{
		int32 eax_n = *rax_n;
		if (eax_n == 0x00)
			ebp_n = 0x00;
		else
		{
			ebp_n = 0x01;
			if (eax_n != 0x22)
				goto l00000000004113C0;
		}
		if (r8 == 0x00)
		{
l0000000000411422:
			rcx.u1->u0 = (int64) rbx_n;
			return ebp_n;
		}
		uint64 rdx_n = (uint64) *r14_n.u4;
		char dl_n = (byte) rdx_n;
		word32 edx_n = (word32) rdx_n;
		if (dl_n == 0x00)
			goto l0000000000411422;
		edx_n = edx_n;
		if (strchr(r8, dl_n) == null)
		{
l0000000000411500:
			rcx.u1->u0 = (int64) rbx_n;
			rax_n = (uint64) (ebp_n | 0x02);
			return (word32) rax_n;
		}
	}
	else
	{
		if (r8 == 0x00)
			goto l00000000004113C0;
		uint64 rdx_n = (uint64) *rdi.u4;
		char dl_n = (byte) rdx_n;
		word32 edx_n = (word32) rdx_n;
		if (dl_n == 0x00)
			goto l00000000004113C0;
		ebp_n = 0x00;
		rbx_n.u1 = 0x01;
		edx_n = edx_n;
		if (strchr(r8, dl_n) == null)
			goto l00000000004113C0;
	}
	word32 eax_n;
	uint64 rcx_n;
	if (strchr(r8, '0') == null)
	{
l00000000004114A3:
		eax_n = 0x0400;
		rcx_n = 0x01;
		goto l00000000004114AD;
	}
	byte al_n = (byte) r14_n.u6[1];
	if (al_n != 0x44)
	{
		if (al_n == 0x69)
		{
			uint64 rcx_n = (uint64) (r14_n.u6[2] == 66);
			eax_n = 0x0400;
			rcx_n = (uint64) ((word32) rcx_n + 0x01 + (word32) rcx_n);
l00000000004114AD:
			word32 ecx_n = (word32) rcx_n;
			cu8 dl_n = (byte) edx_n - 66;
			if (dl_n <= 0x35)
			{
				uint64 rdx_n;
				switch (dl_n)
				{
				case 0x00:
					if (rbx_n > 0x3FFFFFFFFFFFFF)
						goto l000000000041175B;
					rbx_n <<= 0x0A;
					rdx_n = 0x00;
					break;
				case 0x01:
				case 0x02:
				case 0x04:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x0A:
				case 0x0C:
				case 0x0D:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x13:
				case 0x14:
				case 0x15:
				case 22:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 0x22:
				case 0x23:
				case 0x24:
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x2A:
				case 44:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x33:
				case 0x34:
					goto l0000000000411500;
				case 0x03:
					Eq_n rdi_n;
					rdi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rdi_n;
					word32 esi_n;
					ui32 edx_n = 0x00;
					for (esi_n = 0x06; esi_n != 0x00; --esi_n)
					{
						ui32 r8d_n;
						if (rax_n < rbx_n)
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						else
						{
							rbx_n *= rdi_n;
							r8d_n = 0x00;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x05:
				case 0x25:
					Eq_n rsi_n;
					rsi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rsi_n;
					word32 edi_n;
					ui32 edx_n = 0x00;
					for (edi_n = 0x03; edi_n != 0x00; --edi_n)
					{
						ui32 r8d_n;
						if (rax_n >= rbx_n)
						{
							rbx_n *= rsi_n;
							r8d_n = 0x00;
						}
						else
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x09:
				case 0x29:
					Eq_n rdi_n;
					rdi_n.u0 = (int64) eax_n;
					if (rbx_n <= 0FFFFFFFFFFFFFFFF /u rdi_n)
						goto l000000000041166B;
					rbx_n.u0 = ~0x00;
					rdx_n = 0x01;
					break;
				case 11:
				case 0x2B:
					rdi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rdi_n;
					if (rbx_n <= rax_n)
					{
						rbx_n *= rdi_n;
						if (rax_n < rbx_n)
							goto l000000000041177B;
l000000000041166B:
						rbx_n *= rdi_n;
						rdx_n = 0x00;
					}
					else
					{
l000000000041177B:
						rbx_n.u0 = ~0x00;
						rdx_n = 0x01;
					}
					break;
				case 0x0E:
					Eq_n rsi_n;
					rsi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rsi_n;
					word32 edi_n;
					ui32 edx_n = 0x00;
					for (edi_n = 0x05; edi_n != 0x00; --edi_n)
					{
						ui32 r8d_n;
						if (rax_n < rbx_n)
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						else
						{
							rbx_n *= rsi_n;
							r8d_n = 0x00;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x12:
				case 0x32:
					Eq_n rsi_n;
					rsi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rsi_n;
					word32 edi_n;
					ui32 edx_n = 0x00;
					for (edi_n = 0x04; edi_n != 0x00; --edi_n)
					{
						ui32 r8d_n;
						if (rax_n >= rbx_n)
						{
							rbx_n *= rsi_n;
							r8d_n = 0x00;
						}
						else
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x17:
					Eq_n rdi_n;
					rdi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rdi_n;
					word32 esi_n;
					ui32 edx_n = 0x00;
					for (esi_n = 0x08; esi_n != 0x00; --esi_n)
					{
						ui32 r8d_n;
						if (rax_n < rbx_n)
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						else
						{
							rbx_n *= rdi_n;
							r8d_n = 0x00;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x18:
					Eq_n rdi_n;
					rdi_n.u0 = (int64) eax_n;
					Eq_n rax_n = 0FFFFFFFFFFFFFFFF /u rdi_n;
					word32 esi_n;
					ui32 edx_n = 0x00;
					for (esi_n = 0x07; esi_n != 0x00; --esi_n)
					{
						ui32 r8d_n;
						if (rax_n < rbx_n)
						{
							rbx_n.u0 = ~0x00;
							r8d_n = 0x01;
						}
						else
						{
							rbx_n *= rdi_n;
							r8d_n = 0x00;
						}
						rdx_n = (uint64) (edx_n | r8d_n);
						edx_n = (word32) rdx_n;
					}
					break;
				case 0x20:
					if (rbx_n > 0x7FFFFFFFFFFFFF)
						goto l000000000041175B;
					rbx_n <<= 0x09;
					rdx_n = 0x00;
					break;
				case 33:
					rdx_n = 0x00;
					break;
				case 0x35:
					if (rbx_n >= 0x00)
					{
						rbx_n *= 0x02;
						rdx_n = 0x00;
					}
					else
					{
l000000000041175B:
						rbx_n.u0 = ~0x00;
						rdx_n = 0x01;
					}
					break;
				}
				char * r14_n = r14_n.u4 + (int64) ecx_n;
				*r15_n = (char **) r14_n;
				ebp_n |= (word32) rdx_n;
				if (*r14_n != 0x00)
					ebp_n |= 0x02;
				goto l0000000000411422;
			}
			goto l0000000000411500;
		}
		if (al_n != 66)
			goto l00000000004114A3;
	}
	eax_n = 1000;
	rcx_n = 0x02;
	goto l00000000004114AD;
}

// 00000000004117B0: Register word32 fn00000000004117B0(Register (ptr64 Eq_n) rsi, Register word32 edi)
// Called from:
//      fn0000000000411820
//      fn0000000000411840
word32 fn00000000004117B0(security_context_t * rsi, word32 edi)
{
	word64 rdi;
	edi = (word32) rdi;
	uint64 rax_n;
	if (edi != 0x00)
	{
		rax_n = (uint64) edi;
		if (edi == 0x0A)
		{
			Eq_n rdx_n = (Eq_n) *rsi;
			if (memcmp(rdx_n, 4274097, 0x0A) == 0x00)
			{
				freecon(rdx_n);
				*__errno_location() = 0x3D;
				rax_n = 0xFFFFFFFF;
			}
		}
	}
	else
	{
		*__errno_location() = 0x5F;
		rax_n = 0xFFFFFFFF;
	}
	return (word32) rax_n;
}

// 0000000000411820: Register word32 fn0000000000411820(Register (ptr64 Eq_n) rsi, Register Eq_n rdi)
// Called from:
//      fn0000000000407EA0
word32 fn0000000000411820(security_context_t * rsi, Eq_n rdi)
{
	uint64 rdi_n = (uint64) getfilecon(rdi, rsi);
	return fn00000000004117B0(rsi, (word32) rdi_n);
}

// 0000000000411840: Register word32 fn0000000000411840(Register (ptr64 Eq_n) rsi, Register Eq_n rdi)
// Called from:
//      fn0000000000407EA0
word32 fn0000000000411840(security_context_t * rsi, Eq_n rdi)
{
	uint64 rdi_n = (uint64) lgetfilecon(rdi, rsi);
	return fn00000000004117B0(rsi, (word32) rdi_n);
}

// 0000000000411880: void fn0000000000411880(Register (ptr64 Eq_n) rdi)
void fn0000000000411880(FILE * rdi)
{
	Eq_n rax_n = __fpending(rdi);
	ui32 ebx_n = (ui32) *rdi;
	int8 dl_n = (int8) (fn0000000000411D30(rdi) != 0x00);
	if ((ebx_n & 0x20) != 0x00)
	{
		if (dl_n != 0x00)
			return;
		*__errno_location() = 0x00;
	}
	else
	{
		if (dl_n == 0x00 || rax_n != 0x00)
			return;
		__errno_location();
	}
}

// 0000000000411900: Register word32 fn0000000000411900(Register (ptr32 Eq_n) fs)
// Called from:
//      fn000000000040D7B0
word32 fn0000000000411900(struct Eq_n * fs)
{
	word64 rax_n = fs->qw0028;
	Eq_n rax_n = nl_langinfo(0x0E);
	Eq_n r14_n;
	r14_n.u0 = g_t61B358.u0;
	Eq_n rbx_n = rax_n;
	if (rax_n == 0x00)
		rbx_n.u0 = 0x00416919;
	if (r14_n != 0x00)
	{
l000000000041196A:
		Eq_n rbx_n;
		while (true)
		{
			rbx_n = rbx_n;
			byte bpl_n = r14_n.u2->b0000;
			if (bpl_n == 0x00)
				break;
			if (strcmp(rbx_n, r14_n) == 0x00 || bpl_n == 0x2A && (r14_n.u2)->b0001 == 0x00)
			{
				rbx_n = r14_n + 1 + strlen(r14_n);
				break;
			}
			char * rbp_n = r14_n + 1 + strlen(r14_n);
			r14_n = rbp_n + 1 + strlen(rbp_n);
		}
		*rbx_n.u1 != 0x00;
		ui64 rcx_n = rax_n ^ fs->qw0028;
		if (rcx_n == 0x00)
			return (word32) rcx_n;
		__stack_chk_fail();
	}
	Eq_n rax_n = getenv(0x00417002);
	Eq_n r15_n = rax_n;
	Eq_n r12_n;
	Eq_n rax_n;
	if (rax_n != 0x00 && *rax_n != 0x00)
	{
		Eq_n rax_n = strlen(rax_n);
		r12_n = rax_n;
		if (rax_n == 0x00)
			goto l0000000000411C42;
		rax_n = rax_n - 1;
	}
	else
	{
		rax_n.u0 = 0x07;
		r12_n.u0 = 0x08;
		r15_n.u0 = 4288499;
	}
	uint64 r13_n = 0x01;
	word32 dwLocD0_n = 0x01;
	if (Mem27[r15_n + rax_n:byte] != 0x2F)
	{
l0000000000411A19:
		uint64 r13_n = (uint64) (r12_n.u4 + r13_n);
		char * rax_n = malloc(r13_n + 0x0E);
		if (rax_n != null)
		{
			memcpy(rax_n, r15_n, r12_n);
			if (dwLocD0_n != 0x00)
				*rax_n = 0x2F;
			Eq_n r13_n;
			r13_n.u1 = rax_n + r13_n;
			r13_n.u1->qw0000 = 3347411969557751907;
			r13_n.u1->dw0008 = 0x61696C61;
			r13_n.u1->w000C = 115;
			int32 eax_n = open(rax_n, 0x00020000);
			if (eax_n >= 0x00)
			{
				FILE * rax_n = fdopen(eax_n, 4274721);
				if (rax_n != null)
				{
					Eq_n qwLocD0_n;
					qwLocD0_n.u0 = 0x00;
l0000000000411AB0:
					byte * rax_n = rax_n->ptr0008;
					uint64 rdi_n;
					while (rax_n >= rax_n->ptr0010)
					{
						int32 eax_n = __uflow(rax_n);
						rdi_n = (uint64) eax_n;
						if (eax_n == ~0x00)
							break;
l0000000000411AC9:
						Eq_n edi_n = (word32) rdi_n;
						if (edi_n == 0x20 || edi_n <= 0x0A)
							continue;
						if (edi_n == 0x23)
						{
							int32 eax_n;
							do
							{
								byte * rax_n = rax_n->ptr0008;
								if (rax_n < rax_n->ptr0010)
								{
									rax_n->ptr0008 = rax_n + 1;
									eax_n = (word32) *rax_n;
								}
								else
									eax_n = __uflow(rax_n);
							} while (eax_n != 0x0A && eax_n != ~0x00);
							if (eax_n != ~0x00)
								goto l0000000000411AB0;
							fn0000000000411D30(rax_n);
							if (qwLocD0_n == 0x00)
								goto l0000000000411C28;
							Mem457[r14_n + qwLocD0_n:byte] = 0x00;
							goto l0000000000411C2E;
						}
						ungetc(edi_n, rax_n);
						char bLocB8;
						char bLoc78;
						if (fscanf(rax_n, "%50s %50s", &bLocB8, &bLoc78) <= 0x01)
							break;
						Eq_n rdx_n = &bLocB8;
						uint32 eax_n;
						bui8 al_n;
						do
						{
							uint64 rcx_n = (uint64) rdx_n.u2->u1;
							uint64 rax_n = (uint64) ((word32) rcx_n - 0x01010101 & ~((word32) rcx_n) & 0x80808080);
							rdx_n.u1 = (word32) rdx_n + 4;
							eax_n = (word32) rax_n;
							al_n = (byte) rax_n;
						} while (eax_n == 0x00);
						Eq_n r10_n = &bLoc78;
						if ((eax_n & 0x8080) == 0x00)
							al_n = (byte) (eax_n >> 0x10);
						if ((eax_n & 0x8080) == 0x00)
							rdx_n.u1 = (word32) rdx_n + 2;
						int64 rdx_n = rdx_n - 0x03 - (word64) (al_n * 0x02 < 0x00) - &bLocB8;
						uint32 eax_n;
						bui8 al_n;
						do
						{
							uint64 rcx_n = (uint64) r10_n.u2->u1;
							uint64 rax_n = (uint64) ((word32) rcx_n - 0x01010101 & ~((word32) rcx_n) & 0x80808080);
							r10_n.u1 = (word32) r10_n + 4;
							eax_n = (word32) rax_n;
							al_n = (byte) rax_n;
						} while (eax_n == 0x00);
						if ((eax_n & 0x8080) == 0x00)
							al_n = (byte) (eax_n >> 0x10);
						if ((eax_n & 0x8080) == 0x00)
							r10_n.u1 = (word32) r10_n + 2;
						Eq_n r10_n = r10_n - 0x03 - (word64) (al_n * 0x02 < 0x00) - &bLoc78;
						int64 rax_n = (int64) (&r10_n.u2->b0000 + rdx_n);
						Eq_n r13_n;
						if (qwLocD0_n == 0x00)
						{
							qwLocD0_n = rax_n + 2;
							r13_n = malloc(rax_n + 3);
						}
						else
						{
							int64 rax_n = (int64) (&qwLocD0_n.u2->b0000 + rax_n);
							qwLocD0_n = rax_n + 2;
							r13_n = realloc(r14_n, rax_n + 3);
						}
						if (r13_n == 0x00)
						{
							free(r14_n);
							fn0000000000411D30(rax_n);
							r14_n.u1 = 0x00416919;
							goto l0000000000411C2E;
						}
						Eq_n r14_n = qwLocD0_n - r10_n;
						strcpy(~0x01 - rdx_n + r14_n + r13_n, &bLocB8);
						strcpy(r13_n - 1 + r14_n, &bLoc78);
						r14_n = r13_n;
						rax_n = rax_n->ptr0008;
					}
					rax_n->ptr0008 = rax_n + 1;
					rdi_n = (uint64) *rax_n;
					goto l0000000000411AC9;
				}
				close(eax_n);
			}
l0000000000411C28:
			r14_n.u1 = 0x00416919;
l0000000000411C2E:
			free(rax_n);
		}
		else
			r14_n.u1 = 0x00416919;
		g_t61B358.u0 = (int64) r14_n;
		goto l000000000041196A;
	}
l0000000000411C42:
	r13_n = 0x00;
	dwLocD0_n = 0x00;
	goto l0000000000411A19;
}

// 0000000000411D30: Register int32 fn0000000000411D30(Register (ptr64 Eq_n) rdi)
// Called from:
//      fn0000000000411880
//      fn0000000000411900
int32 fn0000000000411D30(FILE * rdi)
{
	if (fileno(rdi) < 0x00)
		return fclose(rdi);
	if (__freading(rdi) != 0x00)
	{
		Eq_n rax_n = lseek(fileno(rdi), 0x00, 1);
		if (rax_n == ~0x00)
			return fclose(rdi);
	}
	uint64 rax_n = (uint64) fn0000000000411DB0(rdi);
	if ((word32) rax_n == 0x00)
		return fclose(rdi);
	int32 * rax_n = __errno_location();
	int32 r12d_n = *rax_n;
	uint64 rax_n = SEQ(SLICE(rax_n, word32, 32), fclose(rdi));
	if (r12d_n != 0x00)
	{
		*rax_n = r12d_n;
		rax_n = 0xFFFFFFFF;
	}
	return (word32) rax_n;
}

// 0000000000411DB0: Register int32 fn0000000000411DB0(Register (ptr64 Eq_n) rdi)
// Called from:
//      fn0000000000411D30
int32 fn0000000000411DB0(FILE * rdi)
{
	if (rdi == null || (__freading(rdi) == 0x00 || (*rdi & 0x0100) == 0x00))
		return fflush(rdi);
	fn0000000000411DF0(0x01, 0x00, rdi);
	return fflush(rdi);
}

// 0000000000411DF0: void fn0000000000411DF0(Register int32 edx, Register Eq_n rsi, Register (ptr64 Eq_n) rdi)
// Called from:
//      fn0000000000411DB0
void fn0000000000411DF0(int32 edx, Eq_n rsi, FILE * rdi)
{
	word64 rdx;
	edx = (word32) rdx;
	if (rdi->ptr0010 == rdi->ptr0008 && (*((char *) (&rdi->ptr0010) + 24) == *((char *) (&rdi->ptr0010) + 16) && *((char *) (&rdi->ptr0010) + 56) == 0x00))
	{
		Eq_n rax_n = lseek(fileno(rdi), rsi, edx);
		if (rax_n != ~0x00)
		{
			*rdi = (FILE *) (*rdi & ~0x10);
			*((char *) &rdi->ptr0010 + 0x0080) = (FILE *) rax_n;
		}
	}
	else
		fseeko(rdi, rsi, (int32) rdx);
}

Eq_n g_t411E60 = ??/* Unexpected function type (fn void ()) */ ; // 0000000000411E60
Eq_n g_t411ED0 = ??/* Unexpected function type (fn void ()) */ ; // 0000000000411ED0
// 0000000000411EE0: void fn0000000000411EE0(Register Eq_n rdi)
// Called from:
//      fn00000000004028C0
void fn0000000000411EE0(Eq_n rdi)
{
	Eq_n rdx_n;
	if (&g_t61A3A8 != null)
		rdx_n.u0 = g_t61A3A8.u0;
	else
		rdx_n.u0 = 0x00;
	__cxa_atexit(rdi, 0x00, rdx_n);
}

