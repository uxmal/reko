// PP.c
// Generated by decompiling PP.EXE
// using Reko decompiler version 0.8.1.0.

#include "PP.h"

// 0800:0150: Register byte fn0800-0150(Register out ptr16 dxOut, Register out ptr16 bxOut, Register out (ptr16 Eq_n) esOut)
byte fn0800-0150(ptr16 & dxOut, ptr16 & bxOut, struct Eq_n & esOut)
{
	struct Eq_n * es_n = seg0800->ptr025A;
	ptr16 bx_n;
	ptr16 dx_n;
	byte ah_n = fn0800-01E6(10004, 10004, es_n, out dx_n, out bx_n);
	dxOut = dx_n;
	bxOut = bx_n;
	esOut = es_n;
	return ah_n;
}

// 0800:0163: void fn0800-0163()
void fn0800-0163()
{
}

// 0800:0164: void fn0800-0164(Stack Eq_n bArg02)
void fn0800-0164(Eq_n bArg02)
{
	msdos_terminate(bArg02);
}

// 0800:0176: void fn0800-0176(Register (ptr16 Eq_n) ds)
void fn0800-0176(struct Eq_n * ds)
{
	word32 es_bx_n = msdos_get_interrupt_vector(0x00);
	ds->w005B = (word16) es_bx_n;
	ds->ptr005D = SLICE(es_bx_n, selector, 16);
	word32 es_bx_n = msdos_get_interrupt_vector(0x04);
	ds->w005F = (word16) es_bx_n;
	ds->ptr0061 = SLICE(es_bx_n, selector, 16);
	word32 es_bx_n = msdos_get_interrupt_vector(0x05);
	ds->w0063 = (word16) es_bx_n;
	ds->ptr0065 = SLICE(es_bx_n, selector, 16);
	word32 es_bx_n = msdos_get_interrupt_vector(0x06);
	ds->w0067 = (word16) es_bx_n;
	ds->ptr0069 = SLICE(es_bx_n, selector, 16);
	msdos_set_interrupt_vector(0x00, (char *) cs + 0x016D);
}

// 0800:01B9: Register word16 fn0800-01B9(Register Eq_n ds, Register out ptr16 dxOut)
word16 fn0800-01B9(Eq_n ds, ptr16 & dxOut)
{
	msdos_set_interrupt_vector(0x00, *((word32) ds + 0x005B));
	msdos_set_interrupt_vector(0x04, *((word32) ds + 0x005F));
	msdos_set_interrupt_vector(0x05, *((word32) ds + 99));
	<anonymous> * ds_dx_n = *((word32) ds + 0x0067);
	msdos_set_interrupt_vector(0x06, ds_dx_n);
	dxOut = (word16) ds_dx_n;
	return 0x2506;
}

// 0800:01E6: Register byte fn0800-01E6(Register Eq_n si, Register Eq_n di, Register (ptr16 Eq_n) es, Register out Eq_n dxOut, Register out Eq_n bxOut)
byte fn0800-01E6(Eq_n si, Eq_n di, struct Eq_n * es, union Eq_n & dxOut, union Eq_n & bxOut)
{
	int8 Top_n = 0x00;
	while (true)
	{
		byte ah_n;
		if (si != 9980)
			ah_n = 0x00;
		else
			ah_n = ~0x00;
		Eq_n dx_n = di;
		Eq_n bx_n = si;
		while (bx_n != di)
		{
			if (es->*bx_n != ~0x00)
			{
				Eq_n CZ_n;
				if (si != 9980)
					CZ_n.u0 = SLICE(cond(ah_n - es->*((word32) bx_n + 0x01)), bool, 2);
				else
					CZ_n.u0 = SLICE(cond(es->*((word32) bx_n + 0x01) - ah_n), bool, 2);
				if (!CZ_n)
				{
					ah_n = es->*((word32) bx_n + 0x01);
					dx_n = bx_n;
				}
			}
			bx_n = (word32) bx_n + 0x06;
		}
		if (dx_n == di)
			break;
		es->*dx_n = ~0x00;
		if (es->*dx_n != 0x00)
		{
			(es->*((word32) dx_n + 0x02))();
			Mem80 = Mem31;
		}
		else
		{
			(seg0800->*(es->*((word32) dx_n + 0x02)))();
			Mem80 = Mem31;
		}
	}
	dxOut = dx_n;
	bxOut = bx_n;
	return ah_n;
}

// 0800:023D: void fn0800-023D(Register word16 cx, Register (memptr (ptr16 Eq_n) char) dx, Register (ptr16 Eq_n) ds)
void fn0800-023D(word16 cx, char Eq_n::* dx, struct Eq_n * ds)
{
	char * ds_dx_n = &(ds->*dx);
	word16 ax_n;
	msdos_write_file(0x02, cx, ds_dx_n, out ax_n);
}

// 0800:025E: void main(Register Eq_n ds)
void main(Eq_n ds)
{
	*((word32) ds + 0x00002A27) = 0x01;
	*((word32) ds + 11853) = 0x00;
	*((word32) ds + 0x00002A1F) = 0x00;
	*((word32) ds + 11855) = 0x00;
	*((word32) ds + 10781) = 0x00;
	*((word32) ds + 10775) = 0x00;
	*((word32) ds + 10779) = 0x00;
	*((word32) ds + 0x00002A11) = 0x00;
	*((word32) ds + 10767) = 0x00;
	*((word32) ds + 0x00002A0D) = 0x00;
	*((word32) ds + 0x00002A0B) = 0x3000;
	*((word32) ds + 11825) = 0x8000;
	*((word32) ds + 0x00002E2F) = 0x1000;
	*((word32) ds + 0x00002A21) = 0x01;
	((word32) ds + 10741)->u0 = 0x00;
	((word32) ds + 0x000029F3)->u0 = 0x00;
	((word32) ds + 10737)->u0 = 0x00;
	((word32) ds + 0x000029EF)->u0 = 0x00;
	((word32) ds + 10771)->u0 = 0x00;
	((word32) ds + 0x00002A23)->u0 = 0x01;
	Eq_n bx_n;
	Eq_n dx_n;
	Eq_n cx_n = fn0800-2C9A(ds, out dx_n, out bx_n);
	Eq_n di_n;
	fn0800_B2EF(cx_n, dx_n, bx_n, ds, 2024, ds, out si_n, out di_n);
	Eq_n ds_n = fn0800-0541(fn0800-0402(cx_n, dx_n, bx_n, ds), di_n, ds);
	Eq_n sp_n = <invalid>;
	(ss->*(sp_n - 0x02)).u0 = 0x01;
	(ss->*(sp_n - 0x04)).u0 = 0x01;
	fn0800-2DBF(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x00;
	union Eq_n Eq_n::* bp_n;
	Eq_n cx_n;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-9764(ds_n, out cx_n, out dx_n, out bp_n);
	ss->*(bp_n - 0x02) = dx_n;
	ss->*(bp_n - 0x04) = ax_n;
	Eq_n sp_n = <invalid>;
	Eq_n sp_n = (word32) sp_n + 0x04;
	Eq_n bx_n = *((word32) ds_n + 0x00002A25);
	if (bx_n <= 0x08)
	{
		switch (bx_n << 0x01)
		{
		case 0x00:
			ds_n = fn0800-0DE8(cx_n, dx_n, ds_n);
			break;
		case 0x01:
		case 0x02:
			ds_n = fn0800-112D(cx_n, dx_n, ds_n);
			break;
		case 0x03:
		case 0x04:
			ds_n = fn0800-12E2(cx_n, dx_n, ds_n);
			sp_n.u0 = <invalid>;
			break;
		case 0x05:
			ds_n = fn0800-18D9(cx_n, dx_n, ds_n);
			sp_n.u0 = <invalid>;
			break;
		case 0x06:
		case 0x07:
		case 0x08:
			ds_n = fn0800-19EE(cx_n, dx_n, ds_n);
			sp_n.u0 = <invalid>;
			break;
		}
	}
	word16 Eq_n::* sp_n = sp_n - 0x02;
	ss->*sp_n = 0x00;
	ss->*(sp_n - 0x02) = 0x00;
	union Eq_n Eq_n::* bp_n;
	word16 dx_n;
	word32 dx_ax_n = SEQ(dx_n, fn0800-9764(ds_n, out cx_n, out dx_n, out bp_n)) - SEQ(ss->*(bp_n - 0x02), ss->*(bp_n - 0x04));
	ss->*(bp_n - 0x02) = SLICE(dx_ax_n, word16, 16);
	ss->*(bp_n - 0x04) = (word16) dx_ax_n;
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10737);
	ss->*sp_n = *((word32) ds_n + 0x000029EF);
	(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10741);
	(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 0x000029F3);
	Eq_n ax_n = fn0800-0B79((ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02));
	(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
	(ss->*sp_n).u0 = 0x3C;
	(ss->*(sp_n - 0x02)).t0000 = ss->*(bp_n - 0x02);
	(ss->*(sp_n - 0x04)).t0000 = ss->*(bp_n - 0x04);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BCA(stackArg0, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = dx_n;
	ss->*(sp_n - 0x04) = ax_n;
	(ss->*(sp_n - 0x06)).u0 = 0x00;
	(ss->*(sp_n - 0x08)).u0 = 0x3C;
	(ss->*(sp_n - 0x0A)).u0 = 0x00;
	(ss->*(sp_n - 0x0C)).u0 = 0x0E10;
	ss->*(sp_n - 0x0E) = ss->*(bp_n - 0x02);
	ss->*(sp_n - 0x0010) = ss->*(bp_n - 0x04);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BCA(stackArg0, ss->*(sp_n - 0x0010), ss->*(sp_n - 0x0E), ss->*(sp_n - 0x0C), ss->*(sp_n - 0x0A), out dx_n);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = dx_n;
	ss->*(sp_n - 0x04) = ax_n;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BBB(stackArg0, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = dx_n;
	ss->*(sp_n - 0x04) = ax_n;
	(ss->*(sp_n - 0x06)).u0 = 0x00;
	(ss->*(sp_n - 0x08)).u0 = 0x0E10;
	(ss->*(sp_n - 0x0A)).u0 = 0x00;
	(ss->*(sp_n - 0x0C)).u0 = 0x5180;
	ss->*(sp_n - 0x0E) = ss->*(bp_n - 0x02);
	ss->*(sp_n - 0x0010) = ss->*(bp_n - 0x04);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BCA(stackArg0, ss->*(sp_n - 0x0010), ss->*(sp_n - 0x0E), ss->*(sp_n - 0x0C), ss->*(sp_n - 0x0A), out dx_n);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = dx_n;
	ss->*(sp_n - 0x04) = ax_n;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n cx_n;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BBB(stackArg0, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = dx_n;
	ss->*(sp_n - 0x04) = ax_n;
	ss->*(sp_n - 0x06) = (uint16) ((uint32) (uint16) ax_n % 100);
	uint32 dx_ax_n = (uint32) (uint16) ax_n;
	ss->*(sp_n - 0x08) = (uint16) (dx_ax_n /u 100);
	ss->*(sp_n - 0x0A) = *((word32) ds_n + 10737);
	ss->*(sp_n - 0x0C) = *((word32) ds_n + 0x000029EF);
	ss->*(sp_n - 0x0E) = *((word32) ds_n + 10741);
	ss->*(sp_n - 0x0010) = *((word32) ds_n + 0x000029F3);
	ss->*(sp_n - 0x0012) = ds_n;
	(ss->*(sp_n - 0x0014)).u0 = 1500;
	(ss->*(sp_n - 22)).u0 = 0x08;
	ss->*(sp_n - 0x0018) = *((word32) ds_n + 10771);
	ss->*(sp_n - 0x001A) = ds_n;
	(ss->*(sp_n - 0x001C)).u0 = 2027;
	fn0800_B2EF(cx_n, (uint16) (dx_ax_n % 100), 100, ds_n, ss->*(sp_n - 0x001C), ss->*(sp_n - 0x001A), out si_n, out di_n);
}

// 0800:0402: Register Eq_n fn0800-0402(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register Eq_n ds)
Eq_n fn0800-0402(Eq_n cx, Eq_n dx, Eq_n bx, Eq_n ds)
{
	if (*((word32) ds + 0x00002A27) == *((word32) ds + 9882))
		fn0800-0DCE(cx, dx, bx, ds, out si_n, out di_n);
	Eq_n es_bx_n = *((word32) ds + 9884);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
	struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (*((word32) ds + 0x00002A27) << 0x02);
	Eq_n stackArg4 = <invalid>;
	word16 cx_n;
	if (fn0800_BFC7(SEQ((es_n->*bx_n).w0002, (es_n->*bx_n).w0000), stackArg4, out cx_n) > 0x01)
	{
		Eq_n es_bx_n = *((word32) ds + 9884);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
		struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (*((word32) ds + 0x00002A27) << 0x02);
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds, 0x01, SEQ((es_n->*bx_n).w0002, (es_n->*bx_n).w0000), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds, out Top_n);
	}
	ui16 ax_n = *((word32) ds + 0x00002A27);
	byte cl_n;
	Eq_n bx_n;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-0C29(ds, 0x0829, ds, SLICE(DPB(ax_n << 0x02, *SEQ(ds, (word16) *((word32) ds + 9884))[ax_n], 0), byte, 0), out cl_n, out dx_n, out bx_n, out es_n);
	*((word32) ds + 0x00002A25) = ax_n;
	Eq_n cx_n = DPB(cx_n, cl_n, 0);
	if (ax_n >= 0x09)
	{
		Eq_n es_bx_n = *((word32) ds + 9884);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
		struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (*((word32) ds + 0x00002A27) << 0x02);
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds, 0x01, SEQ((es_n->*bx_n).w0002, (es_n->*bx_n).w0000), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds, out Top_n);
	}
	++*((word32) ds + 0x00002A27);
	if (*((word32) ds + 0x00002A25) > 0x02)
	{
		if (*((word32) ds + 0x00002A27) == *((word32) ds + 9882))
			fn0800-0DCE(cx_n, dx_n, bx_n, ds, out si_n, out di_n);
		ui16 ax_n = *((word32) ds + 0x00002A27);
		++*((word32) ds + 0x00002A27);
		Eq_n es_bx_n = *((word32) ds + 9884);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
		struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (ax_n << 0x02);
		Eq_n stackArg4 = <invalid>;
		fn0800_BF9E(SEQ(ds, 0x4348), stackArg4, SEQ((es_n->*bx_n).w0002, (es_n->*bx_n).w0000));
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-0C6C(ds, SEQ(ds, 0x4348), stackArg4);
		word16 di_n = 0x4348;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		byte Eq_n::* di_n = di_n - 0x01;
		word16 cx_n = ~cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x2E - ds->*di_n), bool, 2);
			--di_n;
			--cx_n;
			if (ds->*di_n != 0x2E)
				break;
		}
		if (!Z_n)
			di_n = ~0x00;
		Eq_n di_n = di_n + 0x01;
		word16 di_n = 0x4348;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		cx_n = ~cx_n;
		Eq_n di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x5C - ds->*di_n), bool, 2);
			di_n = (word32) di_n + 0x01;
			--cx_n;
			if (ds->*di_n != 0x5C)
				break;
		}
		if (!Z_n)
			di_n.u0 = 0x01;
		if (di_n <= di_n - 0x01)
		{
			word16 di_n = 0x4348;
			word16 si_n = 0x0833;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (ds->*di_n != 0x00)
					break;
			}
			byte Eq_n::* di_n = di_n - 0x01;
			cx_n.u0 = 0x05;
			for (; cx_n != 0x00; --cx_n)
			{
				ds->*di_n = ds->*si_n;
				++si_n;
				++di_n;
			}
		}
		*((word32) ds + 10777) = 0x01;
	}
	return cx_n;
}

// 0800:0541: Register Eq_n fn0800-0541(Register Eq_n ch, Register Eq_n di, Register Eq_n ds)
Eq_n fn0800-0541(Eq_n ch, Eq_n di, Eq_n ds)
{
	ui16 ax_n = *((word32) ds + 0x00002A27);
	if (ax_n == *((word32) ds + 9882))
		return ds;
	if (*SEQ(ds, (word16) *((word32) ds + 9884))[ax_n] != 0x2D && *SEQ(ds, (word16) (*((word32) ds + 9884)))[*((word32) ds + 0x00002A27)] != 0x2F)
		return ds;
	while (*SEQ(ds, (word16) *((word32) ds + 9884))[*((word32) ds + 0x00002A27)] == 0x2D || *SEQ(ds, (word16) (*((word32) ds + 9884)))[*((word32) ds + 0x00002A27)] == 0x2F)
	{
		ui16 ax_n = *((word32) ds + 0x00002A27);
		byte cl_n;
		struct Eq_n * es_n;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-0C29(ds, 0x0838, ds, SLICE(DPB(ax_n << 0x02, SEQ(ds, (word16) *((word32) ds + 9884))[ax_n]->b0001, 0), byte, 0), out cl_n, out dx_n, out bx_n, out es_n);
		cx = DPB(cx, cl_n, 0);
		Eq_n si_n = ax_n;
		if (ax_n >= 11)
		{
			Eq_n es_bx_n = *((word32) ds + 9884);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
			struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (*((word32) ds + 0x00002A27) << 0x02);
			Eq_n stackArg6 = <invalid>;
			fn0800-0D24(ds, 0x02, SEQ((es_n->*bx_n).w0002, (es_n->*bx_n).w0000), stackArg6, out cx, out dx_n, out bx_n, out si_n, out di, out es_n, out ds, out Top_n);
		}
		if (si_n < 0x06)
		{
			byte * ptrLoc06_n;
			Eq_n es_bx_n = *((word32) ds + 9884);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
			Eq_n bx_n = (word16) es_bx_n + (*((word32) ds + 0x00002A27) << 0x02);
			Eq_n stackArg4 = <invalid>;
			if (fn0800_BFC7(SEQ(es_n->*((word32) bx_n + 0x02), es_n->*bx_n), stackArg4, out cx) == 0x02)
			{
				++*((word32) ds + 0x00002A27);
				if (*((word32) ds + 0x00002A27) == *((word32) ds + 9882))
					cx = fn0800-0DCE(cx, dx_n, bx_n, ds, out si_n, out di);
				Eq_n es_bx_n = *((word32) ds + 9884);
				struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
				struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (*((word32) ds + 0x00002A27) << 0x02);
				dx_n = (es_n->*bx_n).t0000;
				ptrLoc06_n = SEQ((es_n->*bx_n).w0002, dx_n);
			}
			else
			{
				Eq_n es_bx_n = *((word32) ds + 9884);
				struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
				struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (*((word32) ds + 0x00002A27) << 0x02);
				word16 dx_n = (es_n->*bx_n).w0000;
				dx_n = dx_n + 0x02;
				ptrLoc06_n = SEQ((es_n->*bx_n).w0002, dx_n + 0x02);
			}
			wLoc04 = SLICE(ptrLoc06_n, word16, 16);
			wLoc04 = SLICE(ptrLoc06_n, word16, 16);
			wLoc06 = SLICE(ptrLoc06_n, word16, 0);
			wLoc06 = SLICE(ptrLoc06_n, word16, 0);
			es_n = SLICE(ptrLoc06_n, selector, 16);
			if ((int16) *ptrLoc06_n == 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg6 = <invalid>;
				fn0800-0D24(ds, 0x02, SEQ(ds, 1500), stackArg6, out cx, out dx_n, out bx_n, out si_n, out di, out es_n, out ds, out Top_n);
			}
		}
		if (si_n <= 0x0A)
		{
			uint16 bx_n = si_n << 0x01;
			segptr32 ptrLoc06_n = &(wLoc04->*wLoc06);
			word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
			word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
			wLoc04 = SLICE(ptrLoc06_n, word16, 16);
			wLoc06 = SLICE(ptrLoc06_n, word16, 0);
			switch (bx_n)
			{
			case 0x00:
				if (*((word32) ds + 10777) == 0x00)
				{
					struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
					byte Eq_n::* di_n = (word16) ptrLoc06_n;
					Eq_n ax_n = 0x00;
					word16 cx_n = ~0x00;
					do
					{
						ax_n = DPB(ax_n, 0x00, 0);
						ax_n = DPB(ax_n, 0x00, 0);
						if (cx_n == 0x00)
							break;
						di_n = di_n + 0x01;
						--cx_n;
						di_n = di_n;
					} while (es_n->*di_n == 0x00);
					cup16 cx_n = ~cx_n;
					word16 cx_n = cx_n - 0x01;
					byte * ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n);
					if (cx_n > 0x02)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg6 = <invalid>;
						ax_n = fn0800-0D24(ds, 0x03, SEQ(wLoc04_n, wLoc06_n), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds, out Top_n);
						ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n);
					}
					byte cl_n;
					Eq_n dx_n;
					Eq_n ax_n = fn0800-0C29(ds, 0x0844, ds, SLICE(DPB(ax_n, *ptrLoc06_n, 0), byte, 0), out cl_n, out dx_n, out bx_n, out es_n);
					*((word32) ds + 0x00002A23) = ax_n;
					wLoc04 = SLICE(ptrLoc06_n, word16, 16);
					wLoc06 = SLICE(ptrLoc06_n, word16, 0);
					wLoc04 = SLICE(ptrLoc06_n, word16, 16);
					wLoc06 = SLICE(ptrLoc06_n, word16, 0);
					cx = DPB(cx_n, cl_n, 0);
					if (ax_n >= 0x06)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg6 = <invalid>;
						fn0800-0D24(ds, 0x03, &(wLoc04->*wLoc06), stackArg6, out cx, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds, out Top_n);
					}
					fn0800_BEA2(cx, dx_n, ds, SEQ(ds, 17009), 2123, ds, out di);
				}
				break;
			case 0x01:
				cx = (word16) fn0800_BF18(cx, dx_n, bx_n, si_n, di, es_n, ds, 2127, ds, out di);
				if (*((word32) ds + 11855) == 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg6 = <invalid>;
					fn0800-0D24(ds, 0x04, &(wLoc04->*wLoc06), stackArg6, out cx, out dx_n, out bx_n, out si_n, out di, out es_n, out ds, out Top_n);
				}
				*((word32) ds + 0x00002A1F) = 0x00;
				break;
			case 0x02:
				cx = (word16) fn0800_BF18(cx, dx_n, bx_n, si_n, di, es_n, ds, 0x0856, ds, out di);
				if (*((word32) ds + 0x00002A21) > 0x02 || *((word32) ds + 0x00002A21) == 0x00 && *((word32) ds + 0x00002A25) == 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg6 = <invalid>;
					fn0800-0D24(ds, 0x05, &(wLoc04->*wLoc06), stackArg6, out cx, out dx_n, out bx_n, out si_n, out di, out es_n, out ds, out Top_n);
				}
				break;
			case 0x03:
				byte Eq_n::* di_n = wLoc06;
				word16 cx_n = ~0x00;
				while (cx_n != 0x00)
				{
					++di_n;
					--cx_n;
					if (wLoc04->*di_n != 0x00)
						break;
				}
				cu16 cx_n = ~cx_n;
				uint16 cx_n;
				struct Eq_n Eq_n::* si_n = di_n - cx_n;
				word16 di_n = 17022;
				for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
				{
					(ds->*di_n).t0000 = (wLoc04->*si_n).t0000;
					si_n += 0x02;
					di_n += 0x02;
				}
				ui16 cx_n;
				for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
				{
					(ds->*di_n).t0000 = (wLoc04->*si_n).t0000;
					++si_n;
					++di_n;
				}
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				fn0800-0C6C(ds, SEQ(ds, 17022), stackArg4);
				di.u0 = 17022;
				word16 cx_n = ~0x00;
				while (cx_n != 0x00)
				{
					di = (byte) di.u0 + 0x01;
					--cx_n;
					if (ds->*di != 0x00)
						break;
				}
				struct Eq_n Eq_n::* cx_n = ~cx_n;
				cx = cx_n - 0x02;
				if ((ds->*cx_n).b427C != 0x5C)
				{
					word16 di_n = 17022;
					word16 si_n = 0x0859;
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						++di_n;
						--cx_n;
						if (ds->*di_n != 0x00)
							break;
					}
					di = di_n - 0x01;
					cx.u0 = 0x02;
					for (; cx != 0x00; --cx)
					{
						ds->*di = ds->*si_n;
						++si_n;
						di = (word32) di + 0x01;
					}
				}
				break;
			case 0x04:
				byte Eq_n::* di_n = wLoc06;
				word16 cx_n = ~0x00;
				while (cx_n != 0x00)
				{
					++di_n;
					--cx_n;
					if (wLoc04->*di_n != 0x00)
						break;
				}
				cu16 cx_n = ~cx_n;
				uint16 cx_n;
				struct Eq_n Eq_n::* si_n = di_n - cx_n;
				word16 di_n = 17123;
				for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
				{
					(ds->*di_n).t0000 = (wLoc04->*si_n).t0000;
					si_n += 0x02;
					di_n += 0x02;
				}
				ui16 cx_n;
				for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
				{
					(ds->*di_n).t0000 = (wLoc04->*si_n).t0000;
					++si_n;
					++di_n;
				}
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				fn0800-0C6C(ds, SEQ(ds, 17123), stackArg4);
				di.u0 = 17123;
				word16 cx_n = ~0x00;
				while (cx_n != 0x00)
				{
					di = (byte) di.u0 + 0x01;
					--cx_n;
					if (ds->*di != 0x00)
						break;
				}
				struct Eq_n Eq_n::* cx_n = ~cx_n;
				cx = cx_n - 0x02;
				if ((ds->*cx_n).b42E1 != 0x5C)
				{
					word16 di_n = 17123;
					word16 si_n = 0x0859;
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						++di_n;
						--cx_n;
						if (ds->*di_n != 0x00)
							break;
					}
					di = di_n - 0x01;
					cx.u0 = 0x02;
					for (; cx != 0x00; --cx)
					{
						ds->*di = ds->*si_n;
						++si_n;
						di = (word32) di + 0x01;
					}
				}
				break;
			case 0x05:
				cx = (word16) fn0800_BF18(cx, dx_n, bx_n, si_n, di, es_n, ds, 2131, ds, out di);
				break;
			case 0x06:
				*((word32) ds + 0x00002A1F) = 0x01;
				*((word32) ds + 11855) = 0x00;
				break;
			case 0x07:
				*((word32) ds + 10779) = 0x01;
				break;
			case 0x08:
				*((word32) ds + 10781) = 0x01;
				break;
			case 0x09:
				*((word32) ds + 10775) = 0x01;
				break;
			case 0x0A:
				*((word32) ds + 10773) = 0x01;
				break;
			}
		}
		++*((word32) ds + 0x00002A27);
	}
	ci16 ax_n = *((word32) ds + 0x00002A21);
	if (ax_n != 0x01)
	{
		if (ax_n == 0x02)
		{
			word16 di_n = 17009;
			word16 si_n = 2141;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (ds->*di_n != 0x00)
					break;
			}
			byte Eq_n::* di_n = di_n - 0x01;
			word16 cx_n;
			for (cx_n = 0x02; cx_n != 0x00; --cx_n)
			{
				ds->*di_n = ds->*si_n;
				++si_n;
				++di_n;
			}
			if (*((word32) ds + 11825) > 0x1000)
				*((word32) ds + 11825) = 0x1000;
			*((word32) ds + 0x00002E2F) = 0xFF;
		}
	}
	else
	{
		word16 di_n = 17009;
		word16 si_n = 0x085B;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		byte Eq_n::* di_n = di_n - 0x01;
		word16 cx_n;
		for (cx_n = 0x02; cx_n != 0x00; --cx_n)
		{
			ds->*di_n = ds->*si_n;
			++si_n;
			++di_n;
		}
		if (*((word32) ds + 11825) > 0x8000)
			*((word32) ds + 11825) = 0x8000;
		*((word32) ds + 0x00002E2F) = 0x1000;
	}
	if (*((word32) ds + 0x00002A23) == 0x02)
	{
		*((word32) ds + 10781) = 0x00;
		*((word32) ds + 11855) = 0x00;
	}
	if (*((word32) ds + 11855) != 0x00)
	{
		word16 di_n = 17009;
		word16 si_n = 1619;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		byte Eq_n::* di_n = di_n - 0x01;
		word16 cx_n;
		for (cx_n = 0x02; cx_n != 0x00; --cx_n)
		{
			ds->*di_n = ds->*si_n;
			++si_n;
			++di_n;
		}
	}
	if (*((word32) ds + 10781) != 0x00)
	{
		word16 di_n = 17009;
		word16 si_n = 0x085F;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		byte Eq_n::* di_n = di_n - 0x01;
		word16 cx_n;
		for (cx_n = 0x02; cx_n != 0x00; --cx_n)
		{
			ds->*di_n = ds->*si_n;
			++si_n;
			++di_n;
		}
	}
	word16 di_n = 17009;
	word16 si_n = 0x0861;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ds->*di_n != 0x00)
			break;
	}
	byte Eq_n::* di_n = di_n - 0x01;
	word16 cx_n;
	for (cx_n = 0x05; cx_n != 0x00; --cx_n)
	{
		ds->*di_n = ds->*si_n;
		++si_n;
		++di_n;
	}
	if (*((word32) ds + 0x00002A25) == 0x00 && Mem278[SEQ(ds, 0x0545)[Mem278[ds:0x2A23:word16] * 0x04] + 0x00:byte] != 0x00)
		fn0800-09A3(out ds);
	return ds;
}

// 0800:09A3: Register Eq_n fn0800-09A3(Register out (ptr16 Eq_n) dsOut)
Eq_n fn0800-09A3(struct Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg2 = <invalid>;
	Eq_n stackArg4 = <invalid>;
	union Eq_n Eq_n::* bp_n;
	Eq_n ds_n;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	ss->*(bp_n - 0x02) = dx_n;
	ss->*(bp_n - 0x04) = ax_n;
	ss->*(bp_n - 0x06) = dx_n;
	ss->*(bp_n - 0x08) = ax_n;
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x02);
	ss->*sp_n = ax_n;
	(ss->*(sp_n - 0x02)).t0000 = ds_n;
	(ss->*(sp_n - 0x04)).t0000.u0 = 0x0A6E;
	Eq_n ds_n;
	struct Eq_n Eq_n::* bp_n = fn0800-867A((ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out ds_n);
	Eq_n sp_n = <invalid>;
	while (true)
	{
		word16 dx_n;
		byte Eq_n::* si_n = (ss->*bp_n).ptr0004;
		ss->*((word32) sp_n + 0x06) = ds_n;
		Eq_n es_di_n = (ss->*(bp_n - 0x08)).t0000;
		struct Eq_n * ds_n = (ss->*bp_n).ptr0006;
		struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
		byte Eq_n::* di_n = (word16) es_di_n;
		word16 ax_n = 0x00;
		word16 cx_n = ~0x00;
		do
		{
			ax_n = DPB(ax_n, 0x00, 0);
			ax_n = DPB(ax_n, 0x00, 0);
			if (cx_n == 0x00)
				break;
			++di_n;
			--cx_n;
		} while (es_n->*di_n == 0x00);
		word16 cx_n = ~cx_n;
		Eq_n di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		di_n = di_n;
		do
		{
			Eq_n di_n;
			if (cx_n == 0x00)
				break;
			Z_n = SLICE(cond(ds_n->*si_n - es_n->*di_n), bool, 2);
			si_n = si_n + 0x01;
			di_n = (word16) di_n + 0x01;
			--cx_n;
			si_n = si_n;
			di_n = di_n;
		} while (ds_n->*si_n != es_n->*di_n);
		if (!Z_n)
		{
			cup16 ax_n = 0x00 - (di_n < 0x00);
			ax_n = ax_n - ~0x00 - (ax_n < 0x00);
		}
		ds_n = ss->*((word32) sp_n + 0x06);
		if (ax_n == 0x00)
			break;
		Eq_n es_di_n = (ss->*(bp_n - 0x08)).t0000;
		struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
		byte Eq_n::* di_n = (word16) es_di_n;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = di_n + 0x01;
			--cx_n;
			di_n = di_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		Eq_n di_n = (ss->*(bp_n - 0x08)).t0000;
		ss->*((word32) sp_n + 0x06) = (int16) ((word32) (ss->*(bp_n - 0x08)).t0000 + (~cx_n - 0x01) + 0x01) << 0x08;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = (word16) di_n + 0x01;
			--cx_n;
			di_n = di_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		struct Eq_n Eq_n::* ax_n = (word32) (ss->*(bp_n - 0x08)).t0000 + (~cx_n - 0x01);
		word16 dx_n = Mem217[ss:sp_n + 0x06:word16] + DPB(DPB(ax_n, Mem217[es_n:ax_n + 0x02:byte], 0), 0x00, 8);
		Eq_n di_n = (ss->*(bp_n - 0x08)).t0000;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = (word16) di_n + 0x01;
			--cx_n;
			di_n = di_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 dx_n = dx_n + (~cx_n - 0x01);
		(ss->*(bp_n - 0x08)).t0000 = (word32) (ss->*(bp_n - 0x08)).t0000 + (dx_n + 0x03);
		dx_n = dx_n + 0x03;
	}
	Eq_n es_di_n = (ss->*(bp_n - 0x08)).t0000;
	struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
	byte Eq_n::* di_n = (word16) es_di_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	(ss->*(bp_n - 0x08)).t0000 = (word32) (ss->*(bp_n - 0x08)).t0000 + ~cx_n;
	Eq_n es_bx_n = (ss->*(bp_n - 0x08)).t0000;
	ss->*((word32) sp_n + 0x06) = ((int16) *es_bx_n << 0x08) + DPB(DPB(dx_n, *((word32) es_bx_n + 0x01), 0), 0x00, 8) + 0x02;
	ss->*((word32) sp_n + 0x04) = (ss->*(bp_n - 0x06)).t0000;
	ss->*((word32) sp_n + 0x02) = (word16) es_bx_n;
	ss->*sp_n = (ss->*bp_n).t000A;
	(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0008;
	fn0800_B0F3((ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06));
	ss->*((word32) sp_n + 0x06) = (ss->*(bp_n - 0x02)).t0000;
	ss->*((word32) sp_n + 0x04) = (ss->*(bp_n - 0x04)).t0000;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg2 = <invalid>;
	struct Eq_n * ds_n;
	fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n, out ds_n);
	Eq_n bp_n = (ss->*bp_n).t0000;
	dsOut = ds_n;
	return bp_n;
}

// 0800:0ABC: Register Eq_n fn0800-0ABC(Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Register out Eq_n dxOut, Register out ptr16 diOut)
Eq_n fn0800-0ABC(Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, union Eq_n & dxOut, ptr16 & diOut)
{
	fn0800-35A3(wArg02, di, fp - 0x10, ss, wArg04, wArg06);
	Eq_n ax_n = fn0800-0B79(*((word32) ds + 0x00002A07), *((word32) ds + 10761), *((word32) ds + 10755), *((word32) ds + 10757));
	Eq_n dx_n = (uint16) ((uint32) (uint16) ax_n % 100);
	cui16 si_n;
	fn0800_B2EF(ax_n, dx_n, 100, ds, 0x0866, ds, out si_n, out di_n);
	Eq_n bx_n = 100;
	if (*((word32) ds + 0x00002A25) == 0x02 || si_n != 0x00)
	{
		fn0800_B2EF(ax_n, dx_n, si_n << 0x02, ds, 0x0889, ds, out si_n, out di_n);
		bx_n = si_n << 0x02;
	}
	ptr16 di_n;
	fn0800_B2EF(ax_n, dx_n, bx_n, ds, 0x0827, ds, out si_n, out di_n);
	Eq_n ax_n = *((word32) ds + 10761);
	Eq_n dx_n = *((word32) ds + 0x00002A07);
	*((word32) ds + 0x000029F3) = v30_n;
	ui32 v31_v30_n = SEQ(*((word32) ds + 10741), *((word32) ds + 0x000029F3)) + SEQ(ax_n, dx_n);
	*((word32) ds + 10741) = SLICE(v31_v30_n, word16, 16);
	Eq_n ax_n = *((word32) ds + 10757);
	Eq_n dx_n = *((word32) ds + 10755);
	*((word32) ds + 0x000029EF) = v32_n;
	ui32 v33_v32_n = SEQ(*((word32) ds + 10737), *((word32) ds + 0x000029EF)) + SEQ(ax_n, dx_n);
	*((word32) ds + 10737) = SLICE(v33_v32_n, word16, 16);
	++*((word32) ds + 10771);
	dxOut = dx_n;
	diOut = di_n;
	uint16 v30_n = (word16) v31_v30_n;
	uint16 v32_n = (word16) v33_v32_n;
	return ax_n;
}

// 0800:0B79: Register Eq_n fn0800-0B79(Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n dwArg06, Stack Eq_n wArg08)
Eq_n fn0800-0B79(Eq_n wArg02, Eq_n wArg04, Eq_n dwArg06, Eq_n wArg08)
{
	mp16 sp_n = fp - 0x02;
	if ((wArg02 | wArg04) == 0x00 || ((wArg06 | wArg08) == 0x00 || wArg04 <= wArg08 && (wArg04 != wArg08 || wArg02 <= wArg06)))
		return 0x00;
	while (true)
	{
		ui32 dwArg06_n = SEQ(wArg08, wArg06);
		ui32 ax_dx_n = SEQ(wArg04, wArg02) - dwArg06_n;
		Eq_n wArg08_n = SLICE(dwArg06_n, word16, 16);
		wArg08_n = SLICE(dwArg06_n, word16, 16);
		Eq_n wArg06_n = SLICE(dwArg06_n, word16, 0);
		wArg06_n = SLICE(dwArg06_n, word16, 0);
		cup16 dx_n = (word16) ax_dx_n;
		cup16 ax_n = SLICE(ax_dx_n, word16, 16);
		if (ax_n <= 0x06 && (ax_n != 0x06 || dx_n <= 0x8DB8))
			break;
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).u0 = 0x00;
		(ss->*(sp_n - 0x02)).u0 = 0x0A;
		ss->*(sp_n - 0x04) = wArg04;
		ss->*(sp_n - 0x06) = wArg02;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n sp_n = <invalid>;
		Eq_n dx_n;
		wArg02 = fn0800-8BC2(stackArg0, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x0A;
		ss->*((word32) sp_n + 0x02) = wArg08_n;
		ss->*sp_n = wArg06_n;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n sp_n = <invalid>;
		Eq_n stackArg0 = <invalid>;
		wArg04 = dx_n;
		sp_n = (mp16) ((word32) sp_n + 0x08);
		wArg08 = dx_n;
		Eq_n dx_n;
		wArg06 = fn0800-8BC2(stackArg0, ss->*sp_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
	}
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	ss->*sp_n = wArg04;
	ss->*(sp_n - 0x02) = wArg02;
	uint32 cx_bx_n = SEQ(wArg04, wArg02) - SEQ(wArg08_n, wArg06_n);
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8F18(10000, SLICE(cx_bx_n, word16, 16), 0x00, (word16) cx_bx_n, out ch_n, out dx_n);
	ss->*(sp_n - 0x04) = dx_n;
	ss->*(sp_n - 0x06) = ax_n;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	return fn0800-8BC2(stackArg0, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out cx_n, out dx_n, out bx_n);
}

// 0800:0C08: Register word16 fn0800-0C08(Stack Eq_n wArg02)
word16 fn0800-0C08(Eq_n wArg02)
{
	Eq_n si_n = wArg02;
	word16 cx_n = 0x01;
	while (true)
	{
		Eq_n ax_n = (uint16) ((uint32) (uint16) si_n /u 0x02);
		si_n = ax_n;
		if (ax_n == 0x00)
			break;
		++cx_n;
	}
	return cx_n;
}

// 0800:0C29: Register cup16 fn0800-0C29(Register Eq_n ds, Stack word16 wArg02, Stack Eq_n wArg04, Stack byte bArg06, Register out Eq_n clOut, Register out ptr16 dxOut, Register out ptr16 bxOut, Register out (ptr16 Eq_n) esOut)
cup16 fn0800-0C29(Eq_n ds, word16 wArg02, Eq_n wArg04, byte bArg06, union Eq_n & clOut, ptr16 & dxOut, ptr16 & bxOut, struct Eq_n & esOut)
{
	Eq_n al_n = (byte) (word16) fn0800-97CC(ds, (int16) bArg06);
	union Eq_n * ptrLoc06_n = SEQ(wArg04, wArg02);
	while (true)
	{
		wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
		ptr16 bx_n = (word16) ptrLoc06_n;
		if (*ptrLoc06_n == 0x00 || *ptrLoc06_n == al_n)
			break;
		ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
		Mem34 = Mem44;
	}
	clOut = al_n;
	cup16 ax_n = wLoc06_n - wArg02;
	dxOut = 0x00 - (ax_n < 0x00);
	bxOut = bx_n;
	esOut = es_n;
	return ax_n;
}

// 0800:0C6C: void fn0800-0C6C(Register Eq_n ds, Stack (ptr32 byte) ptrArg02, Stack Eq_n wArg04)
void fn0800-0C6C(Eq_n ds, byte * ptrArg02, Eq_n wArg04)
{
	while (true)
	{
		word16 wArg02_n = SLICE(ptrArg02, word16, 0);
		word16 wArg04_n = SLICE(ptrArg02, word16, 16);
		if (*ptrArg02 == 0x00)
			break;
		*ptrArg02 = (byte) (word16) fn0800-97CC(ds, (int16) *ptrArg02);
		ptrArg02 = SEQ(wArg04_n, wArg02_n + 0x01);
		Mem11 = Mem41;
	}
}

// 0800:0C93: Register word16 fn0800-0C93(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n dxOut)
word16 fn0800-0C93(Eq_n si, Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, union Eq_n & dxOut)
{
	Eq_n bx_n;
	Eq_n dx_n = fn0800-3509(si, di, fp - 0x68, ss, wArg02, wArg04, out bx_n);
	word16 si_n = 10004;
	byte Eq_n::* di_n = fp - 0x68;
	word16 ax_n = 0x00;
	word16 cx_n = ~0x00;
	do
	{
		ax_n = DPB(ax_n, 0x00, 0);
		ax_n = DPB(ax_n, 0x00, 0);
		if (cx_n == 0x00)
			break;
		++di_n;
		--cx_n;
	} while (ss->*di_n == 0x00);
	Eq_n cx_n = ~cx_n;
	Eq_n di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	di_n = di_n;
	do
	{
		Eq_n di_n;
		if (cx_n == 0x00)
			break;
		Z_n = SLICE(cond(ds->*si_n - ss->*di_n), bool, 2);
		si_n = si_n + 0x01;
		di_n = (word16) di_n + 0x01;
		--cx_n;
		si_n = si_n;
		di_n = di_n;
	} while (ds->*si_n != ss->*di_n);
	if (!Z_n)
	{
		cup16 ax_n = 0x00 - (di_n < 0x00);
		ax_n = ax_n - ~0x00 - (ax_n < 0x00);
	}
	if (ax_n != 0x00)
	{
		fn0800_B2EF(cx_n, dx_n, bx_n, ds, 0x088F, ds, out si_n, out di_n);
		byte Eq_n::* di_n = fp - 0x68;
		dx_n = ds;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ss->*di_n != 0x00)
				break;
		}
		uint16 cx_n = ~cx_n;
		uint16 cx_n;
		struct Eq_n Eq_n::* si_n = di_n - cx_n;
		word16 di_n = 10004;
		for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
		{
			(ds->*di_n).t0000 = (ss->*si_n).t0000;
			si_n += 0x02;
			di_n += 0x02;
		}
		for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
		{
			(ds->*di_n).t0000 = (ss->*si_n).t0000;
			++si_n;
			++di_n;
		}
	}
	word16 ax_n = fn0800_B2EF(cx_n, dx_n, bx_n, ds, 2206, ds, out si_n, out di_n);
	dxOut = dx_n;
	return ax_n;
}

// 0800:0D24: Register word16 fn0800-0D24(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n ptrArg04, Stack Eq_n wArg06, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut, Register out Eq_n siOut, Register out Eq_n diOut, Register out (ptr16 Eq_n) esOut, Register out Eq_n dsOut, Register out Eq_n TopOut)
word16 fn0800-0D24(Eq_n ds, Eq_n wArg02, Eq_n ptrArg04, Eq_n wArg06, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut, union Eq_n & siOut, union Eq_n & diOut, struct Eq_n & esOut, union Eq_n & dsOut, union Eq_n & TopOut)
{
	Eq_n ds_n;
	fn0800-0DA9(ds, *((word32) ds + 10715), *((word32) ds + 0x000029DD), out dx_n, out ds_n);
	Eq_n ds_n;
	fn0800-0DA9(ds_n, *((word32) ds_n + 10711), *((word32) ds_n + 0x000029D9), out dx_n, out ds_n);
	Eq_n ds_n;
	Eq_n dx_n;
	Eq_n cx_n = fn0800-0DA9(ds_n, *((word32) ds_n + 10707), *((word32) ds_n + 10709), out dx_n, out ds_n);
	fn0800_B2EF(cx_n, dx_n, wArg02 << 0x02, ds_n, 2210, ds_n, out si_n, out di_n);
	Eq_n bx_n = (word16) ptrArg04;
	if (*ptrArg04 != 0x00)
		fn0800_B2EF(cx_n, dx_n, bx_n, ds_n, 2214, ds_n, out si_n, out di_n);
	Eq_n di_n;
	word16 si_n;
	fn0800_B2EF(cx_n, dx_n, bx_n, ds_n, 0x0827, ds_n, out si_n, out di_n);
	ptr16 bx_n;
	ptr16 cx_n;
	ptr16 dx_n;
	struct Eq_n * es_n;
	Eq_n si_n;
	Eq_n Top_n;
	word16 ax_n = fn0800-8B5A(cx_n, dx_n, bx_n, si_n, ds_n, 0x01, out cx_n, out dx_n, out bx_n, out si_n, out es_n, out Top_n);
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	siOut = si_n;
	diOut = di_n;
	esOut = es_n;
	dsOut = ds_n;
	TopOut = Top_n;
	return ax_n;
}

// 0800:0DA9: Register word16 fn0800-0DA9(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out ptr16 dxOut, Register out Eq_n dsOut)
word16 fn0800-0DA9(Eq_n ds, Eq_n wArg02, Eq_n wArg04, ptr16 & dxOut, union Eq_n & dsOut)
{
	if ((wArg02 | wArg04) != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		struct Eq_n Eq_n::* bp_n;
		Eq_n ax_n = fn0800_A614(ds, SEQ(wArg04, wArg02), stackArg4, out cx, out dx_n, out bp_n, out si_n, out di_n, out ds);
		Eq_n sp_n = <invalid>;
		ss->*((word32) sp_n + 0x02) = (ss->*bp_n).w000A;
		ss->*sp_n = (ss->*bp_n).t0008;
		dx = fn0800-8F7F(ax_n, ds, ss->*sp_n);
	}
	dxOut = dx;
	dsOut = ds;
	return cx;
}

// 0800:0DCE: Register Eq_n fn0800-0DCE(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register Eq_n ds, Register out Eq_n siOut, Register out Eq_n diOut)
Eq_n fn0800-0DCE(Eq_n cx, Eq_n dx, Eq_n bx, Eq_n ds, union Eq_n & siOut, union Eq_n & diOut)
{
	Eq_n di_n;
	word16 si_n;
	fn0800_B2EF(cx, dx, bx, ds, 2024, ds, out si_n, out di_n);
	Eq_n cx_n;
	Eq_n si_n;
	fn0800-8B5A(cx, dx, bx, si_n, ds, 0x00, out cx_n, out dx_n, out bx_n, out si_n, out es_n, out Top_n);
	siOut = si_n;
	diOut = di_n;
	return cx_n;
}

// 0800:0DE8: Register Eq_n fn0800-0DE8(Register Eq_n cx, Register Eq_n dx, Register Eq_n ds)
Eq_n fn0800-0DE8(Eq_n cx, Eq_n dx, Eq_n ds)
{
	Eq_n bx_n = *((word32) ds + 0x00002A25);
	fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2220, ds, out si_n, out di_n);
	if (*((word32) ds + 11855) != 0x00)
		fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2234, ds, out si_n, out di_n);
	if (*((word32) ds + 0x00002A1F) != 0x00)
		fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2255, ds, out si_n, out di_n);
	fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2268, ds, out si_n, out di_n);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg6 = <invalid>;
	Eq_n stackArg8 = <invalid>;
	Eq_n ds_n;
	Eq_n dx_n;
	Eq_n di_n;
	Eq_n di_n;
	Eq_n cx_n;
	Eq_n dx_n;
	Eq_n ds_n;
	Eq_n si_n;
	Eq_n ax_n = fn0800-4234(fn0800-37BE(fn0800-3678(ds, 17022, ds, out dx_n, out si_n, out ds_n), dx_n, ds_n, 0x4477, ds_n, stackArg6, stackArg8, out di_n), di_n, ds_n, 0x4477, ds_n, 2284, ds_n, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	*((word32) ds_n + 0x000029DD) = dx_n;
	*((word32) ds_n + 10715) = ax_n;
	Eq_n sp_n = <invalid>;
	Eq_n sp_n = (word32) sp_n + 0x08;
	while (true)
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = ds_n;
		(ss->*(sp_n - 0x02)).u0 = 0x4541;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n sp_n = <invalid>;
		Eq_n di_n;
		Eq_n ds_n;
		Eq_n si_n;
		if (fn0800-2DE2(cx_n, dx_n, si_n, di_n, ds_n, ss->*(sp_n - 0x02), stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n) == 0x00)
			break;
		fn0800-3764(si_n, di_n, ds_n);
		sp_n.u0 = <invalid>;
		if (fn0800-388C(si_n, di_n, ds_n, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n) != 0x00)
		{
			Eq_n si_n;
			ss->*(sp_n - 0x02) = ds_n;
			(ss->*(sp_n - 0x04)).u0 = 0x4541;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-0C93(si_n, di_n, ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
			fn0800-4194(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
			*((word32) ds_n + 10761) = dx_n;
			*((word32) ds_n + 0x00002A07) = ax_n;
			*((word32) ds_n + 10757) = dx_n;
			*((word32) ds_n + 10755) = ax_n;
			Eq_n sp_n = sp_n;
			if (*((word32) ds_n + 10761) <= 0x00 && (*((word32) ds_n + 10761) != 0x00 || *((word32) ds_n + 0x00002A07) <= 0x12) && *((word32) ds_n + 10773) == 0x00)
				si_n.u0 = 0x03;
			else
			{
				word16 bp_n;
				Eq_n dx_n;
				Eq_n ax_n = fn0800-3992(0x00, di_n, ds_n, out dx_n, out bp_n, out si_n, out ds_n);
				sp_n.u0 = <invalid>;
				Eq_n ax_n = ax_n;
				if (ax_n != 0x00)
					si_n.u0 = 0x0E;
				else
				{
					Eq_n bx_n = *((word32) ds_n + 0x00002A23);
					if (bx_n <= 0x05)
					{
						switch (bx_n << 0x01)
						{
						case 0x00:
							ax_n = fn0800-6AD4(bp_n, si_n, ds_n, out dx_n, out ds_n);
							sp_n.u0 = <invalid>;
							si_n = ax_n;
							break;
						case 0x01:
							if (*((word32) ds_n + 10761) >= 0x00 && (*((word32) ds_n + 10761) != 0x00 || *((word32) ds_n + 0x00002A07) >= 0x12))
							{
								ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
								ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_n stackArg0 = <invalid>;
								ax_n = fn0800-8CAA(ax_n, 0x08, fn0800-3F58(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out di_n, out ds_n), stackArg0, out dx_n);
								sp_n.u0 = <invalid>;
								if (dx_n == 0x52 && ax_n == 0x4E43)
									si_n.u0 = 0x04;
							}
							if (si_n == 0x00)
							{
								union Eq_n Eq_n::* sp_n = sp_n - 0x02;
								ss->*sp_n = *((word32) ds_n + 10761);
								ss->*(sp_n - 0x02) = *((word32) ds_n + 0x00002A07);
								ss->*(sp_n - 0x04) = *((word32) ds_n + 10761);
								ss->*(sp_n - 0x06) = *((word32) ds_n + 0x00002A07);
								fn0800-75EA(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out bp_n, out si_n, out ds_n);
								Eq_n sp_n = <invalid>;
								sp_n = (word32) sp_n + 0x08;
								ax_n = *((word32) ds_n + 10757);
								dx_n = *((word32) ds_n + 10755);
								if (ax_n >= *((word32) ds_n + 10761) && (ax_n != *((word32) ds_n + 10761) || dx_n >= *((word32) ds_n + 0x00002A07)) && *((word32) ds_n + 10773) != 0x00)
								{
									ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 0x000029E5);
									ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 0x000029E3);
									fn0800_BA67(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06));
									ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
									ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
									fn0800_BA67(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06));
									ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
									ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
									(ss->*((word32) sp_n + 0x02)).u0 = 21070;
									(ss->*sp_n).u0 = 0x4300;
									Eq_n ds_n;
									fn0800-409C(ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out ds_n, out Top_n);
									ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
									ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
									ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10761);
									ss->*sp_n = *((word32) ds_n + 0x00002A07);
									struct Eq_n * ds_n;
									fn0800-409C(ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out ds_n, out Top_n);
									ss->*((word32) sp_n + 0x06) = ds_n->t2A09;
									ss->*((word32) sp_n + 0x04) = ds_n->t2A07;
									ss->*((word32) sp_n + 0x02) = ds_n->t29E1;
									ss->*sp_n = ds_n->t29DF;
									(ss->*(sp_n - 0x02)).t0000 = ds_n->t29E5;
									(ss->*(sp_n - 0x04)).t0000 = ds_n->t29E3;
									Eq_n sp_n = <invalid>;
									ax_n = fn0800-3B0A(ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out bp_n, out ds_n);
									sp_n = (word32) sp_n + 0x0C;
									si_n.u0 = 0x02;
								}
							}
							break;
						case 0x02:
							ax_n = fn0800-741D(ds_n, out dx_n);
							si_n = ax_n;
							break;
						case 0x03:
							ax_n = fn0800-73AC(ds_n, out dx_n, out ds_n);
							si_n = ax_n;
							break;
						case 0x04:
							ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
							ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
							Eq_n ds_n;
							if (fn0800-3F0A(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out ds_n) == 0x4D5A)
							{
								ax_n = fn0800-5E64(ds_n, out dx_n, out ds_n);
								sp_n.u0 = <invalid>;
								si_n = ax_n;
							}
							else
							{
								ax_n = fn0800-669C(ds_n, out dx_n, out ds_n);
								sp_n.u0 = <invalid>;
								si_n = ax_n;
							}
							break;
						case 0x05:
							ax_n = fn0800-67BF(ds_n, out dx_n, out ds_n);
							sp_n.u0 = <invalid>;
							si_n = ax_n;
							break;
						}
					}
					union Eq_n Eq_n::* sp_n = sp_n - 0x02;
					ss->*sp_n = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
					fn0800-4194(ds_n, ss->*(sp_n - 0x02), ss->*sp_n);
					*((word32) ds_n + 10757) = dx_n;
					*((word32) ds_n + 10755) = ax_n;
					sp_n = (char *) sp_n + 0x02;
					Eq_n ax_n = *((word32) ds_n + 10757);
					Eq_n dx_n = *((word32) ds_n + 10755);
					if (ax_n >= *((word32) ds_n + 10761) && (ax_n != *((word32) ds_n + 10761) || dx_n >= *((word32) ds_n + 0x00002A07)) && *((word32) ds_n + 10773) == 0x00)
					{
						Eq_n dx_n = *((word32) ds_n + 0x00002A07);
						*((word32) ds_n + 10757) = *((word32) ds_n + 10761);
						*((word32) ds_n + 10755) = dx_n;
						si_n.u0 = 0x03;
					}
					if (si_n == 0x04)
					{
						Eq_n dx_n = *((word32) ds_n + 0x00002A07);
						*((word32) ds_n + 10757) = *((word32) ds_n + 10761);
						*((word32) ds_n + 10755) = dx_n;
					}
				}
			}
			if (*((word32) ds_n + 17022) != 0x00 && (si_n == 0x03 || si_n == 0x04))
			{
				Eq_n dx_n = *((word32) ds_n + 0x00002A07);
				*((word32) ds_n + 10757) = *((word32) ds_n + 10761);
				*((word32) ds_n + 10755) = dx_n;
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
				fn0800_BA67(ds_n, ss->*(sp_n - 0x02), ss->*sp_n);
				ss->*sp_n = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
				fn0800_BA67(ds_n, ss->*(sp_n - 0x02), ss->*sp_n);
				ss->*sp_n = *((word32) ds_n + 10761);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x00002A07);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x06) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
				fn0800-3B0A(ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out bp_n, out ds_n);
				Eq_n sp_n = <invalid>;
				sp_n = (word32) sp_n + 0x0C;
			}
			Eq_n sp_n;
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n ds_n;
			fn0800_A614(ds_n, ss->*(sp_n - 0x02), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			Eq_n sp_n = <invalid>;
			ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
			ss->*sp_n = *((word32) ds_n + 10719);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n di_n;
			fn0800_A614(ds_n, ss->*sp_n, stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			Eq_n sp_n = <invalid>;
			if (si_n > 0x02)
			{
				ss->*((word32) sp_n + 0x02) = ds_n;
				(ss->*sp_n).u0 = 0x44DC;
				fn0800-8F7F(0x44DC, ds_n, ss->*sp_n);
				sp_n = (word32) sp_n + 0x04;
			}
			else
			{
				si_n = fn0800-37DF(si_n, di_n, ds_n, out di_n, out ds_n);
				sp_n.u0 = <invalid>;
			}
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).t0000 = ds_n;
			(ss->*(sp_n - 0x02)).t0000.u0 = 0x4541;
			(ss->*(sp_n - 0x04)).t0000 = si_n;
			cx_n = fn0800-0ABC(di_n, ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out dx_n, out di_n);
			sp_n = &sp_n->t0002;
		}
	}
	ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 0x000029DD);
	ss->*sp_n = *((word32) ds_n + 10715);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n ds_n;
	fn0800_A614(ds_n, ss->*sp_n, stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	fn0800-8F7F(0x4477, ds_n, SEQ(ds_n, 0x4477));
	return ds_n;
}

// 0800:112D: Register Eq_n fn0800-112D(Register Eq_n cx, Register Eq_n dx, Register Eq_n ds)
Eq_n fn0800-112D(Eq_n cx, Eq_n dx, Eq_n ds)
{
	Eq_n bx_n = *((word32) ds + 0x00002A25);
	fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2288, ds, out si_n, out di_n);
	if (*((word32) ds + 11855) != 0x00)
		fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2302, ds, out si_n, out di_n);
	Eq_n di_n;
	Eq_n si_n;
	fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2323, ds, out si_n, out di_n);
	Eq_n sp_n = fp - 0x02;
	if (*((word32) ds + 0x00002A25) == 0x01)
	{
		cx = fn0800-3678(ds, 17022, ds, out dx, out si_n, out ds);
		sp_n = fp - 0x02;
	}
	while (true)
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = ds;
		(ss->*(sp_n - 0x02)).u0 = 0x4541;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n di_n;
		Eq_n ds_n;
		Eq_n si_n;
		if (fn0800-2DE2(cx, dx, si_n, di_n, ds, ss->*(sp_n - 0x02), stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n) == 0x00)
			break;
		fn0800-3764(si_n, di_n, ds_n);
		sp_n.u0 = <invalid>;
		word16 bp_n;
		if (fn0800-388C(si_n, di_n, ds_n, out cx, out dx, out bp_n, out si_n, out di_n, out ds) != 0x00)
		{
			ss->*(sp_n - 0x02) = ds;
			(ss->*(sp_n - 0x04)).u0 = 0x4541;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-0C93(si_n, di_n, ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n);
			ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E5);
			ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E3);
			fn0800-4194(ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
			*((word32) ds + 10757) = dx_n;
			*((word32) ds + 10755) = ax_n;
			Eq_n sp_n = sp_n;
			Eq_n dx_n = dx_n;
			if (dx_n <= 0x00 && (Test(ULT,false) || ax_n < 0x12))
				si_n.u0 = 0x07;
			else
			{
				Eq_n bx_n = *((word32) ds + 0x00002A23);
				if (bx_n <= 0x05)
				{
					switch (bx_n << 0x01)
					{
					case 0x00:
						ax_n = fn0800-4C55(ax_n, bp_n, ds, out dx_n, out ds);
						sp_n.u0 = <invalid>;
						si_n = ax_n;
						break;
					case 0x01:
						ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E5);
						ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E3);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg0 = <invalid>;
						ax_n = fn0800-8CAA(ax_n, 0x08, fn0800-3F58(ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out di_n, out ds), stackArg0, out dx_n);
						sp_n.u0 = <invalid>;
						if (dx_n == 0x52 && ax_n == 0x4E43)
						{
							ax_n = fn0800-5374(ds, out dx_n, out bp_n, out ds);
							sp_n.u0 = <invalid>;
							si_n = ax_n;
						}
						else
							si_n.u0 = 0x07;
						break;
					case 0x02:
						ax_n = fn0800-51A9(ds, out dx_n, out ds);
						sp_n.u0 = <invalid>;
						si_n = ax_n;
						break;
					case 0x03:
						ax_n = fn0800-518F(ax_n, dx_n, ds, out dx_n, out ds);
						sp_n.u0 = <invalid>;
						si_n = ax_n;
						break;
					case 0x04:
						ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E5);
						ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E3);
						Eq_n ds_n;
						Eq_n dx_n;
						Eq_n ax_n = fn0800-3F0A(ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out ds_n);
						if (ax_n == 0x4D5A)
						{
							ax_n = fn0800-46FE(ds_n, out dx_n, out ds);
							sp_n.u0 = <invalid>;
							si_n = ax_n;
						}
						else
						{
							ax_n = fn0800-4B97(ax_n, dx_n, ds_n, out dx_n, out ds);
							sp_n.u0 = <invalid>;
							si_n = ax_n;
						}
						break;
					case 0x05:
						ax_n = fn0800-4BB1(ax_n, dx_n, ds, out dx_n, out ds);
						sp_n.u0 = <invalid>;
						si_n = ax_n;
						break;
					}
				}
			}
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = *((word32) ds + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds + 10719);
			fn0800-4194(ds, ss->*(sp_n - 0x02), ss->*sp_n);
			*((word32) ds + 10761) = dx_n;
			*((word32) ds + 0x00002A07) = ax_n;
			ss->*sp_n = *((word32) ds + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
			fn0800-4194(ds, ss->*(sp_n - 0x02), ss->*sp_n);
			*((word32) ds + 10757) = dx_n;
			*((word32) ds + 10755) = ax_n;
			if (si_n != 0x00)
			{
				Eq_n dx_n = *((word32) ds + 10755);
				*((word32) ds + 10761) = *((word32) ds + 10757);
				*((word32) ds + 0x00002A07) = dx_n;
			}
			Eq_n sp_n;
			ss->*sp_n = *((word32) ds + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n ds_n;
			fn0800_A614(ds, ss->*(sp_n - 0x02), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			Eq_n sp_n = <invalid>;
			ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
			ss->*sp_n = *((word32) ds_n + 10719);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n si_n;
			Eq_n di_n;
			fn0800_A614(ds_n, ss->*sp_n, stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds);
			Eq_n sp_n = <invalid>;
			if (*((word32) ds + 0x00002A25) != 0x02 && si_n == 0x00)
			{
				si_n = fn0800-37DF(si_n, di_n, ds, out di_n, out ds);
				sp_n.u0 = <invalid>;
			}
			else
			{
				ss->*((word32) sp_n + 0x02) = ds;
				(ss->*sp_n).u0 = 0x44DC;
				fn0800-8F7F(0x44DC, ds, ss->*sp_n);
				si_n = si_n;
				sp_n = (word32) sp_n + 0x04;
			}
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).t0000 = ds;
			(ss->*(sp_n - 0x02)).t0000.u0 = 0x4541;
			(ss->*(sp_n - 0x04)).t0000 = si_n;
			cx = fn0800-0ABC(di_n, ds, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out dx, out di_n);
			sp_n = &sp_n->t0002;
		}
	}
	return ds_n;
}

// 0800:12E2: Register Eq_n fn0800-12E2(Register Eq_n cx, Register Eq_n dx, Register Eq_n ds)
Eq_n fn0800-12E2(Eq_n cx, Eq_n dx, Eq_n ds)
{
	Eq_n bx_n = *((word32) ds + 0x00002A25);
	fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2326, ds, out si_n, out di_n);
	if (*((word32) ds + 11855) != 0x00)
		fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 0x0925, ds, out si_n, out di_n);
	Eq_n di_n;
	Eq_n si_n;
	fn0800_B2EF(cx, dx, bx_n << 0x02, ds, 2362, ds, out si_n, out di_n);
	Eq_n sp_n = <invalid>;
	Eq_n dx_n;
	Eq_n si_n;
	Eq_n di_n;
	byte Eq_n::* bp_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800_AA7E(si_n, di_n, ds, 0x4348, ds, 0x093D, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	*((word32) ds_n + 10705) = dx_n;
	*((word32) ds_n + 10703) = ax_n;
	struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x08;
	Eq_n ax_n = *((word32) ds_n + 0x00002A25);
	if (ax_n != 0x03)
	{
		if (ax_n == 0x04)
		{
			if ((*((word32) ds_n + 10703) | *((word32) ds_n + 10705)) != 0x00)
			{
				ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10705);
				ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10703);
				if (fn0800-3E27(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out di_n, out ds_n, out Top_n) == 0x4D5A)
				{
					(ss->*((word32) sp_n + 0x06)).u0 = 0x02;
					(ss->*((word32) sp_n + 0x04)).u0 = 0x00;
					(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
					ss->*sp_n = *((word32) ds_n + 10705);
					(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10703);
					fn0800_ACB3(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
					ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10705);
					ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10703);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					Eq_n dx_n;
					Eq_n ax_n = fn0800_AD2F(ds_n, ss->*((word32) sp_n + 0x04), stackArg4, out dx_n);
					*((word32) ds_n + 10733) = dx_n;
					*((word32) ds_n + 10731) = ax_n;
				}
				else
				{
					((word32) ds_n + 10705)->u0 = 0x00;
					((word32) ds_n + 10703)->u0 = 0x00;
				}
			}
			struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x08;
			if ((*((word32) ds_n + 10703) | *((word32) ds_n + 10705)) == 0x00)
			{
				ss->*((word32) sp_n + 0x06) = ds_n;
				(ss->*((word32) sp_n + 0x04)).u0 = 0x0941;
				ss->*((word32) sp_n + 0x02) = ds_n;
				(ss->*sp_n).u0 = 0x4348;
				Eq_n sp_n = <invalid>;
				Eq_n dx_n;
				Eq_n ax_n = fn0800-4234(si_n, di_n, ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
				*((word32) ds_n + 10705) = dx_n;
				*((word32) ds_n + 10703) = ax_n;
				((word32) ds_n + 10733)->u0 = 0x00;
				((word32) ds_n + 10731)->u0 = 0x00;
				sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x08);
			}
			ss->*(bp_n - 110) = 0x52;
			ss->*(bp_n - 0x6D) = 0x4E;
			ss->*(bp_n - 0x6C) = 0x43;
			ss->*(bp_n - 0x6B) = 0x41;
			ss->*(bp_n - 0x6A) = 0x00;
			ss->*(bp_n - 0x69) = 0x0C;
			ss->*(bp_n - 0x66) = 0x00;
			ss->*(bp_n - 101) = 0x0C;
			ss->*(bp_n - 100) = 0x00;
			ss->*(bp_n - 99) = 0x00;
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x02)).t0000.u0 = 0x04;
			(ss->*(sp_n - 0x04)).t0000 = ss;
			(ss->*(sp_n - 0x06)).t0000 = bp_n - 0x66;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n stackArg9 = <invalid>;
			ss->*(bp_n - 0x68) = (byte) (fn0800-2CCF(ds_n, (ss->*(sp_n - 0x06)).t0000, stackArg4, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, stackArg9, out cl_n, out dx_n) >> 0x08);
			(ss->*sp_n).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x02)).t0000.u0 = 0x04;
			(ss->*(sp_n - 0x04)).t0000 = ss;
			(ss->*(sp_n - 0x06)).t0000 = bp_n - 0x66;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n stackArg9 = <invalid>;
			ss->*(bp_n - 0x67) = (byte) fn0800-2CCF(ds_n, (ss->*(sp_n - 0x06)).t0000, stackArg4, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, stackArg9, out cl_n, out dx_n);
			(ss->*sp_n).t0000 = *((word32) ds_n + 10705);
			(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10703);
			(ss->*(sp_n - 0x04)).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x06)).t0000.u0 = 0x0C;
			(ss->*(sp_n - 0x08)).t0000 = ss;
			(ss->*(sp_n - 0x0A)).t0000 = bp_n - 110;
			Eq_n ds_n;
			fn0800-4152(ds_n, (ss->*(sp_n - 0x0A)).t0000, (ss->*(sp_n - 0x08)).t0000, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out ds_n);
			(ss->*sp_n).t0000 = *((word32) ds_n + 10705);
			(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10703);
			(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10733);
			(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10731);
			fn0800-409C(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out dx_n, out ds_n, out Top_n);
			sp_n = (struct Eq_n Eq_n::*) &sp_n->t0002;
		}
	}
	else if ((*((word32) ds_n + 10703) | *((word32) ds_n + 10705)) == 0x00)
	{
		ss->*((word32) sp_n + 0x06) = ds_n;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x4348;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x07;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x08);
	}
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	(ss->*sp_n).u0 = 0x00;
	Eq_n sp_n = <invalid>;
	Eq_n dx_n;
	Eq_n ds_n;
	Eq_n di_n;
	Eq_n cx_n = fn0800-1CF6(ds_n, ss->*sp_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x02;
	Eq_n si_n = 0x00;
	do
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = ds_n;
		(ss->*(sp_n - 0x02)).u0 = 0x4541;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n sp_n = <invalid>;
		Eq_n stackArg4 = <invalid>;
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
		union Eq_n Eq_n::* bp_n;
		if (fn0800-2DE2(cx_n, dx_n, si_n, di_n, ds_n, ss->*(sp_n - 0x02), stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n) == 0x00)
			break;
		ss->*((word32) sp_n + 0x02) = ds_n;
		(ss->*sp_n).u0 = 0x4541;
		(ss->*(sp_n - 0x02)).t0000 = ss;
		(ss->*(sp_n - 0x04)).t0000 = bp_n - 110;
		fn0800-3509(si_n, di_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out bx_n);
		ss->*((word32) sp_n + 0x02) = ds_n;
		(ss->*sp_n).u0 = 0x4541;
		(ss->*(sp_n - 0x02)).t0000 = ss;
		(ss->*(sp_n - 0x04)).t0000 = bp_n - 0x84;
		fn0800-35A3(si_n, di_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02));
		ss->*((word32) sp_n + 0x02) = ss;
		ss->*sp_n = bp_n - 110;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-283D(ds_n, ss->*sp_n, stackArg4, out dx_n);
		ss->*(bp_n - 0x02) = dx_n;
		ss->*(bp_n - 0x04) = ax_n;
		if ((ax_n | dx_n) == 0x00)
		{
			ss->*((word32) sp_n + 0x02) = ss;
			ss->*sp_n = bp_n - 110;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-1F5C(ds_n, ss->*sp_n, stackArg4, out dx_n, out di_n, out ds_n);
			ss->*(bp_n - 0x02) = dx_n;
			ss->*(bp_n - 0x04) = ax_n;
		}
		word16 cx_n;
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x02);
		ss->*sp_n = ss->*(bp_n - 0x04);
		(ss->*(sp_n - 0x02)).t0000 = ss;
		(ss->*(sp_n - 0x04)).t0000 = bp_n - 0x84;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg8 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-2931((ss->*(sp_n - 0x04)).t0000, ss->*sp_n, stackArg8, out dx_n);
		ss->*(bp_n - 0x06) = dx_n;
		ss->*(bp_n - 0x08) = ax_n;
		if ((ax_n | dx_n) == 0x00)
		{
			ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x02);
			ss->*sp_n = ss->*(bp_n - 0x04);
			(ss->*(sp_n - 0x02)).t0000 = ss;
			(ss->*(sp_n - 0x04)).t0000 = bp_n - 0x84;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			cx_n = (word16) fn0800-2085(ds_n, (ss->*(sp_n - 0x04)).t0000, stackArg4, ss->*sp_n);
			sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
		}
		else
		{
			ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x06);
			ss->*sp_n = ss->*(bp_n - 0x08);
			Eq_n sp_n = <invalid>;
			cx_n = (word16) fn0800-23EC(ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), out bp_n, out si_n, out di_n, out ds_n);
			sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
		}
		word16 dx_n;
		word16 ax_n;
		Eq_n es_bx_n = *((word32) ds_n + 11857);
		dx_n = DPB(DPB(dx_n, *((word32) es_bx_n + 0x05), 0), 0x00, 8);
		si_n.u0 = 0x01;
		cx_n = DPB(cx_n, 0x08, 0);
	} while ((word32) dx_n + (DPB(DPB(ax_n, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) < ~0x73);
	if (si_n != 0x00)
	{
		Eq_n ds_n = fn0800-1E5E(ds_n);
		Eq_n sp_n = <invalid>;
		(ss->*(sp_n - 0x02)).u0 = 0x01;
		Eq_n ds_n;
		Eq_n cx_n = fn0800-1CF6(ds_n, ss->*(sp_n - 0x02), out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		Eq_n sp_n = <invalid>;
		(ss->*sp_n).u0 = 0x01;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		fn0800-2DBF(ds_n, ss->*(sp_n - 0x02), ss->*sp_n);
		Eq_n dx_n = *((word32) ds_n + 10703);
		*((word32) ds_n + 10721) = *((word32) ds_n + 10705);
		*((word32) ds_n + 10719) = dx_n;
		ss->*sp_n = ds_n;
		(ss->*(sp_n - 0x02)).u0 = 2373;
		ss->*(sp_n - 0x04) = ds_n;
		(ss->*(sp_n - 0x06)).u0 = 0x4477;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		Eq_n stackArg8 = <invalid>;
		Eq_n di_n;
		Eq_n si_n = fn0800-37BE(cx_n, dx_n, ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), stackArg6, stackArg8, out di_n);
		ss->*sp_n = ds_n;
		(ss->*(sp_n - 0x02)).u0 = 0x0941;
		ss->*(sp_n - 0x04) = ds_n;
		(ss->*(sp_n - 0x06)).u0 = 0x4477;
		Eq_n si_n;
		Eq_n di_n;
		Eq_n cx_n;
		Eq_n dx_n;
		Eq_n ds_n;
		Eq_n ax_n = fn0800-4234(si_n, di_n, ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		*((word32) ds_n + 0x000029DD) = dx_n;
		*((word32) ds_n + 10715) = ax_n;
		Eq_n sp_n = <invalid>;
		struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x08;
		do
		{
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = ds_n;
			(ss->*(sp_n - 0x02)).u0 = 0x4541;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n sp_n = <invalid>;
			Eq_n stackArg4 = <invalid>;
			struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x04;
			Eq_n di_n;
			Eq_n si_n;
			if (fn0800-2DE2(cx_n, dx_n, si_n, di_n, ds_n, ss->*(sp_n - 0x02), stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n) == 0x00)
				goto l0800_nA9;
			ss->*((word32) sp_n + 0x02) = ds_n;
			(ss->*sp_n).u0 = 0x093D;
			(ss->*(sp_n - 0x02)).t0000 = ds_n;
			(ss->*(sp_n - 0x04)).t0000.u0 = 0x4541;
			union Eq_n Eq_n::* bp_n;
			Eq_n di_n;
			Eq_n dx_n;
			Eq_n si_n;
			Eq_n ds_n;
			Eq_n ax_n = fn0800-4234(si_n, di_n, ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			*((word32) ds_n + 0x000029E5) = dx_n;
			*((word32) ds_n + 0x000029E3) = ax_n;
			Eq_n sp_n = <invalid>;
			ss->*((word32) sp_n + 0x06) = ds_n;
			(ss->*((word32) sp_n + 0x04)).u0 = 0x4541;
			ss->*((word32) sp_n + 0x02) = ss;
			ss->*sp_n = bp_n - 110;
			fn0800-3509(si_n, di_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out bx_n);
			ss->*((word32) sp_n + 0x06) = ds_n;
			(ss->*((word32) sp_n + 0x04)).u0 = 0x4541;
			ss->*((word32) sp_n + 0x02) = ss;
			ss->*sp_n = bp_n - 0x84;
			fn0800-35A3(si_n, di_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06));
			ss->*((word32) sp_n + 0x06) = ds_n;
			(ss->*((word32) sp_n + 0x04)).u0 = 0x4541;
			fn0800-0C93(si_n, di_n, ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n);
			ss->*((word32) sp_n + 0x06) = ss;
			ss->*((word32) sp_n + 0x04) = bp_n - 110;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-283D(ds_n, ss->*((word32) sp_n + 0x04), stackArg4, out dx_n);
			ss->*((word32) sp_n + 0x06) = dx_n;
			ss->*((word32) sp_n + 0x04) = ax_n;
			ss->*((word32) sp_n + 0x02) = ss;
			ss->*sp_n = bp_n - 0x84;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg8 = <invalid>;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-2931(ss->*sp_n, ss->*((word32) sp_n + 0x04), stackArg8, out dx_n);
			ss->*(bp_n - 0x06) = dx_n;
			ss->*(bp_n - 0x08) = ax_n;
			ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10705);
			ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10703);
			fn0800-4194(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06));
			*((word32) ds_n + 0x000029E9) = dx_n - (ax_n < 0x04);
			*((word32) ds_n + 10727) = ax_n - 0x04;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			int32 dx_ax_n = (int32) *((word32) ds_n + 0x000029E9);
			Eq_n stackArg0 = <invalid>;
			Eq_n ax_n = fn0800-8C8A((word16) dx_ax_n, 0x08, SLICE(dx_ax_n, word16, 16), stackArg0, out cl_n, out dx_n);
			Eq_n es_di_n = ss->*(bp_n - 0x08);
			Eq_n sp_n = <invalid>;
			ss->*(sp_n - 0x02) = ax_n;
			struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
			byte Eq_n::* di_n = (word16) es_di_n;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			word16 cx_n = ~cx_n;
			byte Eq_n::* di_n = di_n - cx_n;
			bool Z_n = SLICE(cond(di_n), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			if (!Z_n)
			{
				di_n = &Eq_n::b0001;
				es_n = 0x00;
			}
			es_n->*di_n = (byte) (ss->*(sp_n - 0x02));
			Eq_n es_di_n = ss->*(bp_n - 0x08);
			ss->*(sp_n - 0x02) = (word16) (int32) *((word32) ds_n + 0x000029E9);
			struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
			byte Eq_n::* di_n = (word16) es_di_n;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			word16 cx_n = ~cx_n;
			struct Eq_n Eq_n::* di_n = di_n - cx_n;
			bool Z_n = SLICE(cond(di_n), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(0x00 - (es_n->*di_n).b0000), bool, 2);
				++di_n;
				--cx_n;
				if ((es_n->*di_n).b0000 != 0x00)
					break;
			}
			if (!Z_n)
			{
				di_n = &Eq_n::t0001;
				es_n = 0x00;
			}
			di_n[0x01] = (byte) (ss->*(sp_n - 0x02));
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg0 = <invalid>;
			word16 dx_n;
			Eq_n ax_n = fn0800-8C8A(*((word32) ds_n + 10727), 0x08, *((word32) ds_n + 0x000029E9), stackArg0, out cl_n, out dx_n);
			Eq_n es_di_n = ss->*(bp_n - 0x08);
			Eq_n sp_n = <invalid>;
			ss->*(sp_n - 0x02) = ax_n;
			struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
			byte Eq_n::* di_n = (word16) es_di_n;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			word16 cx_n = ~cx_n;
			struct Eq_n Eq_n::* di_n = di_n - cx_n;
			bool Z_n = SLICE(cond(di_n), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(0x00 - (es_n->*di_n).b0000), bool, 2);
				++di_n;
				--cx_n;
				if ((es_n->*di_n).b0000 != 0x00)
					break;
			}
			if (!Z_n)
			{
				di_n = &Eq_n::t0001;
				es_n = 0x00;
			}
			di_n[0x02] = (byte) (ss->*(sp_n - 0x02));
			Eq_n es_di_n = ss->*(bp_n - 0x08);
			struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
			byte Eq_n::* di_n = (word16) es_di_n;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			word16 cx_n = ~cx_n;
			struct Eq_n Eq_n::* di_n = di_n - cx_n;
			bool Z_n = SLICE(cond(di_n), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(0x00 - (es_n->*di_n).b0000), bool, 2);
				++di_n;
				--cx_n;
				if ((es_n->*di_n).b0000 != 0x00)
					break;
			}
			if (!Z_n)
			{
				di_n = &Eq_n::t0001;
				es_n = 0x00;
			}
			Eq_n dl_n = *((word32) ds_n + 10727);
			di_n[0x03] = dl_n;
			((word32) ds_n + 10757)->u0 = 0x00;
			((word32) ds_n + 10755)->u0 = 0x00;
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
			fn0800-4194(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
			*((word32) ds_n + 10761) = DPB(dx_n, dl_n, 0);
			((word32) ds_n + 0x00002A07)->u0 = 0x00;
			(ss->*(sp_n - 0x02)).u0 = 0x00;
			ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E9);
			ss->*(sp_n - 0x06) = *((word32) ds_n + 10727);
			ss->*(sp_n - 0x08) = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x0A) = *((word32) ds_n + 10719);
			word16 di_n = 0x01;
			Eq_n ax_n = fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
			Eq_n sp_n = sp_n;
			if (*((word32) ds_n + 10761) >= 0x00 && (*((word32) ds_n + 10761) > 0x00 || *((word32) ds_n + 0x00002A07) > 0x12) && *((word32) ds_n + 0x00002A21) != 0x00)
			{
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				word16 dx_n;
				Eq_n ax_n = fn0800-8CAA(ax_n, 0x08, fn0800-3F58(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out di_n, out ds_n), stackArg0, out dx_n);
				sp_n.u0 = <invalid>;
				if (dx_n != 0x52 || ax_n != 0x4E43)
				{
					word16 ax_n;
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10761);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 0x00002A07);
					ss->*(sp_n - 0x06) = *((word32) ds_n + 10761);
					ss->*(sp_n - 0x08) = *((word32) ds_n + 0x00002A07);
					fn0800-75EA(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out bp_n, out si_n, out ds_n);
					Eq_n sp_n = <invalid>;
					sp_n = (word32) sp_n + 0x08;
					Eq_n ax_n = *((word32) ds_n + 10757);
					Eq_n dx_n = *((word32) ds_n + 10755);
					if (ax_n >= *((word32) ds_n + 10761) && (ax_n != *((word32) ds_n + 10761) || dx_n >= *((word32) ds_n + 0x00002A07)))
						ax_n = 0x01;
					else
						ax_n = 0x00;
					di_n = ax_n;
					if (ax_n != 0x00)
					{
						(ss->*((word32) sp_n + 0x06)).u0 = 0x01;
						Eq_n dx_n = -*((word32) ds_n + 10755);
						ss->*((word32) sp_n + 0x04) = -*((word32) ds_n + 10757) - (dx_n == 0x00);
						ss->*((word32) sp_n + 0x02) = dx_n;
						ss->*sp_n = *((word32) ds_n + 10721);
						(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10719);
						fn0800_ACB3(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
						sp_n = (word32) sp_n + 0x08;
					}
				}
			}
			if (di_n != 0x00)
			{
				Eq_n ax_n = *((word32) ds_n + 10761);
				Eq_n dx_n = *((word32) ds_n + 0x00002A07);
				*((word32) ds_n + 10757) = ax_n;
				*((word32) ds_n + 10755) = dx_n;
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
				fn0800_BA67(ds_n, ss->*(sp_n - 0x02), ss->*sp_n);
				Eq_n sp_n = (char *) sp_n + 0x02;
				if (*((word32) ds_n + 10761) >= 0x00 && (*((word32) ds_n + 10761) != 0x00 || *((word32) ds_n + 0x00002A07) >= 0x12))
				{
					ss->*sp_n = *((word32) ds_n + 0x000029E5);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg0 = <invalid>;
					word16 dx_n;
					Eq_n ax_n = fn0800-8CAA(ax_n, 0x08, fn0800-3F58(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out di_n, out ds_n), stackArg0, out dx_n);
					sp_n.u0 = <invalid>;
					if (dx_n == 0x52 && ax_n == 0x4E43)
						goto l0800_nE;
				}
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = *((word32) ds_n + 10705);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10703);
				(ss->*(sp_n - 0x04)).u0 = 21070;
				(ss->*(sp_n - 0x06)).u0 = 0x4300;
				Eq_n ds_n;
				fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
				ss->*sp_n = *((word32) ds_n + 10705);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10703);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10761);
				ss->*(sp_n - 0x06) = *((word32) ds_n + 0x00002A07);
				fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
				sp_n = (char *) sp_n + 0x02;
l0800_nE:
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = *((word32) ds_n + 10761);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x00002A07);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10705);
				ss->*(sp_n - 0x06) = *((word32) ds_n + 10703);
				ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
				fn0800-3B0A(ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out bp_n, out ds_n);
				Eq_n sp_n = <invalid>;
				sp_n = (word32) sp_n + 0x0C;
			}
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = *((word32) ds_n + 10705);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10703);
			ss->*(sp_n - 0x04) = *((word32) ds_n + 10733);
			ss->*(sp_n - 0x06) = *((word32) ds_n + 10731);
			Eq_n ds_n;
			fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n di_n;
			fn0800_A614(ds_n, ss->*(sp_n - 0x02), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			Eq_n sp_n = <invalid>;
			ss->*((word32) sp_n + 0x02) = ds_n;
			(ss->*sp_n).u0 = 0x4541;
			(ss->*(sp_n - 0x02)).t0000 = si_n;
			word16 dx_n;
			Eq_n cx_n = fn0800-0ABC(di_n, ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out di_n);
			Eq_n es_bx_n = *((word32) ds_n + 11857);
			dx_n = DPB(DPB(dx_n, *((word32) es_bx_n + 0x05), 0), 0x00, 8);
			sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
			Eq_n bx_n = (word16) es_bx_n;
			cx_n = DPB(cx_n, 0x08, 0);
		} while ((word32) dx_n + (DPB(DPB(ax_n, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) < ~0x73);
		ss->*((word32) sp_n + 0x02) = ds_n;
		(ss->*sp_n).u0 = 0x0952;
		fn0800_B2EF(cx_n, dx_n, bx_n, ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), out si_n, out di_n);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
l0800_nA9:
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds_n + 0x000029DD);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10715);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n ds_n;
		fn0800_A614(ds_n, ss->*(sp_n - 0x02), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		Eq_n sp_n = <invalid>;
		ss->*((word32) sp_n + 0x02) = ds_n;
		(ss->*sp_n).u0 = 0x4477;
		fn0800-8F7F(0x4477, ds_n, ss->*sp_n);
		Eq_n ds_n = fn0800-1E5E(ds_n);
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10705);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10703);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n ds_n;
		fn0800_A614(ds_n, ss->*(sp_n - 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		return ds_n;
	}
	else
	{
		struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).t0000 = *((word32) ds_n + 10705);
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10703);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n ds_n;
		fn0800_A614(ds_n, (ss->*(sp_n - 0x02)).t0000, stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		return ds_n;
	}
}

// 0800:18D9: Register Eq_n fn0800-18D9(Register Eq_n cx, Register Eq_n dx, Register Eq_n ds)
Eq_n fn0800-18D9(Eq_n cx, Eq_n dx, Eq_n ds)
{
	Eq_n di_n;
	Eq_n si_n;
	fn0800_B2EF(cx, dx, *((word32) ds + 0x00002A25) << 0x02, ds, 2412, ds, out si_n, out di_n);
	Eq_n dx_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800_AA7E(si_n, di_n, ds, 0x4348, ds, 2429, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	*((word32) ds_n + 10705) = dx_n;
	*((word32) ds_n + 10703) = ax_n;
	Eq_n sp_n = <invalid>;
	if ((ax_n | dx_n) == 0x00)
	{
		ss->*((word32) sp_n + 0x06) = ds_n;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x4348;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x07;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	(ss->*((word32) sp_n + 0x06)).u0 = 0x01;
	union Eq_n Eq_n::* bp_n;
	Eq_n si_n;
	Eq_n di_n;
	Eq_n ds_n;
	Eq_n dx_n;
	Eq_n cx_n = fn0800-1CF6(ds_n, ss->*((word32) sp_n + 0x06), out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	Eq_n sp_n = <invalid>;
	(ss->*sp_n).u0 = 0x00;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	fn0800-2DBF(ds_n, ss->*(sp_n - 0x02), ss->*sp_n);
	struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x02;
	while (true)
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = ss;
		ss->*(sp_n - 0x02) = bp_n - 110;
		ss->*(sp_n - 0x04) = ss;
		ss->*(sp_n - 0x06) = bp_n - 0x08;
		ss->*(sp_n - 0x08) = ss;
		ss->*(sp_n - 0x0A) = bp_n - 0x04;
		Eq_n sp_n = <invalid>;
		Eq_n di_n;
		Eq_n si_n;
		Eq_n ds_n;
		union Eq_n Eq_n::* bp_n;
		if (fn0800-29C5(cx_n, dx_n, si_n, di_n, ds_n, out bp_n, out si_n, out di_n, out ds_n) == 0x00)
			break;
		ss->*((word32) sp_n + 0x0A) = ss;
		ss->*((word32) sp_n + 0x08) = bp_n - 110;
		fn0800-0C93(si_n, di_n, ds_n, ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out dx_n);
		ss->*((word32) sp_n + 0x0A) = ss->*(bp_n - 0x06);
		ss->*((word32) sp_n + 0x08) = ss->*(bp_n - 0x08);
		fn0800-23EC(ds_n, ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out bp_n, out si_n, out di_n, out ds_n);
		Eq_n sp_n = <invalid>;
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x06);
		ss->*sp_n = ss->*(bp_n - 0x08);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-22FE(ds_n, ss->*sp_n, stackArg4);
		Eq_n es_di_n = ss->*(bp_n - 0x04);
		struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
		byte Eq_n::* di_n = (word16) es_di_n + 0x02;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 cx_n = ~cx_n;
		byte Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		if (!Z_n)
		{
			di_n = &Eq_n::b0001;
			es_n = 0x00;
		}
		Eq_n di_n = di_n - 0x01;
		if (es_n->*((word32) di_n + 0x01) == 0x00)
		{
			Eq_n dx_n = *((word32) ds_n + 11857);
			if (*((word32) ds_n + 11859) != ss->*(bp_n - 0x02) || (word32) dx_n + 0x08 != ss->*(bp_n - 0x04))
			{
				ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x02);
				ss->*sp_n = ss->*(bp_n - 0x04);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				fn0800-2201(ds_n, ss->*sp_n, stackArg4);
			}
		}
		ss->*((word32) sp_n + 0x02) = ss;
		ss->*sp_n = bp_n - 110;
		(ss->*(sp_n - 0x02)).t0000.u0 = 0x0D;
		cx_n = fn0800-0ABC(di_n, ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out di_n);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
	}
	Eq_n ds_n = fn0800-1E5E(ds_n);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = *((word32) ds_n + 10705);
	ss->*(sp_n - 0x04) = *((word32) ds_n + 10703);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n ds_n;
	fn0800_A614(ds_n, ss->*(sp_n - 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	return ds_n;
}

// 0800:19EE: Register Eq_n fn0800-19EE(Register Eq_n cx, Register Eq_n dx, Register Eq_n ds)
Eq_n fn0800-19EE(Eq_n cx, Eq_n dx, Eq_n ds)
{
	Eq_n di_n;
	Eq_n si_n;
	fn0800_B2EF(cx, dx, *((word32) ds + 0x00002A25) << 0x02, ds, 0x0986, ds, out si_n, out di_n);
	word16 Eq_n::* bp_n;
	Eq_n dx_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800_AA7E(si_n, di_n, ds, 0x4348, ds, 0x0997, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	*((word32) ds_n + 10705) = dx_n;
	*((word32) ds_n + 10703) = ax_n;
	Eq_n sp_n = <invalid>;
	if ((ax_n | dx_n) == 0x00)
	{
		ss->*((word32) sp_n + 0x06) = ds_n;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x4348;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x07;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	if (*((word32) ds_n + 0x00002A27) == *((word32) ds_n + 9882))
	{
		word16 dx_n = *((word32) ds_n + 2434);
		ss->*(bp_n - 0x0A) = *((word32) ds_n + 0x0984);
		ss->*(bp_n - 0x0C) = dx_n;
		struct Eq_n * es_bx_n = *((word32) ds_n + 9884);
		es_bx_n->t0006 = ss;
		es_bx_n->ptr0004 = bp_n - 0x0C;
		*((word32) ds_n + 0x00002A27) = 0x01;
		*((word32) ds_n + 9882) = 0x02;
		*((word32) ds_n + 10779) = 0x01;
	}
	(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
	(ss->*((word32) sp_n + 0x04)).u0 = 0x01;
	fn0800-2DBF(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06));
	(ss->*((word32) sp_n + 0x06)).u0 = 0x01;
	Eq_n sp_n = <invalid>;
	word16 bp_n;
	Eq_n si_n;
	Eq_n di_n;
	Eq_n ds_n;
	Eq_n dx_n;
	Eq_n cx_n = fn0800-1CF6(ds_n, ss->*((word32) sp_n + 0x06), out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x02;
	if (*((word32) ds_n + 0x00002A25) == 0x07)
	{
		ss->*sp_n = ds_n;
		(ss->*(sp_n - 0x02)).u0 = 0x099B;
		ss->*(sp_n - 0x04) = ds_n;
		(ss->*(sp_n - 0x06)).u0 = 0x44DC;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		Eq_n stackArg8 = <invalid>;
		si_n = fn0800-37BE(cx_n, dx_n, ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), stackArg6, stackArg8, out di_n);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x02);
	}
	while (true)
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = ss;
		ss->*(sp_n - 0x02) = bp_n - 114;
		ss->*(sp_n - 0x04) = ss;
		ss->*(sp_n - 0x06) = bp_n - 0x08;
		ss->*(sp_n - 0x08) = ss;
		ss->*(sp_n - 0x0A) = bp_n - 0x04;
		Eq_n sp_n = <invalid>;
		Eq_n di_n;
		Eq_n si_n;
		Eq_n ds_n;
		union Eq_n Eq_n::* bp_n;
		if (fn0800-29C5(cx_n, dx_n, si_n, di_n, ds_n, out bp_n, out si_n, out di_n, out ds_n) == 0x00)
			break;
		ss->*((word32) sp_n + 0x0A) = ss;
		ss->*((word32) sp_n + 0x08) = bp_n - 114;
		fn0800-0C93(si_n, di_n, ds_n, ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out dx_n);
		ss->*((word32) sp_n + 0x0A) = ss->*(bp_n - 0x06);
		ss->*((word32) sp_n + 0x08) = ss->*(bp_n - 0x08);
		Eq_n ds_n;
		Eq_n si_n = fn0800-24FE(ds_n, ss->*((word32) sp_n + 0x08), out ds_n);
		(ss->*((word32) sp_n + 0x0A)).u0 = 0x00;
		Eq_n es_di_n = ss->*(bp_n - 0x08);
		struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
		byte Eq_n::* di_n = (word16) es_di_n;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 cx_n = ~cx_n;
		byte Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		if (!Z_n)
		{
			di_n = &Eq_n::b0001;
			es_n = 0x00;
		}
		Eq_n es_di_n = ss->*(bp_n - 0x08);
		ss->*((word32) sp_n + 0x08) = (int16) (es_n->*di_n) << 0x08;
		struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
		byte Eq_n::* di_n = (word16) es_di_n;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 cx_n = ~cx_n;
		struct Eq_n Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x00 - (es_n->*di_n).b0000), bool, 2);
			++di_n;
			--cx_n;
			if ((es_n->*di_n).b0000 != 0x00)
				break;
		}
		if (!Z_n)
		{
			di_n = &Eq_n::t0001;
			es_n = 0x00;
		}
		Eq_n es_di_n = ss->*(bp_n - 0x08);
		Mem455[ss:sp_n + 0x08:word16] = Mem382[ss:sp_n + 0x08:word16] + DPB(DPB(es_n, Mem382[es_n:di_n + 0x01:byte], 0), 0x00, 8);
		(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
		struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
		byte Eq_n::* di_n = (word16) es_di_n;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 cx_n = ~cx_n;
		struct Eq_n Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x00 - (es_n->*di_n).b0000), bool, 2);
			++di_n;
			--cx_n;
			if ((es_n->*di_n).b0000 != 0x00)
				break;
		}
		if (!Z_n)
		{
			di_n = &Eq_n::t0001;
			es_n = 0x00;
		}
		Eq_n es_di_n = ss->*(bp_n - 0x08);
		ss->*((word32) sp_n + 0x04) = (int16) di_n[0x02] << 0x08;
		Eq_n es_n = SLICE(es_di_n, selector, 16);
		byte Eq_n::* di_n = (word16) es_di_n;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 cx_n = ~cx_n;
		byte Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		if (!Z_n)
		{
			di_n = 0x01;
			es_n.u0 = 0x00;
		}
		Eq_n di_n = di_n - 0x01;
		word16 ax_n = Mem521[ss:sp_n + 0x06:word16] + (Mem521[ss:sp_n + 0x04:word16] + DPB(DPB(es_n, Mem521[es_n:di_n + 0x04:byte], 0), 0x00, 8));
		Mem594[ss:sp_n + 0x08:word16] = Mem521[ss:sp_n + 0x08:word16] + (ax_n <u 0x00);
		ss->*((word32) sp_n + 0x06) = ax_n;
		ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10705);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10703);
		fn0800_ACB3(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x0A), out cx_n, out dx_n, out bx_n);
		if (*((word32) ds_n + 0x00002A25) != 0x07)
		{
			ss->*((word32) sp_n + 0x0A) = ds_n;
			Eq_n es_n = ss->*((word32) sp_n + 0x0A);
			ss->*((word32) sp_n + 0x0A) = es_n;
			(ss->*((word32) sp_n + 0x08)).u0 = 0x44DC;
			word16 di_n = 17022;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			Eq_n di_n = ss->*((word32) sp_n + 0x08);
			Eq_n es_n = ss->*((word32) sp_n + 0x0A);
			ss->*((word32) sp_n + 0x0A) = ds_n;
			cu16 cx_n = ~cx_n;
			uint16 cx_n;
			Eq_n si_n = di_n - cx_n;
			for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
			{
				es_n->*di_n = es_n->*si_n;
				si_n = (word32) si_n + 0x02;
				di_n = (word32) di_n + 0x02;
			}
			ui16 cx_n;
			for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
			{
				es_n->*di_n = es_n->*si_n;
				si_n = (word32) si_n + 0x01;
				di_n = (word32) di_n + 0x01;
			}
			Eq_n ds_n = ss->*((word32) sp_n + 0x0A);
			if (*((word32) ds_n + 0x00002A25) == 0x08)
			{
				if (*((word32) ds_n + 17022) != 0x00 && ss->*(bp_n - 114) == 0x5C)
				{
					ss->*((word32) sp_n + 0x0A) = ss;
					ss->*((word32) sp_n + 0x08) = bp_n - 113;
					ss->*((word32) sp_n + 0x06) = ds_n;
					Eq_n es_n = ss->*((word32) sp_n + 0x06);
					word16 di_n = 0x44DC;
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						++di_n;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					word16 cx_n = ~cx_n;
					byte Eq_n::* di_n = di_n - cx_n;
					bool Z_n = SLICE(cond(di_n), bool, 2);
					while (cx_n != 0x00)
					{
						Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
						++di_n;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					if (!Z_n)
					{
						di_n = 0x01;
						es_n.u0 = 0x00;
					}
					ss->*((word32) sp_n + 0x06) = es_n;
					Eq_n di_n = di_n - 0x01;
					ss->*((word32) sp_n + 0x04) = di_n;
					fn0800-3509(si_n, di_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out bx_n);
				}
				else
				{
					ss->*((word32) sp_n + 0x0A) = ss;
					ss->*((word32) sp_n + 0x08) = bp_n - 114;
					ss->*((word32) sp_n + 0x06) = ds_n;
					Eq_n es_n = ss->*((word32) sp_n + 0x06);
					word16 di_n = 0x44DC;
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						++di_n;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					word16 cx_n = ~cx_n;
					byte Eq_n::* di_n = di_n - cx_n;
					bool Z_n = SLICE(cond(di_n), bool, 2);
					while (cx_n != 0x00)
					{
						Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
						++di_n;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					if (!Z_n)
					{
						di_n = 0x01;
						es_n.u0 = 0x00;
					}
					ss->*((word32) sp_n + 0x06) = es_n;
					Eq_n di_n = di_n - 0x01;
					ss->*((word32) sp_n + 0x04) = di_n;
					fn0800-3509(si_n, di_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out bx_n);
				}
			}
			ss->*((word32) sp_n + 0x0A) = ds_n;
			(ss->*((word32) sp_n + 0x08)).u0 = 0x44DC;
			fn0800-3678(ds_n, ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out dx_n, out si_n, out ds_n);
			ss->*((word32) sp_n + 0x0A) = ss;
			ss->*((word32) sp_n + 0x08) = bp_n - 114;
			ss->*((word32) sp_n + 0x06) = ds_n;
			Eq_n es_n = ss->*((word32) sp_n + 0x06);
			word16 di_n = 0x44DC;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			word16 cx_n = ~cx_n;
			byte Eq_n::* di_n = di_n - cx_n;
			bool Z_n = SLICE(cond(di_n), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			if (!Z_n)
			{
				di_n = 0x01;
				es_n.u0 = 0x00;
			}
			ss->*((word32) sp_n + 0x06) = es_n;
			di_n = di_n - 0x01;
			ss->*((word32) sp_n + 0x04) = di_n;
			fn0800-35A3(si_n, di_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A));
		}
		ss->*((word32) sp_n + 0x0A) = ds_n;
		(ss->*((word32) sp_n + 0x08)).u0 = 2472;
		ss->*((word32) sp_n + 0x06) = ds_n;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x44DC;
		Eq_n ds_n;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-4234(si_n, di_n, ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		*((word32) ds_n + 10721) = dx_n;
		*((word32) ds_n + 10719) = ax_n;
		Eq_n dx_n = *((word32) ds_n + 10703);
		*((word32) ds_n + 0x000029E5) = *((word32) ds_n + 10705);
		*((word32) ds_n + 0x000029E3) = dx_n;
		Eq_n ds_n;
		fn0800-5374(ds_n, out dx_n, out bp_n, out ds_n);
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n di_n;
		Eq_n si_n;
		fn0800_A614(ds_n, ss->*(sp_n - 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		Eq_n sp_n = <invalid>;
		si_n = si_n;
		if (si_n != 0x00)
		{
			ss->*((word32) sp_n + 0x02) = ds_n;
			(ss->*sp_n).u0 = 0x44DC;
			fn0800-8F7F(0x44DC, ds_n, ss->*sp_n);
		}
		ss->*((word32) sp_n + 0x02) = ss;
		ss->*sp_n = bp_n - 114;
		(ss->*(sp_n - 0x02)).t0000 = si_n;
		cx_n = fn0800-0ABC(di_n, ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out di_n);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
	}
	ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10705);
	ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 10703);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n ds_n;
	fn0800_A614(ds_n, ss->*((word32) sp_n + 0x08), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	Eq_n sp_n = <invalid>;
	if (*((word32) ds_n + 0x00002A25) == 0x07)
	{
		ss->*((word32) sp_n + 0x02) = ds_n;
		(ss->*sp_n).u0 = 0x44DC;
		fn0800-8F7F(0x44DC, ds_n, ss->*sp_n);
	}
	return ds_n;
}

// 0800:1CF6: Register word16 fn0800-1CF6(Register Eq_n ds, Stack Eq_n wArg02, Register out ptr16 dxOut, Register out Eq_n bpOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
word16 fn0800-1CF6(Eq_n ds, Eq_n wArg02, ptr16 & dxOut, union Eq_n & bpOut, ptr16 & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	*((word32) ds + 0x000045A8) = 0x00;
	*((word32) ds + 0x000045A6) = 0x00;
	((word32) ds + 10733)->u0 = 0x00;
	((word32) ds + 10731)->u0 = 0x00;
	Eq_n ax_n = fn0800_ACB3(ds, *((word32) ds + 10703), *((word32) ds + 10705), 0x02, out cx_n, out dx_n, out bx_n);
	Eq_n ds_n;
	Eq_n dx_n = fn0800-3E5D(ds, *((word32) ds + 10703), *((word32) ds + 10705), out ds_n, out Top_n);
	*((word32) ds_n + 10733) = dx_n;
	*((word32) ds_n + 10731) = ax_n;
	fn0800-4194(ds_n, *((word32) ds_n + 10703), *((word32) ds_n + 10705));
	if (dx_n <= *((word32) ds_n + 10733) && (dx_n < *((word32) ds_n + 10733) || ax_n < *((word32) ds_n + 10731)))
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, 11, SEQ(ds_n, 0x4348), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	Eq_n ax_n = fn0800_ACB3(ds_n, *((word32) ds_n + 10703), *((word32) ds_n + 10705), 0x00, out cx_n, out dx_n, out bx_n);
	Eq_n ds_n;
	if (fn0800-3E5D(ds_n, *((word32) ds_n + 10703), *((word32) ds_n + 10705), out ds_n, out Top_n) != 21070 || ax_n != 17217)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, 11, SEQ(ds_n, 0x4348), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	union Eq_n Eq_n::* bp_n;
	Eq_n si_n;
	Eq_n ds_n;
	ptr16 Eq_n::* sp_n;
	Eq_n ds_n;
	fn0800-3E27(ds_n, *((word32) ds_n + 10703), *((word32) ds_n + 10705), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
	fn0800-3E27(ds_n, *((word32) ds_n + 10703), *((word32) ds_n + 10705), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
	if (wArg02 != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		Eq_n sp_n = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		*((word32) ds_n + 11859) = dx_n;
		*((word32) ds_n + 11857) = ax_n;
		sp_n = (ptr16 Eq_n::*) ((word32) sp_n + 0x04);
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		Eq_n sp_n = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		*((word32) ds_n + 11859) = dx_n;
		*((word32) ds_n + 11857) = ax_n;
		sp_n = (ptr16 Eq_n::*) ((word32) sp_n + 0x04);
	}
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	(ss->*sp_n).u0 = 0x00;
	ss->*(sp_n - 0x02) = *((word32) ds_n + 10733);
	ss->*(sp_n - 0x04) = *((word32) ds_n + 10731);
	ss->*(sp_n - 0x06) = *((word32) ds_n + 10705);
	ss->*(sp_n - 0x08) = *((word32) ds_n + 10703);
	fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
	ss->*sp_n = *((word32) ds_n + 10705);
	ss->*(sp_n - 0x02) = *((word32) ds_n + 10703);
	(ss->*(sp_n - 0x04)).u0 = 0x00;
	ss->*(sp_n - 0x06) = si_n;
	ss->*(sp_n - 0x08) = *((word32) ds_n + 11859);
	ss->*(sp_n - 0x0A) = *((word32) ds_n + 11857);
	word16 si_n;
	ptr16 di_n;
	Eq_n ds_n;
	word16 cx_n = (word16) fn0800-4110(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out si_n, out di_n, out ds_n);
	(ss->*sp_n).u0 = 0x00;
	ss->*(sp_n - 0x02) = si_n - 0x08;
	Eq_n ax_n = *((word32) ds_n + 11857);
	ss->*(sp_n - 0x04) = *((word32) ds_n + 11859);
	ss->*(sp_n - 0x06) = (word32) ax_n + 0x08;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n stackArg9 = <invalid>;
	word16 cx_n = DPB(cx_n, cl_n, 0);
	byte cl_n;
	ptr16 dx_n;
	if (fn0800-2CCF(ds_n, ss->*(sp_n - 0x06), stackArg4, ss->*(sp_n - 0x02), ss->*sp_n, stackArg9, out cl_n, out dx_n) != ss->*(bp_n - 0x02))
	{
		ss->*sp_n = ds_n;
		(ss->*(sp_n - 0x02)).u0 = 0x4348;
		(ss->*(sp_n - 0x04)).u0 = 0x0D;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	ptr16 si_n = ss->*sp_n;
	Eq_n bp_n = ss->*bp_n;
	dxOut = dx_n;
	bpOut = bp_n;
	siOut = si_n;
	diOut = di_n;
	dsOut = ds_n;
	return cx_n;
}

// 0800:1E5E: Register Eq_n fn0800-1E5E(Register Eq_n ds)
Eq_n fn0800-1E5E(Eq_n ds)
{
	Eq_n es_bx_n = *((word32) ds + 11857);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n ax_n = (DPB(DPB(ax, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) es_bx_n + 0x05), 0), 0x00, 8);
	Eq_n stackArg4 = <invalid>;
	Eq_n stackArg9 = <invalid>;
	Eq_n ax_n = fn0800-2CCF(ds, SEQ(*((word32) ds + 11859), (word32) *((word32) ds + 11857) + 0x08), stackArg4, ax_n - 0x08, 0x00, stackArg9, out cl_n, out dx_n);
	Eq_n es_bx_n = *((word32) ds + 11857);
	*((word32) es_bx_n + 0x06) = (byte) (ax_n >> 0x08);
	*((word32) es_bx_n + 0x07) = (byte) ax_n;
	fn0800_ACB3(ds, *((word32) ds + 10703), *((word32) ds + 10705), 0x00, out cx_n, out dx_n, out bx_n);
	Eq_n si_n = ax_n;
	Eq_n cx_n;
	Eq_n di_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800-3E27(ds, *((word32) ds + 10703), *((word32) ds + 10705), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
	mp16 sp_n = fp - 0x02;
	if (ax_n > ax_n)
	{
		Eq_n sp_n = <invalid>;
		si_n = fn0800-3BC3(cx_n, 0x00, ds_n, out ds_n);
		sp_n = (mp16) ((word32) sp_n + 0x0C);
	}
	else if (ax_n < ax_n)
	{
		fn0800-3C99(ax_n, di_n, ds_n, out bp_n, out si_n, out ds_n);
		Eq_n sp_n = <invalid>;
		sp_n = (mp16) ((word32) sp_n + 0x0C);
	}
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	(ss->*sp_n).u0 = 0x00;
	ss->*(sp_n - 0x02) = *((word32) ds_n + 10733);
	ss->*(sp_n - 0x04) = *((word32) ds_n + 10731);
	ss->*(sp_n - 0x06) = *((word32) ds_n + 10705);
	ss->*(sp_n - 0x08) = *((word32) ds_n + 10703);
	fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
	ss->*sp_n = *((word32) ds_n + 10705);
	ss->*(sp_n - 0x02) = *((word32) ds_n + 10703);
	(ss->*(sp_n - 0x04)).u0 = 0x00;
	ss->*(sp_n - 0x06) = si_n;
	ss->*(sp_n - 0x08) = *((word32) ds_n + 11859);
	ss->*(sp_n - 0x0A) = *((word32) ds_n + 11857);
	Eq_n ds_n;
	fn0800-4152(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x02), ss->*sp_n, out ds_n);
	ss->*sp_n = *((word32) ds_n + 11859);
	ss->*(sp_n - 0x02) = *((word32) ds_n + 11857);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg2 = <invalid>;
	Eq_n ds_n;
	fn0800-4346(ds_n, stackArg2, ss->*sp_n, out cx_n, out dx_n, out bx_n, out ds_n);
	return ds_n;
}

// 0800:1F5C: Register word16 fn0800-1F5C(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out (ptr16 Eq_n) dxOut, Register out Eq_n diOut, Register out Eq_n dsOut)
word16 fn0800-1F5C(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, struct Eq_n & dxOut, union Eq_n & diOut, union Eq_n & dsOut)
{
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	Eq_n di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x3A - es_n->*di_n), bool, 2);
		di_n = (word32) di_n + 0x01;
		--cx_n;
		if (es_n->*di_n != 0x3A)
			break;
	}
	if (!Z_n)
	{
		di_n.u0 = 0x01;
		es_n = 0x00;
	}
	struct Eq_n * ax_n = es_n;
	if ((di_n - 0x01 | es_n) != 0x00)
	{
		struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
		byte Eq_n::* di_n = (word16) ptrArg02;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 cx_n = ~cx_n;
		byte Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x3A - es_n->*di_n), bool, 2);
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x3A)
				break;
		}
		if (!Z_n)
		{
			di_n = &Eq_n::b0001;
			es_n = 0x00;
		}
		ax_n = es_n;
		ptrArg02 = &(es_n->*di_n);
	}
	Eq_n es_bx_n = *((word32) ds + 11857);
	ui16 ax_n = (DPB(DPB(ax_n, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) es_bx_n + 0x05), 0), 0x00, 8);
	struct Eq_n * wArg04_n = SLICE(ptrArg02, word16, 16);
	byte Eq_n::* wArg02_n = SLICE(ptrArg02, word16, 0);
	word16 dx_n = (word16) ((word32) ds + 11857)->u0 + ax_n;
	Eq_n ptrLoc06_n = *((word32) ds + 11859);
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	do
	{
		ptrLoc06_n = SLICE(ptrLoc06_n, word16, 16);
		if (cx_n == 0x00)
			break;
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
	} while (es_n->*di_n == 0x00);
	word16 cx_n = ~cx_n;
	cup16 ax_n = dx_n - *((word32) ds + 11857);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n ax_n = ax_n + (cx_n + 0x03);
	Eq_n stackArg0 = <invalid>;
	struct Eq_n * ptrLoc06_n = SEQ(SLICE(ptrLoc06_n, word16, 16), dx_n);
	ptrLoc06_n->b0000 = (byte) fn0800-8C8A(ax_n, 0x08, (bool) (ax_n < 0x00) + (0x00 - (ax_n < 0x00)), stackArg0, out cl_n, out dx_n);
	ptrLoc06_n->b0001 = (byte) (dx_n - *((word32) ds + 11857)) + SLICE(cx_n + 0x03, byte, 0);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = SLICE(ptrLoc06_n, selector, 16);
	ss->*(sp_n - 0x04) = dx_n + 0x02;
	struct Eq_n * wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
	<type-error> Eq_n::* bx_n = (word16) ptrLoc06_n;
	byte Eq_n::* di_n = wArg02_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (wArg04_n->*di_n != 0x00)
			break;
	}
	Eq_n di_n = ss->*(sp_n - 0x04);
	Eq_n es_n = ss->*(sp_n - 0x02);
	ss->*(sp_n - 0x02) = ds;
	cu16 cx_n = ~cx_n;
	uint16 cx_n;
	struct Eq_n Eq_n::* si_n = di_n - cx_n;
	for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
	{
		es_n->*di_n = (wArg04_n->*si_n).t0000;
		si_n += 0x02;
		di_n = (word32) di_n + 0x02;
	}
	ui16 cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00);
	while (true)
	{
		byte bLoc08_n = SLICE(ax_n, byte, 0);
		byte bLoc0A_n = SLICE(cx_n + 0x03, byte, 0);
		if (cx_n == 0x00)
			break;
		es_n->*di_n = (wArg04_n->*si_n).t0000;
		++si_n;
		di_n = (word32) di_n + 0x01;
		--cx_n;
	}
	Eq_n ds_n = ss->*(sp_n - 0x02);
	wLoc04_n->*(((char *) bx_n + (cx_n + 0x03)) - 0x01) = 0x00;
	Eq_n es_bx_n = *((word32) ds_n + 11857);
	*((word32) es_bx_n + 0x04) = (byte) (ax_n + (cx_n + 0x03) >> 0x08);
	*((word32) es_bx_n + 0x05) = bLoc08_n + bLoc0A_n;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x00;
	(ss->*(sp_n - 0x06)).u0 = 0x00;
	ss->*(sp_n - 0x08) = cx_n + 0x03;
	fn0800-2688(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
	Eq_n di_n = ss->*sp_n;
	dxOut = wLoc04_n;
	diOut = di_n;
	dsOut = ds_n;
	return dx_n;
}

// 0800:2085: Register byte fn0800-2085(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n psegArg04, Stack Eq_n ptrArg06)
byte fn0800-2085(Eq_n ds, Eq_n ptrArg02, Eq_n psegArg04, Eq_n ptrArg06)
{
	struct Eq_n * psegArg04_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n es_bx_n = *((word32) ds + 11857);
	ui16 ax_n = (DPB(DPB(ax, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) es_bx_n + 0x05), 0), 0x00, 8);
	word16 dx_n = (word32) *((word32) ds + 11857) + ax_n;
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 bx_n = (word32) *((word32) ds + 11857) + (((int16) (*ptrArg06) << 0x08) + DPB(DPB(dx_n, *((word32) ptrArg06 + 0x01), 0), 0x00, 8));
	word16 cx_n = ~cx_n;
	Eq_n dx_n = *((word32) ds + 11859);
	fn0800_B0F3(bx_n - 0x01 + (cx_n + 0x04), *((word32) ds + 11859), bx_n - 0x01, *((word32) ds + 11859), dx_n - (bx_n - 0x01));
	segptr32 ptrLoc06_n = SEQ(dx_n, bx_n - 0x01);
	struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
	struct Eq_n Eq_n::* di_n = (word16) ptrLoc06_n;
	byte Eq_n::* di_n = wArg02_n;
	word16 cx_n = ~0x00;
	segptr32 ptrLoc06_n = SEQ(dx_n, bx_n - 0x01);
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (psegArg04_n->*di_n != 0x00)
			break;
	}
	cu16 cx_n = ~cx_n;
	uint16 cx_n;
	struct Eq_n Eq_n::* si_n = di_n - cx_n;
	struct Eq_n Eq_n::* di_n = di_n;
	for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
	{
		(es_n->*di_n).t0000 = (psegArg04_n->*si_n).t0000;
		si_n += 0x02;
		di_n += 0x02;
	}
	ui16 cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00);
	while (true)
	{
		byte bLoc0E_n = SLICE(cx_n + 0x04, byte, 0);
		byte bLoc0C_n = SLICE(ax_n, byte, 0);
		if (cx_n == 0x00)
			break;
		(es_n->*di_n).t0000 = (psegArg04_n->*si_n).t0000;
		++si_n;
		++di_n;
		--cx_n;
	}
	struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrLoc06_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	if (!Z_n)
	{
		di_n = &Eq_n::b0001;
		es_n = 0x00;
	}
	es_n->*di_n = 0x00;
	struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrLoc06_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	struct Eq_n Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - (es_n->*di_n).b0000), bool, 2);
		++di_n;
		--cx_n;
		if ((es_n->*di_n).b0000 != 0x00)
			break;
	}
	if (!Z_n)
	{
		di_n = &Eq_n::t0001;
		es_n = 0x00;
	}
	di_n[0x01] = 0x00;
	struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrLoc06_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	struct Eq_n Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - (es_n->*di_n).b0000), bool, 2);
		++di_n;
		--cx_n;
		if ((es_n->*di_n).b0000 != 0x00)
			break;
	}
	if (!Z_n)
	{
		di_n = &Eq_n::t0001;
		es_n = 0x00;
	}
	di_n[0x02] = 0x00;
	struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrLoc06_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	struct Eq_n Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - (es_n->*di_n).b0000), bool, 2);
		++di_n;
		--cx_n;
		if ((es_n->*di_n).b0000 != 0x00)
			break;
	}
	if (!Z_n)
	{
		di_n = &Eq_n::t0001;
		es_n = 0x00;
	}
	di_n[0x03] = 0x00;
	Eq_n es_bx_n = *((word32) ds + 11857);
	*((word32) es_bx_n + 0x04) = (byte) (ax_n + (cx_n + 0x04) >> 0x08);
	*((word32) es_bx_n + 0x05) = bLoc0C_n + bLoc0E_n;
	return (byte) DPB(cx_n, fn0800-2688(ds, cx_n + 0x04, 0x00, 0x00, 0x00), 0);
}

// 0800:2201: void fn0800-2201(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04)
void fn0800-2201(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04)
{
	word16 wArg02_n = SLICE(ptrArg02, word16, 0);
	word16 wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg02_n = SLICE(ptrArg02, word16, 0);
	word16 wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n es_bx_n = *((word32) ds + 11857);
	uint16 ax_n = (DPB(DPB(ax, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) es_bx_n + 0x05), 0), 0x00, 8);
	word16 dx_n = (word32) *((word32) ds + 11857) + ax_n;
	uint16 dx_n = (word32) *((word32) ds + 11857) + (((int16) (*ptrArg02) << 0x08) + DPB(DPB(dx_n, *((word32) ptrArg02 + 0x01), 0), 0x00, 8)) - wArg02_n;
	Eq_n ax_n = wArg02_n + dx_n;
	fn0800_B0F3(wArg02_n, wArg04_n, ax_n, wArg04_n, dx_n - ax_n);
	Eq_n es_bx_n = *((word32) ds + 11857);
	*((word32) es_bx_n + 0x04) = (byte) (ax_n - dx_n >> 0x08);
	*((word32) es_bx_n + 0x05) = SLICE(ax_n, byte, 0) - SLICE(dx_n, byte, 0);
	Eq_n ax_n = -dx_n;
	fn0800-2688(ds, ax_n, -0x00 - (ax_n == 0x00), 0x00, 0x00);
	Eq_n dx_n = *((word32) ds + 17838);
	if (*((word32) ds + 0x000045B0) == wArg04_n)
	{
		segptr32 ptrArg02_n = SEQ(wArg04_n, wArg02_n);
		if (dx_n == wArg02_n)
		{
			Eq_n es_n = SLICE(ptrArg02_n, selector, 16);
			byte Eq_n::* di_n = (word16) ptrArg02_n + 0x02;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			word16 cx_n = ~cx_n;
			Eq_n di_n = di_n - cx_n;
			bool Z_n = SLICE(cond(di_n), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
				di_n = (word32) di_n + 0x01;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			if (!Z_n)
			{
				di_n.u0 = 0x01;
				es_n.u0 = 0x00;
			}
			*((word32) ds + 0x000045AC) = es_n;
			*((word32) ds + 0x000045AA) = di_n;
			return;
		}
	}
	if (*((word32) ds + 17838) > wArg02_n)
		*((word32) ds + 0x000045AA) -= dx_n;
}

// 0800:22FE: void fn0800-22FE(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04)
void fn0800-22FE(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04)
{
	Eq_n wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n es_bx_n = *((word32) ds + 11857);
	uint16 ax_n = (DPB(DPB(ax, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) es_bx_n + 0x05), 0), 0x00, 8);
	byte bLoc08_n = SLICE(ax_n, byte, 0);
	word16 dx_n = (word32) *((word32) ds + 11857) + ax_n;
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	if (!Z_n)
		di_n = &Eq_n::b0001;
	Eq_n di_n = di_n + 0x04 - wArg02_n;
	word16 ax_n = wArg02_n + di_n;
	fn0800_B0F3(wArg02_n, wArg04_n, ax_n, wArg04_n, dx_n - ax_n);
	Eq_n es_bx_n = *((word32) ds + 11857);
	*((word32) es_bx_n + 0x04) = (byte) (ax_n - di_n >> 0x08);
	*((word32) es_bx_n + 0x05) = bLoc08_n - SLICE(di_n, byte, 0);
	Eq_n ax_n = -di_n;
	fn0800-2688(ds, ax_n, -0x00 - (ax_n == 0x00), 0x00, 0x00);
	*((word32) ds + 0x000045AC) = wArg04_n;
	word16 dx_n = wArg02_n + di_n;
	*((word32) ds + 0x000045AA) = dx_n;
	if ((dx_n | wArg04_n) == 0x00)
	{
		if (*((word32) ds + 0x000045AA) > wArg02_n)
			*((word32) ds + 0x000045AA) -= di_n;
	}
	else
	{
		*((word32) ds + 0x000045AC) = wArg04_n;
		*((word32) ds + 0x000045AA) = wArg02_n;
	}
}

// 0800:23EC: Register byte fn0800-23EC(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out Eq_n bpOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
byte fn0800-23EC(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, union Eq_n & bpOut, ptr16 & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	segptr32 ptrArg02_n = SEQ(wArg04, wArg02);
	Eq_n ds_n;
	Eq_n si_n = fn0800-24FE(ds, SEQ(wArg04, wArg02), out ds_n);
	struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02_n;
	word16 cx_n = ~0x00;
	segptr32 ptrArg02_n = SEQ(wArg04, wArg02);
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	if (!Z_n)
		di_n = &Eq_n::b0001;
	union Eq_n Eq_n::* bp_n;
	Eq_n ds_n;
	ptr16 si_n;
	word16 cx_n = (word16) fn0800-3C99(si_n, di_n - 0x01, ds_n, out bp_n, out si_n, out ds_n);
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x0A) = ss->*(bp_n - 0x02);
	ss->*((word32) sp_n + 0x08) = ss->*(bp_n - 0x04);
	Eq_n dx_n = -(ss->*(bp_n - 0x08));
	ss->*((word32) sp_n + 0x06) = -(ss->*(bp_n - 0x06)) - (dx_n == 0x00);
	ss->*((word32) sp_n + 0x04) = dx_n;
	fn0800-2688(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A));
	ptr16 di_n = ss->*((word32) sp_n + 0x0C);
	bpOut = ss->*bp_n;
	siOut = si_n;
	diOut = di_n;
	dsOut = ds_n;
	return fn0800-2688(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A));
}

// 0800:24FE: Register word16 fn0800-24FE(Register Eq_n ds, Stack Eq_n ptrArg02, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-24FE(Eq_n ds, Eq_n ptrArg02, struct Eq_n & dsOut)
{
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n ax_n = fn0800_ACB3(ds, *((word32) ds + 10703), *((word32) ds + 10705), 0x00, out cx_n, out dx_n, out bx_n);
	Eq_n stackArg0 = <invalid>;
	word16 dx_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800-8C8A(ax_n, 0x08, fn0800-3E5D(ds, *((word32) ds + 10703), *((word32) ds + 10705), out ds_n, out Top_n), stackArg0, out cl_n, out dx_n);
	Eq_n sp_n = <invalid>;
	if (dx_n != 0x52 || ax_n != 0x4E43)
	{
		ss->*(sp_n - 0x02) = ds_n;
		(ss->*(sp_n - 0x04)).u0 = 0x4348;
		(ss->*(sp_n - 0x06)).u0 = 0x0C;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), stackArg6, out cx_n, out dx_n, out bx_n, out si, out di_n, out es_n, out ds_n, out Top_n);
	}
	struct Eq_n * ds_n;
	if ((ax_n & 0xFF) != 0x00)
	{
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10705);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10703);
		Eq_n ds_n;
		*((word32) ds_n + 10761) = fn0800-3E5D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ds_n, out Top_n);
		*((word32) ds_n + 0x00002A07) = ax_n & 0xFF;
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10705);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10703);
		ds_n->t2A05 = fn0800-3E5D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ds_n, out Top_n);
		ds_n->t2A03 = ax_n & 0xFF;
	}
	else
	{
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10705);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10703);
		Eq_n dx_n = fn0800-3E5D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ds_n, out Top_n);
		ds_n->t2A05 = dx_n;
		ds_n->t2A03 = ax_n & 0xFF;
		ds_n->t2A09 = dx_n;
		ds_n->w2A07 = ax_n & 0xFF;
	}
	dsOut = ds_n;
	return si;
}

// 0800:2688: Register byte fn0800-2688(Register Eq_n ds, Stack Eq_n dwArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08)
byte fn0800-2688(Eq_n ds, Eq_n dwArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08)
{
	Eq_n es_bx_n = *((word32) ds + 11857);
	Eq_n sp_n = fp - 0x12;
	byte cl_n = 0x08;
	Eq_n dx_n = *((word32) ds + 11859);
	Eq_n bx_n = (word16) es_bx_n + ((DPB(DPB(ax, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) es_bx_n + 0x05), 0), 0x00, 8));
	Eq_n wLoc04_n = *((word32) ds + 11859);
	Eq_n wLoc06_n = (word32) *((word32) ds + 11857) + 0x08;
	while (wLoc04_n != dx_n || wLoc06_n != bx_n)
	{
		Eq_n dx_n = wLoc06_n;
		byte * ptrLoc06_n = SEQ(wLoc04_n, (word32) wLoc06_n + 0x02);
		struct Eq_n * ptrLoc0E_n = SEQ(wLoc04_n, wLoc06_n);
		do
		{
			ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
			word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
			word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
			word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
			byte * ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
			ptrLoc06_n = ptrLoc06_n;
		} while (*ptrLoc06_n != 0x00);
		while (true)
		{
			word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
			wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
			if (*ptrLoc06_n == 0x00)
				break;
			do
			{
				ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
				word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
				word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
				word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
				struct Eq_n * ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
				word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
				wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
				wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
				Eq_n ptrLoc06_n = SLICE(ptrLoc06_n, word16, 16);
				ptrLoc06_n.u0 = SLICE(ptrLoc06_n, word16, 16);
				ptrLoc06_n.u0 = SLICE(ptrLoc06_n, word16, 16);
				ptrLoc06_n = ptrLoc06_n;
			} while (*ptrLoc06_n != 0x00);
			ui16 Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = (ui16) ((word32) DPB(DPB(dx_n, ptrLoc06_n->b0001, 0), 0x00, 8) + ((int16) ptrLoc06_n->b0000 << 0x08));
			Eq_n ax_n = ((int16) ptrLoc06_n->b0002 << 0x08) + DPB(DPB((word16) ptrLoc06_n, ptrLoc06_n->b0003, 0), 0x00, 8);
			dx_n = ax_n;
			sp_n = sp_n + 0x01;
			Eq_n ax_n = (bool) (ax_n < 0x00) + ss->*sp_n;
			byte bLoc12_n = SLICE(ax_n, byte, 0);
			if (ax_n >= wArg08 && (ax_n != wArg08 || ax_n >= wArg06))
			{
				ui32 dwArg02_n = SEQ(wArg04, wArg02);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				int32 dx_ax_n = (int32) SLICE(SEQ(ax_n, ax_n) + dwArg02_n, word16, 16);
				Eq_n stackArg0 = <invalid>;
				ptrLoc06_n->b0000 = (byte) fn0800-8C8A((word16) dx_ax_n, 0x08, SLICE(dx_ax_n, word16, 16), stackArg0, out cl_n, out dx_n);
				ui32 dwArg02_n = SEQ(SLICE(dwArg02_n, word16, 16), SLICE(dwArg02_n, word16, 0));
				ptrLoc06_n->b0001 = (byte) (int32) SLICE(SEQ(ax_n, ax_n) + dwArg02_n, word16, 16);
				ui32 dwArg02_n = SEQ(SLICE(dwArg02_n, word16, 16), SLICE(dwArg02_n, word16, 0));
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				int32 dx_ax_n = SEQ(ax_n, ax_n) + dwArg02_n;
				Eq_n stackArg0 = <invalid>;
				ptrLoc06_n->b0002 = (byte) fn0800-8C8A((word16) dx_ax_n, 0x08, SLICE(dx_ax_n, word16, 16), stackArg0, out cl_n, out dx_n);
				ptrLoc06_n->b0003 = bLoc12_n + SLICE(dwArg02_n, byte, 0);
				wArg04 = SLICE(dwArg02_n, word16, 16);
				wArg02 = SLICE(dwArg02_n, word16, 0);
				sp_n.u0 = <invalid>;
			}
			ptrLoc06_n = SEQ(SLICE(ptrLoc06_n, word16, 16), wLoc06_n + 0x04);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n ax_n = wLoc06_n + 0x01 - *((word32) ds + 11857);
		Eq_n stackArg0 = <invalid>;
		ptrLoc0E_n->b0000 = (byte) fn0800-8C8A(ax_n, 0x08, 0x00 - (ax_n < 0x00), stackArg0, out cl_n, out dx_n);
		ptrLoc0E_n->b0001 = (byte) (wLoc06_n + 0x01 - *((word32) ds + 11857));
		wLoc06_n = wLoc06_n + 0x01;
		sp_n.u0 = <invalid>;
	}
	if ((wArg06 | wArg08) == 0x00)
	{
		*((word32) ds + 0x000045A6) = v22_n;
		ui32 v23_v22_n = SEQ(*((word32) ds + 0x000045A8), *((word32) ds + 0x000045A6)) + SEQ(wArg04, wArg02);
		*((word32) ds + 0x000045A8) = SLICE(v23_v22_n, word16, 16);
		uint16 v22_n = (word16) v23_v22_n;
	}
	return cl_n;
}

// 0800:283D: Register word16 fn0800-283D(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out ptr16 dxOut)
word16 fn0800-283D(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, ptr16 & dxOut)
{
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	Eq_n di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x3A - es_n->*di_n), bool, 2);
		di_n = (word32) di_n + 0x01;
		--cx_n;
		if (es_n->*di_n != 0x3A)
			break;
	}
	if (!Z_n)
	{
		di_n.u0 = 0x01;
		es_n = 0x00;
	}
	struct Eq_n * ax_n = es_n;
	if ((di_n - 0x01 | es_n) != 0x00)
	{
		struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
		byte Eq_n::* di_n = (word16) ptrArg02;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 cx_n = ~cx_n;
		byte Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x3A - es_n->*di_n), bool, 2);
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x3A)
				break;
		}
		if (!Z_n)
		{
			di_n = &Eq_n::b0001;
			es_n = 0x00;
		}
		ax_n = es_n;
		ptrArg02 = &(es_n->*di_n);
	}
	Eq_n es_bx_n = *((word32) ds + 11857);
	Eq_n dx_n = *((word32) ds + 11859);
	word16 bx_n = (word16) es_bx_n + ((DPB(DPB(ax_n, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) es_bx_n + 0x05), 0), 0x00, 8));
	Eq_n wLoc08_n = *((word32) ds + 11859);
	word16 wLoc0A_n = (word16) ((word32) ds + 11857)->u0 + 0x08;
	while (wLoc08_n != dx_n || wLoc0A_n != bx_n)
	{
		struct Eq_n * ptrLoc0A_n = SEQ(wLoc08_n, wLoc0A_n);
		byte Eq_n::* si_n = wLoc0A_n + 0x02;
		struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
		byte Eq_n::* di_n = (word16) ptrArg02;
		word16 ax_n = 0x00;
		word16 cx_n = ~0x00;
		ptr16 wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
		word16 wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
		wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
		do
		{
			ax_n = DPB(ax_n, 0x00, 0);
			ax_n = DPB(ax_n, 0x00, 0);
			if (cx_n == 0x00)
				break;
			++di_n;
			--cx_n;
		} while (es_n->*di_n == 0x00);
		word16 cx_n = ~cx_n;
		Eq_n di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		di_n = di_n;
		do
		{
			Eq_n di_n;
			if (cx_n == 0x00)
				break;
			Z_n = SLICE(cond(wLoc08_n->*si_n - es_n->*di_n), bool, 2);
			si_n = si_n + 0x01;
			di_n = (word16) di_n + 0x01;
			--cx_n;
			si_n = si_n;
			di_n = di_n;
		} while (wLoc08_n->*si_n != es_n->*di_n);
		if (!Z_n)
		{
			cup16 ax_n = 0x00 - (di_n < 0x00);
			ax_n = ax_n - ~0x00 - (ax_n < 0x00);
		}
		if (ax_n == 0x00)
		{
			dxOut = wLoc08_n;
			return wLoc0A_n;
		}
		wLoc0A_n = (word16) ((word32) ds + 11857)->u0 + (((int16) ptrLoc0A_n->b0000 << 0x08) + DPB(DPB(wLoc0A_n, ptrLoc0A_n->b0001, 0), 0x00, 8));
	}
	dxOut = 0x00;
	return 0x00;
}

// 0800:2931: Register word16 fn0800-2931(Stack Eq_n ptrArg02, Stack Eq_n ptrArg06, Stack Eq_n wArg08, Register out ptr16 dxOut)
word16 fn0800-2931(Eq_n ptrArg02, Eq_n ptrArg06, Eq_n wArg08, ptr16 & dxOut)
{
	struct Eq_n * es_n = SLICE(ptrArg06, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg06 + 0x02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	if (!Z_n)
	{
		di_n = &Eq_n::b0001;
		es_n = 0x00;
	}
	byte * ptrArg06_n = &(es_n->*di_n);
	while (true)
	{
		byte Eq_n::* wArg06_n = SLICE(ptrArg06_n, word16, 0);
		struct Eq_n * wArg08_n = SLICE(ptrArg06_n, word16, 16);
		if (*ptrArg06_n == 0x00)
			break;
		segptr32 ptrArg06_n = &(wArg08_n->*wArg06_n);
		byte Eq_n::* si_n = wArg06_n;
		struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
		byte Eq_n::* di_n = (word16) ptrArg02;
		word16 ax_n = 0x00;
		word16 cx_n = ~0x00;
		ptr16 wArg08_n = SLICE(ptrArg06_n, word16, 16);
		word16 wArg06_n = SLICE(ptrArg06_n, word16, 0);
		do
		{
			ax_n = DPB(ax_n, 0x00, 0);
			ax_n = DPB(ax_n, 0x00, 0);
			if (cx_n == 0x00)
				break;
			++di_n;
			--cx_n;
		} while (es_n->*di_n == 0x00);
		word16 cx_n = ~cx_n;
		Eq_n di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		di_n = di_n;
		do
		{
			Eq_n di_n;
			if (cx_n == 0x00)
				break;
			Z_n = SLICE(cond(wArg08_n->*si_n - es_n->*di_n), bool, 2);
			si_n = si_n + 0x01;
			di_n = (word16) di_n + 0x01;
			--cx_n;
			si_n = si_n;
			di_n = di_n;
		} while (wArg08_n->*si_n != es_n->*di_n);
		if (!Z_n)
		{
			cup16 ax_n = 0x00 - (di_n < 0x00);
			ax_n = ax_n - ~0x00 - (ax_n < 0x00);
		}
		if (ax_n == 0x00)
		{
			dxOut = wArg08_n;
			return wArg06_n;
		}
		struct Eq_n * es_n = SLICE(ptrArg06_n, selector, 16);
		byte Eq_n::* di_n = (word16) ptrArg06_n;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		word16 cx_n = ~cx_n;
		byte Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		if (!Z_n)
		{
			di_n = &Eq_n::b0001;
			es_n = 0x00;
		}
		ptrArg06_n = &(es_n->*(di_n + 0x04));
		Mem76 = Mem216;
	}
	dxOut = 0x00;
	return 0x00;
}

// 0800:29C5: Register word16 fn0800-29C5(Register Eq_n cx, Register Eq_n dx, Register Eq_n si, Register Eq_n di, Register Eq_n ds, Register out Eq_n bpOut, Register out Eq_n siOut, Register out Eq_n diOut, Register out Eq_n dsOut)
word16 fn0800-29C5(Eq_n cx, Eq_n dx, Eq_n si, Eq_n di, Eq_n ds, union Eq_n & bpOut, union Eq_n & siOut, union Eq_n & diOut, union Eq_n & dsOut)
{
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	mp16 sp_n = fp - 0x7E;
	if ((*((word32) ds + 17838) | *((word32) ds + 0x000045B0)) == 0x00 && (*((word32) ds + 0x000045AA) | *((word32) ds + 0x000045AC)) == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n sp_n = <invalid>;
		Eq_n stackArg4 = <invalid>;
		cx.u0 = <invalid>;
		sp_n = (mp16) ((word32) sp_n + 0x04);
		if (fn0800-2DE2(cx, dx, si, di, ds, SEQ(ds, 0x4541), stackArg4, out ch_n, out bp_n, out si, out di, out ds) == 0x00)
		{
			Eq_n di_n = ss->*((word32) sp_n + 0x04);
			Eq_n si_n = ss->*((word32) sp_n + 0x06);
			bpOut = (ss->*bp_n).t0000;
			siOut = si_n;
			diOut = di_n;
			dsOut = ds;
			return 0x00;
		}
		Eq_n dx_n = *((word32) ds + 11857);
		*((word32) ds + 0x000045B0) = *((word32) ds + 11859);
		*((word32) ds + 17838) = (word32) dx_n + 0x08;
	}
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	ss->*sp_n = ds;
	(ss->*(sp_n - 0x02)).u0 = 0x4541;
	ss->*(sp_n - 0x04) = ss;
	ss->*(sp_n - 0x06) = bp_n - 0x6A;
	fn0800-3509(si, di, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out bx_n);
	ss->*sp_n = ds;
	(ss->*(sp_n - 0x02)).u0 = 0x4541;
	ss->*(sp_n - 0x04) = ss;
	ss->*(sp_n - 0x06) = bp_n - 0x78;
	fn0800-35A3(si, di, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n);
	Eq_n es_bx_n = *((word32) ds + 11857);
	Eq_n bx_n = (word16) es_bx_n + ((DPB(DPB(ax_n, *((word32) es_bx_n + 0x04), 0), 0x00, 8) << 0x08) + DPB(DPB(dx_n, *((word32) es_bx_n + 0x05), 0), 0x00, 8));
	ss->*(bp_n - 0x02) = *((word32) ds + 11859);
	ss->*(bp_n - 0x04) = bx_n;
	Eq_n cx_n = DPB(cx, 0x08, 0);
	while (true)
	{
		Eq_n dx_n = *((word32) ds + 17838);
		if (*((word32) ds + 0x000045B0) == ss->*(bp_n - 0x02) && dx_n == ss->*(bp_n - 0x04))
			break;
		if ((*((word32) ds + 0x000045AA) | *((word32) ds + 0x000045AC)) != 0x00)
		{
			while (**((word32) ds + 0x000045AA) != 0x00)
			{
				struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).t0000 = ss;
				ss->*(sp_n - 0x02) = bp_n - 0x78;
				ss->*(sp_n - 0x04) = *((word32) ds + 0x000045AC);
				ss->*(sp_n - 0x06) = *((word32) ds + 0x000045AA);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				Eq_n stackArg8 = <invalid>;
				dx_n = DPB(dx_n, dl_n, 0);
				if (fn0800-4357(ss->*(sp_n - 0x06), stackArg4, ss->*(sp_n - 0x02), stackArg8) != 0x00)
				{
					Eq_n es_bx_n = (ss->*bp_n).t0004;
					Eq_n dx_n = *((word32) ds + 17838);
					*((word32) es_bx_n + 0x02) = *((word32) ds + 0x000045B0);
					*es_bx_n = dx_n;
					Eq_n es_bx_n = (ss->*bp_n).t0008;
					Eq_n dx_n = *((word32) ds + 0x000045AA);
					*((word32) es_bx_n + 0x02) = *((word32) ds + 0x000045AC);
					*es_bx_n = dx_n;
					Eq_n es_di_n = *((word32) ds + 17838);
					(ss->*sp_n).t0000 = SLICE(es_di_n, selector, 16);
					Eq_n es_n = (ss->*bp_n).t000E;
					ss->*(sp_n - 0x02) = (word16) es_di_n + 0x02;
					Eq_n di_n = (ss->*bp_n).t000C;
					Eq_n di_n = ss->*(sp_n - 0x02);
					Eq_n es_n = (ss->*sp_n).t0000;
					(ss->*sp_n).t0000 = es_n;
					ss->*(sp_n - 0x02) = di_n;
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						di_n = (word32) di_n + 0x01;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					Eq_n di_n = ss->*(sp_n - 0x02);
					Eq_n es_n = (ss->*sp_n).t0000;
					(ss->*sp_n).t0000 = ds;
					cu16 cx_n = ~cx_n;
					uint16 cx_n;
					struct Eq_n Eq_n::* si_n = di_n - cx_n;
					for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
					{
						es_n->*di_n = (es_n->*si_n).t0000;
						si_n += 0x02;
						di_n = (word32) di_n + 0x02;
					}
					ui16 cx_n;
					for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
					{
						es_n->*di_n = (es_n->*si_n).t0000;
						++si_n;
						di_n = (word32) di_n + 0x01;
					}
					Eq_n es_di_n = (ss->*bp_n).t000C;
					Eq_n ds_n = (ss->*sp_n).t0000;
					(ss->*sp_n).t0000 = SLICE(es_di_n, selector, 16);
					Eq_n es_n = *((word32) ds_n + 0x000045AC);
					ss->*(sp_n - 0x02) = (word16) es_di_n;
					Eq_n di_n = *((word32) ds_n + 0x000045AA);
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						di_n = (word32) di_n + 0x01;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					Eq_n cx_n = ~cx_n;
					Eq_n di_n = ss->*(sp_n - 0x02);
					Eq_n es_n = (ss->*sp_n).t0000;
					(ss->*sp_n).t0000 = cx_n;
					byte Eq_n::* si_n = di_n - cx_n;
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						di_n = (word32) di_n + 0x01;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					byte Eq_n::* di_n = di_n - 0x01;
					Eq_n cx_n;
					for (cx_n = (ss->*sp_n).t0000; cx_n != 0x00; --cx_n)
					{
						es_n->*di_n = es_n->*si_n;
						++si_n;
						++di_n;
					}
					Eq_n es_di_n = *((word32) ds_n + 0x000045AA);
					Eq_n es_n = SLICE(es_di_n, selector, 16);
					byte Eq_n::* di_n = (word16) es_di_n;
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						++di_n;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					word16 cx_n = ~cx_n;
					byte Eq_n::* di_n = di_n - cx_n;
					bool Z_n = SLICE(cond(di_n), bool, 2);
					while (cx_n != 0x00)
					{
						Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
						++di_n;
						--cx_n;
						if (es_n->*di_n != 0x00)
							break;
					}
					if (!Z_n)
					{
						di_n = 0x01;
						es_n.u0 = 0x00;
					}
					*((word32) ds_n + 0x000045AC) = es_n;
					*((word32) ds_n + 0x000045AA) = di_n + 0x04;
					Eq_n di_n = (ss->*sp_n).t0002;
					Eq_n si_n = (ss->*sp_n).t0004;
					bpOut = (ss->*bp_n).t0000;
					siOut = si_n;
					diOut = di_n;
					dsOut = ds_n;
					return 0x01;
				}
				Eq_n es_di_n = *((word32) ds + 0x000045AA);
				Eq_n es_n = SLICE(es_di_n, selector, 16);
				byte Eq_n::* di_n = (word16) es_di_n;
				word16 cx_n = ~0x00;
				while (cx_n != 0x00)
				{
					++di_n;
					--cx_n;
					if (es_n->*di_n != 0x00)
						break;
				}
				word16 cx_n = ~cx_n;
				byte Eq_n::* di_n = di_n - cx_n;
				bool Z_n = SLICE(cond(di_n), bool, 2);
				while (cx_n != 0x00)
				{
					Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
					++di_n;
					--cx_n;
					if (es_n->*di_n != 0x00)
						break;
				}
				if (!Z_n)
				{
					di_n = 0x01;
					es_n.u0 = 0x00;
				}
				*((word32) ds + 0x000045AC) = es_n;
				*((word32) ds + 0x000045AA) = di_n + 0x04;
			}
			Eq_n es_bx_n = *((word32) ds + 17838);
			Eq_n bx_n = (word32) *((word32) ds + 11857) + ((word32) DPB(DPB(dx_n, *((word32) es_bx_n + 0x01), 0), 0x00, 8) + ((int16) (*es_bx_n) << 0x08));
			*((word32) ds + 0x000045B0) = *((word32) ds + 11859);
			*((word32) ds + 17838) = bx_n;
		}
		while (true)
		{
			Eq_n dx_n = *((word32) ds + 17838);
			if (*((word32) ds + 0x000045B0) == (ss->*(bp_n - 0x02)).t0000 && dx_n == (ss->*(bp_n - 0x04)).t0000)
				break;
			if (*((word32) ds + 10779) != 0x00)
			{
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = ss;
				Eq_n es_n = ss->*sp_n;
				struct Eq_n Eq_n::* di_n = bp_n - 0x6A;
				word16 cx_n = ~0x00;
				while (cx_n != 0x00)
				{
					di_n = (struct Eq_n Eq_n::*) ((char *) &di_n->t0000 + 0x01);
					--cx_n;
					di_n = di_n;
					if ((es_n->*di_n).t0000 != 0x00)
						break;
				}
				ss->*sp_n = ~cx_n - 0x01;
				ss->*(sp_n - 0x02) = ss;
				ss->*(sp_n - 0x04) = bp_n - 0x6A;
				Eq_n ax_n = *((word32) ds + 17838);
				ss->*(sp_n - 0x06) = *((word32) ds + 0x000045B0);
				ss->*(sp_n - 0x08) = (word32) ax_n + 0x02;
				if (fn0800_BFE6(ss->*(sp_n - 0x08), ss->*(sp_n - 0x04), ss->*sp_n) == 0x00)
					break;
			}
			if (*((word32) ds + 10779) == 0x00)
			{
				si = (word32) *((word32) ds + 17838) + 0x02;
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = ds;
				Eq_n ds_n = *((word32) ds + 0x000045B0);
				ss->*(sp_n - 0x02) = ss;
				Eq_n es_n = ss->*(sp_n - 0x02);
				struct Eq_n Eq_n::* di_n = bp_n - 0x6A;
				word16 ax_n = 0x00;
				word16 cx_n = ~0x00;
				do
				{
					ax_n = DPB(ax_n, 0x00, 0);
					ax_n = DPB(ax_n, 0x00, 0);
					if (cx_n == 0x00)
						break;
					++di_n;
					--cx_n;
				} while ((es_n->*di_n).b0000 == 0x00);
				ui16 cx_n = ~cx_n;
				Eq_n di_n = di_n - cx_n;
				bool Z_n = SLICE(cond(di_n), bool, 2);
				di_n = di_n;
				do
				{
					Eq_n di_n;
					if (cx_n == 0x00)
						break;
					Z_n = SLICE(cond(ds_n->*si - es_n->*di_n), bool, 2);
					si = (word32) si + 0x01;
					di_n = (word16) di_n + 0x01;
					--cx_n;
					di_n = di_n;
				} while (ds_n->*si != es_n->*di_n);
				if (!Z_n)
				{
					cup16 ax_n = 0x00 - (di_n < 0x00);
					ax_n = ax_n - ~0x00 - (ax_n < 0x00);
				}
				ds = ss->*sp_n;
				if (ax_n == 0x00)
					break;
			}
			Eq_n es_bx_n = *((word32) ds + 17838);
			Eq_n bx_n = (word32) *((word32) ds + 11857) + ((word32) DPB(DPB(dx_n, *((word32) es_bx_n + 0x01), 0), 0x00, 8) + ((int16) (*es_bx_n) << 0x08));
			*((word32) ds + 0x000045B0) = *((word32) ds + 11859);
			*((word32) ds + 17838) = bx_n;
		}
		Eq_n es_di_n = *((word32) ds + 17838);
		Eq_n es_n = SLICE(es_di_n, selector, 16);
		byte Eq_n::* di_n = (word16) es_di_n + 0x02;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		cx_n = ~cx_n;
		byte Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x00 - es_n->*di_n), bool, 2);
			++di_n;
			--cx_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		if (!Z_n)
		{
			di_n = 0x01;
			es_n.u0 = 0x00;
		}
		byte Eq_n::* di_n = di_n - 0x01;
		*((word32) ds + 0x000045AC) = es_n;
		*((word32) ds + 0x000045AA) = di_n + 0x01;
		di = di_n + 0x01;
	}
	((word32) ds + 0x000045AC)->u0 = 0x00;
	((word32) ds + 0x000045AA)->u0 = 0x00;
	((word32) ds + 0x000045B0)->u0 = 0x00;
	((word32) ds + 17838)->u0 = 0x00;
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	ss->*sp_n = (ss->*bp_n).t000E;
	ss->*(sp_n - 0x02) = (ss->*bp_n).t000C;
	ss->*(sp_n - 0x04) = (ss->*bp_n).t000A;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0008;
	ss->*(sp_n - 0x08) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x0A) = (ss->*bp_n).t0004;
	word16 ax_n = fn0800-29C5(cx_n, 0x00, si, di, ds, out bp_n, out si_n, out di_n, out ds_n);
	Eq_n sp_n = <invalid>;
	Eq_n di_n = ss->*((word32) sp_n + 0x0C);
	Eq_n si_n = ss->*((word32) sp_n + 0x0E);
	bpOut = (ss->*bp_n).t0000;
	siOut = si_n;
	diOut = di_n;
	dsOut = ds;
	return ax_n;
}

// 0800:2C9A: Register Eq_n fn0800-2C9A(Register Eq_n ds, Register out Eq_n dxOut, Register out ptr16 bxOut)
Eq_n fn0800-2C9A(Eq_n ds, union Eq_n & dxOut, ptr16 & bxOut)
{
	Eq_n cx_n = 0x00;
	word16 si_n = 0x2A29;
	do
	{
		Eq_n dx_n = cx_n;
		ptr16 bx_n;
		for (bx_n = 0x08; bx_n != 0x00; --bx_n)
		{
			Eq_n ax_n;
			if ((dx_n & 0x01) != 0x00)
				ax_n = dx_n >> 0x01 ^ 0xA001;
			else
				ax_n = dx_n >> 0x01;
			dx_n = ax_n;
		}
		ds->*si_n = dx_n;
		++si_n;
		cx_n = (word32) cx_n + 0x01;
	} while (cx_n < 0x0100);
	dxOut = dx_n;
	bxOut = bx_n;
	return cx_n;
}

// 0800:2CCF: Register word16 fn0800-2CCF(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n bArg09, Register out Eq_n clOut, Register out Eq_n dxOut)
word16 fn0800-2CCF(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n bArg09, union Eq_n & clOut, union Eq_n & dxOut)
{
	byte bArg09_n = SLICE(wArg08, byte, 8);
	Eq_n si_n = wArg06;
	Eq_n bArg09_n = SEQ(bArg09_n, bArg08);
	while (true)
	{
		byte bArg09_n = SLICE(bArg09_n, byte, 8);
		byte bArg09_n = SLICE(bArg09_n, byte, 8);
		word16 wArg02_n = SLICE(ptrArg02, word16, 0);
		word16 wArg04_n = SLICE(ptrArg02, word16, 16);
		--si_n;
		word16 wArg08_n = SEQ(bArg09_n, bArg08);
		if (si_n == 0x00)
			break;
		cu16 wArg08_n = SEQ(bArg09_n, bArg08);
		word16 ax_n = SEQ(ds, 0x2A29)[(DPB(DPB(si_n, bArg08 ^ Mem22[ptrArg02 + 0x00:byte], 0), 0x00, 8) & 0xFF) * 0x02] ^ wArg08_n >>u 0x08;
		cl.u0 = 0x08;
		dx = wArg08_n >> 0x08;
		bArg08 = SLICE(ax_n, byte, 0);
		bArg09_n.u0 = SLICE(ax_n, byte, 8);
		ptrArg02 = SEQ(wArg04_n, wArg02_n + 0x01);
		Mem22 = Mem43;
	}
	clOut = cl;
	dxOut = dx;
	return wArg08_n;
}

// 0800:2D0A: Register Eq_n fn0800-2D0A(Register out ptr16 dxOut, Register out Eq_n bpOut, Register out (ptr16 Eq_n) dsOut)
Eq_n fn0800-2D0A(ptr16 & dxOut, union Eq_n & bpOut, struct Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg2 = <invalid>;
	Eq_n stackArg4 = <invalid>;
	struct Eq_n Eq_n::* bp_n;
	Eq_n dx_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	ss->*(bp_n - 0x02) = dx_n;
	ss->*(bp_n - 0x04) = ax_n;
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x02) = (ss->*bp_n).t0006;
	ss->*sp_n = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800_AD2F(ds_n, ss->*sp_n, stackArg4, out dx_n);
	(ss->*(bp_n - 0x0A)).t0000 = dx_n;
	(ss->*(bp_n - 0x0C)).t0000 = ax_n;
	Eq_n si_n = 0x00;
	while (((ss->*bp_n).t0008 | (ss->*bp_n).t000A) != 0x00)
	{
		Eq_n ax_n;
		Eq_n dx_n;
		if ((ss->*bp_n).t000A >= 0x00 && ((ss->*bp_n).t000A > 0x00 || (ss->*bp_n).t0008 > ~0x0F))
		{
			dx_n.u0 = 0x00;
			ax_n.u0 = ~0x0F;
		}
		else
		{
			dx_n = (ss->*bp_n).t000A;
			ax_n = (ss->*bp_n).t0008;
		}
		(ss->*(bp_n - 0x06)).t0000 = dx_n;
		(ss->*(bp_n - 0x08)).t0000 = ax_n;
		ss->*((word32) sp_n + 0x02) = (ss->*bp_n).t0006;
		ss->*sp_n = (ss->*bp_n).t0004;
		(ss->*(sp_n - 0x02)).t0000 = (ss->*(bp_n - 0x06)).t0000;
		(ss->*(sp_n - 0x04)).t0000 = ax_n;
		(ss->*(sp_n - 0x06)).t0000 = (ss->*(bp_n - 0x02)).t0000;
		(ss->*(sp_n - 0x08)).t0000 = (ss->*(bp_n - 0x04)).t0000;
		Eq_n si_n;
		fn0800-4110(ds_n, (ss->*(sp_n - 0x08)).t0000, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out si_n, out di_n, out ds_n);
		ss->*((word32) sp_n + 0x02) = si_n;
		ss->*sp_n = (ss->*(bp_n - 0x08)).t0000;
		(ss->*(sp_n - 0x02)).t0000 = (ss->*(bp_n - 0x02)).t0000;
		(ss->*(sp_n - 0x04)).t0000 = (ss->*(bp_n - 0x04)).t0000;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n stackArg9 = <invalid>;
		si_n = fn0800-2CCF(ds_n, (ss->*(sp_n - 0x04)).t0000, stackArg4, ss->*sp_n, ss->*((word32) sp_n + 0x02), stackArg9, out cl_n, out dx_n);
		Eq_n ax_n = (ss->*(bp_n - 0x06)).t0000;
		Eq_n dx_n = (ss->*(bp_n - 0x08)).t0000;
		(ss->*bp_n).t0008 = v29_n;
		(ss->*bp_n).t0008 = SEQ((ss->*bp_n).t000A, (ss->*bp_n).t0008);
		ui32 v30_v29_n = (ss->*bp_n).t0008 - SEQ(ax_n, dx_n);
		(ss->*bp_n).t000A = SLICE(v30_v29_n, word16, 16);
		Eq_n v29_n = (word16) v30_v29_n;
	}
	(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
	ss->*sp_n = (ss->*(bp_n - 0x0A)).t0000;
	(ss->*(sp_n - 0x02)).t0000 = (ss->*(bp_n - 0x0C)).t0000;
	(ss->*(sp_n - 0x04)).t0000 = (ss->*bp_n).t0006;
	(ss->*(sp_n - 0x06)).t0000 = (ss->*bp_n).t0004;
	fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
	ss->*((word32) sp_n + 0x02) = (ss->*(bp_n - 0x02)).t0000;
	ss->*sp_n = (ss->*(bp_n - 0x04)).t0000;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg2 = <invalid>;
	struct Eq_n * ds_n;
	ptr16 dx_n;
	fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n);
	Eq_n bp_n = (ss->*bp_n).t0000;
	dxOut = dx_n;
	bpOut = bp_n;
	dsOut = ds_n;
	return si_n;
}

// 0800:2DBF: void fn0800-2DBF(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04)
void fn0800-2DBF(Eq_n ds, Eq_n wArg02, Eq_n wArg04)
{
	*((word32) ds + 0x00004656) = ~0x00;
	*((word32) ds + 0x00004654) = 0x00;
	*((word32) ds + 18002) = *((word32) ds + 0x00002A27);
	*((word32) ds + 18000) = wArg02;
	*((word32) ds + 0x0000464E) = wArg04;
}

// 0800:2DE2: Register word16 fn0800-2DE2(Register Eq_n cx, Register Eq_n dx, Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out Eq_n chOut, Register out Eq_n bpOut, Register out Eq_n siOut, Register out Eq_n diOut, Register out Eq_n dsOut)
word16 fn0800-2DE2(Eq_n cx, Eq_n dx, Eq_n si, Eq_n di, Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, union Eq_n & chOut, union Eq_n & bpOut, union Eq_n & siOut, union Eq_n & diOut, union Eq_n & dsOut)
{
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n wArg02_n = SLICE(ptrArg02, word16, 0);
	wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n si_n;
	si_n = si;
	if (*((word32) ds + 0x00004654) == 0x00)
	{
		si_n = si;
		if (*((word32) ds + 18002) == *((word32) ds + 0x00004656))
		{
			si_n = si;
			if (*((word32) ds + 0x0000464E) != 0x00)
				si_n = fn0800-3479(ds, fp - 0x12, ss, 0x00, out cx, out dx);
		}
	}
	Eq_n di_n;
	if (*((word32) ds + 0x00004654) == 0x00)
		di_n = di;
	else
	{
		*((word32) ds + 0x00004617) = 0x00;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg10 = <invalid>;
		Eq_n dx_n;
		if ((fn0800_A77D(ds, 0x45B2, ds, 101, SEQ(*((word32) ds + 17949), *((word32) ds + 17947)), stackArg10, out dx_n) | dx_n) == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			struct Eq_n Eq_n::* bp_n;
			Eq_n cx_n;
			Eq_n di_n;
			Eq_n dx_n;
			Eq_n si_n;
			Eq_n ds_n;
			fn0800_A614(ds, SEQ(*((word32) ds + 17949), *((word32) ds + 17947)), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			*((word32) ds_n + 0x00004654) = 0x00;
			((word32) ds_n + 17949)->u0 = 0x00;
			((word32) ds_n + 17947)->u0 = 0x00;
			++*((word32) ds_n + 18002);
			Eq_n sp_n = <invalid>;
			ss->*((word32) sp_n + 0x02) = (ss->*bp_n).w0006;
			ss->*sp_n = (ss->*bp_n).w0004;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			Eq_n stackArg4 = <invalid>;
			word16 ax_n = fn0800-2DE2(cx_n, dx_n, si_n, di_n, ds_n, stackArg2, stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n);
			Eq_n di_n = ss->*((word32) sp_n + 0x04);
			Eq_n si_n = ss->*((word32) sp_n + 0x06);
			Eq_n bp_n = (ss->*bp_n).t0000;
			chOut.u0 = <invalid>;
			bpOut = bp_n;
			siOut = si_n;
			diOut = di_n;
			dsOut = ds_n;
			return ax_n;
		}
		Eq_n es_n = ds;
		word16 di_n = 0x45B2;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		Eq_n cx_n = ~cx_n;
		Eq_n di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x0D - ds->*di_n), bool, 2);
			di_n = (word32) di_n + 0x01;
			--cx_n;
			if (ds->*di_n != 0x0D)
				break;
		}
		if (!Z_n)
		{
			di_n.u0 = 0x01;
			es_n.u0 = 0x00;
		}
		Eq_n di_n = di_n - 0x01 | es_n;
		if (di_n != 0x00)
		{
			Eq_n es_n = ds;
			word16 di_n = 0x45B2;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (ds->*di_n != 0x00)
					break;
			}
			cx_n = ~cx_n;
			byte Eq_n::* di_n = di_n - cx_n;
			bool Z_n = SLICE(cond(di_n), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(0x0D - ds->*di_n), bool, 2);
				++di_n;
				--cx_n;
				if (ds->*di_n != 0x0D)
					break;
			}
			if (!Z_n)
			{
				di_n = 0x01;
				es_n.u0 = 0x00;
			}
			di_n = di_n - 0x01;
			es_n->*di_n = 0x00;
		}
		if ((int16) *((word32) ds + 0x000045B2) == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			word16 ax_n = fn0800-2DE2(cx_n, dx_n, si_n, di_n, ds, wArg02_n, stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n);
			chOut.u0 = <invalid>;
			bpOut = bp;
			siOut = si;
			diOut = di;
			dsOut = ds;
			return ax_n;
		}
		di_n.u0 = 0x45B2;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = (byte) di_n.u0 + 0x01;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		*((word32) ds + 0x00004619) = ~cx_n - 0x01;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-0C6C(ds, SEQ(ds, 0x45B2), stackArg4);
		if (*((word32) ds + 0x0000464E) == 0x00)
		{
			struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
			struct Eq_n Eq_n::* di_n = (word16) ptrArg02;
			word16 di_n = 0x45B2;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (ds->*di_n != 0x00)
					break;
			}
			cu16 cx_n = ~cx_n;
			uint16 cx_n;
			struct Eq_n Eq_n::* si_n = di_n - cx_n;
			struct Eq_n Eq_n::* di_n = di_n;
			for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
			{
				(es_n->*di_n).t0000 = (ds->*si_n).t0000;
				si_n += 0x02;
				di_n += 0x02;
			}
			ui16 cx_n;
			for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
			{
				(es_n->*di_n).t0000 = (ds->*si_n).t0000;
				++si_n;
				++di_n;
			}
			++*((word32) ds + 0x00004617);
			chOut.u0 = <invalid>;
			bpOut = bp;
			siOut = si;
			diOut = di;
			dsOut = ds;
			return 0x01;
		}
		si_n = fn0800-33CD(ds, fp - 0x12, ss, 0x00, 0x45B2, ds, out cx, out dx);
		*((word32) ds + 0x00004654) = 0x00;
	}
	ui16 ax_n = *((word32) ds + 18002);
	if (ax_n != *((word32) ds + 0x00004656))
	{
		if (ax_n == *((word32) ds + 9882))
		{
			chOut.u0 = <invalid>;
			bpOut = bp;
			siOut = si;
			diOut = di;
			dsOut = ds;
			return 0x00;
		}
		Eq_n es_bx_n = *((word32) ds + 9884);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
		struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (*((word32) ds + 18002) << 0x02);
		Eq_n stackArg4 = <invalid>;
		fn0800_BF9E(SEQ(ds, 0x45B2), stackArg4, SEQ((es_n->*bx_n).w0002, (es_n->*bx_n).w0000));
		di_n.u0 = 0x45B2;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = (word32) di_n + 0x01;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		*((word32) ds + 0x00004619) = ~cx_n - 0x01;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-0C6C(ds, SEQ(ds, 0x45B2), stackArg4);
		ui16 ax_n = *((word32) ds + 18002);
		*((word32) ds + 0x00004656) = ax_n;
		*((word32) ds + 0x00004617) = 0x00;
		if (*SEQ(ds, (word16) *((word32) ds + 9884))[ax_n] == 0x40)
		{
			Eq_n es_bx_n = *((word32) ds + 9884);
			struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
			struct Eq_n Eq_n::* bx_n = (word16) es_bx_n + (*((word32) ds + 18002) << 0x02);
			struct Eq_n Eq_n::* bp_n;
			Eq_n cx_n;
			Eq_n di_n;
			Eq_n ds_n;
			Eq_n dx_n;
			Eq_n si_n;
			Eq_n ax_n = fn0800-4234(si_n, di_n, ds, (es_n->*bx_n).w0000 + 0x01, (es_n->*bx_n).t0002, 0x0A13, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			*((word32) ds_n + 17949) = dx_n;
			*((word32) ds_n + 17947) = ax_n;
			*((word32) ds_n + 0x00004654) = 0x01;
			Eq_n sp_n = <invalid>;
			ss->*((word32) sp_n + 0x06) = (ss->*bp_n).t0006;
			ss->*((word32) sp_n + 0x04) = (ss->*bp_n).t0004;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			Eq_n stackArg4 = <invalid>;
			word16 ax_n = fn0800-2DE2(cx_n, dx_n, si_n, di_n, ds_n, stackArg2, stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n);
			Eq_n di_n = ss->*((word32) sp_n + 0x08);
			Eq_n si_n = ss->*((word32) sp_n + 0x0A);
			Eq_n bp_n = (ss->*bp_n).t0000;
			chOut.u0 = <invalid>;
			bpOut = bp_n;
			siOut = si_n;
			diOut = di_n;
			dsOut = ds_n;
			return ax_n;
		}
		fn0800-335C(si_n, di_n, ds, 0x45B2, ds);
		if (*((word32) ds + 0x0000464E) == 0x00)
		{
			struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
			struct Eq_n Eq_n::* di_n = (word16) ptrArg02;
			word16 di_n = 0x45B2;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (ds->*di_n != 0x00)
					break;
			}
			cu16 cx_n = ~cx_n;
			uint16 cx_n;
			struct Eq_n Eq_n::* si_n = di_n - cx_n;
			struct Eq_n Eq_n::* di_n = di_n;
			for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
			{
				(es_n->*di_n).t0000 = (ds->*si_n).t0000;
				si_n += 0x02;
				di_n += 0x02;
			}
			ui16 cx_n;
			for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
			{
				(es_n->*di_n).t0000 = (ds->*si_n).t0000;
				++si_n;
				++di_n;
			}
			++*((word32) ds + 0x00004617);
			++*((word32) ds + 18002);
			chOut.u0 = <invalid>;
			bpOut = bp;
			siOut = si;
			diOut = di;
			dsOut = ds;
			return 0x01;
		}
		si_n = fn0800-33CD(ds, fp - 0x12, ss, 0x00, 0x45B2, ds, out cx, out dx);
	}
	Eq_n si_n = si_n;
	if (si_n != 0x00)
	{
		if (*((word32) ds + 10779) != 0x00)
		{
			while (si_n != 0x00 && fn0800-31B4(si_n, di_n, ds, 0x45B2, ds, out cx, out dx) != 0x00)
			{
				si_n = fn0800-33CD(ds, fp - 0x12, ss, 0x00, 0x45B2, ds, out cx, out dx);
				Mem914 = Mem892;
			}
		}
		if (si_n != 0x00)
		{
			Eq_n bx_n = *((word32) ds + 0x00004619);
			ds->*((word32) bx_n + 0x000045B2) = 0x00;
			if (*((word32) ds + 0x00004617) == 0x00 && *((word32) ds + 18000) != 0x00)
				fn0800_B2EF(cx, dx, bx_n, ds, 0x0A17, ds, out si_n, out di_n);
			if ((*((word32) ds + 17947) | *((word32) ds + 17949)) != 0x00)
				*((word32) ds + 0x00004654) = 0x01;
			else
				++*((word32) ds + 18002);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			word16 ax_n = fn0800-2DE2(cx, dx, si_n, di_n, ds, wArg02_n, stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n);
			chOut.u0 = <invalid>;
			bpOut = bp;
			siOut = si;
			diOut = di;
			dsOut = ds;
			return ax_n;
		}
	}
	fn0800-3509(si_n, di_n, wArg02_n, wArg04_n, 0x45B2, ds, out bx_n);
	byte Eq_n::* di_n = fp - 0x12;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	ui16 cx_n = ~cx_n;
	byte Eq_n::* si_n = di_n - cx_n;
	Eq_n di_n = wArg02_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		di_n = (word32) di_n + 0x01;
		--cx_n;
		if (wArg04_n->*di_n != 0x00)
			break;
	}
	byte Eq_n::* di_n = di_n - 0x01;
	ui16 cx_n;
	for (cx_n = cx_n; cx_n != 0x00; --cx_n)
	{
		wArg04_n->*di_n = ss->*si_n;
		++si_n;
		++di_n;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	fn0800-0C6C(ds, SEQ(wArg04_n, wArg02_n), stackArg4);
	Eq_n si_n = wArg02_n;
	word16 di_n = 0x4348;
	word16 ax_n = 0x00;
	word16 cx_n = ~0x00;
	do
	{
		ax_n = DPB(ax_n, 0x00, 0);
		ax_n = DPB(ax_n, 0x00, 0);
		if (cx_n == 0x00)
			break;
		++di_n;
		--cx_n;
	} while (ds->*di_n == 0x00);
	Eq_n cx_n = ~cx_n;
	Eq_n di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	di_n = di_n;
	do
	{
		Eq_n di_n;
		if (cx_n == 0x00)
			break;
		Z_n = SLICE(cond(wArg04_n->*si_n - ds->*di_n), bool, 2);
		si_n = (word32) si_n + 0x01;
		di_n = (word16) di_n + 0x01;
		--cx_n;
	} while (wArg04_n->*si_n != ds->*di_n);
	if (!Z_n)
	{
		cup16 ax_n = 0x00 - (di_n < 0x00);
		ax_n = ax_n - ~0x00 - (ax_n < 0x00);
	}
	if (ax_n != 0x00)
	{
		si_n = wArg02_n;
		word16 di_n = 0x4477;
		word16 ax_n = 0x00;
		word16 cx_n = ~0x00;
		do
		{
			ax_n = DPB(ax_n, 0x00, 0);
			ax_n = DPB(ax_n, 0x00, 0);
			if (cx_n == 0x00)
				break;
			++di_n;
			--cx_n;
		} while (ds->*di_n == 0x00);
		cx_n = ~cx_n;
		Eq_n di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		di_n = di_n;
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(wArg04_n->*si_n - ds->*di_n), bool, 2);
			si_n = (word32) si_n + 0x01;
			di_n = (word32) di_n + 0x01;
			--cx_n;
			if (wArg04_n->*si_n == ds->*di_n)
				break;
		}
		if (!Z_n)
		{
			cup16 ax_n = 0x00 - (di_n < 0x00);
			ax_n = ax_n - ~0x00 - (ax_n < 0x00);
		}
		if (ax_n != 0x00)
		{
			++*((word32) ds + 0x00004617);
			chOut.u0 = <invalid>;
			bpOut = bp;
			siOut = si;
			diOut = di;
			dsOut = ds;
			return 0x01;
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	word16 ax_n = fn0800-2DE2(cx_n, dx_n, si_n, di_n, ds, wArg02_n, stackArg4, out ch_n, out bp_n, out si_n, out di_n, out ds_n);
	chOut.u0 = <invalid>;
	bpOut = bp;
	siOut = si;
	diOut = di;
	dsOut = ds;
	return ax_n;
}

// 0800:31B4: Register word16 fn0800-31B4(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n cxOut, Register out Eq_n dxOut)
word16 fn0800-31B4(Eq_n si, Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, union Eq_n & cxOut, union Eq_n & dxOut)
{
	while (true)
	{
		fn0800-3509(si, di, fp - 0x84, ss, wArg02, wArg04, out bx_n);
		fn0800-35A3(si, di, fp - 0x10, ss, wArg02, wArg04);
		Eq_n cx_n;
		Eq_n dx_n;
		if (fn0800-32CD(ds, fp - 0x1E, ss, fp - 0x84, ss, SEQ(ds, 0x09AE)[Mem56[ds:0x09AC:word16] * 0x02], out cx_n, out dx_n) == 0x00)
			break;
		if (*((word32) ds + 0x09AC) == 0x00)
		{
			*((word32) ds + 0x09AE) = 0x00;
			cxOut.u0 = <invalid>;
			dxOut.u0 = <invalid>;
			return 0x00;
		}
		Eq_n di_n = fp - 0x84;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = (word32) di_n + 0x01;
			--cx_n;
			if (ss->*di_n != 0x00)
				break;
		}
		Mem133[ss:~cx_n - 0x02 + (fp - 0x84):byte] = 0x00;
		fn0800-3509(si, di_n, wArg02, wArg04, fp - 0x84, ss, out bx_n);
		Eq_n di_n = fp - 0x10;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = (word32) di_n + 0x01;
			--cx_n;
			if (ss->*di_n != 0x00)
				break;
		}
		Eq_n cx_n = ~cx_n;
		si = di_n - cx_n;
		Eq_n di_n = wArg02;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = (word32) di_n + 0x01;
			--cx_n;
			if (wArg04->*di_n != 0x00)
				break;
		}
		di = di_n - 0x01;
		Eq_n cx_n;
		Mem244 = Mem217;
		for (cx_n = cx_n; cx_n != 0x00; --cx_n)
		{
			wArg04->*di = ss->*si;
			si = (word32) si + 0x01;
			di = (word32) di + 0x01;
		}
		--*((word32) ds + 0x09AC);
		ui16 bx_n = *((word32) ds + 0x09AC);
		++SEQ(ds, 0x09AE)[bx_n * 0x02];
	}
	fn0800_BEA2(cx_n, dx_n, ds, SEQ(wArg04, wArg02), 2599, ds, out di_n);
	++*((word32) ds + 0x09AC);
	SEQ(ds, 0x09AE)[Mem315[ds:0x09AC:word16] * 0x02] = 0x00;
	cxOut.u0 = <invalid>;
	dxOut.u0 = <invalid>;
	return 0x01;
}

// 0800:32CD: Register word16 fn0800-32CD(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n psegArg08, Stack word16 wArg0A, Register out ptr16 cxOut, Register out ptr16 dxOut)
word16 fn0800-32CD(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n psegArg08, word16 wArg0A, ptr16 & cxOut, ptr16 & dxOut)
{
	Eq_n di_n = wArg06;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		di_n = (word32) di_n + 0x01;
		--cx_n;
		if (psegArg08->*di_n != 0x00)
			break;
	}
	cu16 cx_n = ~cx_n;
	uint16 cx_n;
	struct Eq_n Eq_n::* si_n = di_n - cx_n;
	struct Eq_n Eq_n::* di_n = fp - 0x68;
	for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
	{
		(ss->*di_n).t0000 = (psegArg08->*si_n).t0000;
		si_n += 0x02;
		di_n += 0x02;
	}
	ui16 cx_n;
	for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
	{
		(ss->*di_n).t0000 = (psegArg08->*si_n).t0000;
		++si_n;
		++di_n;
	}
	byte Eq_n::* di_n = fp - 0x68;
	word16 si_n = 0x0A32;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	byte Eq_n::* di_n = di_n - 0x01;
	word16 cx_n;
	for (cx_n = 0x04; cx_n != 0x00; --cx_n)
	{
		ss->*di_n = ds->*si_n;
		++si_n;
		++di_n;
	}
	ptr16 dx_n;
	ptr16 cx_n;
	if (fn0800-33CD(ds, wArg02, wArg04, 0x10, fp - 0x68, ss, out cx_n, out dx_n) == 0x00)
	{
		while (wArg0A != 0x00 && fn0800-3479(ds, wArg02, wArg04, 0x10, out cx_n, out dx_n) == 0x00)
			--wArg0A;
		cxOut = cx_n;
		dxOut = dx_n;
		return wArg0A;
	}
	else
	{
		cxOut = cx_n;
		dxOut = dx_n;
		return 0x01;
	}
}

// 0800:335C: void fn0800-335C(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04)
void fn0800-335C(Eq_n si, Eq_n di, Eq_n ds, Eq_n ptrArg02, Eq_n wArg04)
{
	if (fn0800-33CD(ds, fp - 0x10, ss, 0x10, wArg02, wArg04, out cx_n, out dx_n) == 0x00)
	{
		fn0800-35A3(si, di, fp - 0x1E, ss, wArg02, wArg04);
		byte Eq_n::* si_n = fp - 0x10;
		byte Eq_n::* di_n = fp - 0x1E;
		word16 ax_n = 0x00;
		word16 cx_n = ~0x00;
		segptr32 ptrArg02_n = SEQ(wArg04, wArg02);
		do
		{
			ax_n = DPB(ax_n, 0x00, 0);
			ax_n = DPB(ax_n, 0x00, 0);
			if (cx_n == 0x00)
				break;
			++di_n;
			--cx_n;
		} while (ss->*di_n == 0x00);
		ui16 cx_n = ~cx_n;
		Eq_n di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		di_n = di_n;
		do
		{
			Eq_n di_n;
			if (cx_n == 0x00)
				break;
			Z_n = SLICE(cond(ss->*si_n - ss->*di_n), bool, 2);
			si_n = si_n + 0x01;
			di_n = (word16) di_n + 0x01;
			--cx_n;
			si_n = si_n;
			di_n = di_n;
		} while (ss->*si_n != ss->*di_n);
		if (!Z_n)
		{
			cup16 ax_n = 0x00 - (di_n < 0x00);
			ax_n = ax_n - ~0x00 - (ax_n < 0x00);
		}
		if (ax_n == 0x00)
		{
			struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
			byte Eq_n::* di_n = (word16) ptrArg02_n;
			word16 si_n = 0x0A36;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			byte Eq_n::* di_n = di_n - 0x01;
			word16 cx_n;
			for (cx_n = 0x05; cx_n != 0x00; --cx_n)
			{
				es_n->*di_n = ds->*si_n;
				++si_n;
				++di_n;
			}
		}
	}
}

// 0800:33CD: Register Eq_n fn0800-33CD(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack cui16 wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A, Register out Eq_n cxOut, Register out ptr16 dxOut)
Eq_n fn0800-33CD(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, cui16 wArg06, Eq_n wArg08, Eq_n wArg0A, union Eq_n & cxOut, ptr16 & dxOut)
{
	Eq_n cx_n;
	ptr16 dx_n;
	if (fn0800_A817(17955, ds, SEQ(wArg0A, wArg08), SEQ(ds, 17955), wArg06, out cx_n, out dx_n) == 0x00)
	{
		word16 di_n = 0x0A3B;
		word16 si_n = 0x4641;
		word16 cx_n = 0x02;
		word16 ax_n = 0x00;
		bool Z_n = SLICE(cond(0x00), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(ds->*si_n - ds->*di_n), bool, 2);
			si_n = si_n + 0x01;
			di_n = di_n + 0x01;
			--cx_n;
			si_n = si_n;
			di_n = di_n;
			if (ds->*si_n == ds->*di_n)
				break;
		}
		if (!Z_n)
			ax_n = 0x01;
		if (ax_n != 0x00)
		{
			word16 di_n = 2621;
			word16 si_n = 0x4641;
			Eq_n cx_n = 0x03;
			word16 ax_n = 0x00;
			bool Z_n = SLICE(cond(0x00), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(ds->*si_n - ds->*di_n), bool, 2);
				si_n = si_n + 0x01;
				di_n = di_n + 0x01;
				--cx_n;
				si_n = si_n;
				di_n = di_n;
				if (ds->*si_n == ds->*di_n)
					break;
			}
			if (!Z_n)
				ax_n = 0x01;
			if (ax_n != 0x00 && ((int16) (*((word32) ds + 17976)) & wArg06) == wArg06)
			{
				segptr32 ptrArg02_n = SEQ(wArg04, wArg02);
				if ((wArg02 | wArg04) != 0x00)
				{
					struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
					struct Eq_n Eq_n::* di_n = (word16) ptrArg02_n;
					word16 di_n = 0x4641;
					word16 cx_n = ~0x00;
					while (cx_n != 0x00)
					{
						++di_n;
						--cx_n;
						if (ds->*di_n != 0x00)
							break;
					}
					cu16 cx_n = ~cx_n;
					uint16 cx_n;
					struct Eq_n Eq_n::* si_n = di_n - cx_n;
					struct Eq_n Eq_n::* di_n = di_n;
					for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
					{
						(es_n->*di_n).t0000 = (ds->*si_n).t0000;
						si_n += 0x02;
						di_n += 0x02;
					}
					for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
					{
						(es_n->*di_n).t0000 = (ds->*si_n).t0000;
						++si_n;
						++di_n;
					}
				}
				cxOut = cx_n;
				dxOut = dx_n;
				return 0x00;
			}
		}
		Eq_n cx_n;
		ptr16 dx_n;
		Eq_n ax_n = fn0800-3479(ds, wArg02, wArg04, wArg06, out cx_n, out dx_n);
		cxOut = cx_n;
		dxOut = dx_n;
		return ax_n;
	}
	else
	{
		cxOut = cx_n;
		dxOut = dx_n;
		return 0x01;
	}
}

// 0800:3479: Register word16 fn0800-3479(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack cui16 wArg06, Register out Eq_n cxOut, Register out Eq_n dxOut)
word16 fn0800-3479(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, cui16 wArg06, union Eq_n & cxOut, union Eq_n & dxOut)
{
	do
	{
		Eq_n cx_n;
		if (fn0800_A84A(17955, ds, SEQ(ds, 17955), out cx_n, out dx_n) != 0x00)
		{
			cxOut = cx_n;
			dxOut.u0 = <invalid>;
			return 0x01;
		}
		word16 di_n = 0x0A3B;
		word16 si_n = 0x4641;
		word16 cx_n = 0x02;
		word16 ax_n = 0x00;
		bool Z_n = SLICE(cond(0x00), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(ds->*si_n - ds->*di_n), bool, 2);
			si_n = si_n + 0x01;
			di_n = di_n + 0x01;
			--cx_n;
			si_n = si_n;
			di_n = di_n;
			if (ds->*si_n == ds->*di_n)
				break;
		}
		if (!Z_n)
			ax_n = 0x01;
		if (ax_n == 0x00)
			continue;
		word16 di_n = 2621;
		word16 si_n = 0x4641;
		Eq_n cx_n = 0x03;
		word16 ax_n = 0x00;
		bool Z_n = SLICE(cond(0x00), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(ds->*si_n - ds->*di_n), bool, 2);
			si_n = si_n + 0x01;
			di_n = di_n + 0x01;
			--cx_n;
			si_n = si_n;
			di_n = di_n;
			if (ds->*si_n == ds->*di_n)
				break;
		}
		if (!Z_n)
			ax_n = 0x01;
	} while (ax_n == 0x00 || ((int16) (*((word32) ds + 17976)) & wArg06) != wArg06);
	segptr32 ptrArg02_n = SEQ(wArg04, wArg02);
	if ((wArg02 | wArg04) != 0x00)
	{
		struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
		struct Eq_n Eq_n::* di_n = (word16) ptrArg02_n;
		word16 di_n = 0x4641;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		cu16 cx_n = ~cx_n;
		uint16 cx_n;
		struct Eq_n Eq_n::* si_n = di_n - cx_n;
		struct Eq_n Eq_n::* di_n = di_n;
		for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
		{
			(es_n->*di_n).t0000 = (ds->*si_n).t0000;
			si_n += 0x02;
			di_n += 0x02;
		}
		for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
		{
			(es_n->*di_n).t0000 = (ds->*si_n).t0000;
			++si_n;
			++di_n;
		}
	}
	cxOut = cx_n;
	dxOut.u0 = <invalid>;
	return 0x00;
}

// 0800:3509: Register Eq_n fn0800-3509(Register Eq_n si, Register Eq_n di, Stack Eq_n wArg02, Stack Eq_n psegArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 bxOut)
Eq_n fn0800-3509(Eq_n si, Eq_n di, Eq_n wArg02, Eq_n psegArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & bxOut)
{
	ptr16 bx_n = fn0800_BE3B(si, di, wArg06, wArg08, fp - 0x06, ss, fp - 0x5A, ss, fp - 0x10, ss, fp - 22, ss);
	byte Eq_n::* di_n = fp - 0x06;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	uint16 cx_n = ~cx_n;
	uint16 cx_n;
	struct Eq_n Eq_n::* si_n = di_n - cx_n;
	Eq_n di_n = wArg02;
	for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
	{
		psegArg04->*di_n = (ss->*si_n).t0000;
		si_n += 0x02;
		di_n = (word32) di_n + 0x02;
	}
	ui16 cx_n;
	for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
	{
		psegArg04->*di_n = (ss->*si_n).t0000;
		++si_n;
		di_n = (word32) di_n + 0x01;
	}
	byte Eq_n::* di_n = fp - 0x5A;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	ui16 cx_n = ~cx_n;
	byte Eq_n::* si_n = di_n - cx_n;
	Eq_n di_n = wArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		di_n = (word32) di_n + 0x01;
		--cx_n;
		if (psegArg04->*di_n != 0x00)
			break;
	}
	byte Eq_n::* di_n = di_n - 0x01;
	ui16 cx_n;
	for (cx_n = cx_n; cx_n != 0x00; --cx_n)
	{
		psegArg04->*di_n = ss->*si_n;
		++si_n;
		++di_n;
	}
	bxOut = bx_n;
	return psegArg04;
}

// 0800:35A3: void fn0800-35A3(Register Eq_n si, Register Eq_n di, Stack Eq_n wArg02, Stack Eq_n psegArg04, Stack Eq_n wArg06, Stack Eq_n wArg08)
void fn0800-35A3(Eq_n si, Eq_n di, Eq_n wArg02, Eq_n psegArg04, Eq_n wArg06, Eq_n wArg08)
{
	fn0800_BE3B(si, di, wArg06, wArg08, fp - 0x06, ss, fp - 0x5A, ss, fp - 0x10, ss, fp - 22, ss);
	byte Eq_n::* di_n = fp - 0x10;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	uint16 cx_n = ~cx_n;
	uint16 cx_n;
	struct Eq_n Eq_n::* si_n = di_n - cx_n;
	Eq_n di_n = wArg02;
	for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
	{
		psegArg04->*di_n = (ss->*si_n).t0000;
		si_n += 0x02;
		di_n = (word32) di_n + 0x02;
	}
	ui16 cx_n;
	for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
	{
		psegArg04->*di_n = (ss->*si_n).t0000;
		++si_n;
		di_n = (word32) di_n + 0x01;
	}
	byte Eq_n::* di_n = fp - 22;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	ui16 cx_n = ~cx_n;
	byte Eq_n::* si_n = di_n - cx_n;
	Eq_n di_n = wArg02;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		di_n = (word32) di_n + 0x01;
		--cx_n;
		if (psegArg04->*di_n != 0x00)
			break;
	}
	byte Eq_n::* di_n = di_n - 0x01;
	ui16 cx_n;
	for (cx_n = cx_n; cx_n != 0x00; --cx_n)
	{
		psegArg04->*di_n = ss->*si_n;
		++si_n;
		++di_n;
	}
}

// 0800:363D: Register word16 fn0800-363D(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 dxOut)
word16 fn0800-363D(Eq_n ds, Eq_n ptrArg02, Eq_n wArg06, Eq_n wArg08, ptr16 & dxOut)
{
	if (fn0800_A817(fp - 0x2E, ds, SEQ(wArg08, wArg06), fp - 0x2E, 0x00, out cx_n, out dx_n) != 0x00)
		return;
	*ptrArg02 = wLoc18;
	*((word32) ptrArg02 + 0x02) = wLoc16;
	return;
}

// 0800:3678: Register word16 fn0800-3678(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out Eq_n dxOut, Register out ptr16 siOut, Register out Eq_n dsOut)
word16 fn0800-3678(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, union Eq_n & dxOut, ptr16 & siOut, union Eq_n & dsOut)
{
	segptr32 ptrArg02_n = SEQ(wArg04, wArg02);
	Eq_n es_n = SLICE(ptrArg02_n, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02_n;
	word16 cx_n = ~0x00;
	segptr32 ptrLoc06_n = SEQ(wArg04, wArg02);
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x5C - es_n->*di_n), bool, 2);
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x5C)
			break;
	}
	if (!Z_n)
	{
		di_n = 0x01;
		es_n.u0 = 0x00;
	}
	Eq_n di_n = di_n - 0x01;
	if ((di_n | es_n) == 0x00)
	{
l0800_n:
		while (true)
		{
			struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
			byte Eq_n::* di_n = (word16) ptrLoc06_n;
			word16 cx_n = ~0x00;
			while (cx_n != 0x00)
			{
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x00)
					break;
			}
			word16 cx_n = ~cx_n;
			byte Eq_n::* di_n = di_n - cx_n;
			bool Z_n = SLICE(cond(di_n), bool, 2);
			while (cx_n != 0x00)
			{
				Z_n = SLICE(cond(0x5C - es_n->*di_n), bool, 2);
				++di_n;
				--cx_n;
				if (es_n->*di_n != 0x5C)
					break;
			}
			if (!Z_n)
			{
				di_n = &Eq_n::b0001;
				es_n = 0x00;
			}
			Eq_n di_n = di_n - 0x01;
			Eq_n dx_n = di_n | es_n;
			byte * ptrLoc0A_n = di_n;
			word16 wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
			word16 wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
			if (dx_n == 0x00)
				break;
			*ptrLoc0A_n = 0x00;
			Eq_n ax_n = fn0800-33CD(ds, 0x00, 0x00, 0x10, wArg02, wArg04, out cx_n, out dx_n);
			if (ax_n != 0x00 && fn0800-8E52(ax_n, ds, SEQ(wArg04, wArg02)) != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg6 = <invalid>;
				fn0800-0D24(ds, 0x0E, SEQ(wArg04, wArg02), stackArg6, out cx_n, out dx_n, out bx_n, out si, out di_n, out es_n, out ds, out Top_n);
			}
			*ptrLoc0A_n = 0x5C;
			ptrLoc06_n = SEQ(wLoc08_n, wLoc0A_n + 0x01);
			Mem102 = Mem265;
		}
		dxOut = dx_n;
		siOut = si;
		dsOut = ds;
		return cx_n;
	}
	ptrLoc0A_n = SEQ(es_n, di_n);
	Eq_n ptrLoc0A_n = SEQ(es_n, di_n);
	word16 wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	word16 wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	if (es_n == wArg04)
	{
		if (di_n == wArg02)
		{
l0800_nD0:
			ptrLoc06_n = SEQ(wLoc08_n, wLoc0A_n + 0x01);
			goto l0800_n;
		}
	}
	wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	if (*(ptrLoc0A_n - 0x01) != 0x3A)
		goto l0800_n;
	goto l0800_nD0;
}

// 0800:3764: void fn0800-3764(Register Eq_n si, Register Eq_n di, Register Eq_n ds)
void fn0800-3764(Eq_n si, Eq_n di, Eq_n ds)
{
	if (*((word32) ds + 17022) != 0x00)
	{
		word16 di_n = 17022;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ds->*di_n != 0x00)
				break;
		}
		cu16 cx_n = ~cx_n;
		uint16 cx_n;
		struct Eq_n Eq_n::* si_n = di_n - cx_n;
		word16 di_n = 0x44DC;
		for (cx_n = cx_n >> 0x01; cx_n != 0x00; --cx_n)
		{
			(ds->*di_n).t0000 = (ds->*si_n).t0000;
			si_n += 0x02;
			di_n += 0x02;
		}
		ui16 cx_n;
		for (cx_n = cx_n * 0x02 + (cx_n >> 0x01 < 0x00); cx_n != 0x00; --cx_n)
		{
			(ds->*di_n).t0000 = (ds->*si_n).t0000;
			++si_n;
			++di_n;
		}
	}
	else
		fn0800-3509(si, di, 0x44DC, ds, 0x4541, ds, out bx_n);
	word16 di_n = 0x44DC;
	word16 si_n = 0x0A40;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ds->*di_n != 0x00)
			break;
	}
	byte Eq_n::* di_n = di_n - 0x01;
	word16 cx_n;
	for (cx_n = 0x0D; cx_n != 0x00; --cx_n)
	{
		ds->*di_n = ds->*si_n;
		++si_n;
		++di_n;
	}
}

// 0800:37BE: Register word16 fn0800-37BE(Register Eq_n cx, Register Eq_n dx, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 diOut)
word16 fn0800-37BE(Eq_n cx, Eq_n dx, Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & diOut)
{
	ptr16 di_n;
	word16 si_n = fn0800_BEA2(cx, dx, ds, SEQ(wArg04, wArg02), 0x0A2B, ds, out di_n);
	diOut = di_n;
	return si_n;
}

// 0800:37DF: Register Eq_n fn0800-37DF(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Register out Eq_n diOut, Register out Eq_n dsOut)
Eq_n fn0800-37DF(Eq_n si, Eq_n di, Eq_n ds, union Eq_n & diOut, union Eq_n & dsOut)
{
	fn0800-3509(si, di, fp - 0x6C, ss, 0x44DC, ds, out bx_n);
	Eq_n es_n = ss;
	byte Eq_n::* di_n = fp - 0x6C;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	ui16 cx_n = ~cx_n;
	byte Eq_n::* di_n = di_n - cx_n;
	bool Z_n = SLICE(cond(di_n), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(0x00 - ss->*di_n), bool, 2);
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	if (!Z_n)
	{
		di_n = 0x01;
		es_n.u0 = 0x00;
	}
	Eq_n di_n = di_n - 0x01;
	fn0800-35A3(si, di_n, di_n, es_n, 0x4541, ds);
	Eq_n dx_n;
	Eq_n si_n;
	union Eq_n Eq_n::* bp_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800_AA7E(si, di_n, ds, fp - 0x6C, ss, 0x0A4D, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	ss->*(bp_n - 0x02) = dx_n;
	ss->*(bp_n - 0x04) = ax_n;
	Eq_n sp_n = <invalid>;
	struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x08;
	if ((ax_n | dx_n) != 0x00)
	{
		ss->*((word32) sp_n + 0x06) = ss->*(bp_n - 0x02);
		ss->*((word32) sp_n + 0x04) = ss->*(bp_n - 0x04);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800_A614(ds_n, ss->*((word32) sp_n + 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		Eq_n sp_n = <invalid>;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x0180;
		ss->*sp_n = ss;
		(ss->*(sp_n - 0x02)).t0000 = bp_n - 0x6A;
		fn0800_A4F6(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02));
		ss->*((word32) sp_n + 0x02) = ss;
		ss->*sp_n = bp_n - 0x6A;
		fn0800-8F7F(bp_n - 0x6A, ds_n, ss->*sp_n);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
	}
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	ss->*sp_n = ss;
	ss->*(sp_n - 0x02) = bp_n - 0x6A;
	ss->*(sp_n - 0x04) = ds_n;
	(ss->*(sp_n - 0x06)).u0 = 0x44DC;
	if (fn0800_BA4A(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x02)) == ~0x00)
	{
		ss->*sp_n = ds_n;
		(ss->*(sp_n - 0x02)).u0 = 0x44DC;
		(ss->*(sp_n - 0x04)).u0 = 0x0A;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	diOut = (ss->*sp_n).t0000;
	dsOut = ds_n;
	return si_n;
}

// 0800:388C: Register word16 fn0800-388C(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out Eq_n bpOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
word16 fn0800-388C(Eq_n si, Eq_n di, Eq_n ds, ptr16 & cxOut, ptr16 & dxOut, union Eq_n & bpOut, ptr16 & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	Eq_n di_n;
	Eq_n ds_n;
	Eq_n dx_n;
	Eq_n si_n;
	Eq_n ax_n = fn0800-4234(si, di, ds, 0x4541, ds, 0x0A13, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	*((word32) ds_n + 0x000029E5) = dx_n;
	*((word32) ds_n + 0x000029E3) = ax_n;
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x06) = ds_n;
	(ss->*((word32) sp_n + 0x04)).u0 = 0x0A50;
	ss->*((word32) sp_n + 0x02) = ds_n;
	(ss->*sp_n).u0 = 0x44DC;
	union Eq_n Eq_n::* bp_n;
	ptr16 di_n;
	Eq_n ds_n;
	Eq_n dx_n;
	ptr16 si_n;
	Eq_n ax_n = fn0800-4234(si_n, di_n, ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	*((word32) ds_n + 10721) = dx_n;
	*((word32) ds_n + 10719) = ax_n;
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x06) = ds_n;
	(ss->*((word32) sp_n + 0x04)).u0 = 0x44DC;
	ss->*((word32) sp_n + 0x02) = ss;
	ss->*sp_n = bp_n - 0x04;
	ptr16 dx_n;
	ptr16 cx_n = fn0800-363D(ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n);
	if (*((word32) ds_n + 0x0A12) != 0x00)
	{
		ss->*((word32) sp_n + 0x06) = ds_n;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x4541;
		ss->*((word32) sp_n + 0x02) = ss;
		ss->*sp_n = bp_n - 0x08;
		ptr16 dx_n;
		ptr16 cx_n = fn0800-363D(ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n);
		ss->*((word32) sp_n + 0x06) = ds_n;
		(ss->*((word32) sp_n + 0x04)).u0 = 17951;
		ss->*((word32) sp_n + 0x02) = ss;
		ss->*sp_n = bp_n - 0x08;
		if (fn0800-395B(ss->*sp_n, ss->*((word32) sp_n + 0x04)) >= 0x00)
		{
			ss->*((word32) sp_n + 0x06) = ss;
			ss->*((word32) sp_n + 0x04) = bp_n - 0x04;
			ss->*((word32) sp_n + 0x02) = ss;
			ss->*sp_n = bp_n - 0x08;
			if (fn0800-395B(ss->*sp_n, ss->*((word32) sp_n + 0x04)) <= 0x00)
			{
				ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 0x000029E5);
				ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 0x000029E3);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				Eq_n ds_n;
				fn0800_A614(ds_n, ss->*((word32) sp_n + 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
				Eq_n sp_n = <invalid>;
				ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
				ss->*sp_n = *((word32) ds_n + 10719);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				union Eq_n Eq_n::* bp_n;
				ptr16 cx_n;
				ptr16 di_n;
				ptr16 si_n;
				Eq_n ds_n;
				fn0800_A614(ds_n, ss->*sp_n, stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
				Eq_n sp_n = <invalid>;
				ss->*((word32) sp_n + 0x02) = ds_n;
				(ss->*sp_n).u0 = 0x44DC;
				ptr16 dx_n = fn0800-8F7F(0x44DC, ds_n, ss->*sp_n);
				Eq_n bp_n = ss->*bp_n;
				cxOut = cx_n;
				dxOut = dx_n;
				bpOut = bp_n;
				siOut = si_n;
				diOut = di_n;
				dsOut = ds_n;
				return 0x00;
			}
		}
		Eq_n bp_n = ss->*bp_n;
		cxOut = cx_n;
		dxOut = dx_n;
		bpOut = bp_n;
		siOut = si_n;
		diOut = di_n;
		dsOut = ds_n;
		return 0x01;
	}
	else
	{
		*((word32) ds_n + 0x00004621) = ss->*(bp_n - 0x02);
		*((word32) ds_n + 17951) = ss->*(bp_n - 0x04);
		*((word32) ds_n + 0x0A12) = 0x01;
		Eq_n bp_n = ss->*bp_n;
		cxOut = cx_n;
		dxOut = dx_n;
		bpOut = bp_n;
		siOut = si_n;
		diOut = di_n;
		dsOut = ds_n;
		return 0x01;
	}
}

// 0800:395B: Register word16 fn0800-395B(Stack Eq_n ptrArg02, Stack Eq_n ptrArg06)
word16 fn0800-395B(Eq_n ptrArg02, Eq_n ptrArg06)
{
	Eq_n ax_n = *((word32) ptrArg02 + 0x02);
	if (ax_n != *((word32) ptrArg06 + 0x02))
		return ax_n - *((word32) ptrArg06 + 0x02);
	return *ptrArg02 - *ptrArg06;
}

// 0800:3992: Register word16 fn0800-3992(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Register out Eq_n dxOut, Register out Eq_n bpOut, Register out Eq_n siOut, Register out Eq_n dsOut)
word16 fn0800-3992(Eq_n si, Eq_n di, Eq_n ds, union Eq_n & dxOut, union Eq_n & bpOut, union Eq_n & siOut, union Eq_n & dsOut)
{
	if (*((word32) ds + 17022) == 0x00 || (*((word32) ds + 0x00002A23) != 0x01 || *((word32) ds + 10775) == 0x00))
	{
		dxOut = dx;
		bpOut = bp;
		siOut = si;
		dsOut = ds;
		return 0x00;
	}
	else
	{
		fn0800-3509(si, di, fp - 116, ss, 0x44DC, ds, out bx_n);
		Eq_n es_n = ss;
		byte Eq_n::* di_n = fp - 116;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			++di_n;
			--cx_n;
			if (ss->*di_n != 0x00)
				break;
		}
		ui16 cx_n = ~cx_n;
		byte Eq_n::* di_n = di_n - cx_n;
		bool Z_n = SLICE(cond(di_n), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(0x00 - ss->*di_n), bool, 2);
			++di_n;
			--cx_n;
			if (ss->*di_n != 0x00)
				break;
		}
		if (!Z_n)
		{
			di_n = 0x01;
			es_n.u0 = 0x00;
		}
		Eq_n di_n = di_n - 0x01;
		fn0800-35A3(si, di_n, di_n, es_n, 0x4541, ds);
		union Eq_n Eq_n::* bp_n;
		Eq_n ds_n;
		Eq_n dx_n;
		Eq_n si_n;
		Eq_n ax_n = fn0800_AA7E(si, di_n, ds, fp - 116, ss, 0x0A4D, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		ss->*(bp_n - 0x02) = dx_n;
		ss->*(bp_n - 0x04) = ax_n;
		Eq_n sp_n = <invalid>;
		Eq_n ax_n = ax_n | dx_n;
		if (ax_n != 0x00)
		{
			ss->*((word32) sp_n + 0x06) = ss->*(bp_n - 0x02);
			ss->*((word32) sp_n + 0x04) = ss->*(bp_n - 0x04);
			fn0800-4194(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06));
			if (dx_n > 0x00 || dx_n == 0x00 && ax_n > 0x12)
			{
				ss->*((word32) sp_n + 0x06) = ss->*(bp_n - 0x02);
				ss->*((word32) sp_n + 0x04) = ss->*(bp_n - 0x04);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				Eq_n ds_n;
				word16 dx_n;
				Eq_n ax_n = fn0800-8CAA(ax_n, 0x08, fn0800-3E5D(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out ds_n, out Top_n), stackArg0, out dx_n);
				Eq_n sp_n = <invalid>;
				if (dx_n != 0x52 || ax_n != 0x4E43)
				{
					ss->*(sp_n - 0x02) = ss->*(bp_n - 0x02);
					ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					union Eq_n Eq_n::* bp_n;
					Eq_n dx_n;
					Eq_n si_n;
					Eq_n ds_n;
					fn0800_A614(ds_n, ss->*(sp_n - 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
					Eq_n bp_n = ss->*bp_n;
					dxOut = dx_n;
					bpOut = bp_n;
					siOut = si_n;
					dsOut = ds_n;
					return 0x00;
				}
				else
				{
					ss->*(sp_n - 0x02) = ss->*(bp_n - 0x02);
					ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
					Eq_n ds_n;
					if (fn0800-3E5D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ds_n, out Top_n) != *((word32) ds_n + 10761) || ax_n != *((word32) ds_n + 0x00002A07))
					{
						ss->*(sp_n - 0x02) = ss->*(bp_n - 0x02);
						ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg4 = <invalid>;
						union Eq_n Eq_n::* bp_n;
						Eq_n dx_n;
						Eq_n si_n;
						Eq_n ds_n;
						fn0800_A614(ds_n, ss->*(sp_n - 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
						Eq_n bp_n = ss->*bp_n;
						dxOut = dx_n;
						bpOut = bp_n;
						siOut = si_n;
						dsOut = ds_n;
						return 0x00;
					}
					else
					{
						ss->*(sp_n - 0x02) = ss;
						ss->*(sp_n - 0x04) = bp_n - 114;
						ss->*(sp_n - 0x06) = ss;
						ss->*(sp_n - 0x08) = bp_n - 0x0C;
						fn0800-363D(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n);
						ss->*(sp_n - 0x02) = ds_n;
						(ss->*(sp_n - 0x04)).u0 = 0x4541;
						ss->*(sp_n - 0x06) = ss;
						ss->*(sp_n - 0x08) = bp_n - 0x08;
						fn0800-363D(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n);
						ss->*(sp_n - 0x02) = ss;
						ss->*(sp_n - 0x04) = bp_n - 0x08;
						ss->*(sp_n - 0x06) = ss;
						ss->*(sp_n - 0x08) = bp_n - 0x0C;
						wchar_t ax_n = fn0800-395B(ss->*(sp_n - 0x08), ss->*(sp_n - 0x04));
						if (ax_n >= 0x00)
						{
							ss->*(sp_n - 0x02) = ss->*(bp_n - 0x02);
							ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
							Eq_n ds_n;
							Mem340[ds_n:0x2A05:word16] = fn0800-3E5D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ds_n, out Top_n) + (ax_n <u 0x12);
							*((word32) ds_n + 10755) = ax_n + 0x12;
							ss->*(sp_n - 0x02) = ss->*(bp_n - 0x02);
							ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_n stackArg4 = <invalid>;
							union Eq_n Eq_n::* bp_n;
							Eq_n dx_n;
							Eq_n si_n;
							Eq_n ds_n;
							fn0800_A614(ds_n, ss->*(sp_n - 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
							Eq_n bp_n = ss->*bp_n;
							dxOut = dx_n;
							bpOut = bp_n;
							siOut = si_n;
							dsOut = ds_n;
							return 0x01;
						}
						else
						{
							ss->*(sp_n - 0x02) = ss->*(bp_n - 0x02);
							ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_n stackArg4 = <invalid>;
							union Eq_n Eq_n::* bp_n;
							Eq_n dx_n;
							Eq_n si_n;
							Eq_n ds_n;
							fn0800_A614(ds_n, ss->*(sp_n - 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
							Eq_n bp_n = ss->*bp_n;
							dxOut = dx_n;
							bpOut = bp_n;
							siOut = si_n;
							dsOut = ds_n;
							return 0x00;
						}
					}
				}
			}
			else
			{
				ss->*((word32) sp_n + 0x06) = ss->*(bp_n - 0x02);
				ss->*((word32) sp_n + 0x04) = ss->*(bp_n - 0x04);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				union Eq_n Eq_n::* bp_n;
				Eq_n dx_n;
				Eq_n si_n;
				Eq_n ds_n;
				fn0800_A614(ds_n, ss->*((word32) sp_n + 0x04), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
				Eq_n bp_n = ss->*bp_n;
				dxOut = dx_n;
				bpOut = bp_n;
				siOut = si_n;
				dsOut = ds_n;
				return 0x00;
			}
		}
		else
		{
			Eq_n bp_n = ss->*bp_n;
			dxOut = dx_n;
			bpOut = bp_n;
			siOut = si_n;
			dsOut = ds_n;
			return 0x00;
		}
	}
}

// 0800:3B0A: Register cui16 fn0800-3B0A(Stack Eq_n wArg0A, Stack Eq_n wArg0C, Register out ptr16 dxOut, Register out Eq_n bpOut, Register out (ptr16 Eq_n) dsOut)
cui16 fn0800-3B0A(Eq_n wArg0A, Eq_n wArg0C, ptr16 & dxOut, union Eq_n & bpOut, struct Eq_n & dsOut)
{
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	cui16 ax_n = wArg0A | wArg0C;
	if (ax_n != 0x00)
	{
		if (wArg0C >= 0x00 && (wArg0C > 0x00 || wArg0A > 65000))
			;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ds_n;
		Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		ss->*(bp_n - 0x02) = dx_n;
		ss->*(bp_n - 0x04) = ax_n;
		Eq_n sp_n = <invalid>;
		while (((ss->*bp_n).t000C | (ss->*bp_n).t000E) != 0x00)
		{
			Eq_n ax_n;
			Eq_n dx_n;
			if ((ss->*bp_n).t000E >= 0x00 && ((ss->*bp_n).t000E > 0x00 || (ss->*bp_n).t000C > 65000))
			{
				dx_n.u0 = 0x00;
				ax_n.u0 = 65000;
			}
			else
			{
				dx_n = (ss->*bp_n).t000E;
				ax_n = (ss->*bp_n).t000C;
			}
			(ss->*(bp_n - 0x06)).t0000 = dx_n;
			(ss->*(bp_n - 0x08)).t0000 = ax_n;
			ss->*((word32) sp_n + 0x02) = (ss->*bp_n).t0006;
			ss->*sp_n = (ss->*bp_n).t0004;
			(ss->*(sp_n - 0x02)).t0000 = (ss->*(bp_n - 0x06)).t0000;
			(ss->*(sp_n - 0x04)).t0000 = ax_n;
			(ss->*(sp_n - 0x06)).t0000 = (ss->*(bp_n - 0x02)).t0000;
			(ss->*(sp_n - 0x08)).t0000 = (ss->*(bp_n - 0x04)).t0000;
			Eq_n ds_n;
			fn0800-4110(ds_n, (ss->*(sp_n - 0x08)).t0000, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out si_n, out di_n, out ds_n);
			ss->*((word32) sp_n + 0x02) = (ss->*bp_n).t000A;
			ss->*sp_n = (ss->*bp_n).t0008;
			(ss->*(sp_n - 0x02)).t0000 = (ss->*(bp_n - 0x06)).t0000;
			(ss->*(sp_n - 0x04)).t0000 = (ss->*(bp_n - 0x08)).t0000;
			(ss->*(sp_n - 0x06)).t0000 = (ss->*(bp_n - 0x02)).t0000;
			(ss->*(sp_n - 0x08)).t0000 = (ss->*(bp_n - 0x04)).t0000;
			fn0800-4152(ds_n, (ss->*(sp_n - 0x08)).t0000, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out ds_n);
			Eq_n ax_n = (ss->*(bp_n - 0x06)).t0000;
			Eq_n dx_n = (ss->*(bp_n - 0x08)).t0000;
			(ss->*bp_n).t000C = v27_n;
			(ss->*bp_n).t000C = SEQ((ss->*bp_n).t000E, (ss->*bp_n).t000C);
			ui32 v28_v27_n = (ss->*bp_n).t000C - SEQ(ax_n, dx_n);
			(ss->*bp_n).t000E = SLICE(v28_v27_n, word16, 16);
			Eq_n v27_n = (word16) v28_v27_n;
		}
		ss->*((word32) sp_n + 0x02) = (ss->*(bp_n - 0x02)).t0000;
		ss->*sp_n = (ss->*(bp_n - 0x04)).t0000;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		ax_n = fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx, out bx_n, out ds);
	}
	Eq_n bp_n = (ss->*bp_n).t0000;
	dxOut = dx;
	bpOut = bp_n;
	dsOut = ds;
	return ax_n;
}

// 0800:3BC3: Register word16 fn0800-3BC3(Register Eq_n cx, Register Eq_n dx, Register Eq_n ds, Register out Eq_n dsOut)
word16 fn0800-3BC3(Eq_n cx, Eq_n dx, Eq_n ds, union Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg6 = <invalid>;
	Eq_n stackArg8 = <invalid>;
	Eq_n di_n;
	struct Eq_n Eq_n::* bp_n;
	Eq_n ds_n;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-4234(fn0800-37BE(cx, dx, ds, 0x43AD, ds, stackArg6, stackArg8, out di_n), di_n, ds, 0x43AD, ds, 0x0A61, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	*((word32) ds_n + 10709) = dx_n;
	*((word32) ds_n + 10707) = ax_n;
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x06) = (ss->*bp_n).t0006;
	ss->*((word32) sp_n + 0x04) = (ss->*bp_n).t0004;
	fn0800-4194(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06));
	(ss->*bp_n).t0008 = SEQ((ss->*bp_n).t000A, (ss->*bp_n).t0008);
	ui32 dx_ax_n = SEQ(dx_n, ax_n) - (ss->*bp_n).t0008;
	(ss->*(bp_n - 0x02)).t0000 = SLICE(dx_ax_n, word16, 16);
	(ss->*(bp_n - 0x04)).t0000 = (word16) dx_ax_n;
	(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
	ss->*((word32) sp_n + 0x04) = (ss->*bp_n).t000A;
	ss->*((word32) sp_n + 0x02) = (ss->*bp_n).t0008;
	ss->*sp_n = (ss->*bp_n).t0006;
	(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0004;
	fn0800_ACB3(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
	ss->*((word32) sp_n + 0x06) = (ss->*(bp_n - 0x02)).t0000;
	ss->*((word32) sp_n + 0x04) = (ss->*(bp_n - 0x04)).t0000;
	ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10709);
	ss->*sp_n = *((word32) ds_n + 10707);
	(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0006;
	(ss->*(sp_n - 0x04)).t0000 = (ss->*bp_n).t0004;
	struct Eq_n Eq_n::* bp_n;
	Eq_n ds_n;
	fn0800-3B0A(ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out bp_n, out ds_n);
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10709);
	ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 10707);
	fn0800_BA67(ds_n, ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A));
	(ss->*((word32) sp_n + 0x0A)).u0 = 0x00;
	ui32 ax_dx_n = SEQ((ss->*bp_n).w000A, (ss->*bp_n).w0008);
	(ss->*bp_n).t000C = SEQ((ss->*bp_n).w000E, (ss->*bp_n).t000C);
	ui32 ax_dx_n = (word32) (ss->*bp_n).t000C.u1 + ax_dx_n;
	ss->*((word32) sp_n + 0x08) = SLICE(ax_dx_n, word16, 16);
	ss->*((word32) sp_n + 0x06) = (word16) ax_dx_n;
	ss->*((word32) sp_n + 0x04) = (ss->*bp_n).t0006;
	ss->*((word32) sp_n + 0x02) = (ss->*bp_n).t0004;
	fn0800_ACB3(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x0A), out cx_n, out dx_n, out bx_n);
	ss->*((word32) sp_n + 0x0A) = (ss->*(bp_n - 0x02)).t0000;
	ss->*((word32) sp_n + 0x08) = (ss->*(bp_n - 0x04)).t0000;
	ss->*((word32) sp_n + 0x06) = (ss->*bp_n).t0006;
	ss->*((word32) sp_n + 0x04) = (ss->*bp_n).t0004;
	ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10709);
	ss->*sp_n = *((word32) ds_n + 10707);
	Eq_n ds_n;
	fn0800-3B0A(ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out dx_n, out bp_n, out ds_n);
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10709);
	ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 10707);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	word16 si_n;
	Eq_n ds_n;
	fn0800_A614(ds_n, ss->*((word32) sp_n + 0x08), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x02) = ds_n;
	(ss->*sp_n).u0 = 0x43AD;
	fn0800-8F7F(0x43AD, ds_n, ss->*sp_n);
	dsOut = ds_n;
	return si_n;
}

// 0800:3C99: Register byte fn0800-3C99(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Register out ptr16 bpOut, Register out Eq_n siOut, Register out (ptr16 Eq_n) dsOut)
byte fn0800-3C99(Eq_n si, Eq_n di, Eq_n ds, ptr16 & bpOut, union Eq_n & siOut, struct Eq_n & dsOut)
{
	fn0800-3509(si, di, fp - 0x6C, ss, 0x4348, ds, out bx_n);
	byte Eq_n::* di_n = fp - 0x6C;
	Eq_n si_n = 2644;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (ss->*di_n != 0x00)
			break;
	}
	Eq_n di_n = di_n - 0x01;
	word16 cx_n;
	for (cx_n = 0x0D; cx_n != 0x00; --cx_n)
	{
		ss->*di_n = ds->*si_n;
		si_n = (word32) si_n + 0x01;
		di_n = (word32) di_n + 0x01;
	}
	struct Eq_n Eq_n::* bp_n;
	Eq_n ds_n;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-4234(si_n, di_n, ds, fp - 0x6C, ss, 0x0A61, ds, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	ss->*(bp_n - 0x02) = dx_n;
	ss->*(bp_n - 0x04) = ax_n;
	Eq_n sp_n = <invalid>;
	(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
	(ss->*((word32) sp_n + 0x04)).u0 = 0x00;
	(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
	ss->*sp_n = (ss->*bp_n).t0006;
	(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0004;
	fn0800_ACB3(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
	ss->*((word32) sp_n + 0x06) = (ss->*bp_n).t000A;
	ss->*((word32) sp_n + 0x04) = (ss->*bp_n).t0008;
	ss->*((word32) sp_n + 0x02) = (ss->*(bp_n - 0x02)).t0000;
	ss->*sp_n = (ss->*(bp_n - 0x04)).t0000;
	(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0006;
	(ss->*(sp_n - 0x04)).t0000 = (ss->*bp_n).t0004;
	struct Eq_n Eq_n::* bp_n;
	Eq_n ds_n;
	fn0800-3B0A(ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out bp_n, out ds_n);
	Eq_n sp_n = <invalid>;
	(ss->*((word32) sp_n + 0x0A)).u0 = 0x00;
	ui32 ax_dx_n = SEQ((ss->*bp_n).w000A, (ss->*bp_n).w0008);
	(ss->*bp_n).t000C = SEQ((ss->*bp_n).t000E, (ss->*bp_n).t000C);
	ui32 ax_dx_n = (word32) (ss->*bp_n).t000C + ax_dx_n;
	ss->*((word32) sp_n + 0x08) = SLICE(ax_dx_n, word16, 16);
	ss->*((word32) sp_n + 0x06) = (word16) ax_dx_n;
	ss->*((word32) sp_n + 0x04) = (ss->*bp_n).t0006;
	ss->*((word32) sp_n + 0x02) = (ss->*bp_n).t0004;
	ui16 dx_n;
	Eq_n ax_n = fn0800_ACB3(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x0A), out cx_n, out dx_n, out bx_n);
	ss->*((word32) sp_n + 0x0A) = (ss->*bp_n).t0006;
	ss->*((word32) sp_n + 0x08) = (ss->*bp_n).t0004;
	fn0800-4194(ds_n, ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A));
	ui32 bx_cx_n = SEQ((ss->*bp_n).w000A, (ss->*bp_n).w0008);
	(ss->*bp_n).t000C = SEQ((ss->*bp_n).t000E, (ss->*bp_n).t000C);
	ui32 dx_ax_n = SEQ(dx_n, ax_n) - ((word32) (ss->*bp_n).t000C + bx_cx_n);
	(ss->*bp_n).t000E = SLICE(dx_ax_n, word16, 16);
	Eq_n ax_n = (word16) dx_ax_n;
	(ss->*bp_n).t000C = ax_n;
	ss->*((word32) sp_n + 0x0A) = (ss->*bp_n).t000E;
	ss->*((word32) sp_n + 0x08) = ax_n;
	ss->*((word32) sp_n + 0x06) = (ss->*(bp_n - 0x02)).t0000;
	ss->*((word32) sp_n + 0x04) = (ss->*(bp_n - 0x04)).t0000;
	ss->*((word32) sp_n + 0x02) = (ss->*bp_n).t0006;
	ss->*sp_n = (ss->*bp_n).t0004;
	union Eq_n Eq_n::* bp_n;
	Eq_n ds_n;
	fn0800-3B0A(ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out dx_n, out bp_n, out ds_n);
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x0A) = ss->*(bp_n - 0x02);
	ss->*((word32) sp_n + 0x08) = ss->*(bp_n - 0x04);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n ds_n;
	fn0800_A614(ds_n, ss->*((word32) sp_n + 0x08), stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	Eq_n sp_n = <invalid>;
	ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10705);
	ss->*sp_n = *((word32) ds_n + 10703);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	word16 bp_n;
	Eq_n ds_n;
	Eq_n si_n;
	Eq_n di_n;
	fn0800_A614(ds_n, ss->*sp_n, stackArg4, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	Eq_n sp_n = <invalid>;
	(ss->*((word32) sp_n + 0x02)).u0 = 0x0180;
	ss->*sp_n = ds_n;
	(ss->*(sp_n - 0x02)).t0000.u0 = 0x4348;
	fn0800_A4F6(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02));
	ss->*((word32) sp_n + 0x02) = ds_n;
	(ss->*sp_n).u0 = 0x4348;
	fn0800-8F7F(0x4348, ds_n, ss->*sp_n);
	ss->*((word32) sp_n + 0x02) = ds_n;
	(ss->*sp_n).u0 = 0x4348;
	(ss->*(sp_n - 0x02)).t0000 = ss;
	(ss->*(sp_n - 0x04)).t0000 = bp_n - 0x6A;
	if (fn0800_BA4A(ds_n, (ss->*(sp_n - 0x04)).t0000, ss->*sp_n) == ~0x00)
	{
		ss->*((word32) sp_n + 0x02) = ss;
		ss->*sp_n = bp_n - 0x6A;
		(ss->*(sp_n - 0x02)).t0000.u0 = 0x0A;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	ss->*((word32) sp_n + 0x02) = ds_n;
	(ss->*sp_n).u0 = 2661;
	(ss->*(sp_n - 0x02)).t0000 = ds_n;
	(ss->*(sp_n - 0x04)).t0000.u0 = 0x4348;
	ptr16 Eq_n::* bp_n;
	word16 cx_n;
	struct Eq_n * ds_n;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-4234(si_n, di_n, ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	ds_n->t29D1 = dx_n;
	ds_n->t29CF = ax_n;
	Eq_n sp_n = <invalid>;
	Eq_n si_n = ss->*((word32) sp_n + 0x0A);
	bpOut = ss->*bp_n;
	siOut = si_n;
	dsOut = ds_n;
	return (byte) cx_n;
}

// 0800:3DCF: Register word16 fn0800-3DCF(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out Eq_n chOut, Register out ptr16 dxOut, Register out ptr16 diOut, Register out Eq_n dsOut, Register out Eq_n TopOut)
word16 fn0800-3DCF(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, union Eq_n & chOut, ptr16 & dxOut, ptr16 & diOut, union Eq_n & dsOut, union Eq_n & TopOut)
{
	wArg04_n = SLICE(ptrArg02, word16, 16);
	wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n Top_n = 0x00;
	Eq_n ax_n;
	ci16 v10_n = *ptrArg02 - 0x01;
	*ptrArg02 = v10_n;
	if (v10_n >= 0x00)
	{
		struct Eq_n * ax_n = *((word32) ptrArg02 + 0x0E);
		union Eq_n Eq_n::* si_n = *((word32) ptrArg02 + 0x0C);
		*((word32) ptrArg02 + 0x0C) = (word32) *((word32) ptrArg02 + 0x0C) + 0x01;
		ax_n = DPB(DPB(ax_n, ax_n->*si_n, 0), 0x00, 8);
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		ax_n = fn0800_AEC2(ds, SEQ(wArg04_n, wArg02_n), stackArg4, out ch_n, out dx);
	}
	byte bLoc04_n = SLICE(ax_n, byte, 0);
	bLoc04_n = SLICE(ax_n, byte, 0);
	if (ax_n == ~0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		word16 dx_n;
		ax_n = fn0800-0D24(ds, 0x08, SEQ(dx_n, fn0800-4271(ds, wArg02_n, wArg04_n, out dx_n)), stackArg6, out cx_n, out dx, out bx_n, out si_n, out di, out es_n, out ds, out Top_n);
	}
	chOut.u0 = <invalid>;
	dxOut = dx;
	diOut = di;
	dsOut = ds;
	TopOut = Top_n;
	return DPB(ax_n, bLoc04_n, 0);
}

// 0800:3E27: Register ui16 fn0800-3E27(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 diOut, Register out (ptr16 Eq_n) dsOut, Register out Eq_n TopOut)
ui16 fn0800-3E27(Eq_n ds, Eq_n wArg02, Eq_n wArg04, ptr16 & cxOut, ptr16 & dxOut, ptr16 & diOut, struct Eq_n & dsOut, union Eq_n & TopOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n stackArg4 = <invalid>;
	Eq_n cx_n = <invalid>;
	Eq_n ds_n;
	ptr16 dx_n;
	Eq_n Top_n;
	ptr16 di_n;
	struct Eq_n * ds_n;
	ui16 ax_n = (DPB(fn0800-3DCF(ds, SEQ(wArg04, wArg02), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n), 0x00, 8) << 0x08) + DPB(fn0800-3DCF(ds_n, SEQ(wArg04, wArg02), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n), 0x00, 8);
	cxOut = (ptr16) DPB(cx_n, 0x08, 0);
	dxOut = dx_n;
	diOut = di_n;
	dsOut = ds_n;
	TopOut = Top_n;
	return ax_n;
}

// 0800:3E5D: Register word16 fn0800-3E5D(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out (ptr16 Eq_n) dsOut, Register out Eq_n TopOut)
word16 fn0800-3E5D(Eq_n ds, Eq_n wArg02, Eq_n wArg04, struct Eq_n & dsOut, union Eq_n & TopOut)
{
	Eq_n ds_n;
	struct Eq_n * ds_n;
	Eq_n Top_n;
	word16 dx_n = fn0800-3E27(ds, wArg02, wArg04, out cx_n, out dx_n, out di_n, out ds_n, out Top_n) + (fn0800-3E27(ds_n, wArg02, wArg04, out cx_n, out dx_n, out di_n, out ds_n, out Top_n) <u 0x00);
	dsOut = ds_n;
	TopOut = Top_n;
	return dx_n;
}

// 0800:3E9A: Register word16 fn0800-3E9A(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out ptr16 dxOut, Register out Eq_n dsOut)
word16 fn0800-3E9A(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, ptr16 & dxOut, union Eq_n & dsOut)
{
	wArg04_n = SLICE(ptrArg02, word16, 16);
	wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n ax_n;
	ci16 v10_n = *ptrArg02 - 0x01;
	*ptrArg02 = v10_n;
	if (v10_n >= 0x00)
	{
		struct Eq_n * ax_n = *((word32) ptrArg02 + 0x0E);
		union Eq_n Eq_n::* si_n = *((word32) ptrArg02 + 0x0C);
		*((word32) ptrArg02 + 0x0C) = (word32) *((word32) ptrArg02 + 0x0C) + 0x01;
		ax_n = DPB(DPB(ax_n, ax_n->*si_n, 0), 0x00, 8);
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		ax_n = fn0800_AEC2(ds, SEQ(wArg04_n, wArg02_n), stackArg4, out ch_n, out dx_n);
	}
	byte bLoc04_n = SLICE(ax_n, byte, 0);
	bLoc04_n = SLICE(ax_n, byte, 0);
	if (ax_n == ~0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		word16 dx_n;
		fn0800-0D24(ds, 0x08, SEQ(dx_n, fn0800-4271(ds, wArg02_n, wArg04_n, out dx_n)), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds, out Top_n);
	}
	ptr16 dx_n;
	word16 ax_n = DPB(fn0800_ACB3(ds, wArg02_n, wArg04_n, 0x01, out cx_n, out dx_n, out bx_n), bLoc04_n, 0);
	dxOut = dx_n;
	dsOut = ds;
	return ax_n;
}

// 0800:3F0A: Register ui16 fn0800-3F0A(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out ptr16 dxOut, Register out Eq_n dsOut)
ui16 fn0800-3F0A(Eq_n ds, Eq_n wArg02, Eq_n wArg04, ptr16 & dxOut, union Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n ds_n;
	cui16 ax_n = DPB(fn0800-3DCF(ds, SEQ(wArg04, wArg02), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n), 0x00, 8);
	Eq_n stackArg4 = <invalid>;
	Eq_n ds_n;
	word16 ax_n = DPB(fn0800-3DCF(ds_n, SEQ(wArg04, wArg02), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n), 0x00, 8);
	ptr16 dx_n;
	fn0800_ACB3(ds_n, wArg02, wArg04, 0x01, out cx_n, out dx_n, out bx_n);
	dxOut = dx_n;
	dsOut = ds_n;
	return (ax_n << 0x08) + ax_n;
}

// 0800:3F58: Register word16 fn0800-3F58(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out ptr16 diOut, Register out Eq_n dsOut)
word16 fn0800-3F58(Eq_n ds, Eq_n wArg02, Eq_n wArg04, ptr16 & diOut, union Eq_n & dsOut)
{
	Eq_n ds_n;
	Eq_n ax_n = fn0800-3E27(ds, wArg02, wArg04, out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
	ptr16 di_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800-3E27(ds_n, wArg02, wArg04, out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
	fn0800_ACB3(ds_n, wArg02, wArg04, 0x01, out cx_n, out dx_n, out bx_n);
	diOut = di_n;
	dsOut = ds_n;
	return ax_n + (ax_n <u 0x00);
}

// 0800:3FAD: Register ui16 fn0800-3FAD(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n chOut, Register out ptr16 diOut, Register out (ptr16 Eq_n) dsOut)
ui16 fn0800-3FAD(Eq_n ds, Eq_n wArg02, Eq_n wArg04, union Eq_n & chOut, ptr16 & diOut, struct Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n stackArg4 = <invalid>;
	Eq_n ds_n;
	ptr16 di_n;
	struct Eq_n * ds_n;
	ui16 ax_n = (DPB(fn0800-3DCF(ds_n, SEQ(wArg04, wArg02), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n), 0x00, 8) << 0x08) + DPB(fn0800-3DCF(ds, SEQ(wArg04, wArg02), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n), 0x00, 8);
	chOut.u0 = <invalid>;
	diOut = di_n;
	dsOut = ds_n;
	return ax_n;
}

// 0800:401E: Register word16 fn0800-401E(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut, Register out (ptr16 Eq_n) dsOut, Register out Eq_n TopOut)
word16 fn0800-401E(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut, struct Eq_n & dsOut, union Eq_n & TopOut)
{
	byte bArg02_n = SLICE(wArg02, byte, 0);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg6 = <invalid>;
	Eq_n stackArg6 = <invalid>;
	Eq_n ds_n;
	ptr16 bx_n;
	ptr16 cx_n;
	ptr16 dx_n;
	Eq_n Top_n;
	struct Eq_n * ds_n;
	word16 ax_n = fn0800-4047(ds_n, SLICE(DPB(fn0800-4047(ds, SLICE(wArg02 >> 0x08, byte, 0), SEQ(wArg06, wArg04), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n), bArg02_n, 0), byte, 0), SEQ(wArg06, wArg04), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	dsOut = ds_n;
	TopOut = Top_n;
	return ax_n;
}

// 0800:4047: Register Eq_n fn0800-4047(Register Eq_n ds, Stack Eq_n bArg02, Stack Eq_n ptrArg04, Stack Eq_n wArg06, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut, Register out Eq_n diOut, Register out Eq_n dsOut, Register out Eq_n TopOut)
Eq_n fn0800-4047(Eq_n ds, Eq_n bArg02, Eq_n ptrArg04, Eq_n wArg06, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut, union Eq_n & diOut, union Eq_n & dsOut, union Eq_n & TopOut)
{
	wArg06_n = SLICE(ptrArg04, word16, 16);
	wArg04_n = SLICE(ptrArg04, word16, 0);
	Eq_n wArg06_n = SLICE(ptrArg04, word16, 16);
	Eq_n wArg04_n = SLICE(ptrArg04, word16, 0);
	Eq_n Top_n = 0x00;
	ptr16 dx_n;
	Eq_n ax_n;
	ci16 v10_n = (word32) *ptrArg04 + 0x01;
	*ptrArg04 = v10_n;
	word16 cx_n = DPB(cx, bArg02, 0);
	ptr16 cx_n = DPB(cx, bArg02, 0);
	ptr16 bx_n = (word16) ptrArg04;
	if (v10_n < 0x00)
	{
		struct Eq_n * ax_n = *((word32) ptrArg04 + 0x0E);
		union Eq_n Eq_n::* si_n = *((word32) ptrArg04 + 0x0C);
		*((word32) ptrArg04 + 0x0C) = (word32) *((word32) ptrArg04 + 0x0C) + 0x01;
		ax_n->*si_n = bArg02;
		dx_n = DPB(dx, bArg02, 0);
		ax_n = DPB(DPB(ax_n, bArg02, 0), 0x00, 8);
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		ax_n = fn0800_B30A(ds, SLICE(cx_n, byte, 0), SEQ(wArg06_n, wArg04_n), stackArg6, out cx_n, out dx_n, out bx_n);
	}
	if (ax_n == ~0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		word16 dx_n;
		ax_n = fn0800-0D24(ds, 0x09, SEQ(dx_n, fn0800-4271(ds, wArg04_n, wArg06_n, out dx_n)), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di, out es_n, out ds, out Top_n);
	}
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	diOut = di;
	dsOut = ds;
	TopOut = Top_n;
	return ax_n;
}

// 0800:409C: Register word16 fn0800-409C(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 dxOut, Register out (ptr16 Eq_n) dsOut, Register out Eq_n TopOut)
word16 fn0800-409C(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & dxOut, struct Eq_n & dsOut, union Eq_n & TopOut)
{
	Eq_n ds_n;
	fn0800-401E(ds, wArg04, wArg06, wArg08, out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
	struct Eq_n * ds_n;
	ptr16 dx_n;
	Eq_n Top_n;
	word16 ax_n = fn0800-401E(ds_n, wArg02, wArg06, wArg08, out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
	dxOut = dx_n;
	dsOut = ds_n;
	TopOut = Top_n;
	return ax_n;
}

// 0800:40BF: Register word16 fn0800-40BF(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n bArg03, Stack Eq_n wArg04, Stack Eq_n wArg06, Register out ptr16 dxOut, Register out ptr16 diOut, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-40BF(Eq_n ds, Eq_n wArg02, Eq_n bArg03, Eq_n wArg04, Eq_n wArg06, ptr16 & dxOut, ptr16 & diOut, struct Eq_n & dsOut)
{
	byte bArg03_n = SLICE(wArg02, byte, 8);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg6 = <invalid>;
	Eq_n ds_n;
	fn0800-4047(ds, SLICE(DPB(ax, bArg02 & ~0x00, 0), byte, 0), SEQ(wArg06, wArg04), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	cu16 wArg02_n = SEQ(bArg03_n, bArg02);
	Eq_n stackArg6 = <invalid>;
	ptr16 dx_n;
	ptr16 di_n;
	struct Eq_n * ds_n;
	word16 ax_n = fn0800-4047(ds_n, SLICE(DPB(wArg02_n >> 0x08, (byte) (wArg02_n >> 0x08) & ~0x00, 0), byte, 0), SEQ(wArg06, wArg04), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
	dxOut = dx_n;
	diOut = di_n;
	dsOut = ds_n;
	return ax_n;
}

// 0800:4110: Register byte fn0800-4110(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A, Stack Eq_n wArg0C, Register out ptr16 siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
byte fn0800-4110(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A, Eq_n wArg0C, ptr16 & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	ptr16 di_n;
	ptr16 si_n;
	Eq_n ax_n = fn0800_ABA3(ds, wArg02, wArg04, 0x01, wArg06, wArg0A, wArg0C, out ch_n, out si_n, out di_n);
	Eq_n cx_n = <invalid>;
	if (wArg08 != 0x00 || ax_n != wArg06)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		word16 dx_n;
		fn0800-0D24(ds, 0x08, SEQ(dx_n, fn0800-4271(ds, wArg0A, wArg0C, out dx_n)), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds, out Top_n);
	}
	siOut = si_n;
	diOut = di_n;
	dsOut = ds;
	return (byte) cx_n;
}

// 0800:4152: Register byte fn0800-4152(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg0A, Stack Eq_n wArg0C, Register out Eq_n dsOut)
byte fn0800-4152(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg0A, Eq_n wArg0C, union Eq_n & dsOut)
{
	struct Eq_n Eq_n::* bp_n;
	Eq_n ax_n = fn0800_AD85(ds, wArg02, wArg04, 0x01, wArg06, wArg0A, wArg0C, out bp_n);
	if ((ss->*bp_n).w000A != 0x00 || ax_n != (ss->*bp_n).t0008)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		word16 dx_n;
		ax_n = fn0800-0D24(ds, 0x09, SEQ(dx_n, fn0800-4271(ds, (ss->*bp_n).t000C, (ss->*bp_n).t000E, out dx_n)), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds, out Top_n);
	}
	dsOut = ds;
	return (byte) ax_n;
}

// 0800:4194: void fn0800-4194(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04)
void fn0800-4194(Eq_n ds, Eq_n wArg02, Eq_n wArg04)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	fn0800_AD2F(ds, SEQ(wArg04, wArg02), stackArg4, out dx_n);
	fn0800_ACB3(ds, wArg02, wArg04, 0x02, out cx_n, out dx_n, out bx_n);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	fn0800_AD2F(ds, SEQ(wArg04, wArg02), stackArg4, out dx_n);
	fn0800_ACB3(ds, wArg02, wArg04, 0x00, out cx_n, out dx_n, out bx_n);
}

// 0800:4234: Register Eq_n fn0800-4234(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 cxOut, Register out Eq_n dxOut, Register out Eq_n bpOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
Eq_n fn0800-4234(Eq_n si, Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & cxOut, union Eq_n & dxOut, union Eq_n & bpOut, ptr16 & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	struct Eq_n Eq_n::* bp_n;
	Eq_n dx_n;
	ptr16 cx_n;
	ptr16 di_n;
	Eq_n ds_n;
	ptr16 si_n;
	Eq_n ax_n = fn0800_AA7E(si, di, ds, wArg02, wArg04, wArg06, wArg08, out cx_n, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	ss->*(bp_n - 0x02) = dx_n;
	ss->*(bp_n - 0x04) = ax_n;
	Eq_n sp_n = <invalid>;
	if ((ax_n | ss->*(bp_n - 0x02)) == 0x00)
	{
		ss->*((word32) sp_n + 0x06) = (ss->*bp_n).w0006;
		ss->*((word32) sp_n + 0x04) = (ss->*bp_n).t0004;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x07;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	Eq_n dx_n = ss->*(bp_n - 0x02);
	Eq_n ax_n = ss->*(bp_n - 0x04);
	Eq_n bp_n = (ss->*bp_n).t0000;
	cxOut = cx_n;
	dxOut = dx_n;
	bpOut = bp_n;
	siOut = si_n;
	diOut = di_n;
	dsOut = ds_n;
	return ax_n;
}

// 0800:4271: Register word16 fn0800-4271(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n dxOut)
word16 fn0800-4271(Eq_n ds, Eq_n wArg02, Eq_n wArg04, union Eq_n & dxOut)
{
	if (wArg04 != *((word32) ds + 0x000029E5) || wArg02 != *((word32) ds + 0x000029E3))
	{
		if (wArg04 != *((word32) ds + 10721) || wArg02 != *((word32) ds + 10719))
		{
			if (wArg04 != *((word32) ds + 10705) || wArg02 != *((word32) ds + 10703))
			{
				if (wArg04 != *((word32) ds + 0x000029DD) || wArg02 != *((word32) ds + 10715))
				{
					if (wArg04 != *((word32) ds + 0x000029D9) || wArg02 != *((word32) ds + 10711))
					{
						if (wArg04 != *((word32) ds + 10709) || wArg02 != *((word32) ds + 10707))
						{
							dxOut.u0 = <invalid>;
							return 0x0A60;
						}
						else
						{
							dxOut.u0 = <invalid>;
							return 0x43AD;
						}
					}
					else
					{
						dxOut.u0 = <invalid>;
						return 0x4412;
					}
				}
				else
				{
					dxOut.u0 = <invalid>;
					return 0x4477;
				}
			}
			else
			{
				dxOut.u0 = <invalid>;
				return 0x4348;
			}
		}
		else
		{
			dxOut.u0 = <invalid>;
			return 0x44DC;
		}
	}
	else
	{
		dxOut.u0 = <invalid>;
		return 0x4541;
	}
}

// 0800:4311: Register Eq_n fn0800-4311(Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n dxOut, Register out Eq_n bpOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
Eq_n fn0800-4311(Eq_n wArg02, Eq_n wArg04, union Eq_n & dxOut, union Eq_n & bpOut, ptr16 & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg2 = <invalid>;
	Eq_n stackArg4 = <invalid>;
	union Eq_n Eq_n::* bp_n;
	Eq_n dx_n;
	ptr16 di_n;
	Eq_n ds_n;
	ptr16 si_n;
	Eq_n ax_n = fn0800-9F89(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	ss->*(bp_n - 0x02) = dx_n;
	ss->*(bp_n - 0x04) = ax_n;
	Eq_n sp_n = <invalid>;
	if ((ax_n | dx_n) == 0x00)
	{
		ss->*((word32) sp_n + 0x02) = ds_n;
		(ss->*sp_n).u0 = 2668;
		(ss->*(sp_n - 0x02)).t0000.u0 = 0x06;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-0D24(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, stackArg6, out cx_n, out dx_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	}
	Eq_n ax_n = ss->*(bp_n - 0x04);
	Eq_n bp_n = ss->*bp_n;
	dxOut = ss->*(bp_n - 0x02);
	bpOut = bp_n;
	siOut = si_n;
	diOut = di_n;
	dsOut = ds_n;
	return ax_n;
}

// 0800:4346: Register word16 fn0800-4346(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-4346(Eq_n ds, Eq_n wArg02, Eq_n wArg04, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut, struct Eq_n & dsOut)
{
	struct Eq_n * ds_n;
	ptr16 dx_n;
	ptr16 bx_n;
	ptr16 cx_n;
	word16 ax_n = fn0800-9E75(ds, wArg04, out cx_n, out dx_n, out bx_n, out ds_n);
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	dsOut = ds_n;
	return ax_n;
}

// 0800:4357: Register word16 fn0800-4357(Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack Eq_n ptrArg06, Stack Eq_n wArg08)
word16 fn0800-4357(Eq_n ptrArg02, Eq_n wArg04, Eq_n ptrArg06, Eq_n wArg08)
{
	while (true)
	{
		word16 wArg02_n = SLICE(ptrArg02, word16, 0);
		ptrArg02 = SLICE(ptrArg02, word16, 16);
		ptrArg02 = SLICE(ptrArg02, word16, 16);
		ptrArg02 = SLICE(ptrArg02, word16, 16);
		word16 wArg06_n = SLICE(ptrArg06, word16, 0);
		wArg06_n = SLICE(ptrArg06, word16, 0);
		Eq_n ptrArg06_n = SLICE(ptrArg06, word16, 16);
		ptrArg06_n.u0 = SLICE(ptrArg06, word16, 16);
		if (*ptrArg06 == 0x00)
			break;
		Eq_n al_n = *ptrArg06;
		int16 ax_n = (int16) al_n;
		if (ax_n != 0x2A)
		{
			if (ax_n != 0x2E)
			{
				if (ax_n != 0x3F)
					goto l0800_nA7;
				if (*ptrArg02 != 0x2E)
				{
					ptrArg02 = SEQ(ptrArg02, wArg02_n);
					if (*ptrArg02 != 0x00)
						;
				}
			}
			else if (*ptrArg02 != 0x00)
			{
l0800_nA7:
				if (al_n != *ptrArg02)
					return 0x00;
			}
		}
		else
		{
			while (true)
			{
				ptrArg06_n.u0 = SLICE(ptrArg06_n, word16, 16);
				word16 wArg02_n = SLICE(ptrArg02, word16, 0);
				ptrArg02 = SLICE(ptrArg02, word16, 16);
				ptrArg02 = SLICE(ptrArg02, word16, 16);
				if (*ptrArg02 == 0x2E || *ptrArg02 == 0x00)
					break;
				ptrArg02 = SEQ(ptrArg02, wArg02_n + 0x01);
				Mem27 = Mem36;
			}
		}
		ptrArg06 = SEQ(SLICE(ptrArg06_n, word16, 16), wArg06_n + 0x01);
		Mem11 = Mem73;
	}
	word16 ax_n;
	if (*ptrArg02 == 0x00)
		ax_n = 0x01;
	else
		ax_n = 0x00;
	return ax_n;
}

// 0800:43D4: void fn0800-43D4(Stack Eq_n wArg02, Stack Eq_n psegArg04, Stack Eq_n wArg06)
void fn0800-43D4(Eq_n wArg02, Eq_n psegArg04, Eq_n wArg06)
{
	Eq_n cx_n = wArg06;
	struct Eq_n Eq_n::* si_n = (word32) wArg02 + (word16) (wArg06 *s 0x0C);
	while (true)
	{
		si_n -= 0x0C;
		--cx_n;
		if (cx_n == 0x00)
			break;
		(psegArg04->*si_n).w0002 = 0x00;
		(psegArg04->*si_n).w0000 = 0x00;
		(psegArg04->*si_n).w0004 = ~0x00;
		(psegArg04->*si_n).w0008 = 0x00;
		(psegArg04->*si_n).w0006 = 0x00;
		(psegArg04->*si_n).w000A = 0x00;
	}
}

// 0800:441C: void fn0800-441C(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n psegArg04, Stack Eq_n wArg06)
void fn0800-441C(Eq_n ds, Eq_n ptrArg02, Eq_n psegArg04, Eq_n wArg06)
{
	struct Eq_n * psegArg04_n = SLICE(ptrArg02, selector, 16);
	Eq_n psegArg04_n = SLICE(ptrArg02, selector, 16);
	word16 di_n = 0x00;
	Eq_n cx_n = 0x00;
	struct Eq_n Eq_n::* si_n = wArg02;
	psegArg04_n = &&(psegArg04_n->*(psegArg04_n->*wArg02).w0000);
	if (wArg06 > 0x00)
	{
		do
		{
			if (((psegArg04_n->*si_n).w0000 | (psegArg04_n->*si_n).w0002) != 0x00)
			{
				++di_n;
				wLoc04 = cx_n;
				Mem47 = Mem40;
			}
			++si_n;
			cx_n = (word32) cx_n + 0x01;
		} while (cx_n < wArg06);
	}
	Eq_n psegArg04_n = SLICE(psegArg04_n, selector, 16);
	Eq_n wArg02_n = SLICE(psegArg04_n, word16, 0);
	if (di_n == 0x00)
		return;
	if (di_n == 0x01)
	{
		struct Eq_n * es_n = SLICE(psegArg04_n, selector, 16);
		word16 bx_n = (word16) (psegArg04_n + wLoc04 *s 0x0C);
		++(es_n->*bx_n).w000A;
	}
	else
	{
		while (true)
		{
			segptr32 ptrArg02_n = SEQ(psegArg04_n, wArg02_n);
			word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
			word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
			word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
			if (fn0800-463B(ds, wArg02_n, psegArg04_n, wArg06) == 0x00)
				break;
			word16 ax_n = (word16) (*((word32) ds + 18008) *s 0x0C);
			struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
			struct Eq_n Eq_n::* bx_n = (word16) ptrArg02_n + ax_n;
			word16 ax_n = (word16) (*((word32) ds + 18010) *s 0x0C);
			ui16 ax_n = (es_n->*bx_n).w0002;
			uint16 dx_n = (es_n->*bx_n).w0000;
			struct Eq_n Eq_n::* bx_n = wArg02_n + ax_n;
			(es_n->*bx_n).w0000 = v23_n;
			ui32 v24_v23_n = SEQ((es_n->*bx_n).w0002, (es_n->*bx_n).w0000) + SEQ(ax_n, dx_n);
			(es_n->*bx_n).w0002 = SLICE(v24_v23_n, word16, 16);
			struct Eq_n Eq_n::* bx_n = wArg02_n + ax_n;
			(es_n->*bx_n).w0002 = 0x00;
			(es_n->*bx_n).w0000 = 0x00;
			struct Eq_n Eq_n::* bx_n = wArg02_n + ax_n;
			++(es_n->*bx_n).w000A;
			word16 cx_n = ax_n;
			word16 dx_n = ax_n;
			uint16 v23_n = (word16) v24_v23_n;
			while (true)
			{
				struct Eq_n * psegArg04_n = SLICE(ptrArg02_n, selector, 16);
				word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
				word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
				struct Eq_n * psegArg04_n = SLICE(ptrArg02_n, selector, 16);
				struct Eq_n * es_n = SLICE(ptrArg02_n, selector, 16);
				struct Eq_n Eq_n::* bx_n = (word16) ptrArg02_n + dx_n;
				if ((es_n->*bx_n).t0004 == ~0x00)
					break;
				Eq_n ax_n = (psegArg04_n->*bx_n).t0004;
				*((word32) ds + 18010) = ax_n;
				word16 ax_n = (word16) (ax_n *s 0x0C);
				struct Eq_n Eq_n::* bx_n = wArg02_n + ax_n;
				++(psegArg04_n->*bx_n).w000A;
				dx_n = ax_n;
				ptrArg02_n = (segptr32) wArg02_n;
			}
			(es_n->*bx_n).t0004 = *((word32) ds + 18008);
			struct Eq_n Eq_n::* bx_n = wArg02_n + ax_n;
			++(es_n->*bx_n).w000A;
			Eq_n psegArg04_n = wArg02_n;
			while (true)
			{
				psegArg04_n = SLICE(psegArg04_n, selector, 16);
				word16 wArg02_n = SLICE(psegArg04_n, word16, 0);
				psegArg04_n = SLICE(psegArg04_n, selector, 16);
				wArg02_n = SLICE(psegArg04_n, word16, 0);
				struct Eq_n Eq_n::* bx_n = (word16) psegArg04_n + cx_n;
				if ((SLICE(psegArg04_n, selector, 16)->*bx_n).t0004 == ~0x00)
					break;
				Eq_n ax_n = (psegArg04_n->*bx_n).t0004;
				*((word32) ds + 18008) = ax_n;
				word16 ax_n = (word16) (ax_n *s 0x0C);
				struct Eq_n Eq_n::* bx_n = wArg02_n + ax_n;
				++(psegArg04_n->*bx_n).w000A;
				cx_n = ax_n;
			}
		}
		fn0800-4550(wArg02_n, psegArg04_n, wArg06);
	}
}

// 0800:4550: void fn0800-4550(Stack Eq_n wArg02, Stack Eq_n psegArg04, Stack Eq_n wArg06)
void fn0800-4550(Eq_n wArg02, Eq_n psegArg04, Eq_n wArg06)
{
	struct Eq_n Eq_n::* sp_n = fp - 0x10;
	Eq_n wLoc04_n = 0x00;
	Eq_n wLoc06_n = 0x00;
	Eq_n wLoc08_n = 0x8000;
	Eq_n wLoc0A_n = 0x00;
	Eq_n wLoc0C_n = 0x01;
	while (wLoc0C_n <= 0x10)
	{
		Eq_n di_n = 0x00;
		Eq_n si_n = wArg02;
		if (wArg06 > 0x00)
		{
			do
			{
				if (psegArg04->*((word32) si_n + 0x0A) == wLoc0C_n)
				{
					union Eq_n Eq_n::* sp_n = sp_n - 0x02;
					ss->*sp_n = wLoc0C_n;
					ss->*(sp_n - 0x02) = wLoc08_n;
					ss->*(sp_n - 0x04) = wLoc0A_n;
					ss->*(sp_n - 0x06) = wLoc04_n;
					ss->*(sp_n - 0x08) = wLoc06_n;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg0 = <invalid>;
					uint16 dx_n;
					Eq_n ax_n = fn0800-8BC2(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
					Eq_n sp_n = <invalid>;
					ss->*((word32) sp_n + 0x06) = dx_n;
					ss->*((word32) sp_n + 0x04) = ax_n;
					word16 dx_n;
					word16 ax_n = fn0800-45E2(ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), out dx_n);
					psegArg04->*((word32) si_n + 0x08) = dx_n;
					psegArg04->*((word32) si_n + 0x06) = ax_n;
					uint32 v21_v20_n = SEQ(wLoc04_n, v20_n) + SEQ(wLoc08_n, wLoc0A_n);
					Eq_n v20_n = (word16) v21_v20_n;
					sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x0A);
					wLoc06_n = v20_n;
					wLoc04_n = SLICE(v21_v20_n, word16, 16);
					Mem96 = Mem87;
				}
				si_n = (word32) si_n + 0x0C;
				di_n = (word32) di_n + 0x01;
			} while (di_n < wArg06);
		}
		wLoc0C_n = (word32) wLoc0C_n + 0x01;
		wLoc08_n >>= 0x01;
		wLoc0A_n = __rcr(wLoc0A_n, 0x01, SLICE(cond(wLoc08_n >> 0x01), bool, 1));
		Mem24 = Mem113;
	}
}

// 0800:45E2: Register ui16 fn0800-45E2(Stack Eq_n wArg02, Stack uint16 wArg04, Stack word16 wArg06, Register out Eq_n dxOut)
ui16 fn0800-45E2(Eq_n wArg02, uint16 wArg04, word16 wArg06, union Eq_n & dxOut)
{
	word16 bx_n = wArg06;
	Eq_n wLoc04_n = 0x00;
	ui16 wLoc06_n = 0x00;
	while (true)
	{
		--bx_n;
		if (bx_n == 0x00)
			break;
		Eq_n ax_n = __rcl(wLoc04_n, 0x01, SLICE(cond(wLoc06_n << 0x01), bool, 1));
		wLoc06_n <<= 0x01;
		if ((wArg02 & 0x01) != 0x00)
			wLoc06_n |= 0x01;
		wLoc04_n = ax_n;
		wArg04 >>= 0x01;
		wArg02 = __rcr(wArg02, 0x01, SLICE(cond(wArg04 >> 0x01), bool, 1));
	}
	dxOut = wLoc04_n;
	return wLoc06_n;
}

// 0800:463B: Register word16 fn0800-463B(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n psegArg04, Stack Eq_n wArg06)
word16 fn0800-463B(Eq_n ds, Eq_n wArg02, Eq_n psegArg04, Eq_n wArg06)
{
	cu16 wLoc0C_n = ~0x00;
	cu16 wLoc0E_n = ~0x00;
	cu16 wLoc08_n = ~0x00;
	cu16 wLoc0A_n = ~0x00;
	Eq_n cx_n = 0x00;
	Eq_n si_n = wArg02;
	if (wArg06 > 0x00)
	{
		do
		{
			cu16 ax_n = psegArg04->*((word32) si_n + 0x02);
			cu16 dx_n = psegArg04->*si_n;
			Mem106 = Mem35;
			if ((dx_n | ax_n) != 0x00)
			{
				if (ax_n <= wLoc08_n && (ax_n < wLoc08_n || dx_n < wLoc0A_n))
				{
					*((word32) ds + 18008) = *((word32) ds + 18010);
					*((word32) ds + 18010) = cx_n;
					wLoc0C_n = wLoc08_n;
					wLoc0E_n = wLoc0A_n;
					wLoc08_n = ax_n;
					wLoc0A_n = dx_n;
					goto l0800_nCD;
				}
				Mem106 = Mem35;
				if (ax_n > wLoc0C_n)
					goto l0800_nCD;
				if (ax_n >= wLoc0C_n)
				{
					Mem106 = Mem35;
					if (dx_n < wLoc0E_n)
						goto l0800_nBD;
				}
				else
				{
l0800_nBD:
					*((word32) ds + 18008) = cx_n;
					wLoc0C_n = ax_n;
					wLoc0E_n = dx_n;
				}
			}
l0800_nCD:
			si_n = (word32) si_n + 0x0C;
			cx_n = (word32) cx_n + 0x01;
		} while (cx_n < wArg06);
	}
	if ((wLoc08_n != ~0x00 || wLoc0A_n != ~0x00) && (wLoc0C_n != ~0x00 || wLoc0E_n != ~0x00))
		return 0x01;
	return 0x00;
}

// 0800:46FE: Register Eq_n fn0800-46FE(Register Eq_n ds, Register out Eq_n dxOut, Register out Eq_n dsOut)
Eq_n fn0800-46FE(Eq_n ds, union Eq_n & dxOut, union Eq_n & dsOut)
{
	if (*((word32) ds + 10757) > 0x00 || *((word32) ds + 10757) >= 0x00 && *((word32) ds + 10755) >= 0x2A)
	{
		fn0800_ACB3(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), 0x00, out cx_n, out dx_n, out bx_n);
		Eq_n ds_n;
		Eq_n ax_n = fn0800-3FAD(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out ch_n, out di_n, out ds_n);
		if (*((word32) ds_n + 10757) > 0x00 || *((word32) ds_n + 10757) >= 0x00 && (word32) ax_n + 0x0024 <= *((word32) ds_n + 10755))
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg0 = <invalid>;
			Eq_n ds_n;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-8CAA(fn0800_ACB3(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), 0x00, out cx_n, out dx_n, out bx_n), 0x08, fn0800-3F58(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out di_n, out ds_n), stackArg0, out dx_n);
			Eq_n sp_n = <invalid>;
			if (dx_n != 0x52 || ax_n != 0x4E43)
			{
				dxOut = dx_n;
				dsOut = ds_n;
				return 0x07;
			}
			else
			{
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				Eq_n dx_n;
				Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x04), stackArg4, out dx_n);
				(ss->*(sp_n - 0x02)).u0 = 0x00;
				(ss->*(sp_n - 0x04)).u0 = 0x00;
				(ss->*(sp_n - 0x06)).u0 = 0x02;
				ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
				fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				word16 di_n;
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				Eq_n wLoc0C_n = ax_n;
				if (di_n != 0x00)
					wLoc0C_n = ax_n - 0x01;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				fn0800-8C69(wLoc0C_n, 0x09, 0x00, stackArg0, out cl_n, out dx_n);
				Eq_n sp_n = <invalid>;
				(ss->*(sp_n - 0x02)).u0 = 0x00;
				(ss->*(sp_n - 0x04)).u0 = 0x00;
				(ss->*(sp_n - 0x06)).u0 = 22;
				ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
				fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x06)).u0 = 0x4D5A;
				Eq_n ds_n;
				fn0800-401E(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x06)).u0 = 0x00;
				(ss->*(sp_n - 0x08)).u0 = 0x00;
				Eq_n ds_n;
				fn0800-409C(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out ds_n, out Top_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x06)).u0 = 0x00;
				(ss->*(sp_n - 0x08)).u0 = 0x00;
				Eq_n ds_n;
				fn0800-409C(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out ds_n, out Top_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x06) = ax_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x06) = ax_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x06) = ax_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x06) = ax_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x06)).u0 = 0x00;
				Eq_n ds_n;
				fn0800-401E(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x06) = ax_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x06) = ax_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x06)).u0 = 0x1E;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x06) = ax_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x06)).u0 = 0x00;
				Eq_n ds_n;
				fn0800-401E(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
				(ss->*(sp_n - 0x02)).u0 = 0x00;
				(ss->*(sp_n - 0x04)).u0 = 0x00;
				ss->*(sp_n - 0x06) = (word32) ax_n + 0x0020;
				ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
				fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
				do
				{
					ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					word16 ax_n = DPB(fn0800-3DCF(ds_n, ss->*(sp_n - 0x04), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n), 0x00, 8);
					word16 di_n = ax_n;
					if (ax_n != 0x00)
					{
						ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
						ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
						Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
						Eq_n si_n = 0x00;
						word16 wLoc0C_n = di_n;
						while (true)
						{
							--wLoc0C_n;
							if (wLoc0C_n == 0x00)
								break;
							ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
							ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_n stackArg4 = <invalid>;
							Eq_n ds_n;
							si_n = (word32) si_n + DPB(fn0800-3DCF(ds_n, ss->*(sp_n - 0x04), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n), 0x00, 8);
							ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
							ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
							ss->*(sp_n - 0x06) = si_n;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_n stackArg3 = <invalid>;
							Eq_n ds_n;
							fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
							ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
							ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
							ss->*(sp_n - 0x06) = ax_n;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_n stackArg3 = <invalid>;
							fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
						}
					}
				} while (di_n != 0x00);
				cui16 di_n;
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				ci16 dx_n;
				Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x04), stackArg4, out dx_n);
				if (dx_n <= 0x00 && (dx_n < 0x00 || ax_n < 0x0200))
				{
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					di_n = 0x0200 - fn0800_AD2F(ds_n, ss->*(sp_n - 0x04), stackArg4, out dx_n);
				}
				else
				{
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					di_n = 0x10 - fn0800_AD2F(ds_n, ss->*(sp_n - 0x04), stackArg4, out dx_n) & 0x0F;
				}
				while (di_n != 0x00)
				{
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
					ss->*(sp_n - 0x06) = DPB(di_n, 0x00, 0);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg6 = <invalid>;
					fn0800-4047(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
				}
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				Eq_n stackArg0 = <invalid>;
				Eq_n dx_n;
				fn0800-8C8A(fn0800_AD2F(ds_n, ss->*(sp_n - 0x04), stackArg4, out dx_n), 0x04, dx_n, stackArg0, out cl_n, out dx_n);
				Eq_n sp_n = <invalid>;
				(ss->*(sp_n - 0x02)).u0 = 0x00;
				ss->*(sp_n - 0x04) = dx_n;
				ss->*(sp_n - 0x06) = ax_n;
				ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
				fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
				union Eq_n Eq_n::* bp_n;
				Eq_n ds_n;
				Eq_n ax_n = fn0800-5374(ds_n, out dx_n, out bp_n, out ds_n);
				Eq_n sp_n = <invalid>;
				if (ax_n == 0x00)
				{
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					Eq_n dx_n;
					Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x04), stackArg4, out dx_n);
					ss->*(bp_n - 0x06) = dx_n;
					ss->*(bp_n - 0x08) = ax_n;
					(ss->*(sp_n - 0x02)).u0 = 0x00;
					ss->*(sp_n - 0x04) = ss->*(bp_n - 0x02);
					ss->*(sp_n - 0x06) = ss->*(bp_n - 0x04);
					ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
					ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
					ui16 dx_n;
					Eq_n ax_n = fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
					fn0800-4194(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
					ui32 dx_ax_n = SEQ(dx_n, ax_n) - SEQ(ss->*(bp_n - 0x02), ss->*(bp_n - 0x04));
					ss->*(sp_n - 0x02) = SLICE(dx_ax_n, word16, 16);
					ss->*(sp_n - 0x04) = (word16) dx_ax_n;
					ss->*(sp_n - 0x06) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x08) = *((word32) ds_n + 10719);
					ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E5);
					ss->*(sp_n - 0x0C) = *((word32) ds_n + 0x000029E3);
					union Eq_n Eq_n::* bp_n;
					Eq_n ds_n;
					fn0800-3B0A(ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out bp_n, out ds_n);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n di_n = ss->*(bp_n - 0x08);
					Eq_n stackArg0 = <invalid>;
					ss->*(bp_n - 0x0A) = fn0800-8CAA(ss->*(bp_n - 0x08), 0x09, ss->*(bp_n - 0x06), stackArg0, out dx_n);
					Eq_n sp_n = <invalid>;
					if ((di_n & 0x01FF) != 0x00)
						ss->*(bp_n - 0x0A) = (word16) (ss->*(bp_n - 0x0A)) + 0x01;
					(ss->*(sp_n - 0x02)).u0 = 0x00;
					(ss->*(sp_n - 0x04)).u0 = 0x00;
					(ss->*(sp_n - 0x06)).u0 = 0x02;
					ss->*(sp_n - 0x08) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x0A) = *((word32) ds_n + 10719);
					fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
					ss->*(sp_n - 0x06) = di_n & 0x01FF;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg3 = <invalid>;
					Eq_n ds_n;
					fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
					ss->*(sp_n - 0x06) = ss->*(bp_n - 0x0A);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg3 = <invalid>;
					Eq_n ds_n;
					fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
					ss->*(sp_n - 0x06) = ss->*(bp_n - 0x0C);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg3 = <invalid>;
					Eq_n ds_n;
					fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
					ss->*(sp_n - 0x06) = ss->*(bp_n - 0x0E);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg3 = <invalid>;
					Eq_n ds_n;
					Eq_n dx_n;
					fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
					dxOut = dx_n;
					dsOut = ds_n;
					return 0x00;
				}
				else
				{
					dxOut = ax_n;
					dsOut = ds_n;
					return ax_n;
				}
			}
		}
		else
		{
			dxOut.u0 = 0x00;
			dsOut = ds_n;
			return 0x07;
		}
	}
	else
	{
		dxOut = dx;
		dsOut = ds;
		return 0x07;
	}
}

// 0800:4B97: Register Eq_n fn0800-4B97(Register Eq_n ax, Register Eq_n dx, Register Eq_n ds, Register out ptr16 dxOut, Register out Eq_n dsOut)
Eq_n fn0800-4B97(Eq_n ax, Eq_n dx, Eq_n ds, ptr16 & dxOut, union Eq_n & dsOut)
{
	Eq_n ds_n;
	ptr16 dx_n;
	if (fn0800-5DCE(ax, dx, ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out dx_n, out ds_n) != 0x00)
	{
		Eq_n ds_n;
		ptr16 dx_n;
		Eq_n ax_n = fn0800-5374(ds_n, out dx_n, out bp_n, out ds_n);
		dxOut = dx_n;
		dsOut = ds_n;
		return ax_n;
	}
	else
	{
		dxOut = dx_n;
		dsOut = ds_n;
		return 0x07;
	}
}

// 0800:4BB1: Register Eq_n fn0800-4BB1(Register Eq_n ax, Register Eq_n dx, Register Eq_n ds, Register out ptr16 dxOut, Register out Eq_n dsOut)
Eq_n fn0800-4BB1(Eq_n ax, Eq_n dx, Eq_n ds, ptr16 & dxOut, union Eq_n & dsOut)
{
	Eq_n ds_n;
	ptr16 dx_n;
	if (fn0800-5DCE(ax, dx, ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out dx_n, out ds_n) != 0x00)
	{
		fn0800_ACB3(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), 0x01, out cx_n, out dx_n, out bx_n);
		fn0800-401E(ds_n, 0x601A, *((word32) ds_n + 10719), *((word32) ds_n + 10721), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
		Eq_n ds_n;
		fn0800-3B0A(0x10, 0x00, out dx_n, out bp_n, out ds_n);
		Eq_n sp_n = <invalid>;
		ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10721);
		ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 10719);
		(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x00;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out dx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10721);
		ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 10719);
		(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x00;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out dx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10721);
		ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 10719);
		ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 0x000029E5);
		ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*((word32) sp_n + 0x06) = fn0800-3E27(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
		Eq_n ds_n;
		fn0800-401E(ds_n, ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
		Eq_n ds_n;
		ptr16 dx_n;
		Eq_n ax_n = fn0800-5374(ds_n, out dx_n, out bp_n, out ds_n);
		dxOut = dx_n;
		dsOut = ds_n;
		return ax_n;
	}
	else
	{
		dxOut = dx_n;
		dsOut = ds_n;
		return 0x07;
	}
}

// 0800:4C55: Register Eq_n fn0800-4C55(Register Eq_n ax, Register word16 bp, Register Eq_n ds, Register out Eq_n dxOut, Register out Eq_n dsOut)
Eq_n fn0800-4C55(Eq_n ax, word16 bp, Eq_n ds, union Eq_n & dxOut, union Eq_n & dsOut)
{
	Eq_n ds_n;
	Eq_n dx_n = fn0800-3E5D(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out ds_n, out Top_n);
	if (dx_n != 0x00 || ax != 1011)
	{
		dxOut = dx_n;
		dsOut = ds_n;
		return 0x07;
	}
	else
	{
		Eq_n ds_n;
		Eq_n ax_n;
		do
		{
			Eq_n ds_n;
			Eq_n dx_n = fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n);
			fn0800-409C(ds_n, ax_n, dx_n, *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
			Eq_n wLoc08_n = dx_n;
			Eq_n wLoc0A_n = ax_n;
			while (true)
			{
				Eq_n v21_n = wLoc0A_n - 0x01;
				wLoc0A_n = v21_n;
				wLoc08_n -= v21_n < 0x00;
				Eq_n ax_n = wLoc0A_n | wLoc08_n;
				if (ax_n == 0x00)
					break;
				Eq_n ds_n;
				fn0800-409C(ds_n, ax_n, fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n), *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
			}
			ax_n |= dx_n;
			Mem66 = Mem129;
		} while (ax_n != 0x00);
		Eq_n ds_n;
		Eq_n ds_n;
		Eq_n ax_n = fn0800-409C(ds_n, ax_n - 0x01, fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n) - (ax_n < 0x01), *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
		Eq_n ds_n;
		Eq_n dx_n = fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n);
		Eq_n ds_n;
		Eq_n dx_n = fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n);
		Eq_n ds_n;
		fn0800-409C(ds_n, ax_n, dx_n, *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
		Eq_n ds_n;
		fn0800-409C(ds_n, ax_n - 0x01, dx_n - (ax_n < 0x01), *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, SEQ(*((word32) ds_n + 10721), *((word32) ds_n + 10719)), stackArg4, out dx_n);
		*((word32) ds_n + 0x00004E8E) = dx_n;
		*((word32) ds_n + 20108) = ax_n;
		fn0800_ACB3(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), 0x01, out cx_n, out dx_n, out bx_n);
		ui32 ax_dx_n = SEQ(dx_n, ax_n) - SEQ(dx_n, ax_n);
		cui16 ax_n = SLICE(ax_dx_n, word16, 16);
		cu16 dx_n = (word16) ax_dx_n;
		cui16 wLoc04_n = ax_n;
		cu16 wLoc06_n = dx_n;
		while (true)
		{
			Eq_n ax_n = wLoc06_n | wLoc04_n;
			if (ax_n == 0x00)
				break;
			Eq_n ds_n;
			fn0800-409C(ds_n, ax_n, fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n), *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
			cu16 v56_n = wLoc06_n - 0x01;
			wLoc06_n = v56_n;
			wLoc04_n -= v56_n < 0x00;
			Mem389 = Mem444;
		}
		Eq_n v45_n = *((word32) ds_n + 0x000029E5);
		Eq_n v46_n = *((word32) ds_n + 0x000029E3);
		Eq_n ax_n = fn0800_ACB3(ds_n, v46_n, v45_n, 0x01, out cx_n, out dx_n, out bx_n);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n v48_n = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		word16 dx_n = fn0800-3E5D(ds_n, v48_n, *((word32) ds_n + 0x000029E5), out ds_n, out Top_n) + (ax_n <u 0x01);
		Eq_n stackArg0 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-8C69((word32) ax_n + 0x01, 0x02, dx_n, stackArg0, out cl_n, out dx_n);
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = ax_n;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x02), stackArg4, out dx_n);
		ss->*sp_n = ax_n;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E3);
		fn0800-4194(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04));
		Eq_n bx_n = ss->*(sp_n - 0x02);
		Eq_n dx_n = ss->*sp_n;
		if (bx_n >= dx_n && (bx_n != dx_n || dx_n >= ax_n))
		{
			dxOut = dx_n;
			dsOut = ds_n;
			return 0x00;
		}
		else
		{
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			Eq_n ds_n;
			Eq_n dx_n = fn0800-3E5D(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ds_n, out Top_n);
			ss->*sp_n = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
			ss->*(sp_n - 0x04) = dx_n;
			ss->*(sp_n - 0x06) = ax_n;
			Eq_n ds_n;
			int8 Top_n;
			fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
			word16 cx_n;
			struct Eq_n Eq_n::* bx_n = Eq_n::a4F14;
			for (cx_n = 0x04; cx_n != 0x00; --cx_n)
			{
				if ((seg0800->*bx_n).w0000 == ax_n)
				{
					cui16 ax_n = bx_n[0x04];
					if (ax_n == (dx_n & 0x3FFF))
					{
						Eq_n dx_n;
						Eq_n ax_n;
						bx_n[0x08]();
						dxOut = dx_n;
						dsOut = ds_n;
						return ax_n;
					}
				}
				++bx_n;
			}
			dxOut = ax_n;
			dsOut = ds_n;
			return 0x09;
		}
	}
}

// 0800:4F2C: void fn0800-4F2C(Register Eq_n ax, Register Eq_n ds)
void fn0800-4F2C(Eq_n ax, Eq_n ds)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800-8C69(ax, 0x02, fn0800-3E5D(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out ds_n, out Top_n), stackArg0, out cl_n, out dx_n);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
	ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x04), stackArg4, out dx_n);
	if (dx_n >= 0x00 && (dx_n > 0x00 || ax_n > 0x12))
	{
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		wLoc16 = fn0800-3E5D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ds_n, out Top_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		wLoc18 = ax_n;
		wLoc0E = fn0800-3E5D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ds_n, out Top_n);
		wLoc10 = ax_n;
	}
	ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
	ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n ds_n;
	word16 dx_n;
	Eq_n ax_n = fn0800-8CAA(ax_n, 0x08, fn0800-3F58(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out di_n, out ds_n), stackArg0, out dx_n);
	Eq_n sp_n = <invalid>;
	if (dx_n != 0x52 || ax_n != 0x4E43)
	{
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-8CAA(ax_n, 0x02, dx_n, stackArg0, out dx_n);
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = ax_n;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		ss->*sp_n = dx_n;
		(ss->*(sp_n - 0x02)).t0000 = ax_n;
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 0x000029E5);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		ss->*((word32) sp_n + 0x02) = dx_n;
		ss->*sp_n = ax_n;
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 0x000029E5);
		(ss->*(sp_n - 0x08)).t0000 = *((word32) ds_n + 0x000029E3);
		Eq_n sp_n = <invalid>;
		union Eq_n Eq_n::* bp_n;
		Eq_n ds_n;
		Eq_n ax_n = fn0800-3B0A(ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out bp_n, out ds_n);
		union Eq_n Eq_n::* sp_n = (word32) sp_n + 0x0C;
		while (true)
		{
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			Eq_n ds_n;
			if (fn0800-3F58(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out di_n, out ds_n) != 0x00 || ax_n != 1004)
				break;
			(ss->*sp_n).u0 = 0x01;
			(ss->*(sp_n - 0x02)).u0 = 0x00;
			(ss->*(sp_n - 0x04)).u0 = 0x04;
			ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E3);
			fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
			ss->*sp_n = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
			(ss->*(sp_n - 0x04)).u0 = 0x00;
			(ss->*(sp_n - 0x06)).u0 = 1004;
			ax_n = fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
			sp_n = (union Eq_n Eq_n::*) ((char *) sp_n + 0x02);
			do
			{
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				ss->*(bp_n - 0x04) = fn0800-3E5D(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ds_n, out Top_n);
				ss->*(bp_n - 0x06) = ax_n;
				ss->*sp_n = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
				ss->*(sp_n - 0x06) = ax_n;
				fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
				sp_n = (union Eq_n Eq_n::*) ((char *) sp_n + 0x02);
				cu16 ax_n = ss->*(bp_n - 0x06) | ss->*(bp_n - 0x04);
				if (ax_n != 0x00)
				{
					ss->*sp_n = *((word32) ds_n + 0x000029E5);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
					Eq_n ds_n;
					ss->*(bp_n - 0x08) = fn0800-3E5D(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ds_n, out Top_n) - (ax_n < 0x01);
					ss->*(bp_n - 0x0A) = ax_n - 0x01;
					ss->*sp_n = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
					ss->*(sp_n - 0x04) = ss->*(bp_n - 0x08);
					ss->*(sp_n - 0x06) = ax_n - 0x01;
					struct Eq_n * ds_n;
					fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg0 = <invalid>;
					Eq_n dx_n;
					Eq_n ax_n = fn0800-8C69(ss->*(bp_n - 0x06), 0x02, ss->*(bp_n - 0x04), stackArg0, out cl_n, out dx_n);
					Eq_n sp_n = <invalid>;
					ss->*(sp_n - 0x02) = dx_n;
					ss->*(sp_n - 0x04) = ax_n;
					ss->*(sp_n - 0x06) = ds_n->t29E1;
					ss->*(sp_n - 0x08) = ds_n->t29DF;
					ss->*(sp_n - 0x0A) = ds_n->t29E5;
					ss->*(sp_n - 0x0C) = ds_n->t29E3;
					fn0800-3B0A(ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out bp_n, out ds_n);
					Eq_n sp_n = <invalid>;
					sp_n = (union Eq_n Eq_n::*) ((word32) sp_n + 0x0C);
				}
				ax_n = ss->*(bp_n - 0x06) | ss->*(bp_n - 0x04);
			} while (ax_n != 0x00);
		}
		Eq_n v58_n = (word32) *((word32) ds_n + 20108) + 0x04;
		*((word32) ds_n + 20108) = v58_n;
		Mem293[ds_n:20110:word16] = Mem289[ds_n:20110:word16] + (v58_n <u 0x00);
	}
	else
	{
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-8CAA(wLoc18, 0x02, wLoc16, stackArg0, out dx_n);
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = ax_n;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*sp_n, stackArg4, out dx_n);
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		ss->*sp_n = *((word32) ds_n + 0x00004E8E);
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 20108);
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000 = wLoc0E;
		(ss->*(sp_n - 0x04)).t0000 = wLoc10;
		Eq_n ds_n;
		fn0800-409C(ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		Eq_n v48_n = (word32) *((word32) ds_n + 20108) + 0x04;
		*((word32) ds_n + 20108) = v48_n;
		Mem629[ds_n:20110:word16] = Mem625[ds_n:20110:word16] + (v48_n <u 0x00);
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		ss->*sp_n = dx_n;
		(ss->*(sp_n - 0x02)).t0000 = ax_n;
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		union Eq_n Eq_n::* bp_n;
		Eq_n ds_n;
		ss->*(bp_n - 0x02) = fn0800-5374(ds_n, out dx_n, out bp_n, out ds_n);
		Eq_n sp_n = <invalid>;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		ui32 ax_dx_n = SEQ(ss->*(bp_n - 0x18), ss->*(bp_n - 0x1A)) + SEQ(ss->*(bp_n - 0x10), ss->*(bp_n - 0x12));
		ss->*(sp_n - 0x04) = SLICE(ax_dx_n, word16, 16);
		ss->*(sp_n - 0x06) = (word16) ax_dx_n;
		ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
	}
}

// 0800:518F: Register Eq_n fn0800-518F(Register Eq_n ax, Register Eq_n dx, Register Eq_n ds, Register out ptr16 dxOut, Register out Eq_n dsOut)
Eq_n fn0800-518F(Eq_n ax, Eq_n dx, Eq_n ds, ptr16 & dxOut, union Eq_n & dsOut)
{
	Eq_n ds_n;
	ptr16 dx_n;
	if (fn0800-5DCE(ax, dx, ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out dx_n, out ds_n) != 0x00)
	{
		Eq_n ds_n;
		ptr16 dx_n;
		Eq_n ax_n = fn0800-5374(ds_n, out dx_n, out bp_n, out ds_n);
		dxOut = dx_n;
		dsOut = ds_n;
		return ax_n;
	}
	else
	{
		dxOut = dx_n;
		dsOut = ds_n;
		return 0x07;
	}
}

// 0800:51A9: Register Eq_n fn0800-51A9(Register Eq_n ds, Register out Eq_n dxOut, Register out Eq_n dsOut)
Eq_n fn0800-51A9(Eq_n ds, union Eq_n & dxOut, union Eq_n & dsOut)
{
	union Eq_n Eq_n::* bp_n = fp - 0x02;
	Eq_n sp_n = fp - 0x08;
	while (true)
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800_AD2F(ds, ss->*(sp_n - 0x02), stackArg4, out dx_n);
		ss->*sp_n = ax_n;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E3);
		fn0800-4194(ds, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04));
		Eq_n bx_n = ss->*(sp_n - 0x02);
		Eq_n dx_n = ss->*sp_n;
		if (bx_n >= dx_n && (bx_n != dx_n || dx_n >= ax_n))
			break;
		ss->*sp_n = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-3E9A(ds, ss->*(sp_n - 0x02), stackArg4, out dx_n, out ds);
		if (ax_n != 0x00)
		{
			if (ax_n != 0x01)
			{
				if (ax_n == 0x03)
				{
					word16 si_n;
					for (si_n = 0x00; si_n != 0x03; ++si_n)
					{
						union Eq_n Eq_n::* sp_n = sp_n - 0x02;
						ss->*sp_n = *((word32) ds + 10721);
						ss->*(sp_n - 0x02) = *((word32) ds + 10719);
						ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E5);
						ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E3);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg4 = <invalid>;
						Eq_n ds_n;
						ss->*(sp_n - 0x04) = fn0800-3DCF(ds, ss->*(sp_n - 0x06), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg6 = <invalid>;
						fn0800-4047(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds, out Top_n);
					}
				}
				else
				{
					ss->*sp_n = *((word32) ds + 0x000029E5);
					ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
					fn0800-4194(ds, ss->*(sp_n - 0x02), ss->*sp_n);
					ss->*sp_n = ax_n;
					ss->*(sp_n - 0x02) = dx_n;
					ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E5);
					ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E3);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					ui16 dx_n;
					ui32 bx_cx_n = SEQ(ss->*(sp_n - 0x02), ss->*sp_n) - SEQ(dx_n, fn0800_AD2F(ds, ss->*(sp_n - 0x06), stackArg4, out dx_n));
					ss->*sp_n = SLICE(bx_cx_n, word16, 16);
					ss->*(sp_n - 0x02) = (word16) bx_cx_n;
					ss->*(sp_n - 0x04) = *((word32) ds + 10721);
					ss->*(sp_n - 0x06) = *((word32) ds + 10719);
					ss->*(sp_n - 0x08) = *((word32) ds + 0x000029E5);
					ss->*(sp_n - 0x0A) = *((word32) ds + 0x000029E3);
					fn0800-3B0A(ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out bp_n, out ds);
					Eq_n sp_n = <invalid>;
					sp_n = (word32) sp_n + 0x0C;
				}
				continue;
			}
			ss->*sp_n = *((word32) ds + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds + 10719);
			ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E5);
			ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E3);
			Eq_n ds_n;
			ss->*(sp_n - 0x04) = fn0800-3E5D(ds, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), out ds_n, out Top_n);
			ss->*(sp_n - 0x06) = ax_n;
			Eq_n ds_n;
			fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			Eq_n ds_n;
			Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ch_n, out di_n, out ds_n);
			(ss->*(bp_n - 0x02)).u0 = 0x00;
			ss->*(bp_n - 0x04) = ax_n;
			ss->*sp_n = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
			ss->*(sp_n - 0x04) = ax_n;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg3 = <invalid>;
			Eq_n ds_n;
			Eq_n ax_n = fn0800-40BF(ds_n, ss->*(sp_n - 0x04), stackArg3, ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out di_n, out ds_n);
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg0 = <invalid>;
			Eq_n ds_n;
			word16 dx_n;
			Eq_n ax_n = fn0800-8CAA(ax_n, 0x08, fn0800-3F58(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out di_n, out ds_n), stackArg0, out dx_n);
			Eq_n sp_n = <invalid>;
			if (dx_n != 0x52 || ax_n != 0x4E43)
			{
				ss->*(sp_n - 0x02) = ss->*(bp_n - 0x02);
				ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
				ss->*(sp_n - 0x06) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x08) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x0C) = *((word32) ds_n + 0x000029E3);
				fn0800-3B0A(ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out bp_n, out ds);
				Eq_n sp_n = <invalid>;
				sp_n = (word32) sp_n + 0x0C;
				continue;
			}
			Eq_n ds_n;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-5374(ds_n, out dx_n, out bp_n, out ds_n);
			Eq_n sp_n = <invalid>;
			if (ax_n == 0x00)
			{
				(ss->*(sp_n - 0x02)).u0 = 0x01;
				Eq_n dx_n = *((word32) ds_n + 0x00002A07);
				Eq_n dx_n = -((word32) dx_n + 0x02);
				Mem341[ss:sp_n - 0x04 + 0x00:word16] = -(Mem328[ds_n:0x2A09:word16] + (dx_n <u 0x02)) - (dx_n == 0x00);
				ss->*(sp_n - 0x06) = dx_n;
				ss->*(sp_n - 0x08) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 10719);
				fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
				ss->*(sp_n - 0x06) = *((word32) ds_n + 0x00002A07);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds);
				(ss->*(sp_n - 0x02)).u0 = 0x01;
				ss->*(sp_n - 0x04) = *((word32) ds + 10761);
				ss->*(sp_n - 0x06) = *((word32) ds + 0x00002A07);
				ss->*(sp_n - 0x08) = *((word32) ds + 10721);
				ss->*(sp_n - 0x0A) = *((word32) ds + 10719);
				fn0800_ACB3(ds, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
				sp_n = sp_n;
				continue;
			}
			else
			{
				dxOut = dx_n;
				dsOut = ds_n;
				return ax_n;
			}
		}
		ss->*sp_n = *((word32) ds + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds + 10719);
		ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E3);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n ds_n;
		ss->*(sp_n - 0x04) = fn0800-3DCF(ds, ss->*(sp_n - 0x06), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		fn0800-4047(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds, out Top_n);
		sp_n = (char *) sp_n + 0x02;
	}
	dxOut = dx_n;
	dsOut = ds;
	return 0x00;
}

// 0800:5374: Register word16 fn0800-5374(Register Eq_n ds, Register out Eq_n dxOut, Register out Eq_n bpOut, Register out Eq_n dsOut)
word16 fn0800-5374(Eq_n ds, union Eq_n & dxOut, union Eq_n & bpOut, union Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n ax_n = fn0800_AD2F(ds, SEQ(*((word32) ds + 0x000029E5), *((word32) ds + 0x000029E3)), stackArg4, out dx_n);
	Eq_n ds_n;
	fn0800-3E5D(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out ds_n, out Top_n);
	*((word32) ds_n + 0x00002A21) = ax_n & 0x03;
	Eq_n ds_n;
	*((word32) ds_n + 10761) = fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n);
	*((word32) ds_n + 0x00002A07) = ax_n & 0x03;
	if (*((word32) ds_n + 0x00002A21) != 0x00)
	{
		Eq_n ds_n;
		*((word32) ds_n + 10757) = fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n);
		*((word32) ds_n + 10755) = ax_n & 0x03;
		Eq_n ds_n;
		*((word32) ds_n + 11851) = fn0800-3E27(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
		Eq_n ds_n;
		*((word32) ds_n + 11849) = fn0800-3E27(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
		fn0800-3E27(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
		Eq_n sp_n = <invalid>;
		union Eq_n Eq_n::* bp_n;
		Eq_n ds_n;
		Eq_n dx_n;
		if (fn0800-2D0A(out dx_n, out bp_n, out ds_n) == *((word32) ds_n + 11849))
		{
			ss->*((word32) sp_n + 0x06) = 0x01;
			ss->*((word32) sp_n + 0x04) = 0x0F;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			Eq_n stackArg4 = <invalid>;
			union Eq_n Eq_n::* bp_n;
			struct Eq_n * ds_n;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			ss->*(bp_n - 0x06) = dx_n;
			ss->*(bp_n - 0x08) = ax_n;
			ds_n->w2E73 = (word16) ((word32) dx_n + 0x01);
			ds_n->w2E71 = 0x00;
			Eq_n sp_n = <invalid>;
			(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
			(ss->*sp_n).u0 = 0x0F;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			Eq_n stackArg4 = <invalid>;
			union Eq_n Eq_n::* bp_n;
			Eq_n ds_n;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			ss->*(bp_n - 0x02) = dx_n;
			ss->*(bp_n - 0x04) = ax_n;
			*((word32) ds_n + 11867) = (word32) dx_n + 0x01;
			((word32) ds_n + 11865)->u0 = 0x00;
			Eq_n dx_n = *((word32) ds_n + 11889);
			*((word32) ds_n + 11887) = *((word32) ds_n + 11891);
			*((word32) ds_n + 11885) = (word32) dx_n + 0x0000FFFD;
			word16 dx_n = Mem251[ds_n:11865:word16] + Mem251[ds_n:11825:word16];
			*((word32) ds_n + 11863) = *((word32) ds_n + 11867);
			*((word32) ds_n + 11861) = dx_n;
			((word32) ds_n + 11853)->u0 = 0x00;
			((word32) ds_n + 11845)->u1 = 0x00;
			((word32) ds_n + 0x000029FD)->u0 = 0x00;
			((word32) ds_n + 10747)->u0 = 0x00;
			((word32) ds_n + 0x00002A01)->u0 = 0x00;
			((word32) ds_n + 0x000029FF)->u0 = 0x00;
			ss->*(bp_n - 0x0E) = *((word32) ds_n + 11855);
			Eq_n sp_n = <invalid>;
			(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
			word16 si_n;
			Eq_n ds_n;
			if (fn0800-5C1A(ds_n, ss->*((word32) sp_n + 0x02), out si_n, out ds_n) != 0x00 && (*((word32) ds_n + 0x00002A25) != 0x02 && *((word32) ds_n + 0x00002A25) != 0x07))
				si_n = 0x0A;
			word16 si_n = si_n;
			if (si_n == 0x00)
			{
				(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
				if (fn0800-5C1A(ds_n, ss->*((word32) sp_n + 0x02), out si_n, out ds_n) != 0x00)
				{
					if (*((word32) ds_n + 0x00002A23) != 0x01)
					{
						(ss->*((word32) sp_n + 0x02)).u0 = 0x10;
						Eq_n ax_n = fn0800-5C1A(ds_n, ss->*((word32) sp_n + 0x02), out si_n, out ds_n);
						if (*((word32) ds_n + 0x00002A25) == 0x02 && *((word32) ds_n + 11855) == 0x00)
							*((word32) ds_n + 11855) = ax_n;
						if (*((word32) ds_n + 11855) != ax_n && *((word32) ds_n + 11855) != 0x00)
							si_n = 0x0C;
					}
					if (*((word32) ds_n + 11855) == 0x00)
						si_n = 11;
				}
				else
					((word32) ds_n + 11855)->u0 = 0x00;
			}
			word16 si_n = si_n;
			if (si_n == 0x00)
			{
				cui16 ax_n = *((word32) ds_n + 0x00002A21);
				if (ax_n != 0x01)
				{
					if (ax_n == 0x02)
						si_n = fn0800-579B(ds_n, out ds_n);
				}
				else
					si_n = fn0800-55E8(ds_n, out ds_n);
			}
			*((word32) ds_n + 11855) = ss->*(bp_n - 0x0E);
			ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x06);
			ss->*sp_n = ss->*(bp_n - 0x08);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			Eq_n ds_n;
			fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n);
			ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x02);
			ss->*sp_n = ss->*(bp_n - 0x04);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			Eq_n ds_n;
			fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n);
			Eq_n v40_n = (word32) *((word32) ds_n + 10755) + 0x0012;
			*((word32) ds_n + 10755) = v40_n;
			Mem462[ds_n:0x2A05:word16] = Mem458[ds_n:0x2A05:word16] + (v40_n <u 0x00);
			(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
			ui32 ax_dx_n = SEQ(ss->*(bp_n - 0x0A), ss->*(bp_n - 0x0C)) + SEQ(*((word32) ds_n + 10757), *((word32) ds_n + 10755));
			ss->*sp_n = SLICE(ax_dx_n, word16, 16);
			(ss->*(sp_n - 0x02)).t0000 = (word16) ax_dx_n;
			(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 0x000029E5);
			(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 0x000029E3);
			Eq_n dx_n;
			fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
			if (si_n == 0x00)
			{
				if (*((word32) ds_n + 11853) == *((word32) ds_n + 11851))
				{
					Eq_n bp_n = ss->*bp_n;
					dxOut = dx_n;
					bpOut = bp_n;
					dsOut = ds_n;
					return 0x00;
				}
				else
				{
					Eq_n bp_n = ss->*bp_n;
					dxOut = dx_n;
					bpOut = bp_n;
					dsOut = ds_n;
					return 0x06;
				}
			}
			else
			{
				Eq_n bp_n = ss->*bp_n;
				dxOut = dx_n;
				bpOut = bp_n;
				dsOut = ds_n;
				return si_n;
			}
		}
		else
		{
			Eq_n bp_n = ss->*bp_n;
			dxOut = dx_n;
			bpOut = bp_n;
			dsOut = ds_n;
			return 0x05;
		}
	}
	else
	{
		union Eq_n Eq_n::* bp_n;
		Eq_n ds_n;
		fn0800-3B0A(ax_n & 0x03, *((word32) ds_n + 10761), out dx_n, out bp_n, out ds_n);
		Eq_n dx_n = *((word32) ds_n + 0x00002A07);
		*((word32) ds_n + 10757) = *((word32) ds_n + 10761);
		*((word32) ds_n + 10755) = dx_n;
		Eq_n bp_n = ss->*bp_n;
		dxOut = dx_n;
		bpOut = bp_n;
		dsOut = ds_n;
		return 0x00;
	}
}

// 0800:55E8: Register word16 fn0800-55E8(Register Eq_n ds, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-55E8(Eq_n ds, struct Eq_n & dsOut)
{
	Eq_n sp_n = fp - 0x06;
	while (true)
	{
		Eq_n ax_n = *((word32) ds + 0x00002A01);
		Eq_n dx_n = *((word32) ds + 0x000029FF);
		if (ax_n >= *((word32) ds + 10761) && (ax_n != *((word32) ds + 10761) || dx_n >= *((word32) ds + 0x00002A07)))
			break;
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).u0 = 0x10;
		ss->*(sp_n - 0x02) = ds;
		(ss->*(sp_n - 0x04)).u0 = 10511;
		Eq_n ds_n = fn0800-5A24(ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n);
		(ss->*sp_n).u0 = 0x10;
		ss->*(sp_n - 0x02) = ds_n;
		(ss->*(sp_n - 0x04)).u0 = 10319;
		Eq_n ds_n = fn0800-5A24(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n);
		(ss->*sp_n).u0 = 0x10;
		ss->*(sp_n - 0x02) = ds_n;
		(ss->*(sp_n - 0x04)).u0 = 10127;
		Eq_n ds_n = fn0800-5A24(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n);
		(ss->*sp_n).u0 = 0x10;
		sp_n = (char *) sp_n + 0x02;
		cui16 wLoc04_n = 0x00;
		Eq_n wLoc06_n = fn0800-5C39(ds_n, ss->*sp_n, out si_n, out di_n, out ds);
		while (true)
		{
			Eq_n v11_n = wLoc06_n - 0x01;
			cui16 v12_n = wLoc04_n - (v11_n < 0x00);
			wLoc06_n = v11_n;
			wLoc04_n = v12_n;
			if ((wLoc06_n | wLoc04_n) == 0x00)
				break;
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = ds;
			(ss->*(sp_n - 0x02)).u0 = 10511;
			Eq_n ax_n = fn0800-5A8D(ds, ss->*(sp_n - 0x02), ss->*sp_n, out ds);
			*((word32) ds + 11847) = ax_n;
			word16 v17_n = Mem197[ds:0x29FF:word16] + ax_n;
			*((word32) ds + 0x000029FF) = v17_n;
			Mem203[ds:0x2A01:word16] = Mem199[ds:0x2A01:word16] + (v17_n <u 0x00);
			sp_n = (char *) sp_n + 0x02;
			if (*((word32) ds + 11847) != 0x00)
			{
				while (true)
				{
					word16 dx_n;
					Eq_n ax_n = *((word32) ds + 11847);
					--*((word32) ds + 11847);
					Eq_n ax_n = ax_n;
					if (ax_n == 0x00)
						break;
					Eq_n ds_n;
					word16 ax_n = fn0800-5B15(ds, out si_n, out di_n, out ds_n);
					union Eq_n Eq_n::* sp_n = sp_n - 0x02;
					ss->*sp_n = DPB(ax_n, (byte) ax_n ^ *((word32) ds_n + 11855), 0);
					ds = fn0800-5D2F(ds_n, ss->*sp_n);
					dx_n = dx_n;
				}
				if ((*((word32) ds + 11855) & 0x01) != 0x00)
				{
					ax_n = *((word32) ds + 11855) >> 0x01 | 0x8000;
					*((word32) ds + 11855) = ax_n;
				}
				else
					*((word32) ds + 11855) >>= 0x01;
				Eq_n es_bx_n = *((word32) ds + 11885);
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = DPB(DPB(ax_n, *((word32) es_bx_n + 0x02), 0), 0x00, 8);
				cui16 dx_n = DPB(DPB(dx_n, *((word32) es_bx_n + 0x01), 0), 0x00, 8);
				word16 dx_n = Mem277[ss:sp_n + 0x00:word16] + (dx_n << 0x08 <u 0x00);
				word16 bx_n = DPB(DPB((word16) es_bx_n, *es_bx_n, 0), 0x00, 8);
				ss->*sp_n = dx_n << 0x08;
				ss->*(sp_n - 0x02) = dx_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				int32 dx_ax_n = SEQ(ss->*(sp_n - 0x02), ss->*sp_n) + (int32) bx_n;
				Eq_n stackArg0 = <invalid>;
				Eq_n sp_n = <invalid>;
				Eq_n dx_n;
				ss->*(sp_n - 0x02) = fn0800-8C69((word16) dx_ax_n, *((word32) ds + 11845), SLICE(dx_ax_n, word16, 16), stackArg0, out cl_n, out dx_n);
				ui16 ax_n = 0x01 << *((word32) ds + 11845);
				ss->*(sp_n - 0x04) = dx_n;
				int32 dx_ax_n = (int32) (ax_n - 0x01);
				ui32 ax_dx_n = SEQ(ss->*(sp_n - 0x04), ss->*(sp_n - 0x02)) + SEQ(*((word32) ds + 0x000029FD) & SLICE(dx_ax_n, word16, 16), *((word32) ds + 10747) & (word16) dx_ax_n);
				*((word32) ds + 0x000029FD) = SLICE(ax_dx_n, word16, 16);
				*((word32) ds + 10747) = (word16) ax_dx_n;
				sp_n = sp_n;
			}
			if ((v11_n | v12_n) == 0x00)
				break;
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = ds;
			(ss->*(sp_n - 0x02)).u0 = 10319;
			Eq_n ds_n;
			*((word32) ds_n + 11819) = (word16) fn0800-5A8D(ds, ss->*(sp_n - 0x02), ss->*sp_n, out ds_n) + 0x01;
			ss->*sp_n = ds_n;
			(ss->*(sp_n - 0x02)).u0 = 10127;
			Eq_n ax_n = fn0800-5A8D(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ds);
			*((word32) ds + 11817) = (ui16) ((word32) ax_n + 0x02);
			Eq_n v19_n = (word32) *((word32) ds + 0x000029FF) + ((word32) ax_n + 0x02);
			*((word32) ds + 0x000029FF) = v19_n;
			Mem410[ds:0x2A01:word16] = Mem406[ds:0x2A01:word16] + (v19_n <u 0x00);
			while (true)
			{
				ui16 ax_n = *((word32) ds + 11817);
				--*((word32) ds + 11817);
				if (ax_n == 0x00)
					break;
				Eq_n es_bx_n = *((word32) ds + 11861);
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = DPB(ax_n, SLICE(es_bx_n, selector, 16)->*((word16) es_bx_n - *((word32) ds + 11819)), 0);
				ds = fn0800-5D2F(ds, ss->*sp_n);
			}
		}
	}
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	ss->*sp_n = *((word32) ds + 10721);
	ss->*(sp_n - 0x02) = *((word32) ds + 10719);
	cup16 ax_n = *((word32) ds + 11861) - *((word32) ds + 11865);
	Eq_n ax_n = ax_n - *((word32) ds + 11825);
	ss->*(sp_n - 0x04) = 0x00 - (ax_n < 0x00) - (ax_n < 0x00);
	ss->*(sp_n - 0x06) = ax_n;
	word16 ax_n = Mem45[ds:11865:word16] + Mem45[ds:11825:word16];
	ss->*(sp_n - 0x08) = *((word32) ds + 11867);
	ss->*(sp_n - 0x0A) = ax_n;
	struct Eq_n * ds_n;
	fn0800-4152(ds, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x02), ss->*sp_n, out ds_n);
	dsOut = ds_n;
	return 0x00;
}

// 0800:579B: Register word16 fn0800-579B(Register Eq_n ds, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-579B(Eq_n ds, struct Eq_n & dsOut)
{
	while (true)
	{
		Eq_n ax_n = *((word32) ds + 0x00002A01);
		Eq_n dx_n = *((word32) ds + 0x000029FF);
		if (ax_n >= *((word32) ds + 10761) && (ax_n != *((word32) ds + 10761) || dx_n >= *((word32) ds + 0x00002A07)))
		{
			struct Eq_n * ds_n;
			fn0800-4152(ds, Mem38[ds:11865:word16] + Mem38[ds:11825:word16], Mem38[ds:11867:word16], Mem24[ds:11861:word16] - Mem24[ds:11865:word16] - Mem24[ds:11825:word16], Mem21[ds:10719:word16], Mem5[ds:10721:word16], out ds_n);
			dsOut = ds_n;
			return 0x00;
		}
l0800_nCF:
		while (true)
		{
			while (true)
			{
				Eq_n ds_n;
				if (fn0800-5CD9(ds, 0x01, out ds_n) != 0x00)
					break;
				Eq_n ds_n;
				word16 ax_n = fn0800-5B15(ds_n, out si_n, out di_n, out ds_n);
				ds = fn0800-5D2F(ds_n, SLICE(DPB(ax_n, (byte) ax_n ^ *((word32) ds_n + 11855), 0), byte, 0));
				if ((*((word32) ds + 11855) & 0x01) != 0x00)
					*((word32) ds + 11855) = *((word32) ds + 11855) >> 0x01 | 0x8000;
				else
					*((word32) ds + 11855) >>= 0x01;
				Eq_n v16_n = (word32) *((word32) ds + 0x000029FF) + 0x01;
				*((word32) ds + 0x000029FF) = v16_n;
				Mem139[ds:0x2A01:word16] = Mem135[ds:0x2A01:word16] + (v16_n <u 0x00);
			}
			Eq_n ds_n;
			if (fn0800-5CD9(ds_n, 0x01, out ds_n) != 0x00)
				break;
			Eq_n ds_n = fn0800-593F(ds_n);
			if (*((word32) ds_n + 11817) == 0x09)
			{
				ds = fn0800-5A0F(ds_n);
				word16 v22_n = Mem143[ds:0x29FF:word16] + Mem143[ds:11847:word16];
				*((word32) ds + 0x000029FF) = v22_n;
				Mem246[ds:0x2A01:word16] = Mem242[ds:0x2A01:word16] + (v22_n <u 0x00);
				while (true)
				{
					Eq_n ax_n = *((word32) ds + 11847);
					--*((word32) ds + 11847);
					if (ax_n == 0x00)
						break;
					Eq_n ds_n;
					word16 ax_n = fn0800-5B15(ds, out si_n, out di_n, out ds_n);
					ds = fn0800-5D2F(ds_n, SLICE(DPB(ax_n, (byte) ax_n ^ *((word32) ds_n + 11855), 0), byte, 0));
					Mem249 = Mem278;
				}
				if ((*((word32) ds + 11855) & 0x01) != 0x00)
					*((word32) ds + 11855) = *((word32) ds + 11855) >> 0x01 | 0x8000;
				else
					*((word32) ds + 11855) >>= 0x01;
			}
			else
			{
				ds = fn0800-5975(ds_n);
				Eq_n v28_n = (word32) *((word32) ds + 0x000029FF) + *((word32) ds + 11817);
				*((word32) ds + 0x000029FF) = v28_n;
				Mem192[ds:0x2A01:word16] = Mem188[ds:0x2A01:word16] + (v28_n <u 0x00);
				while (true)
				{
					ui16 ax_n = *((word32) ds + 11817);
					--*((word32) ds + 11817);
					if (ax_n == 0x00)
						break;
					Eq_n es_bx_n = *((word32) ds + 11861);
					ds = fn0800-5D2F(ds, SLICE(DPB(ax_n, SLICE(es_bx_n, selector, 16)->*((word16) es_bx_n - *((word32) ds + 11819)), 0), byte, 0));
					Mem195 = Mem213;
				}
			}
		}
		Eq_n ds_n;
		Eq_n ds_n;
		if (fn0800-5CD9(ds_n, 0x01, out ds_n) == 0x00)
			break;
		Eq_n ds_n;
		Eq_n ds_n;
		if (fn0800-5CD9(ds_n, 0x01, out ds_n) == 0x00)
		{
			*((word32) ds_n + 11817) = 0x03;
l0800_n:
			ds = fn0800-5975(ds_n);
			goto l0800_n;
		}
		*((word32) ds_n + 11817) = DPB(fn0800-5B15(ds_n, out si_n, out di_n, out ds_n), 0x00, 8) + 0x08;
		ds_n = ds_n;
		if (*((word32) ds_n + 11817) != 0x08)
			goto l0800_n;
		fn0800-5CD9(ds_n, 0x01, out ds);
	}
	*((word32) ds_n + 11817) = 0x02;
	*((word32) ds_n + 11819) = DPB(fn0800-5B15(ds_n, out si_n, out di_n, out ds_n), 0x00, 8) + 0x01;
	ds = ds_n;
l0800_n:
	Eq_n v13_n = (word32) *((word32) ds + 0x000029FF) + *((word32) ds + 11817);
	*((word32) ds + 0x000029FF) = v13_n;
	Mem423[ds:0x2A01:word16] = Mem419[ds:0x2A01:word16] + (v13_n <u 0x00);
	while (true)
	{
		ui16 ax_n = *((word32) ds + 11817);
		--*((word32) ds + 11817);
		if (ax_n == 0x00)
			break;
		Eq_n es_bx_n = *((word32) ds + 11861);
		ds = fn0800-5D2F(ds, SLICE(DPB(ax_n, SLICE(es_bx_n, selector, 16)->*((word16) es_bx_n - *((word32) ds + 11819)), 0), byte, 0));
		Mem426 = Mem444;
	}
	goto l0800_nCF;
}

// 0800:593F: Register Eq_n fn0800-593F(Register Eq_n ds)
Eq_n fn0800-593F(Eq_n ds)
{
	Eq_n ds_n;
	*((word32) ds_n + 11817) = (word16) fn0800-5CD9(ds, 0x01, out ds_n) + 0x04;
	Eq_n ds_n;
	if (fn0800-5CD9(ds_n, 0x01, out ds_n) != 0x00)
		*((word32) ds_n + 11817) = (word16) fn0800-5CD9(ds_n, 0x01, out ds_n) + (*((word32) ds_n + 11817) - 0x01 << 0x01);
	return ds_n;
}

// 0800:5975: Register Eq_n fn0800-5975(Register Eq_n ds)
Eq_n fn0800-5975(Eq_n ds)
{
	((word32) ds + 11819)->u0 = 0x00;
	Eq_n ds_n;
	if (fn0800-5CD9(ds, 0x01, out ds_n) != 0x00)
	{
		Eq_n ds_n;
		*((word32) ds_n + 11819) = fn0800-5CD9(ds_n, 0x01, out ds_n);
		if (fn0800-5CD9(ds_n, 0x01, out ds_n) != 0x00)
		{
			Eq_n ds_n;
			*((word32) ds_n + 11819) = (word16) fn0800-5CD9(ds_n, 0x01, out ds_n) + (*((word32) ds_n + 11819) << 0x01) | 0x04;
			if (fn0800-5CD9(ds_n, 0x01, out ds_n) == 0x00)
				*((word32) ds_n + 11819) = (word16) fn0800-5CD9(ds_n, 0x01, out ds_n) + (*((word32) ds_n + 11819) << 0x01);
		}
		else if (*((word32) ds_n + 11819) == 0x00)
			*((word32) ds_n + 11819) = (word16) fn0800-5CD9(ds_n, 0x01, out ds_n) + 0x02;
	}
	Eq_n ds_n;
	*((word32) ds_n + 11819) = (*((word32) ds_n + 11819) << 0x08) + DPB(fn0800-5B15(ds_n, out si_n, out di_n, out ds_n), 0x00, 8) + 0x01;
	return ds_n;
}

// 0800:5A0F: Register Eq_n fn0800-5A0F(Register Eq_n ds)
Eq_n fn0800-5A0F(Eq_n ds)
{
	Eq_n ds_n;
	*((word32) ds_n + 11847) = (fn0800-5CD9(ds, 0x04, out ds_n) << 0x02) + 0x0C;
	return ds_n;
}

// 0800:5A24: Register Eq_n fn0800-5A24(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06)
Eq_n fn0800-5A24(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06)
{
	fn0800-43D4(wArg02, wArg04, wArg06);
	Eq_n ds_n;
	Eq_n ax_n = fn0800-5C39(ds, 0x05, out si_n, out di_n, out ds_n);
	Eq_n wArg06_n = ax_n;
	if (ax_n != 0x00)
	{
		if (ax_n > 0x10)
			wArg06_n.u0 = 0x10;
		if (wArg06_n > 0x00)
		{
			do
			{
				union Eq_n Eq_n::* si_n;
				cup16 di_n;
				wArg04->*si_n = fn0800-5C39(ds_n, 0x04, out si_n, out di_n, out ds_n);
			} while (di_n + 0x01 < wArg06_n);
		}
		fn0800-4550(wArg02, wArg04, wArg06_n);
	}
	return ds_n;
}

// 0800:5A8D: Register Eq_n fn0800-5A8D(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n psegArg04, Register out Eq_n dsOut)
Eq_n fn0800-5A8D(Eq_n ds, Eq_n wArg02, Eq_n psegArg04, union Eq_n & dsOut)
{
	Eq_n wLoc04_n = 0x00;
	Eq_n di_n = wArg02;
	while (true)
	{
		byte bLoc04_n = SLICE(wLoc04_n, byte, 0);
		if (psegArg04->*((word32) di_n + 0x0A) != 0x00)
		{
			int32 dx_ax_n = (int32) ((0x01 << psegArg04->*((word32) di_n + 0x0A)) - 0x01);
			cui16 cx_n = *((word32) ds + 10747) & (word16) dx_ax_n;
			if ((*((word32) ds + 0x000029FD) & SLICE(dx_ax_n, word16, 16)) == psegArg04->*((word32) di_n + 0x08) && cx_n == psegArg04->*((word32) di_n + 0x06))
			{
				Eq_n ds_n;
				fn0800-5C39(ds, (word32) wArg02 + (word16) (wLoc04_n *s 0x0C) + 0x0A, out si_n, out di_n, out ds_n);
				if (wLoc04_n >= 0x02)
				{
					Eq_n ds_n;
					Eq_n ax_n = fn0800-5C39(ds_n, wLoc04_n - 0x01, out si_n, out di_n, out ds_n) | 0x01 << bLoc04_n - 0x01;
					dsOut = ds_n;
					return ax_n;
				}
				else
				{
					dsOut = ds_n;
					return wLoc04_n;
				}
			}
		}
		di_n = (word32) di_n + 0x0C;
		wLoc04_n = (word32) wLoc04_n + 0x01;
		Mem21 = Mem49;
	}
}

// 0800:5B15: Register word16 fn0800-5B15(Register Eq_n ds, Register out Eq_n siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
word16 fn0800-5B15(Eq_n ds, union Eq_n & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	Eq_n ax_n = *((word32) ds + 11891);
	Eq_n dx_n = *((word32) ds + 11889);
	if (ax_n == *((word32) ds + 11887) && (word32) dx_n + 0x0000FFFD == *((word32) ds + 11885))
	{
		Eq_n ax_n;
		Eq_n dx_n;
		fn0800-4194(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5));
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		ui16 dx_n;
		ui32 bx_cx_n = SEQ((word32) dx_n + 0x0000FFFD, ax_n) - SEQ(dx_n, fn0800_AD2F(ds, SEQ(*((word32) ds + 0x000029E5), *((word32) ds + 0x000029E3)), stackArg4, out dx_n));
		Eq_n cx_n = (word16) bx_cx_n;
		Eq_n bx_n = SLICE(bx_cx_n, word16, 16);
		if (bx_n >= 0x00 && (bx_n > 0x00 || cx_n > ~0x02))
		{
			dx_n.u0 = 0x00;
			ax_n.u0 = ~0x02;
		}
		else
		{
			dx_n = bx_n;
			ax_n = cx_n;
		}
		Eq_n v23_n = *((word32) ds + 0x000029E5);
		Eq_n v24_n = *((word32) ds + 0x000029E3);
		Eq_n ax_n = *((word32) ds + 11891);
		Eq_n dx_n = *((word32) ds + 11889);
		*((word32) ds + 11887) = ax_n;
		*((word32) ds + 11885) = dx_n;
		Eq_n ds_n;
		fn0800-4110(ds, dx_n, ax_n, ax_n, dx_n, v24_n, v23_n, out si_n, out di_n, out ds_n);
		ui32 v27_v26_n = SEQ(bx_n, v26_n) - SEQ(dx_n, ax_n);
		Eq_n v26_n = (word16) v27_v26_n;
		Eq_n v27_n = SLICE(v27_v26_n, word16, 16);
		Eq_n wLoc06_n = v26_n;
		Eq_n wLoc04_n = v27_n;
		if (Test(UGE,false) && (v27_n > 0x00 || v26_n > 0x02))
		{
			wLoc04_n.u0 = 0x00;
			wLoc06_n.u0 = 0x02;
		}
		fn0800-4110(ds_n, Mem163[ds_n:11889:word16] + ax_n, Mem163[ds_n:11891:word16], wLoc06_n, wLoc04_n, Mem153[ds_n:0x29E3:word16], Mem147[ds_n:0x29E5:word16], out si, out di, out ds);
		ax_n = fn0800_ACB3(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), 0x01, out cx_n, out dx_n, out bx_n);
	}
	Eq_n es_bx_n = *((word32) ds + 11885);
	*((word32) ds + 11885) = (word32) *((word32) ds + 11885) + 0x01;
	word16 ax_n = DPB(ax_n, *es_bx_n, 0);
	siOut = si;
	diOut = di;
	dsOut = ds;
	return ax_n;
}

// 0800:5C1A: Register Eq_n fn0800-5C1A(Register Eq_n ds, Stack Eq_n wArg02, Register out ptr16 siOut, Register out (ptr16 Eq_n) dsOut)
Eq_n fn0800-5C1A(Eq_n ds, Eq_n wArg02, ptr16 & siOut, struct Eq_n & dsOut)
{
	if (*((word32) ds + 0x00002A21) != 0x02)
	{
		ptr16 si_n;
		struct Eq_n * ds_n;
		Eq_n ax_n = fn0800-5C39(ds, wArg02, out si_n, out di_n, out ds_n);
		siOut = si_n;
		dsOut = ds_n;
		return ax_n;
	}
	else
	{
		struct Eq_n * ds_n;
		Eq_n ax_n = fn0800-5CD9(ds, wArg02, out ds_n);
		siOut = si;
		dsOut = ds_n;
		return ax_n;
	}
}

// 0800:5C39: Register cui16 fn0800-5C39(Register Eq_n ds, Stack Eq_n wArg02, Register out ptr16 siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
cui16 fn0800-5C39(Eq_n ds, Eq_n wArg02, ptr16 & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	Eq_n sp_n = fp - 0x0C;
	Eq_n si_n = wArg02;
	cui16 di_n = 0x00;
	ui16 wLoc08_n = 0x01;
	while (true)
	{
		Eq_n si_n = si_n;
		if (si_n == 0x00)
			break;
		if (*((word32) ds + 11845) == 0x00)
		{
			Eq_n ds_n;
			word16 ax_n = DPB(fn0800-5B15(ds, out si_n, out di_n, out ds_n), 0x00, 8);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			word16 ax_n = fn0800-5B15(ds_n, out si_n, out di_n, out ds);
			Eq_n stackArg0 = <invalid>;
			word16 dx_n;
			Eq_n ax_n = fn0800-8C69(DPB(DPB(DPB(ax_n, 0x00, 8), *((word32) *((word32) ds + 11885) + 0x01), 0), 0x00, 8), 0x18, 0x00, stackArg0, out cl_n, out dx_n);
			cup16 ax_n = (word32) ax_n + (DPB(ax_n, 0x00, 8) << 0x08);
			Eq_n es_bx_n = *((word32) ds + 11885);
			Eq_n ax_n = ax_n + ax_n;
			*((word32) ds + 0x000029FD) = (bool) (ax_n < 0x00) + ((bool) (ax_n < 0x00) + ((bool) (ax_n < 0x00) + (dx_n + DPB(DPB((word16) es_bx_n, *es_bx_n, 0), 0x00, 8))));
			*((word32) ds + 10747) = ax_n;
			((word32) ds + 11845)->u1 = 0x10;
			sp_n.u0 = <invalid>;
		}
		if ((*((word32) ds + 10747) & 0x01) != 0x00)
			di_n |= wLoc08_n;
		Eq_n ax_n = *((word32) ds + 0x000029FD);
		Eq_n dx_n = __rcr(*((word32) ds + 10747), 0x01, SLICE(cond(ax_n >> 0x01), bool, 1));
		*((word32) ds + 0x000029FD) = ax_n >> 0x01;
		*((word32) ds + 10747) = dx_n;
		--*((word32) ds + 11845);
		wLoc08_n <<= 0x01;
		si_n = si_n - 0x01;
	}
	ptr16 di_n = ss->*sp_n;
	siOut = ss->*((word32) sp_n + 0x02);
	diOut = di_n;
	dsOut = ds;
	return di_n;
}

// 0800:5CD9: Register ui16 fn0800-5CD9(Register Eq_n ds, Stack Eq_n wArg02, Register out Eq_n dsOut)
ui16 fn0800-5CD9(Eq_n ds, Eq_n wArg02, union Eq_n & dsOut)
{
	Eq_n di_n = wArg02;
	ui16 si_n = 0x00;
	while (true)
	{
		Eq_n di_n = di_n;
		if (di_n == 0x00)
			break;
		if (*((word32) ds + 11845) == 0x00)
		{
			Eq_n ax_n = DPB(fn0800-5B15(ds, out si_n, out di_n, out ds), 0x00, 8);
			((word32) ds + 0x000029FD)->u0 = 0x00;
			*((word32) ds + 10747) = ax_n;
			((word32) ds + 11845)->u1 = 0x08;
		}
		si_n <<= 0x01;
		if ((*((word32) ds + 10747) & 0x80) != 0x00)
			++si_n;
		Eq_n dx_n = *((word32) ds + 10747);
		*((word32) ds + 0x000029FD) = __rcl(*((word32) ds + 0x000029FD), 0x01, SLICE(cond(dx_n << 0x01), bool, 1));
		*((word32) ds + 10747) = dx_n << 0x01;
		--*((word32) ds + 11845);
		di_n = di_n - 0x01;
	}
	dsOut = ds;
	return si_n;
}

// 0800:5D2F: Register Eq_n fn0800-5D2F(Register Eq_n ds, Stack Eq_n bArg02)
Eq_n fn0800-5D2F(Eq_n ds, Eq_n bArg02)
{
	Eq_n ax_n = *((word32) ds + 11867);
	Eq_n dx_n = *((word32) ds + 11865);
	if (ax_n == *((word32) ds + 11863) && dx_n - 0x01 == *((word32) ds + 11861))
	{
		fn0800-4152(ds, Mem32[ds:11865:word16] + Mem32[ds:11825:word16], Mem32[ds:11867:word16], ~0x00 - Mem22[ds:11825:word16], Mem19[ds:10719:word16], Mem7[ds:10721:word16], out ds);
		fn0800_B0F3(*((word32) ds + 11865), *((word32) ds + 11867), *((word32) ds + 11861) - *((word32) ds + 11825), *((word32) ds + 11863), *((word32) ds + 11825));
		ax_n = *((word32) ds + 11867);
		word16 dx_n = Mem71[ds:11865:word16] + Mem71[ds:11825:word16];
		*((word32) ds + 11863) = ax_n;
		*((word32) ds + 11861) = dx_n;
	}
	**((word32) ds + 11861) = bArg02;
	((word32) ds + 11861)->u0 = (word16) ((word32) ds + 11861)->u0 + 0x01;
	Mem116[ds:11853:word16] = SEQ(ds, 0x2A29)[(DPB(DPB(ax_n, Mem99[ds:11853:byte] ^ bArg02, 0), 0x00, 8) & 0xFF) * 0x02] ^ Mem99[ds:11853:word16] >>u 0x08;
	return ds;
}

// 0800:5DCE: Register Eq_n fn0800-5DCE(Register Eq_n ax, Register Eq_n dx, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n dxOut, Register out Eq_n dsOut)
Eq_n fn0800-5DCE(Eq_n ax, Eq_n dx, Eq_n ds, Eq_n wArg02, Eq_n wArg04, union Eq_n & dxOut, union Eq_n & dsOut)
{
	Eq_n ax_n;
	fn0800-4194(ds, wArg02, wArg04);
	Eq_n dx_n = dx;
	if (Test(UGE,false) && (dx != 0x00 || ax >= 0x0400))
		ax_n.u0 = 0x0400;
	else
	{
		fn0800-4194(ds, wArg02, wArg04);
		ax_n = ax & ~0x03;
	}
	Eq_n si_n;
	for (si_n = ax_n; si_n != 0x00; si_n -= 0x02)
	{
		if (fn0800-3E27(ds, wArg02, wArg04, out cx_n, out dx_n, out di_n, out ds, out Top_n) == 21070)
		{
			if ((fn0800-3E27(ds, wArg02, wArg04, out cx_n, out dx_n, out di_n, out ds, out Top_n) & 0xFF00) == 0x4300)
			{
				fn0800_ACB3(ds, wArg02, wArg04, 0x01, out cx_n, out dx_n, out bx_n);
				break;
			}
			fn0800_ACB3(ds, wArg02, wArg04, 0x01, out cx_n, out dx_n, out bx_n);
		}
	}
	dxOut = dx_n;
	dsOut = ds;
	return si_n;
}

// 0800:5E64: Register word16 fn0800-5E64(Register Eq_n ds, Register out Eq_n dxOut, Register out Eq_n dsOut)
word16 fn0800-5E64(Eq_n ds, union Eq_n & dxOut, union Eq_n & dsOut)
{
	union Eq_n Eq_n::* bp_n = fp - 0x02;
	mp16 sp_n = fp - 0x3E;
	word16 di_n = 0x2202;
	word16 si_n = 17009;
	word16 cx_n = 0x04;
	word16 dx_n = 0x03;
	if (false)
		cx_n = 0x03;
	word16 ax_n = 0x00;
	bool Z_n = SLICE(cond(0x00), bool, 2);
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(ds->*si_n - ds->*di_n), bool, 2);
		si_n = si_n + 0x01;
		di_n = di_n + 0x01;
		--cx_n;
		si_n = si_n;
		di_n = di_n;
		if (ds->*si_n == ds->*di_n)
			break;
	}
	if (!Z_n)
		ax_n = 0x01;
	word16 ax_n = ax_n;
	if (ax_n != 0x00)
	{
		word16 di_n = 17009;
		word16 si_n = 0x2202;
		cu16 cx_n = 0x04;
		word16 dx_n = ~0x00;
		if (false)
		{
			cx_n = 0x03;
			dx_n = 0x00;
		}
		uint16 cx_n = cx_n >> 0x01;
		cx_n = cx_n;
		while (true)
		{
			uint16 cx_n;
			if (cx_n == 0x00)
				break;
			(ds->*di_n).t0000 = (ds->*si_n).t0000;
			si_n += 0x02;
			di_n += 0x02;
			--cx_n;
		}
		ui16 cx_n;
		for (cx_n = cx_n * 0x02 + (cx_n < 0x00); cx_n != 0x00; --cx_n)
		{
			(ds->*di_n).t0000 = (ds->*si_n).t0000;
			++si_n;
			++di_n;
		}
		word16 cx_n;
		for (cx_n = dx_n; cx_n != 0x00; --cx_n)
		{
			(ds->*di_n).t0000 = 0x00;
			++di_n;
		}
		Eq_n sp_n = <invalid>;
		bp_n = fn0800-09A3(out ds);
		sp_n = (mp16) ((word32) sp_n + 0x08);
	}
	Eq_n ax_n = (DPB(DPB(ax_n, *((word32) ds + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx_n, *((word32) ds + 11894), 0), 0x00, 8);
	if (*((word32) ds + 10761) > 0x00 || *((word32) ds + 10761) == 0x00 && ax_n < *((word32) ds + 0x00002A07))
	{
		if (*((word32) ds + 0x00002A0D) >= 0x00 && (*((word32) ds + 0x00002A0D) > 0x00 || *((word32) ds + 0x00002A0B) > 0x7FF0))
		{
			*((word32) ds + 0x00002A0D) = 0x00;
			*((word32) ds + 0x00002A0B) = 0x7FF0;
		}
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).u0 = 0x00;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x02;
		ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x08) = *((word32) ds + 0x000029E3);
		fn0800_ACB3(ds, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x22) = fn0800-3FAD(ds, ss->*(sp_n - 0x02), ss->*sp_n, out ch_n, out di_n, out ds_n);
		ss->*sp_n = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ch_n, out di_n, out ds_n);
		Eq_n di_n = ax_n;
		if (ss->*(bp_n - 0x22) != 0x00)
			di_n = ax_n - 0x01;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		word16 dx_n;
		word16 ax_n = fn0800-8C69(di_n, 0x09, 0x00, stackArg0, out cl_n, out dx_n) + Mem237[ss:(bp_n - 0x22) + 0x00:word16];
		ss->*(bp_n - 0x02) = (bool) (ax_n < 0x00) + dx_n;
		ss->*(bp_n - 0x04) = ax_n;
		Eq_n sp_n = <invalid>;
		Eq_n ax_n = ss->*(bp_n - 0x02);
		Eq_n dx_n = ss->*(bp_n - 0x04);
		if (ax_n >= *((word32) ds_n + 10761) && (ax_n > *((word32) ds_n + 10761) || dx_n > *((word32) ds_n + 0x00002A07)))
		{
			Eq_n dx_n = *((word32) ds_n + 0x00002A07);
			ss->*(bp_n - 0x02) = *((word32) ds_n + 10761);
			ss->*(bp_n - 0x04) = dx_n;
		}
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x24) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x26) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x28) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x2A) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 44) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x2E) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x30) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x32) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		ss->*(bp_n - 0x34) = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ch_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		Eq_n ax_n = (DPB(DPB(ax_n, *((word32) ds_n + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx_n, *((word32) ds_n + 11894), 0), 0x00, 8);
		(ss->*(sp_n - 0x06)).u0 = 0x00;
		ss->*(sp_n - 0x08) = ax_n;
		ss->*(sp_n - 0x0A) = ds_n;
		(ss->*(sp_n - 0x0C)).u0 = 0x2E77;
		Eq_n ds_n;
		cui16 ax_n = (word16) fn0800-4152(ds_n, ss->*(sp_n - 0x0C), ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out ds_n);
		Eq_n sp_n = sp_n;
		if (ss->*(bp_n - 0x24) != 0x00)
		{
			(ss->*(sp_n - 0x02)).u0 = 0x00;
			(ss->*(sp_n - 0x04)).u0 = ~0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			Eq_n stackArg4 = <invalid>;
			Eq_n dx_n;
			Eq_n di_n;
			Eq_n ds_n;
			Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
			ss->*(bp_n - 0x0A) = dx_n;
			ss->*(bp_n - 0x0C) = ax_n;
			Eq_n sp_n = <invalid>;
			(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
			(ss->*sp_n).u0 = 0x00;
			(ss->*(sp_n - 0x02)).t0000 = ss->*(bp_n - 0x34);
			(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 0x000029E5);
			(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 0x000029E3);
			Eq_n bx_n;
			word16 cx_n;
			fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
			ss->*(bp_n - 0x36) = ss->*(bp_n - 0x0C);
			Eq_n sp_n = (word32) sp_n + 0x04;
			Eq_n si_n = 0x00;
			while (si_n != ss->*(bp_n - 0x24))
			{
				struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).t0000 = *((word32) ds_n + 0x000029E5);
				(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				ss->*(bp_n - 0x22) = fn0800-3FAD(ds_n, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out ch_n, out di_n, out ds_n);
				(ss->*sp_n).t0000 = *((word32) ds_n + 0x000029E5);
				(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 0x000029E3);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n ax_n = fn0800-3FAD(ds_n, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out ch_n, out di_n, out ds_n);
				Eq_n stackArg0 = <invalid>;
				byte cl_n;
				word16 dx_n;
				word16 ax_n = fn0800-8C69(ax_n, 0x04, 0x00, stackArg0, out cl_n, out dx_n) + Mem666[ss:(bp_n - 0x22) + 0x00:word16];
				Eq_n es_n = ss->*(bp_n - 0x0A);
				bx_n = ss->*(bp_n - 0x36);
				es_n->*((word32) bx_n + 0x02) = (word16) ((bool) (ax_n < 0x00) + dx_n);
				es_n->*bx_n = ax_n;
				ss->*(bp_n - 0x36) = (word16) (ss->*(bp_n - 0x36)) + 0x04;
				Eq_n cx_n = <invalid>;
				di_n = ax_n;
				sp_n.u0 = <invalid>;
				cx_n = (word16) DPB(cx_n, cl_n, 0);
				si_n = (word32) si_n + 0x01;
			}
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).t0000.u0 = 0x667B;
			(ss->*(sp_n - 0x02)).t0000.u0 = 0x04;
			(ss->*(sp_n - 0x04)).t0000 = ss->*(bp_n - 0x24);
			(ss->*(sp_n - 0x06)).t0000 = ss->*(bp_n - 0x0A);
			(ss->*(sp_n - 0x08)).t0000 = ss->*(bp_n - 0x0C);
			fn0800_B95E(cx_n, bx_n, si_n, di_n, ds_n, (ss->*(sp_n - 0x08)).t0000, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000);
			Eq_n di_n = ss->*(bp_n - 0x0C);
			ss->*(bp_n - 0x38) = -false;
			struct Eq_n Eq_n::* sp_n = &(ss->*sp_n).t0002;
			Eq_n si_n = 0x00;
			while (si_n != ss->*(bp_n - 0x24))
			{
				Eq_n es_n = ss->*(bp_n - 0x0A);
				Eq_n ax_n = es_n->*((word32) di_n + 0x02);
				Eq_n dx_n = es_n->*di_n;
				ss->*(bp_n - 0x12) = ax_n;
				ss->*(bp_n - 0x14) = dx_n;
				ss->*(bp_n - 0x0E) = ax_n & 0x0F;
				ss->*(bp_n - 0x10) = dx_n & ~0x0F;
				struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).t0000 = *((word32) ds_n + 10721);
				(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x04)).t0000 = DPB(ax_n & 0x0F, 0x00, 0);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg6 = <invalid>;
				Eq_n ds_n;
				fn0800-4047(ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
				(ss->*sp_n).t0000 = *((word32) ds_n + 10721);
				(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10719);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				Eq_n sp_n = <invalid>;
				ss->*(sp_n - 0x02) = fn0800-8CAA(ss->*(bp_n - 0x10), 0x04, ss->*(bp_n - 0x0E), stackArg0, out dx_n);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				struct Eq_n Eq_n::* di_n;
				Eq_n ds_n;
				fn0800-40BF(ds_n, ss->*(sp_n - 0x02), stackArg3, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out di_n, out ds_n);
				(ss->*(bp_n - 0x22)).u0 = 0x00;
				do
				{
					Eq_n es_n = ss->*(bp_n - 0x0A);
					ui32 ax_dx_n = SEQ((es_n->*di_n).w0002, (es_n->*di_n).w0000) - SEQ(ss->*(bp_n - 0x0E), ss->*(bp_n - 0x10));
					ss->*(bp_n - 22) = SLICE(ax_dx_n, word16, 16);
					ss->*(bp_n - 0x18) = (word16) ax_dx_n;
					ss->*(bp_n - 0x10) = v101_n;
					ui32 v102_v101_n = SEQ(ss->*(bp_n - 0x0E), ss->*(bp_n - 0x10)) + ax_dx_n;
					ss->*(bp_n - 0x0E) = SLICE(v102_v101_n, word16, 16);
					Eq_n v101_n = (word16) v102_v101_n;
					if (ss->*(bp_n - 22) > 0x00 || ss->*(bp_n - 22) == 0x00 && ss->*(bp_n - 0x18) > 0xFF)
						break;
					ui32 ax_dx_n = SEQ(ss->*(bp_n - 0x0E), ss->*(bp_n - 0x10)) - SEQ(ss->*(bp_n - 0x12), ss->*(bp_n - 0x14));
					cup16 dx_n = (word16) ax_dx_n;
					cup16 ax_n = SLICE(ax_dx_n, word16, 16);
					if (ax_n > 0x00 || Test(UGE,false) && dx_n >= ~0x0F || ss->*(bp_n - 0x22) == 0xFF)
						break;
					ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
					ss->*sp_n = *((word32) ds_n + 10719);
					(ss->*(sp_n - 0x02)).t0000 = DPB(ax_n, ss->*(bp_n - 0x18), 0);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg6 = <invalid>;
					word16 di_n;
					fn0800-4047(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
					ss->*(bp_n - 0x22) = (word16) (ss->*(bp_n - 0x22)) + 0x01;
					di_n = di_n + 0x04;
					si_n = (word32) si_n + 0x01;
				} while (si_n != ss->*(bp_n - 0x24));
				(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
				Eq_n ax_n = -((word16) (ss->*(bp_n - 0x22)) + 0x03);
				ss->*sp_n = ss->*(bp_n - 0x38) - (ax_n == 0x00);
				(ss->*(sp_n - 0x02)).t0000 = ax_n;
				(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
				(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
				Eq_n ax_n = fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
				ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
				ss->*sp_n = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x02)).t0000 = DPB(ax_n, ss->*(bp_n - 0x22), 0);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg6 = <invalid>;
				fn0800-4047(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
				(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
				Eq_n ax_n = ss->*(bp_n - 0x22);
				ss->*sp_n = SLICE(cond((word32) ax_n + 0x02), bool, 1);
				(ss->*(sp_n - 0x02)).t0000 = (word32) ax_n + 0x02;
				(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
				(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
				fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
				sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
			}
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).t0000 = ss->*(bp_n - 0x0A);
			(ss->*(sp_n - 0x02)).t0000 = ss->*(bp_n - 0x0C);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			ax_n = fn0800-4346(ds_n, stackArg2, (ss->*sp_n).t0000, out cx_n, out dx_n, out bx_n, out ds_n);
			sp_n = &(ss->*sp_n).t0002;
		}
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x04) = DPB(ax_n, 0x00, 0);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		Eq_n ds_n;
		fn0800-4047(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		word16 dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x02), stackArg4, out dx_n);
		ss->*(bp_n - 0x1A) = (bool) (ax_n < ~0x1F) + (dx_n + ~0x00);
		ss->*(bp_n - 0x1C) = (word32) ax_n + 0x0000FFE0;
		while (true)
		{
			Eq_n ax_n = ss->*(bp_n - 0x1C);
			if ((ax_n & 0x0F) == 0x00)
				break;
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
			ss->*(sp_n - 0x04) = DPB(ax_n & 0x0F, 0x00, 0);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg6 = <invalid>;
			fn0800-4047(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
			Eq_n v163_n = (word16) (ss->*(bp_n - 0x1C)) + 0x01;
			ss->*(bp_n - 0x1C) = v163_n;
			Mem1111[ss:bp_n - 0x1A + 0x00:word16] = Mem1107[ss:bp_n - 0x1A + 0x00:word16] + (v163_n <u 0x00);
		}
		Eq_n v64_n = ss->*(bp_n - 0x04) - (ss->*(bp_n - 0x26) << 0x04);
		ss->*(bp_n - 0x04) = v64_n;
		ss->*(bp_n - 0x02) -= v64_n < 0x00;
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).u0 = 0x00;
		Eq_n ax_n = ss->*(bp_n - 0x26);
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		ss->*(sp_n - 0x04) = ax_n << 0x04;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = ss->*(bp_n - 0x02);
		ss->*(sp_n - 0x02) = ss->*(bp_n - 0x04);
		ss->*(sp_n - 0x04) = ss->*(bp_n - 0x02);
		ss->*(sp_n - 0x06) = ss->*(bp_n - 0x04);
		union Eq_n Eq_n::* bp_n;
		Eq_n ds_n;
		fn0800-75EA(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out bp_n, out si_n, out ds_n);
		Eq_n sp_n = <invalid>;
		(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
		(ss->*((word32) sp_n + 0x04)).u0 = 0x00;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x20;
		ss->*sp_n = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
		ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
		ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x30);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*((word32) sp_n + 0x02), stackArg3, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out di_n, out ds_n);
		ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
		ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x32);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*((word32) sp_n + 0x02), stackArg3, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out di_n, out ds_n);
		ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
		ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x2E);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*((word32) sp_n + 0x02), stackArg3, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out di_n, out ds_n);
		ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
		ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 44);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*((word32) sp_n + 0x02), stackArg3, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out di_n, out ds_n);
		ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
		ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x1C);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*((word32) sp_n + 0x02), stackArg3, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out di_n, out ds_n);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		ss->*(bp_n - 0x22) = fn0800-8CAA(*((word32) ds_n + 10755), 0x04, *((word32) ds_n + 10757), stackArg0, out dx_n);
		Eq_n sp_n = <invalid>;
		if ((*((word32) ds_n + 10755) & 0x0F) != 0x00)
			ss->*(bp_n - 0x22) = (word16) (ss->*(bp_n - 0x22)) + 0x01;
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = ss->*(bp_n - 0x22);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n sp_n = <invalid>;
		Mem1393[ss:sp_n - 0x02 + 0x00:word16] = Mem1376[ss:bp_n - 0x22 + 0x00:word16] + fn0800-8CAA(ss->*(bp_n - 0x1C), 0x04, ss->*(bp_n - 0x1A), stackArg0, out dx_n);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x02), stackArg3, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out di_n, out ds_n);
		ui32 ax_dx_n = SEQ(ss->*(bp_n - 0x02), ss->*(bp_n - 0x04)) - SEQ(*((word32) ds_n + 10757), *((word32) ds_n + 10755)) + SEQ(*((word32) ds_n + 20106), *((word32) ds_n + 0x00004E88));
		cup16 dx_n = (word16) ax_dx_n;
		ss->*(bp_n - 0x06) = (bool) (dx_n < 0x80) + SLICE(ax_dx_n, word16, 16);
		ss->*(bp_n - 0x08) = dx_n + 0x80;
		if (*((word32) ds_n + 10781) != 0x00)
		{
			Eq_n v95_n = (word16) (ss->*(bp_n - 0x08)) + 0x0200;
			ss->*(bp_n - 0x08) = v95_n;
			Mem1439[ss:bp_n - 0x06 + 0x00:word16] = Mem1435[ss:bp_n - 0x06 + 0x00:word16] + (v95_n <u 0x00);
		}
		else if (*((word32) ds_n + 0x00002A21) == 0x01)
		{
			Eq_n v153_n = (word16) (ss->*(bp_n - 0x08)) + 0x0180;
			ss->*(bp_n - 0x08) = v153_n;
			Mem1432[ss:bp_n - 0x06 + 0x00:word16] = Mem1428[ss:bp_n - 0x06 + 0x00:word16] + (v153_n <u 0x00);
		}
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		Eq_n bx_n = (word16) (ss->*(bp_n - 0x04)) + (ss->*(bp_n - 0x26) << 0x04);
		Mem1458[ss:sp_n + 0x00:word16] = Mem1445[ss:bp_n - 0x02 + 0x00:word16] + (bx_n <u 0x00);
		(ss->*(sp_n - 0x02)).t0000 = bx_n;
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 0x000029E5);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		(ss->*((word32) sp_n + 0x02)).u0 = 0x02;
		(ss->*sp_n).u0 = 0x00;
		(ss->*(sp_n - 0x02)).t0000.u0 = 0x00;
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*sp_n, stackArg4, out dx_n);
		ss->*(bp_n - 0x1E) = dx_n;
		ss->*(bp_n - 0x20) = ax_n;
		ui32 dx_bx_n = SEQ(*((word32) ds_n + 10761), *((word32) ds_n + 0x00002A07)) - SEQ(ss->*(bp_n - 0x02), ss->*(bp_n - 0x04));
		Eq_n bx_n = (word16) dx_bx_n - (ss->*(bp_n - 0x26) << 0x04);
		ss->*((word32) sp_n + 0x02) = SLICE(dx_bx_n, word16, 16) - (bx_n < 0x00);
		ss->*sp_n = bx_n;
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 0x000029E5);
		(ss->*(sp_n - 0x08)).t0000 = *((word32) ds_n + 0x000029E3);
		union Eq_n Eq_n::* bp_n;
		Eq_n ds_n;
		fn0800-3B0A(ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out bp_n, out ds_n);
		ss->*(bp_n - 0x22) = ss->*(bp_n - 0x20) & 0x01FF;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		fn0800-8CAA(ss->*(bp_n - 0x20), 0x09, ss->*(bp_n - 0x1E), stackArg0, out dx_n);
		Eq_n sp_n = <invalid>;
		ss->*(bp_n - 0x22) == 0x00;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		(ss->*(sp_n - 0x06)).u0 = 0x02;
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x0A) = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = ss->*(bp_n - 0x22);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n di_n;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = di_n;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		if (*((word32) ds_n + 10781) != 0x00)
		{
			(ss->*(sp_n - 0x02)).u0 = 0x00;
			(ss->*(sp_n - 0x04)).u0 = 0x00;
			(ss->*(sp_n - 0x06)).u0 = 0x2E;
			ss->*(sp_n - 0x08) = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x0A) = *((word32) ds_n + 10719);
			fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
			ss->*(sp_n - 0x06) = ss->*(bp_n - 0x22);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg3 = <invalid>;
			Eq_n di_n;
			Eq_n ds_n;
			fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
			ss->*(sp_n - 0x06) = di_n;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg3 = <invalid>;
			fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		}
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		(ss->*(sp_n - 0x06)).u0 = 0x18;
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x0A) = *((word32) ds_n + 10719);
		word16 dx_n;
		Eq_n ax_n = fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = (DPB(DPB(ax_n, *((word32) ds_n + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx_n, *((word32) ds_n + 11894), 0), 0x00, 8) - 0x20;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		(ss->*(sp_n - 0x06)).u0 = 0x1C;
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x0A) = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = ss->*(bp_n - 0x28);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = ss->*(bp_n - 0x2A);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		(ss->*(sp_n - 0x06)).u0 = 0x0A;
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x0A) = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
		Eq_n cx_n = ss->*(bp_n - 0x20);
		cup16 bx_n = (word16) (ss->*(bp_n - 0x04)) + (ss->*(bp_n - 0x28) << 0x04);
		cup16 cx_n = (word16) (ss->*(bp_n - 0x08)) + (cx_n - 0x20);
		word16 dx_n = Mem1891[ss:bp_n - 0x02 + 0x00:word16] + (bx_n <u 0x00);
		cup16 ax_n = (bool) (cx_n < 0x00) + ((word16) (ss->*(bp_n - 0x06)) + (ss->*(bp_n - 0x1E) - (cx_n < 0x20)));
		if (dx_n >= ax_n && (dx_n > ax_n || bx_n > cx_n))
		{
			Eq_n cx_n = ss->*(bp_n - 0x20);
			uint16 bx_n = (word16) (ss->*(bp_n - 0x04)) + (ss->*(bp_n - 0x28) << 0x04);
			uint16 cx_n = (word16) (ss->*(bp_n - 0x08)) + (cx_n - 0x20);
			ui32 dx_bx_n = SEQ((word16) (ss->*(bp_n - 0x02)) + (bx_n < 0x00), bx_n) - SEQ(((word16) (ss->*(bp_n - 0x06)) + (ss->*(bp_n - 0x1E) - (cx_n < 0x20))) + (cx_n < 0x00), cx_n);
			ss->*(bp_n - 0x08) = v151_n;
			ui32 v152_v151_n = SEQ(ss->*(bp_n - 0x06), ss->*(bp_n - 0x08)) + dx_bx_n;
			ss->*(bp_n - 0x06) = SLICE(v152_v151_n, word16, 16);
			Eq_n v151_n = (word16) v152_v151_n;
		}
		0x10 = 0x10;
		Eq_n v157_n = (word16) (ss->*(bp_n - 0x08)) + ((word16) (0x10 - SEQ(ss->*(bp_n - 0x06), ss->*(bp_n - 0x08))) & 0x0F);
		ss->*(bp_n - 0x08) = v157_n;
		Mem1974[ss:bp_n - 0x06 + 0x00:word16] = Mem1970[ss:bp_n - 0x06 + 0x00:word16] + (v157_n <u 0x00);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n ax_n = fn0800-8CAA(ss->*(bp_n - 0x08), 0x04, ss->*(bp_n - 0x06), stackArg0, out dx_n);
		ss->*(bp_n - 0x28) = ax_n;
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = ax_n;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		if (ss->*(bp_n - 0x2A) < ss->*(bp_n - 0x28))
			ss->*(bp_n - 0x2A) = ss->*(bp_n - 0x28);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = ss->*(bp_n - 0x2A);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		ui32 dx_ax_n = SEQ(ss->*(bp_n - 0x02), ss->*(bp_n - 0x04)) + SEQ(*((word32) ds_n + 20106), *((word32) ds_n + 0x00004E88));
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		cup16 ax_n = (word16) dx_ax_n;
		Eq_n stackArg0 = <invalid>;
		Eq_n ax_n = fn0800-8CAA(ax_n + 0x20, 0x04, (bool) (ax_n < 0x20) + SLICE(dx_ax_n, word16, 16), stackArg0, out dx_n);
		ss->*(bp_n - 44) = ax_n;
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = ax_n;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		ss->*(bp_n - 0x2E) = (word16) (ss->*(bp_n - 0x1C)) + 0x0080;
		if (*((word32) ds_n + 10781) != 0x00)
			ss->*(bp_n - 0x2E) = (word16) (ss->*(bp_n - 0x2E)) + 0x0200;
		else if (*((word32) ds_n + 0x00002A21) == 0x01)
			ss->*(bp_n - 0x2E) = (word16) (ss->*(bp_n - 0x2E)) + 0x0180;
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x06) = ss->*(bp_n - 0x2E);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg3 = <invalid>;
		Eq_n ds_n;
		fn0800-40BF(ds_n, ss->*(sp_n - 0x06), stackArg3, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out di_n, out ds_n);
		ui32 dx_bx_n = SEQ(*((word32) ds_n + 10761), *((word32) ds_n + 0x00002A07)) - SEQ(ss->*(bp_n - 0x02), ss->*(bp_n - 0x04));
		cu16 bx_n = (word16) dx_bx_n - (ss->*(bp_n - 0x26) << 0x04);
		Eq_n dx_n = SLICE(dx_bx_n, word16, 16) - (bx_n < 0x00);
		if ((bx_n | dx_n) == 0x00)
		{
			dxOut = dx_n;
			dsOut = ds_n;
			return 0x00;
		}
		else
		{
			dxOut = dx_n;
			dsOut = ds_n;
			return 0x01;
		}
	}
	else
	{
		dxOut.u0 = 0x00;
		dsOut = ds;
		return 0x03;
	}
}

// 0800:669C: Register word16 fn0800-669C(Register Eq_n ds, Register out Eq_n dxOut, Register out Eq_n dsOut)
word16 fn0800-669C(Eq_n ds, union Eq_n & dxOut, union Eq_n & dsOut)
{
	union Eq_n Eq_n::* bp_n = fp - 0x02;
	if (*((word32) ds + 10761) < 0x00 || *((word32) ds + 10761) <= 0x00 && *((word32) ds + 0x00002A07) <= ~0x0101)
	{
		mp16 sp_n = fp - 0x0A;
		word16 di_n = 0x2206;
		word16 si_n = 17009;
		word16 cx_n = 0x04;
		word16 dx_n = 0x03;
		if (false)
			cx_n = 0x03;
		word16 ax_n = 0x00;
		bool Z_n = SLICE(cond(0x00), bool, 2);
		while (cx_n != 0x00)
		{
			Z_n = SLICE(cond(ds->*si_n - ds->*di_n), bool, 2);
			si_n = si_n + 0x01;
			di_n = di_n + 0x01;
			--cx_n;
			si_n = si_n;
			di_n = di_n;
			if (ds->*si_n == ds->*di_n)
				break;
		}
		if (!Z_n)
			ax_n = 0x01;
		word16 ax_n = ax_n;
		if (ax_n != 0x00)
		{
			word16 di_n = 17009;
			word16 si_n = 0x2206;
			cu16 cx_n = 0x04;
			word16 dx_n = ~0x00;
			if (false)
			{
				cx_n = 0x03;
				dx_n = 0x00;
			}
			uint16 cx_n = cx_n >> 0x01;
			cx_n = cx_n;
			while (true)
			{
				uint16 cx_n;
				if (cx_n == 0x00)
					break;
				(ds->*di_n).t0000 = (ds->*si_n).t0000;
				si_n += 0x02;
				di_n += 0x02;
				--cx_n;
			}
			ui16 cx_n;
			for (cx_n = cx_n * 0x02 + (cx_n < 0x00); cx_n != 0x00; --cx_n)
			{
				(ds->*di_n).t0000 = (ds->*si_n).t0000;
				++si_n;
				++di_n;
			}
			word16 cx_n;
			for (cx_n = dx_n; cx_n != 0x00; --cx_n)
			{
				(ds->*di_n).t0000 = 0x00;
				++di_n;
			}
			Eq_n sp_n = <invalid>;
			bp_n = fn0800-09A3(out ds);
			sp_n = (mp16) ((word32) sp_n + 0x08);
		}
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds + 10719);
		Eq_n ax_n = (DPB(DPB(ax_n, *((word32) ds + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx_n, *((word32) ds + 11894), 0), 0x00, 8);
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		ss->*(sp_n - 0x06) = ax_n;
		ss->*(sp_n - 0x08) = ds;
		(ss->*(sp_n - 0x0A)).u0 = 0x2E77;
		Eq_n ds_n;
		cup16 bx_n = (word32) *((word32) ds_n + 0x00002A07) + ((DPB(DPB((word16) fn0800-4152(ds, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x02), ss->*sp_n, out ds_n), *((word32) ds_n + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx_n, *((word32) ds_n + 11894), 0), 0x00, 8));
		word16 dx_n = Mem178[ds_n:0x2A09:word16] + (bx_n <u 0x00) + (bx_n <u 0x40);
		ss->*(bp_n - 0x02) = dx_n;
		ss->*(bp_n - 0x04) = bx_n + 0x40;
		if (*((word32) ds_n + 10781) != 0x00)
		{
			Eq_n v25_n = (word16) (ss->*(bp_n - 0x04)) + 0x0200;
			ss->*(bp_n - 0x04) = v25_n;
			Mem238[ss:bp_n - 0x02 + 0x00:word16] = Mem234[ss:bp_n - 0x02 + 0x00:word16] + (v25_n <u 0x00);
		}
		else if (*((word32) ds_n + 0x00002A21) == 0x01)
		{
			Eq_n v28_n = (word16) (ss->*(bp_n - 0x04)) + 0x0180;
			ss->*(bp_n - 0x04) = v28_n;
			Mem231[ss:bp_n - 0x02 + 0x00:word16] = Mem227[ss:bp_n - 0x02 + 0x00:word16] + (v28_n <u 0x00);
		}
		if (ss->*(bp_n - 0x02) < 0x00 || ss->*(bp_n - 0x02) <= 0x00 && ss->*(bp_n - 0x04) <= ~0x0101)
		{
			ss->*sp_n = *((word32) ds_n + 10761);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x00002A07);
			ss->*(sp_n - 0x04) = *((word32) ds_n + 10761);
			ss->*(sp_n - 0x06) = *((word32) ds_n + 0x00002A07);
			Eq_n ds_n;
			dxOut = fn0800-75EA(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out bp_n, out si_n, out ds_n);
			dsOut = ds_n;
			return 0x00;
		}
		else
		{
			dxOut = dx_n;
			dsOut = ds_n;
			return 0x03;
		}
	}
	else
	{
		dxOut = dx;
		dsOut = ds;
		return 0x03;
	}
}

// 0800:67BF: Register word16 fn0800-67BF(Register Eq_n ds, Register out ptr16 dxOut, Register out Eq_n dsOut)
word16 fn0800-67BF(Eq_n ds, ptr16 & dxOut, union Eq_n & dsOut)
{
	Eq_n ax_n = (DPB(DPB(ax, *((word32) ds + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) ds + 11894), 0), 0x00, 8);
	if (*((word32) ds + 10761) > 0x00 || *((word32) ds + 10761) == 0x00 && ax_n < *((word32) ds + 0x00002A07))
	{
		Eq_n ds_n;
		union Eq_n Eq_n::* bp_n;
		word16 sp_n;
		Eq_n ds_n;
		fn0800-4152(ds, 0x2E77, ds, ax_n, *((word32) ds + 10719), *((word32) ds + 10721), out ds_n);
		fn0800_ACB3(ds_n, *((word32) ds_n + 10719), *((word32) ds_n + 10721), 0x01, out cx_n, out dx_n, out bx_n);
		Eq_n ds_n;
		if (fn0800-3F0A(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out dx_n, out ds_n) != 0x601A)
		{
			Eq_n ds_n;
			fn0800-409C(ds_n, *((word32) ds_n + 0x00002A07), *((word32) ds_n + 10761), *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
			fn0800_ACB3(ds_n, *((word32) ds_n + 10719), *((word32) ds_n + 10721), 0x01, out cx_n, out dx_n, out bx_n);
			fn0800-75EA(ds_n, *((word32) ds_n + 0x00002A07), *((word32) ds_n + 10761), *((word32) ds_n + 0x00002A07), *((word32) ds_n + 10761), out bp_n, out si_n, out ds_n);
			ui32 ax_dx_n = SEQ(*((word32) ds_n + 10761), *((word32) ds_n + 0x00002A07)) - SEQ(*((word32) ds_n + 10757), *((word32) ds_n + 10755)) + SEQ(*((word32) ds_n + 20106), *((word32) ds_n + 0x00004E88));
			cup16 dx_n = (word16) ax_dx_n;
			ss->*(bp_n - 0x06) = (bool) (dx_n < 0x0E) + SLICE(ax_dx_n, word16, 16);
			ss->*(bp_n - 0x08) = dx_n + 0x0E;
			Eq_n sp_n = <invalid>;
			sp_n = (word16) ((word32) sp_n + 0x08);
		}
		else
		{
			fn0800_ACB3(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), 0x01, out cx_n, out dx_n, out bx_n);
			Eq_n ds_n;
			fn0800-3B0A(0x10, 0x00, out dx_n, out bp_n, out ds_n);
			Eq_n sp_n = <invalid>;
			(ss->*((word32) sp_n + 0x0A)).u0 = 0x00;
			(ss->*((word32) sp_n + 0x08)).u0 = 0x00;
			(ss->*((word32) sp_n + 0x06)).u0 = 0x1A;
			ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 0x000029E5);
			ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 0x000029E3);
			fn0800_ACB3(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x0A), out cx_n, out dx_n, out bx_n);
			ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10721);
			ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 10719);
			ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 0x000029E5);
			ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 0x000029E3);
			Eq_n ds_n;
			ss->*((word32) sp_n + 0x06) = fn0800-3E27(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
			Eq_n ds_n;
			fn0800-401E(ds_n, ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
			Eq_n dx_n = *((word32) ds_n + 0x00002A07);
			ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10761) - (dx_n < 0x1C);
			ss->*((word32) sp_n + 0x08) = dx_n - 0x1C;
			Eq_n dx_n = *((word32) ds_n + 0x00002A07);
			ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10761) - (dx_n < 0x1C);
			ss->*((word32) sp_n + 0x04) = dx_n - 0x1C;
			fn0800-75EA(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out bp_n, out si_n, out ds_n);
			Eq_n dx_n = *((word32) ds_n + 0x00002A07);
			uint16 dx_n = dx_n - 0x1C - *((word32) ds_n + 10755);
			ui32 ax_dx_n = SEQ(*((word32) ds_n + 10761) - (dx_n < 0x1C) - *((word32) ds_n + 10757) - (dx_n < 0x00), dx_n) + SEQ(*((word32) ds_n + 20106), *((word32) ds_n + 0x00004E88));
			cup16 dx_n = (word16) ax_dx_n;
			ss->*(bp_n - 0x06) = (bool) (dx_n < 0x0E) + SLICE(ax_dx_n, word16, 16);
			ss->*(bp_n - 0x08) = dx_n + 0x0E;
			Eq_n sp_n = <invalid>;
			sp_n = (word16) ((word32) sp_n + 0x08);
		}
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x02), stackArg4, out dx_n);
		if ((ax_n & 0x01) != 0x00)
		{
			ss->*sp_n = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
			ss->*(sp_n - 0x04) = DPB(ax_n & 0x01, 0x90, 0);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg6 = <invalid>;
			fn0800-4047(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
			Eq_n v50_n = (word16) (ss->*(bp_n - 0x08)) + 0x01;
			ss->*(bp_n - 0x08) = v50_n;
			Mem458[ss:bp_n - 0x06 + 0x00:word16] = Mem454[ss:bp_n - 0x06 + 0x00:word16] + (v50_n <u 0x00);
		}
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		(ss->*(sp_n - 0x06)).u0 = 0x00;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		word16 dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x02), stackArg4, out dx_n);
		*((word32) ds_n + 10757) = (bool) (ax_n < ~0x1F) + (dx_n + ~0x00);
		*((word32) ds_n + 10755) = (word32) ax_n + 0x0000FFE0;
		(ss->*sp_n).u0 = 0x00;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x02;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10719);
		Eq_n ax_n = fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		Eq_n ds_n;
		Eq_n dx_n = fn0800-3F58(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out di_n, out ds_n);
		ss->*(bp_n - 0x08) = v60_n;
		ui32 v61_v60_n = SEQ(ss->*(bp_n - 0x06), ss->*(bp_n - 0x08)) - SEQ(dx_n, ax_n);
		ss->*(bp_n - 0x06) = SLICE(v61_v60_n, word16, 16);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10757);
		ss->*(sp_n - 0x06) = *((word32) ds_n + 10755);
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
		(ss->*sp_n).u0 = 0x00;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
		Eq_n v60_n = (word16) v61_v60_n;
		Eq_n ds_n;
		Eq_n ax_n = fn0800-3E27(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
		if (ax_n == 0x601A)
		{
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			Eq_n ds_n;
			Eq_n dx_n = fn0800-3E5D(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ds_n, out Top_n);
			ss->*sp_n = ax_n;
			ss->*(sp_n - 0x02) = dx_n;
			ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E3);
			Eq_n ds_n;
			ui32 bx_cx_n = SEQ(ss->*(sp_n - 0x02), ss->*sp_n) + SEQ(fn0800-3E5D(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), out ds_n, out Top_n), ax_n);
			ss->*(bp_n - 0x02) = SLICE(bx_cx_n, word16, 16);
			ss->*(bp_n - 0x04) = (word16) bx_cx_n;
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			ss->*(bp_n - 0x0A) = fn0800-3E5D(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ds_n, out Top_n);
			ss->*(bp_n - 0x0C) = ax_n;
			ui32 ax_dx_n = SEQ(ss->*(bp_n - 0x02), ss->*(bp_n - 0x04)) + SEQ(ss->*(bp_n - 0x0A), ss->*(bp_n - 0x0C));
			ui32 bx_cx_n = SEQ(*((word32) ds_n + 10757), *((word32) ds_n + 10755)) + SEQ(ss->*(bp_n - 0x06), ss->*(bp_n - 0x08));
			cup16 dx_n = (word16) ax_dx_n;
			cup16 ax_n = SLICE(ax_dx_n, word16, 16);
			cup16 cx_n = (word16) bx_cx_n;
			cup16 bx_n = SLICE(bx_cx_n, word16, 16);
			if (ax_n >= bx_n && (ax_n > bx_n || dx_n > cx_n))
			{
				ui32 ax_dx_n = SEQ(ss->*(bp_n - 0x02), ss->*(bp_n - 0x04)) + SEQ(ss->*(bp_n - 0x0A), ss->*(bp_n - 0x0C)) - (SEQ(*((word32) ds_n + 10757), *((word32) ds_n + 10755)) + SEQ(ss->*(bp_n - 0x06), ss->*(bp_n - 0x08)));
				ss->*(bp_n - 0x08) = v79_n;
				ui32 v80_v79_n = SEQ(ss->*(bp_n - 0x06), ss->*(bp_n - 0x08)) + ax_dx_n;
				ss->*(bp_n - 0x06) = SLICE(v80_v79_n, word16, 16);
				Eq_n v79_n = (word16) v80_v79_n;
			}
		}
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).u0 = 0x00;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x0A;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x04) = ss->*(bp_n - 0x06);
		ss->*(sp_n - 0x06) = ss->*(bp_n - 0x08);
		Eq_n ds_n;
		ptr16 dx_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
		dxOut = dx_n;
		dsOut = ds_n;
		return 0x00;
	}
	else
	{
		dxOut = 0x00;
		dsOut = ds;
		return 0x03;
	}
}

// 0800:6AD4: Register word16 fn0800-6AD4(Register word16 bp, Register Eq_n si, Register Eq_n ds, Register out Eq_n dxOut, Register out Eq_n dsOut)
word16 fn0800-6AD4(word16 bp, Eq_n si, Eq_n ds, union Eq_n & dxOut, union Eq_n & dsOut)
{
	Eq_n ax_n = (DPB(DPB(ax, *((word32) ds + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) ds + 11894), 0), 0x00, 8);
	if (*((word32) ds + 10761) > 0x00 || *((word32) ds + 10761) == 0x00 && ax_n < *((word32) ds + 0x00002A07))
	{
		Eq_n ds_n;
		Eq_n dx_n = fn0800-3E5D(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out ds_n, out Top_n);
		if (dx_n != 0x00 || ax_n != 1011)
		{
			dxOut = dx_n;
			dsOut = ds_n;
			return 0x03;
		}
		else
		{
			Eq_n ds_n;
			Eq_n ax_n;
			do
			{
				Eq_n ds_n;
				Eq_n dx_n = fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n);
				fn0800-409C(ds_n, ax_n, dx_n, *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
				Eq_n wLoc08_n = dx_n;
				Eq_n wLoc0A_n = ax_n;
				while (true)
				{
					Eq_n v27_n = wLoc0A_n - 0x01;
					wLoc0A_n = v27_n;
					wLoc08_n -= v27_n < 0x00;
					Eq_n ax_n = wLoc0A_n | wLoc08_n;
					if (ax_n == 0x00)
						break;
					Eq_n ds_n;
					fn0800-409C(ds_n, ax_n, fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n), *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
				}
				ax_n |= dx_n;
				Mem91 = Mem154;
			} while (ax_n != 0x00);
			Eq_n ds_n;
			Eq_n ds_n;
			word16 ax_n = fn0800-409C(ds_n, (word32) ax_n + 0x01, fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n) + (ax_n <u 0x01), Mem211[ds_n:10719:word16], Mem154[ds_n:10721:word16], out dx_n, out ds_n, out Top_n);
			Eq_n ds_n;
			Eq_n dx_n = fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n);
			Eq_n ds_n;
			Eq_n dx_n = fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n);
			Eq_n ds_n;
			fn0800-409C(ds_n, ax_n, dx_n, *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
			Eq_n ds_n;
			word16 dx_n;
			Eq_n ds_n;
			fn0800-409C(ds_n, (DPB(DPB(fn0800-409C(ds_n, (word16) ax_n + 0x01, dx_n + (ax_n <u 0x01), Mem337[ds_n:10719:word16], Mem321[ds_n:10721:word16], out dx_n, out ds_n, out Top_n), Mem351[ds_n:11893:byte], 0), 0x00, 8) << 0x08) + DPB(DPB(dx_n, Mem351[ds_n:11894:byte], 0), 0x00, 8) - 0x0C >>u 0x02, 0x00, Mem383[ds_n:10719:word16], Mem380[ds_n:10721:word16], out dx_n, out ds_n, out Top_n);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n dx_n;
			Eq_n ax_n = fn0800_AD2F(ds_n, SEQ(*((word32) ds_n + 10721), *((word32) ds_n + 10719)), stackArg4, out dx_n);
			*((word32) ds_n + 0x00004E8E) = dx_n;
			*((word32) ds_n + 20108) = ax_n;
			ui32 ax_dx_n = SEQ(dx_n, ax_n) - SEQ(dx_n, ax_n);
			cup16 dx_n = (word16) ax_dx_n;
			cui16 ax_n = (bool) (dx_n < 0x01) + SLICE(ax_dx_n, word16, 16);
			cup16 dx_n = dx_n + 0x01;
			cui16 wLoc04_n = ax_n;
			cu16 wLoc06_n = dx_n + 0x01;
			while (true)
			{
				Eq_n ax_n = wLoc06_n | wLoc04_n;
				if (ax_n == 0x00)
					break;
				Eq_n ds_n;
				fn0800-409C(ds_n, ax_n, fn0800-3E5D(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), out ds_n, out Top_n), *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
				cu16 v58_n = wLoc06_n - 0x01;
				wLoc06_n = v58_n;
				wLoc04_n -= v58_n < 0x00;
				Mem434 = Mem489;
			}
			Eq_n ax_n = (DPB(DPB(ax_n, *((word32) ds_n + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx_n, *((word32) ds_n + 11894), 0), 0x00, 8);
			Eq_n ds_n;
			fn0800-4152(ds_n, 0x2E77, ds_n, ax_n, *((word32) ds_n + 10719), *((word32) ds_n + 10721), out ds_n);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n dx_n;
			Eq_n ax_n = fn0800_AD2F(ds_n, SEQ(*((word32) ds_n + 0x000029E5), *((word32) ds_n + 0x000029E3)), stackArg4, out dx_n);
			if (dx_n >= *((word32) ds_n + 10761) && (dx_n != *((word32) ds_n + 10761) || ax_n >= *((word32) ds_n + 0x00002A07)))
			{
				dxOut = dx_n;
				dsOut = ds_n;
				return 0x00;
			}
			else
			{
				Eq_n v62_n = *((word32) ds_n + 0x000029E5);
				Eq_n v63_n = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				int8 Top_n;
				Eq_n dx_n = fn0800-3E5D(ds_n, v63_n, v62_n, out ds_n, out Top_n);
				word16 cx_n;
				struct Eq_n Eq_n::* bx_n = Eq_n::a6EBC;
				for (cx_n = 0x07; cx_n != 0x00; --cx_n)
				{
					if ((seg0800->*bx_n).w0000 == ax_n)
					{
						cui16 ax_n = bx_n[0x07];
						if (ax_n == (dx_n & 0x3FFF))
						{
							word16 ax_n;
							Eq_n dx_n;
							bx_n[0x0E]();
							dxOut = dx_n;
							dsOut = ds_n;
							return ax_n;
						}
					}
					++bx_n;
				}
				dxOut = ax_n;
				dsOut = ds_n;
				return 0x09;
			}
		}
	}
	else
	{
		dxOut.u0 = 0x00;
		dsOut = ds;
		return 0x03;
	}
}

// 0800:6EE6: void fn0800-6EE6(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register Eq_n ds, Stack word16 wArg02, Stack word16 wArg04, Stack word16 wArg06)
void fn0800-6EE6(Eq_n cx, Eq_n dx, Eq_n bx, Eq_n ds, word16 wArg02, word16 wArg04, word16 wArg06)
{
	fn0800_B2EF(cx, dx, bx, ds, 0x2223, ds, out si_n, out di_n);
}

// 0800:6EFF: void fn0800-6EFF(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register Eq_n ds, Stack cup16 wArg02)
void fn0800-6EFF(Eq_n cx, Eq_n dx, Eq_n bx, Eq_n ds, cup16 wArg02)
{
	fn0800_B2EF(cx, dx, bx, ds, 0x2231, ds, out si_n, out di_n);
	if (wArg02 > 0x09)
		fn0800_B2EF(cx, dx, bx, ds, 0x223E, ds, out si_n, out di_n);
}

// 0800:6F20: void fn0800-6F20(Register Eq_n ax, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04)
void fn0800-6F20(Eq_n ax, Eq_n ds, Eq_n wArg02, Eq_n wArg04)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ds_n;
	Eq_n ax_n = fn0800-8C69(ax, 0x02, fn0800-3E5D(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), out ds_n, out Top_n), stackArg0, out cl_n, out dx_n);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E5);
	ss->*(sp_n - 0x04) = *((word32) ds_n + 0x000029E3);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x04), stackArg4, out dx_n);
	(ss->*(sp_n - 0x02)).u0 = 0x01;
	ss->*(sp_n - 0x04) = dx_n;
	ss->*(sp_n - 0x06) = ax_n;
	ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
	ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
	union Eq_n Eq_n::* bp_n = fp - 0x02;
	Eq_n ax_n = fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
	Eq_n sp_n = sp_n;
	while (true)
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
		if (fn0800-3F58(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out di_n, out ds_n) != 0x00 || ax_n != 1004)
			break;
		(ss->*sp_n).u0 = 0x01;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x04;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E3);
		ax_n = fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		sp_n = (char *) sp_n + 0x02;
		do
		{
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = *((word32) ds_n + 0x000029E5);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg0 = <invalid>;
			cui16 dx_n;
			Eq_n ax_n = fn0800-8C69(ax_n, 0x02, fn0800-3E5D(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ds_n, out Top_n), stackArg0, out cl_n, out dx_n);
			Eq_n sp_n = <invalid>;
			Mem220 = Mem182;
			if ((ax_n | dx_n) != 0x00)
			{
				(ss->*(sp_n - 0x02)).u0 = 0x01;
				ss->*(sp_n - 0x04) = (bool) (ax_n < 0x04) + dx_n;
				ss->*(sp_n - 0x06) = (word16) ax_n + 0x04;
				ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
				fn0800_ACB3(ds_n, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
			}
			sp_n = sp_n;
			ax_n = ax_n | dx_n;
		} while (ax_n != 0x00);
	}
	ss->*sp_n = *((word32) ds_n + 0x000029E5);
	ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	ui16 dx_n;
	ui32 dx_ax_n = SEQ(dx_n, fn0800_AD2F(ds_n, ss->*(sp_n - 0x02), stackArg4, out dx_n)) - SEQ(dx_n, ax_n);
	Eq_n dx_n = SLICE(dx_ax_n, word16, 16);
	*((word32) ds_n + 10757) = dx_n;
	Eq_n ax_n = (word16) dx_ax_n;
	*((word32) ds_n + 10755) = ax_n;
	ss->*sp_n = *((word32) ds_n + 10721);
	ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
	ss->*(sp_n - 0x04) = wArg04;
	ss->*(sp_n - 0x06) = wArg02;
	Eq_n ds_n;
	fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
	ss->*sp_n = *((word32) ds_n + 10721);
	ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x02), stackArg4, out dx_n);
	union Eq_n Eq_n::* sp_n = (char *) sp_n + 0x02;
	if (dx_n >= 0x00 && (dx_n > 0x00 || ax_n > 0x12))
	{
		(ss->*sp_n).u0 = 0x00;
		ss->*(sp_n - 0x02) = *((word32) ds_n + 0x00004E8E);
		ss->*(sp_n - 0x04) = *((word32) ds_n + 20108);
		ss->*(sp_n - 0x06) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10719);
		Eq_n ax_n = fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		Eq_n ds_n;
		Eq_n dx_n = fn0800-3E5D(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ds_n, out Top_n);
		(ss->*sp_n).u0 = 0x00;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = ax_n;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		(ss->*(sp_n - 0x06)).u0 = 0x00;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x04) = dx_n;
		ss->*(sp_n - 0x06) = ax_n;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x04) = dx_n;
		ss->*(sp_n - 0x06) = ax_n;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
		(ss->*sp_n).u0 = 0x00;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = ax_n;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = dx_n - (ax_n < 0x08);
		ss->*(sp_n - 0x02) = ax_n - 0x08;
		ss->*(sp_n - 0x04) = dx_n;
		ss->*(sp_n - 0x06) = ax_n;
		fn0800-75EA(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out bp_n, out si_n, out ds_n);
		Eq_n v58_n = (word32) *((word32) ds_n + 10755) + 0x08;
		*((word32) ds_n + 10755) = v58_n;
		Mem528[ds_n:0x2A05:word16] = Mem524[ds_n:0x2A05:word16] + (v58_n <u 0x00);
		Eq_n sp_n = <invalid>;
		sp_n = (union Eq_n Eq_n::*) ((word32) sp_n + 0x08);
	}
	Eq_n ax_n = *((word32) ds_n + 10757);
	Eq_n dx_n = *((word32) ds_n + 10755);
	if (ax_n >= ss->*(bp_n - 22) && (ax_n != ss->*(bp_n - 22) || dx_n >= ss->*(bp_n - 0x18)))
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).u0 = 0x00;
		ss->*(sp_n - 0x02) = ss->*(bp_n - 0x02);
		ss->*(sp_n - 0x04) = ss->*(bp_n - 0x04);
		ss->*(sp_n - 0x06) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		(ss->*sp_n).u0 = 0x00;
		Eq_n dx_n = ss->*(bp_n - 0x14);
		ss->*(sp_n - 0x02) = ss->*(bp_n - 0x12) - (dx_n < 0x04);
		ss->*(sp_n - 0x04) = dx_n - 0x04;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		Eq_n dx_n = ss->*(bp_n - 0x10);
		Mem611[ss:sp_n + 0x00:word16] = Mem592[ss:bp_n - 0x0E + 0x00:word16] + (dx_n <u 0x04);
		ss->*(sp_n - 0x02) = (word32) dx_n + 0x04;
		ss->*(sp_n - 0x04) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x06) = *((word32) ds_n + 10719);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 0x000029E5);
		ss->*(sp_n - 0x0A) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		union Eq_n Eq_n::* bp_n;
		Eq_n ax_n = fn0800-3B0A(ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out bp_n, out ds_n);
		Eq_n sp_n = <invalid>;
		ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 0x000029E5);
		ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 0x000029E3);
		Eq_n ds_n;
		if (fn0800-3F58(ds_n, ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out di_n, out ds_n) == 0x00 && ax_n == 1004)
		{
			(ss->*((word32) sp_n + 0x0A)).u0 = 0x01;
			(ss->*((word32) sp_n + 0x08)).u0 = 0x00;
			(ss->*((word32) sp_n + 0x06)).u0 = 0x04;
			ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 0x000029E5);
			ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 0x000029E3);
			fn0800_ACB3(ds_n, ss->*((word32) sp_n + 0x02), ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x0A), out cx_n, out dx_n, out bx_n);
			ss->*((word32) sp_n + 0x0A) = *((word32) ds_n + 10721);
			ss->*((word32) sp_n + 0x08) = *((word32) ds_n + 10719);
			(ss->*((word32) sp_n + 0x06)).u0 = 0x00;
			(ss->*((word32) sp_n + 0x04)).u0 = 1004;
			Eq_n ax_n = fn0800-409C(ds_n, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), ss->*((word32) sp_n + 0x08), ss->*((word32) sp_n + 0x0A), out dx_n, out ds_n, out Top_n);
			struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x0C;
			do
			{
				struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).t0000 = *((word32) ds_n + 0x000029E5);
				(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				ss->*(bp_n - 0x02) = fn0800-3E5D(ds_n, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out ds_n, out Top_n);
				ss->*(bp_n - 0x04) = ax_n;
				(ss->*sp_n).t0000 = *((word32) ds_n + 10721);
				(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x04)).t0000 = ss->*(bp_n - 0x02);
				(ss->*(sp_n - 0x06)).t0000 = ax_n;
				fn0800-409C(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out dx_n, out ds_n, out Top_n);
				sp_n = (struct Eq_n Eq_n::*) &(ss->*sp_n).t0002;
				cu16 ax_n = ss->*(bp_n - 0x04) | ss->*(bp_n - 0x02);
				if (ax_n != 0x00)
				{
					(ss->*sp_n).t0000 = *((word32) ds_n + 0x000029E5);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
					Eq_n ds_n;
					Mem801[ss:bp_n - 0x06 + 0x00:word16] = fn0800-3E5D(ds_n, ss->*(sp_n - 0x02), (ss->*sp_n).t0000, out ds_n, out Top_n) + (ax_n <u 0x01);
					ss->*(bp_n - 0x08) = ax_n + 0x01;
					(ss->*sp_n).t0000 = *((word32) ds_n + 10721);
					ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
					ss->*(sp_n - 0x04) = ss->*(bp_n - 0x06);
					ss->*(sp_n - 0x06) = ax_n + 0x01;
					struct Eq_n * ds_n;
					fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), (ss->*sp_n).t0000, out dx_n, out ds_n, out Top_n);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg0 = <invalid>;
					Eq_n dx_n;
					Eq_n ax_n = fn0800-8C69(ss->*(bp_n - 0x04), 0x02, ss->*(bp_n - 0x02), stackArg0, out cl_n, out dx_n);
					Eq_n sp_n = <invalid>;
					ss->*(sp_n - 0x02) = dx_n;
					ss->*(sp_n - 0x04) = ax_n;
					ss->*(sp_n - 0x06) = ds_n->t29E1;
					ss->*(sp_n - 0x08) = ds_n->t29DF;
					ss->*(sp_n - 0x0A) = ds_n->t29E5;
					ss->*(sp_n - 0x0C) = ds_n->t29E3;
					fn0800-3B0A(ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n, out bp_n, out ds_n);
					Eq_n sp_n = <invalid>;
					sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x0C);
				}
				ax_n = ss->*(bp_n - 0x04) | ss->*(bp_n - 0x02);
			} while (ax_n != 0x00);
		}
		Eq_n v80_n = (word32) *((word32) ds_n + 20108) + 0x04;
		*((word32) ds_n + 20108) = v80_n;
		Mem889[ds_n:20110:word16] = Mem885[ds_n:20110:word16] + (v80_n <u 0x00);
	}
	else
	{
		ui32 ax_dx_n = SEQ(ss->*(bp_n - 22), ss->*(bp_n - 0x18)) + SEQ(*((word32) ds_n + 20106), *((word32) ds_n + 0x00004E88));
		ss->*(bp_n - 0x02) = SLICE(ax_dx_n, word16, 16);
		ss->*(bp_n - 0x04) = (word16) ax_dx_n;
		if ((*((word32) ds_n + 10755) & 0x03) != 0x00)
		{
			Eq_n v60_n = (word16) (ss->*(bp_n - 0x04)) + 0x02;
			ss->*(bp_n - 0x04) = v60_n;
			Mem919[ss:bp_n - 0x02 + 0x00:word16] = Mem915[ss:bp_n - 0x02 + 0x00:word16] + (v60_n <u 0x00);
		}
		Eq_n sp_n;
		if ((ss->*(bp_n - 0x04) & 0x03) != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg0 = <invalid>;
			word16 dx_n;
			Eq_n ax_n = fn0800-8CAA(ss->*(bp_n - 0x04), 0x02, ss->*(bp_n - 0x02), stackArg0, out dx_n);
			ss->*(bp_n - 0x02) = (bool) (ax_n < 0x01) + dx_n;
			ss->*(bp_n - 0x04) = (word32) ax_n + 0x01;
			sp_n.u0 = <invalid>;
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg0 = <invalid>;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-8CAA(ss->*(bp_n - 0x04), 0x02, ss->*(bp_n - 0x02), stackArg0, out dx_n);
			ss->*(bp_n - 0x02) = dx_n;
			ss->*(bp_n - 0x04) = ax_n;
			sp_n.u0 = <invalid>;
		}
		while (true)
		{
			Eq_n ax_n = *((word32) ds_n + 10755);
			if ((ax_n & 0x03) == 0x00)
				break;
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = *((word32) ds_n + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
			ss->*(sp_n - 0x04) = DPB(ax_n & 0x03, 0x00, 0);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg6 = <invalid>;
			fn0800-4047(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
			Eq_n v101_n = (word32) *((word32) ds_n + 10755) + 0x01;
			*((word32) ds_n + 10755) = v101_n;
			Mem1001[ds_n:0x2A05:word16] = Mem997[ds_n:0x2A05:word16] + (v101_n <u 0x00);
			sp_n = (char *) sp_n + 0x02;
		}
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*(sp_n - 0x02), stackArg4, out dx_n);
		ss->*(bp_n - 0x06) = dx_n;
		ss->*(bp_n - 0x08) = ax_n;
		(ss->*sp_n).u0 = 0x01;
		cup16 dx_n = -*((word32) ds_n + 10755);
		ss->*(sp_n - 0x02) = -*((word32) ds_n + 10757) - (dx_n == 0x00) - (dx_n < 0x04);
		ss->*(sp_n - 0x04) = dx_n - 0x04;
		ss->*(sp_n - 0x06) = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x08) = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
		ss->*sp_n = *((word32) ds_n + 10721);
		ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-8CAA(*((word32) ds_n + 10755), 0x02, *((word32) ds_n + 10757), stackArg0, out dx_n);
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = ax_n;
		Eq_n ds_n;
		fn0800-409C(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		Eq_n ax_n = ss->*(bp_n - 0x0A);
		Eq_n dx_n = ss->*(bp_n - 0x0C);
		ss->*(bp_n - 0x1A) = ax_n & 0x3FFF;
		if ((ax_n & 0x3FFF) >= ss->*(bp_n - 0x02) && ((ax_n & 0x3FFF) > ss->*(bp_n - 0x02) || dx_n > ss->*(bp_n - 0x04)))
		{
			Eq_n ax_n = ss->*(bp_n - 0x0C);
			ss->*(bp_n - 0x02) = ss->*(bp_n - 0x1A);
			ss->*(bp_n - 0x04) = ax_n;
		}
		Eq_n ax_n = ss->*(bp_n - 0x0A);
		ss->*(bp_n - 0x04) = ss->*(bp_n - 0x04);
		ss->*(bp_n - 0x02) |= ax_n & 0xC000;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		ss->*sp_n = *((word32) ds_n + 0x00004E8E);
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 20108);
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000 = ss->*(bp_n - 0x02);
		(ss->*(sp_n - 0x04)).t0000 = ss->*(bp_n - 0x04);
		Eq_n ds_n;
		fn0800-409C(ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		ss->*sp_n = ss->*(bp_n - 0x06);
		(ss->*(sp_n - 0x02)).t0000 = ss->*(bp_n - 0x08);
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		Eq_n v96_n = (word32) *((word32) ds_n + 20108) + 0x04;
		*((word32) ds_n + 20108) = v96_n;
		Mem1208[ds_n:20110:word16] = Mem1204[ds_n:20110:word16] + (v96_n <u 0x00);
	}
}

// 0800:73AC: Register word16 fn0800-73AC(Register Eq_n ds, Register out Eq_n dxOut, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-73AC(Eq_n ds, union Eq_n & dxOut, struct Eq_n & dsOut)
{
	Eq_n ds_n;
	fn0800-4152(ds, 0x2E77, ds, (DPB(DPB(ax, *((word32) ds + 11893), 0), 0x00, 8) << 0x08) + DPB(DPB(dx, *((word32) ds + 11894), 0), 0x00, 8), *((word32) ds + 10719), *((word32) ds + 10721), out ds_n);
	fn0800_ACB3(ds_n, *((word32) ds_n + 10719), *((word32) ds_n + 10721), 0x01, out cx_n, out dx_n, out bx_n);
	Eq_n ds_n;
	fn0800-409C(ds_n, *((word32) ds_n + 10767), *((word32) ds_n + 0x00002A11), *((word32) ds_n + 10719), *((word32) ds_n + 10721), out dx_n, out ds_n, out Top_n);
	struct Eq_n * ds_n;
	dxOut = fn0800-75EA(ds_n, *((word32) ds_n + 0x00002A07), *((word32) ds_n + 10761), *((word32) ds_n + 0x00002A07), *((word32) ds_n + 10761), out bp_n, out si_n, out ds_n);
	dsOut = ds_n;
	return 0x00;
}

// 0800:741D: Register word16 fn0800-741D(Register Eq_n ds, Register out Eq_n dxOut)
word16 fn0800-741D(Eq_n ds, union Eq_n & dxOut)
{
	union Eq_n Eq_n::* bp_n = fp - 0x02;
	struct Eq_n Eq_n::* sp_n = fp - 0x08;
	while (true)
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800_AD2F(ds, ss->*(sp_n - 0x02), stackArg4, out dx_n);
		if (dx_n >= *((word32) ds + 10761) && (dx_n != *((word32) ds + 10761) || ax_n >= *((word32) ds + 0x00002A07)))
			break;
		ss->*sp_n = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n ax_n = fn0800-3E9A(ds, ss->*(sp_n - 0x02), stackArg4, out dx_n, out ds);
		if (ax_n != 0x00)
		{
			if (ax_n != 0x01)
			{
				if (ax_n == 0x03)
				{
					word16 si_n;
					for (si_n = 0x00; si_n != 0x03; ++si_n)
					{
						union Eq_n Eq_n::* sp_n = sp_n - 0x02;
						ss->*sp_n = *((word32) ds + 10721);
						ss->*(sp_n - 0x02) = *((word32) ds + 10719);
						ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E5);
						ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E3);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg4 = <invalid>;
						Eq_n ds_n;
						ss->*(sp_n - 0x04) = fn0800-3DCF(ds, ss->*(sp_n - 0x06), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg6 = <invalid>;
						fn0800-4047(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds, out Top_n);
					}
				}
				else
				{
					ss->*sp_n = *((word32) ds + 0x000029E5);
					ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					ui16 dx_n;
					ui32 bx_cx_n = SEQ(*((word32) ds + 10761), *((word32) ds + 0x00002A07)) - SEQ(dx_n, fn0800_AD2F(ds, ss->*(sp_n - 0x02), stackArg4, out dx_n));
					ss->*sp_n = SLICE(bx_cx_n, word16, 16);
					ss->*(sp_n - 0x02) = (word16) bx_cx_n;
					ss->*(sp_n - 0x04) = *((word32) ds + 10721);
					ss->*(sp_n - 0x06) = *((word32) ds + 10719);
					ss->*(sp_n - 0x08) = *((word32) ds + 0x000029E5);
					ss->*(sp_n - 0x0A) = *((word32) ds + 0x000029E3);
					fn0800-3B0A(ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out bp_n, out ds);
					Eq_n sp_n = <invalid>;
					sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x0C);
				}
			}
			else
			{
				ss->*sp_n = *((word32) ds + 10721);
				ss->*(sp_n - 0x02) = *((word32) ds + 10719);
				ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E5);
				ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E3);
				Eq_n ds_n;
				ss->*(sp_n - 0x04) = fn0800-3E5D(ds, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), out ds_n, out Top_n);
				ss->*(sp_n - 0x06) = ax_n;
				Eq_n ds_n;
				fn0800-409C(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out ds_n, out Top_n);
				ss->*sp_n = *((word32) ds_n + 0x000029E5);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 0x000029E3);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3FAD(ds_n, ss->*(sp_n - 0x02), ss->*sp_n, out ch_n, out di_n, out ds_n);
				(ss->*(bp_n - 0x02)).u0 = 0x00;
				ss->*(bp_n - 0x04) = ax_n;
				ss->*sp_n = *((word32) ds_n + 10721);
				ss->*(sp_n - 0x02) = *((word32) ds_n + 10719);
				(ss->*(sp_n - 0x04)).u0 = 0x00;
				Eq_n ds_n;
				fn0800-401E(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
				ss->*sp_n = ss->*(bp_n - 0x02);
				ss->*(sp_n - 0x02) = ss->*(bp_n - 0x04);
				ss->*(sp_n - 0x04) = ss->*(bp_n - 0x02);
				ss->*(sp_n - 0x06) = ss->*(bp_n - 0x04);
				Eq_n ds_n;
				fn0800-75EA(ds_n, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out bp_n, out si_n, out ds_n);
				Eq_n sp_n = <invalid>;
				(ss->*((word32) sp_n + 0x06)).u0 = 0x01;
				Eq_n dx_n = *((word32) ds_n + 10755);
				Eq_n dx_n = -((word32) dx_n + 0x02);
				Mem255[ss:sp_n + 0x04:word16] = -(Mem242[ds_n:0x2A05:word16] + (dx_n <u 0x02)) - (dx_n == 0x00);
				ss->*((word32) sp_n + 0x02) = dx_n;
				ss->*sp_n = *((word32) ds_n + 10721);
				(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10719);
				fn0800_ACB3(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
				ss->*((word32) sp_n + 0x06) = *((word32) ds_n + 10721);
				ss->*((word32) sp_n + 0x04) = *((word32) ds_n + 10719);
				ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10755);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg3 = <invalid>;
				fn0800-40BF(ds_n, ss->*((word32) sp_n + 0x02), stackArg3, ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out di_n, out ds);
				Eq_n dx_n = *((word32) ds + 10755);
				if (*((word32) ds + 10757) == ss->*(bp_n - 0x02) && dx_n == ss->*(bp_n - 0x04))
				{
					(ss->*((word32) sp_n + 0x06)).u0 = 0x01;
					Eq_n dx_n = -(ss->*(bp_n - 0x04));
					ss->*((word32) sp_n + 0x04) = -(ss->*(bp_n - 0x02)) - (dx_n == 0x00);
					ss->*((word32) sp_n + 0x02) = dx_n;
					ss->*sp_n = *((word32) ds + 0x000029E5);
					(ss->*(sp_n - 0x02)).t0000 = *((word32) ds + 0x000029E3);
					fn0800_ACB3(ds, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
					ss->*((word32) sp_n + 0x06) = ss->*(bp_n - 0x02);
					ss->*((word32) sp_n + 0x04) = ss->*(bp_n - 0x04);
					ss->*((word32) sp_n + 0x02) = *((word32) ds + 10721);
					ss->*sp_n = *((word32) ds + 10719);
					(ss->*(sp_n - 0x02)).t0000 = *((word32) ds + 0x000029E5);
					(ss->*(sp_n - 0x04)).t0000 = *((word32) ds + 0x000029E3);
					fn0800-3B0A(ss->*((word32) sp_n + 0x04), ss->*((word32) sp_n + 0x06), out dx_n, out bp_n, out ds);
					Eq_n sp_n = <invalid>;
					sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x0C);
				}
				else
				{
					(ss->*((word32) sp_n + 0x06)).u0 = 0x01;
					ss->*((word32) sp_n + 0x04) = *((word32) ds + 10757);
					ss->*((word32) sp_n + 0x02) = *((word32) ds + 10755);
					ss->*sp_n = *((word32) ds + 10721);
					(ss->*(sp_n - 0x02)).t0000 = *((word32) ds + 10719);
					fn0800_ACB3(ds, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x06), out cx_n, out dx_n, out bx_n);
					sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x08);
				}
			}
		}
		else
		{
			ss->*sp_n = *((word32) ds + 10721);
			ss->*(sp_n - 0x02) = *((word32) ds + 10719);
			ss->*(sp_n - 0x04) = *((word32) ds + 0x000029E5);
			ss->*(sp_n - 0x06) = *((word32) ds + 0x000029E3);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			Eq_n ds_n;
			ss->*(sp_n - 0x04) = fn0800-3DCF(ds, ss->*(sp_n - 0x06), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg6 = <invalid>;
			fn0800-4047(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds, out Top_n);
			sp_n = (struct Eq_n Eq_n::*) ((char *) sp_n + 0x02);
		}
	}
	dxOut = dx_n;
	return 0x00;
}

// 0800:75EA: Register Eq_n fn0800-75EA(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out Eq_n bpOut, Register out Eq_n siOut, Register out Eq_n dsOut)
Eq_n fn0800-75EA(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, union Eq_n & bpOut, union Eq_n & siOut, union Eq_n & dsOut)
{
	*((word32) ds + 18048) = wArg04;
	*((word32) ds + 0x0000467E) = wArg02;
	*((word32) ds + 10757) = wArg04;
	*((word32) ds + 10755) = wArg02;
	*((word32) ds + 18040) = wArg04;
	*((word32) ds + 0x00004676) = wArg02;
	*((word32) ds + 20102) = wArg08 - (wArg06 < 0x12);
	*((word32) ds + 20100) = wArg06 - 0x12;
	union Eq_n Eq_n::* bp_n = fp - 0x02;
	struct Eq_n Eq_n::* sp_n = fp - 0x1A;
	Eq_n dx_n = wArg06 - 0x12;
	if (*((word32) ds + 18048) > 0x00 || *((word32) ds + 18048) == 0x00 && wArg02 > 0x12)
	{
		*((word32) ds + 11851) = 0x00;
		*((word32) ds + 11849) = 0x00;
		*((word32) ds + 18012) = 0x00;
		*((word32) ds + 0x00004668) = 0x00;
		*((word32) ds + 0x00004666) = 0x00;
		((word32) ds + 10757)->u0 = 0x00;
		((word32) ds + 10755)->u0 = 0x00;
		*((word32) ds + 0x00002A01) = 0x00;
		*((word32) ds + 0x000029FF) = 0x00;
		*((word32) ds + 18044) = 0x00;
		*((word32) ds + 0x0000467A) = 0x00;
		*((word32) ds + 0x00004674) = 0x00;
		*((word32) ds + 0x00004672) = 0x00;
		*((word32) ds + 11843) = 0x00;
		*((word32) ds + 11845) = 0x00;
		*((word32) ds + 20098) = 0x00;
		*((word32) ds + 20106) = 0x00;
		*((word32) ds + 0x00004E88) = 0x00;
		*((word32) ds + 0x000029F9) = 0x00;
		*((word32) ds + 0x000029F7) = 0x00;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		union Eq_n Eq_n::* bp_n;
		struct Eq_n * ds_n;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		ss->*(bp_n - 0x14) = dx_n;
		ss->*(bp_n - 22) = ax_n;
		ds_n->w2E73 = (word16) ((word32) dx_n + 0x01);
		ds_n->w2E71 = 0x00;
		Eq_n sp_n = <invalid>;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
		(ss->*sp_n).u0 = 0x10;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		union Eq_n Eq_n::* bp_n;
		struct Eq_n * ds_n;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		ss->*(bp_n - 0x10) = dx_n;
		ss->*(bp_n - 0x12) = ax_n;
		ds_n->w2E39 = (word16) ((word32) dx_n + 0x01);
		ds_n->w2E37 = 0x00;
		Eq_n sp_n = <invalid>;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
		(ss->*sp_n).u0 = 0x10;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		union Eq_n Eq_n::* bp_n;
		struct Eq_n * ds_n;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		ss->*(bp_n - 0x0C) = dx_n;
		ss->*(bp_n - 0x0E) = ax_n;
		ds_n->w2E35 = (word16) ((word32) dx_n + 0x01);
		ds_n->w2E33 = 0x00;
		Eq_n sp_n = <invalid>;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
		(ss->*sp_n).u0 = 0x10;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		union Eq_n Eq_n::* bp_n;
		struct Eq_n * ds_n;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		ss->*(bp_n - 0x08) = dx_n;
		ss->*(bp_n - 0x0A) = ax_n;
		ds_n->w2E41 = (word16) ((word32) dx_n + 0x01);
		ds_n->w2E3F = 0x00;
		Eq_n sp_n = <invalid>;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
		(ss->*sp_n).u0 = 0x10;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		Eq_n ds_n;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-4311(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		ss->*(bp_n - 0x04) = dx_n;
		ss->*(bp_n - 0x06) = ax_n;
		*((word32) ds_n + 11837) = (struct Eq_n *) ((word32) dx_n + 0x01);
		((word32) ds_n + 11835)->u1 = 0x00;
		fn0800-87F8(ds_n);
		Eq_n sp_n = <invalid>;
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 0x000029E5);
		ss->*sp_n = *((word32) ds_n + 0x000029E3);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		ui16 dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*sp_n, stackArg4, out dx_n);
		*((word32) ds_n + 0x00004664) = dx_n;
		*((word32) ds_n + 0x00004662) = ax_n;
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		int16 dx_n;
		Eq_n ax_n = fn0800_AD2F(ds_n, ss->*sp_n, stackArg4, out dx_n);
		*((word32) ds_n + 0x00004660) = dx_n;
		*((word32) ds_n + 18014) = ax_n;
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		int32 dx_ax_n = (int32) *((word32) ds_n + 0x00002A21);
		cup16 ax_n = (word16) dx_ax_n;
		(ss->*(sp_n - 0x02)).t0000 = (bool) (ax_n < 0x4300) + (SLICE(dx_ax_n, word16, 16) + 21070);
		(ss->*(sp_n - 0x04)).t0000 = ax_n + 0x4300;
		Eq_n ds_n;
		fn0800-409C(ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 18048);
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 0x0000467E);
		Eq_n ds_n;
		fn0800-409C(ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000.u0 = 0x00;
		(ss->*(sp_n - 0x04)).t0000.u0 = 0x00;
		Eq_n ds_n;
		fn0800-409C(ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000.u0 = 0x00;
		Eq_n ds_n;
		fn0800-401E(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000.u0 = 0x00;
		Eq_n ds_n;
		fn0800-401E(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000.u0 = 0x00;
		Eq_n bx_n;
		Eq_n cx_n;
		Eq_n dx_n;
		Eq_n ds_n;
		fn0800-401E(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = ds_n;
		(ss->*sp_n).u0 = 0x2240;
		fn0800_B2EF(cx_n, dx_n, bx_n, ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02), out si_n, out di_n);
		ss->*(bp_n - 0x02) = *((word32) ds_n + 11855);
		(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
		Eq_n ax_n = 0x01;
		if (*((word32) ds_n + 0x00002A1F) == 0x00)
			ax_n.u0 = 0x00;
		ss->*sp_n = ax_n;
		fn0800-8465(ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02));
		(ss->*((word32) sp_n + 0x02)).u0 = 0x01;
		Eq_n ax_n = 0x01;
		if (*((word32) ds_n + 11855) == 0x00)
			ax_n.u0 = 0x00;
		ss->*sp_n = ax_n;
		fn0800-8465(ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02));
		if (*((word32) ds_n + 0x00002A23) != 0x01 && *((word32) ds_n + 11855) != 0x00)
		{
			(ss->*((word32) sp_n + 0x02)).u0 = 0x10;
			ss->*sp_n = *((word32) ds_n + 11855);
			fn0800-8465(ds_n, ss->*sp_n, ss->*((word32) sp_n + 0x02));
		}
		word16 ax_n = *((word32) ds_n + 0x00002A21);
		if (ax_n != 0x01)
		{
			if (ax_n == 0x02)
				ax_n = (word16) fn0800-7C78(ds_n, out ds_n);
		}
		else
			ax_n = (word16) fn0800-7A02(ds_n, out ds_n);
		word16 si_n = 18050;
		while (Mem520[ds_n:20098:word16] != 0x00)
		{
			ss->*((word32) sp_n + 0x02) = DPB(ax_n, ds_n->*si_n, 0);
			ax_n = (word16) fn0800-8624(ds_n, ss->*((word32) sp_n + 0x02), out di_n, out ds_n);
			--*((word32) ds_n + 20098);
			++si_n;
		}
		*((word32) ds_n + 11855) = ss->*(bp_n - 0x02);
		ui32 ax_dx_n = SEQ(*((word32) ds_n + 18048), *((word32) ds_n + 0x0000467E)) - SEQ(*((word32) ds_n + 10757), *((word32) ds_n + 10755));
		Eq_n dx_n = (word16) ax_dx_n;
		uint16 ax_n = SLICE(ax_dx_n, word16, 16);
		if (ax_n <= *((word32) ds_n + 20106) && (ax_n < *((word32) ds_n + 20106) || dx_n < *((word32) ds_n + 0x00004E88)))
		{
			ui32 ax_dx_n = SEQ(*((word32) ds_n + 18048), *((word32) ds_n + 0x0000467E)) - SEQ(*((word32) ds_n + 10757), *((word32) ds_n + 10755));
			*((word32) ds_n + 0x00004E88) = v34_n;
			ui32 v35_v34_n = SEQ(*((word32) ds_n + 20106), *((word32) ds_n + 0x00004E88)) - ax_dx_n;
			*((word32) ds_n + 20106) = SLICE(v35_v34_n, word16, 16);
			Eq_n v34_n = (word16) v35_v34_n;
		}
		else
		{
			*((word32) ds_n + 20106) = 0x00;
			((word32) ds_n + 0x00004E88)->u0 = 0x00;
		}
		if (*((word32) ds_n + 0x00002A21) == 0x02)
		{
			Eq_n v39_n = (word32) *((word32) ds_n + 0x00004E88) + 0x02;
			*((word32) ds_n + 0x00004E88) = v39_n;
			*((word32) ds_n + 20106) = (uint16) ((bool) (v39_n < 0x00) + *((word32) ds_n + 20106));
		}
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		int16 dx_n;
		int32 dx_ax_n = SEQ(dx_n, fn0800_AD2F(ds_n, ss->*sp_n, stackArg4, out dx_n)) - SEQ(*((word32) ds_n + 0x00004660), *((word32) ds_n + 18014));
		*((word32) ds_n + 10757) = SLICE(dx_ax_n, word16, 16);
		*((word32) ds_n + 10755) = (word16) dx_ax_n;
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		Eq_n dx_n = *((word32) ds_n + 18014);
		ss->*sp_n = (bool) (dx_n < 0x08) + *((word32) ds_n + 0x00004660);
		(ss->*(sp_n - 0x02)).t0000 = (word32) dx_n + 0x08;
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		Eq_n dx_n = *((word32) ds_n + 10755);
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 10757) - (dx_n < 0x12);
		(ss->*(sp_n - 0x04)).t0000 = dx_n - 0x12;
		Eq_n ds_n;
		fn0800-409C(ds_n, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out dx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 11851);
		Eq_n ds_n;
		fn0800-401E(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000 = *((word32) ds_n + 11849);
		Eq_n ds_n;
		word16 ax_n = fn0800-401E(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000 = DPB(ax_n, *((word32) ds_n + 0x00004E88), 0);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		Eq_n ds_n;
		word16 ax_n = fn0800-4047(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
		ss->*((word32) sp_n + 0x02) = *((word32) ds_n + 10721);
		ss->*sp_n = *((word32) ds_n + 10719);
		(ss->*(sp_n - 0x02)).t0000 = DPB(ax_n, *((word32) ds_n + 0x000029F7), 0);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		Eq_n ds_n;
		fn0800-4047(ds_n, (ss->*(sp_n - 0x02)).t0000, ss->*sp_n, stackArg6, out cx_n, out dx_n, out bx_n, out di_n, out ds_n, out Top_n);
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		ui32 ax_dx_n = SEQ(*((word32) ds_n + 0x00004660), *((word32) ds_n + 18014)) + SEQ(*((word32) ds_n + 10757), *((word32) ds_n + 10755));
		ss->*sp_n = SLICE(ax_dx_n, word16, 16);
		(ss->*(sp_n - 0x02)).t0000 = (word16) ax_dx_n;
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 10721);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 10719);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		(ss->*((word32) sp_n + 0x02)).u0 = 0x00;
		ui32 ax_dx_n = SEQ(*((word32) ds_n + 0x00004664), *((word32) ds_n + 0x00004662)) + SEQ(*((word32) ds_n + 18048), *((word32) ds_n + 0x0000467E));
		ss->*sp_n = SLICE(ax_dx_n, word16, 16);
		(ss->*(sp_n - 0x02)).t0000 = (word16) ax_dx_n;
		(ss->*(sp_n - 0x04)).t0000 = *((word32) ds_n + 0x000029E5);
		(ss->*(sp_n - 0x06)).t0000 = *((word32) ds_n + 0x000029E3);
		fn0800_ACB3(ds_n, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x14);
		ss->*sp_n = ss->*(bp_n - 22);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n ds_n;
		fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x10);
		ss->*sp_n = ss->*(bp_n - 0x12);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n ds_n;
		fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x0C);
		ss->*sp_n = ss->*(bp_n - 0x0E);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n ds_n;
		fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x08);
		ss->*sp_n = ss->*(bp_n - 0x0A);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n ds_n;
		fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds_n);
		ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x04);
		ss->*sp_n = ss->*(bp_n - 0x06);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n bx_n;
		Eq_n cx_n;
		fn0800-4346(ds_n, stackArg2, ss->*((word32) sp_n + 0x02), out cx_n, out dx_n, out bx_n, out ds);
		ss->*((word32) sp_n + 0x02) = ds;
		(ss->*sp_n).u0 = 0x223C;
		fn0800_B2EF(cx_n, dx_n, bx_n, ds, ss->*sp_n, ss->*((word32) sp_n + 0x02), out si_n, out di_n);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
	}
	Eq_n si_n = (ss->*sp_n).t0000;
	bpOut = ss->*bp_n;
	siOut = si_n;
	dsOut = ds;
	return dx_n;
}

// 0800:7A02: Register byte fn0800-7A02(Register Eq_n ds, Register out Eq_n dsOut)
byte fn0800-7A02(Eq_n ds, union Eq_n & dsOut)
{
	while (true)
	{
		Eq_n ax_n = *((word32) ds + 18044);
		Eq_n dx_n = *((word32) ds + 0x0000467A);
		if (ax_n >= *((word32) ds + 18048) && (ax_n != *((word32) ds + 18048) || dx_n >= *((word32) ds + 0x0000467E)))
			break;
		fn0800-43D4(10319, ds, 0x10);
		fn0800-43D4(10127, ds, 0x10);
		fn0800-43D4(10511, ds, 0x10);
		ds = fn0800-7FDC(ds);
		fn0800_ACB3(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), 0x00, out cx_n, out dx_n, out bx_n);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-441C(ds, 10511, stackArg4, 0x10);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-441C(ds, 10319, stackArg4, 0x10);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-441C(ds, 10127, stackArg4, 0x10);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-83A1(ds, SEQ(ds, 10511), stackArg4, 0x10);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-83A1(ds, SEQ(ds, 10319), stackArg4, 0x10);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800-83A1(ds, SEQ(ds, 10127), stackArg4, 0x10);
		fn0800-8489(ds, *((word32) ds + 0x0000466A), 0x10);
		while (true)
		{
			Eq_n ax_n = *((word32) ds + 0x0000466A);
			cu16 dx_n = *((word32) ds + 0x0000466C);
			Eq_n v18_n = *((word32) ds + 0x0000466A) - 0x01;
			*((word32) ds + 0x0000466A) = v18_n;
			*((word32) ds + 0x0000466C) -= v18_n < 0x00;
			cui16 ax_n = ax_n | dx_n;
			if (ax_n == 0x00)
				break;
			Eq_n ax_n = fn0800-3E27(ds, *((word32) ds + 10715), *((word32) ds + 0x000029DD), out cx_n, out dx_n, out di_n, out ds, out Top_n);
			*((word32) ds + 11847) = ax_n;
			word16 v25_n = Mem439[ds:0x467A:word16] + ax_n;
			*((word32) ds + 0x0000467A) = v25_n;
			Mem445[ds:18044:word16] = Mem441[ds:18044:word16] + (v25_n <u 0x00);
			fn0800-8407(ds, *((word32) ds + 11847), SEQ(ds, 10511));
			if (*((word32) ds + 11847) != 0x00)
			{
				if (*((word32) ds + 11845) != 0x00)
				{
					while (true)
					{
						Eq_n ds_n;
						Eq_n ax_n = *((word32) ds + 11847);
						--*((word32) ds + 11847);
						if (ax_n == 0x00)
							break;
						(ds_n->**((word32) ds_n + 20098)).b4682 = (byte) (word16) fn0800-8359(ds, out ds_n) ^ *((word32) ds_n + 11855);
						*((word32) ds_n + 20098) = (struct Eq_n Eq_n::*) ((char *) *((word32) ds_n + 20098) + 0x01);
						ds = ds_n;
					}
				}
				else
				{
					while (true)
					{
						Eq_n ax_n = *((word32) ds + 11847);
						--*((word32) ds + 11847);
						if (ax_n == 0x00)
							break;
						Eq_n ds_n;
						word16 ax_n = (word16) fn0800-8359(ds, out ds_n);
						fn0800-8624(ds_n, SLICE(DPB(ax_n, (byte) ax_n ^ *((word32) ds_n + 11855), 0), byte, 0), out di_n, out ds);
						Mem470 = Mem498;
					}
				}
				if ((*((word32) ds + 11855) & 0x01) != 0x00)
					*((word32) ds + 11855) = *((word32) ds + 11855) >> 0x01 | 0x8000;
				else
					*((word32) ds + 11855) >>= 0x01;
			}
			if ((*((word32) ds + 0x0000466A) | *((word32) ds + 0x0000466C)) != 0x00)
			{
				Eq_n ds_n;
				*((word32) ds_n + 11817) = fn0800-3E27(ds, *((word32) ds + 10715), *((word32) ds + 0x000029DD), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
				Eq_n ds_n;
				*((word32) ds_n + 11819) = fn0800-3E27(ds_n, *((word32) ds_n + 10715), *((word32) ds_n + 0x000029DD), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
				fn0800-8407(ds_n, *((word32) ds_n + 11819), SEQ(ds_n, 10319));
				fn0800-8407(ds_n, *((word32) ds_n + 11817), SEQ(ds_n, 10127));
				*((word32) ds_n + 11817) = (word32) *((word32) ds_n + 11817) + 0x02;
				word16 v40_n = Mem649[ds_n:0x467A:word16] + Mem649[ds_n:11817:word16];
				*((word32) ds_n + 0x0000467A) = v40_n;
				Mem656[ds_n:18044:word16] = Mem652[ds_n:18044:word16] + (v40_n <u 0x00);
				ds = ds_n;
				while (true)
				{
					Eq_n ax_n = *((word32) ds + 11817);
					--*((word32) ds + 11817);
					if (ax_n == 0x00)
						break;
					fn0800-8359(ds, out ds);
				}
			}
		}
		if (*((word32) ds + 11845) == 0x00)
		{
			word16 si_n = 18050;
			while (Mem354[ds:20098:word16] != 0x00)
			{
				ax_n = (word16) fn0800-8624(ds, SLICE(DPB(ax_n, ds->*si_n, 0), byte, 0), out di_n, out ds);
				--*((word32) ds + 20098);
				++si_n;
			}
		}
		Eq_n v29_n = (word32) *((word32) ds + 0x000029F7) + 0x01;
		*((word32) ds + 0x000029F7) = v29_n;
		*((word32) ds + 0x000029F9) = (word16) ((bool) (v29_n < 0x00) + *((word32) ds + 0x000029F9));
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800_AD2F(ds, SEQ(*((word32) ds + 0x000029E5), *((word32) ds + 0x000029E3)), stackArg4, out dx_n);
	}
	*((word32) ds + 11843) >>= 0x10 - *((word32) ds + 11845);
	if (*((word32) ds + 11845) != 0x00 || Mem33[ds:20098:word16] != 0x00)
		ax_n = (word16) fn0800-8624(ds, SLICE(DPB(ax_n, *((word32) ds + 11843), 0), byte, 0), out di_n, out ds);
	if (*((word32) ds + 11845) > 0x08 || Mem67[ds:20098:word16] != 0x00)
		ax_n = (word16) fn0800-8624(ds, SLICE(*((word32) ds + 11843) >> 0x08, byte, 0), out di_n, out ds);
	dsOut = ds;
	return (byte) ax_n;
}

// 0800:7C78: Register byte fn0800-7C78(Register Eq_n ds, Register out Eq_n dsOut)
byte fn0800-7C78(Eq_n ds, union Eq_n & dsOut)
{
	while (true)
	{
		Eq_n ax_n = *((word32) ds + 18044);
		Eq_n dx_n = *((word32) ds + 0x0000467A);
		if (ax_n >= *((word32) ds + 18048) && (ax_n != *((word32) ds + 18048) || dx_n >= *((word32) ds + 0x0000467E)))
			break;
		Eq_n ds_n = fn0800-7FDC(ds);
		fn0800_ACB3(ds_n, *((word32) ds_n + 0x000029E3), *((word32) ds_n + 0x000029E5), 0x00, out cx_n, out dx_n, out bx_n);
		while (true)
		{
			Eq_n ax_n = *((word32) ds_n + 0x0000466A);
			cu16 dx_n = *((word32) ds_n + 0x0000466C);
			Eq_n v17_n = *((word32) ds_n + 0x0000466A) - 0x01;
			*((word32) ds_n + 0x0000466A) = v17_n;
			*((word32) ds_n + 0x0000466C) -= v17_n < 0x00;
			if ((ax_n | dx_n) == 0x00)
				break;
			Eq_n ax_n = fn0800-3E27(ds_n, *((word32) ds_n + 10715), *((word32) ds_n + 0x000029DD), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
			*((word32) ds_n + 11847) = ax_n;
			word16 v25_n = Mem307[ds_n:0x467A:word16] + ax_n;
			*((word32) ds_n + 0x0000467A) = v25_n;
			Mem313[ds_n:18044:word16] = Mem309[ds_n:18044:word16] + (v25_n <u 0x00);
			fn0800-7EAF(ds_n, ax_n);
			if ((*((word32) ds_n + 0x0000466A) | *((word32) ds_n + 0x0000466C)) != 0x00)
			{
				Eq_n ds_n;
				*((word32) ds_n + 11817) = fn0800-3E27(ds_n, *((word32) ds_n + 10715), *((word32) ds_n + 0x000029DD), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
				Eq_n ds_n;
				Eq_n ax_n = fn0800-3E27(ds_n, *((word32) ds_n + 10715), *((word32) ds_n + 0x000029DD), out cx_n, out dx_n, out di_n, out ds_n, out Top_n);
				*((word32) ds_n + 11819) = ax_n;
				if (*((word32) ds_n + 11817) == 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg5 = <invalid>;
					fn0800-854B(ds_n, 0x06, 0x03, stackArg5);
					fn0800-8600(ds_n, SLICE(DPB(ax_n, *((word32) ds_n + 11819), 0), byte, 0), out ds_n);
				}
				else if (*((word32) ds_n + 11817) < 0x07)
				{
					Eq_n bx_n = *((word32) ds_n + 11817);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					byte al_n = ds_n->*((word32) bx_n + 8667);
					Eq_n stackArg5 = <invalid>;
					fn0800-854B(ds_n, DPB(DPB(DPB(DPB(ax_n, al_n, 0), 0x00, 8), ds_n->*((word32) bx_n + 8660), 0), 0x00, 8), SLICE(DPB(DPB(ax_n, al_n, 0), 0x00, 8), byte, 0), stackArg5);
					Eq_n bx_n = *((word32) ds_n + 11819);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					byte al_n = ds_n->*((word16) (bx_n >> 0x08) + 0x000021F2);
					Eq_n stackArg5 = <invalid>;
					fn0800-854B(ds_n, DPB(DPB(DPB(DPB(ax_n, al_n, 0), 0x00, 8), ds_n->*((word16) (bx_n >> 0x08) + 0x000021E2), 0), 0x00, 8), SLICE(DPB(DPB(ax_n, al_n, 0), 0x00, 8), byte, 0), stackArg5);
					fn0800-8600(ds_n, SLICE(DPB(ax_n, *((word32) ds_n + 11819) & ~0x00, 0), byte, 0), out ds_n);
				}
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg5 = <invalid>;
					fn0800-854B(ds_n, 0x0F, 0x04, stackArg5);
					Eq_n ds_n;
					fn0800-8600(ds_n, SLICE(DPB(ax_n, *((word32) ds_n + 11817) - 0x06, 0), byte, 0), out ds_n);
					Eq_n bx_n = *((word32) ds_n + 11819);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					byte al_n = ds_n->*((word16) (bx_n >> 0x08) + 0x000021F2);
					Eq_n stackArg5 = <invalid>;
					fn0800-854B(ds_n, DPB(DPB(DPB(DPB(ax_n, al_n, 0), 0x00, 8), ds_n->*((word16) (bx_n >> 0x08) + 0x000021E2), 0), 0x00, 8), SLICE(DPB(DPB(ax_n, al_n, 0), 0x00, 8), byte, 0), stackArg5);
					fn0800-8600(ds_n, SLICE(DPB(ax_n, *((word32) ds_n + 11819) & ~0x00, 0), byte, 0), out ds_n);
				}
				*((word32) ds_n + 11817) = (word32) *((word32) ds_n + 11817) + 0x02;
				word16 v36_n = Mem555[ds_n:0x467A:word16] + Mem555[ds_n:11817:word16];
				*((word32) ds_n + 0x0000467A) = v36_n;
				Mem562[ds_n:18044:word16] = Mem558[ds_n:18044:word16] + (v36_n <u 0x00);
				while (true)
				{
					Eq_n ax_n = *((word32) ds_n + 11817);
					--*((word32) ds_n + 11817);
					if (ax_n == 0x00)
						break;
					fn0800-8359(ds_n, out ds_n);
				}
			}
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg5 = <invalid>;
		fn0800-854B(ds_n, 0x0F, 0x04, stackArg5);
		fn0800-8600(ds_n, SLICE(DPB(ax_n, 0x00, 0), byte, 0), out ds);
		Eq_n ax_n = *((word32) ds + 18044);
		Eq_n dx_n = *((word32) ds + 0x0000467A);
		if (ax_n <= *((word32) ds + 18048) && (ax_n < *((word32) ds + 18048) || dx_n < *((word32) ds + 0x0000467E)))
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg5 = <invalid>;
			fn0800-854B(ds, 0x01, 0x01, stackArg5);
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg5 = <invalid>;
			fn0800-854B(ds, 0x00, 0x01, stackArg5);
		}
		word16 ax_n;
		if (*((word32) ds + 11845) == 0x00)
		{
			word16 si_n = 18050;
			while (Mem219[ds:20098:word16] != 0x00)
			{
				ax_n = (word16) fn0800-8624(ds, SLICE(DPB(ax_n, ds->*si_n, 0), byte, 0), out di_n, out ds);
				--*((word32) ds + 20098);
				++si_n;
			}
		}
		Eq_n v31_n = (word32) *((word32) ds + 0x000029F7) + 0x01;
		*((word32) ds + 0x000029F7) = v31_n;
		*((word32) ds + 0x000029F9) = (word16) ((bool) (v31_n < 0x00) + *((word32) ds + 0x000029F9));
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800_AD2F(ds, SEQ(*((word32) ds + 0x000029E5), *((word32) ds + 0x000029E3)), stackArg4, out dx_n);
	}
	*((word32) ds + 11843) <<= 0x08 - *((word32) ds + 11845);
	if (*((word32) ds + 11845) != 0x00 || Mem33[ds:20098:word16] != 0x00)
		ax_n = (word16) fn0800-8624(ds, SLICE(DPB(ax_n, *((word32) ds + 11843), 0), byte, 0), out di_n, out ds);
	dsOut = ds;
	return (byte) ax_n;
}

// 0800:7EAF: void fn0800-7EAF(Register Eq_n ds, Stack Eq_n wArg02)
void fn0800-7EAF(Eq_n ds, Eq_n wArg02)
{
	Eq_n si_n = wArg02;
	while (true)
	{
		Eq_n si_n = si_n;
		if (si_n == 0x00)
			break;
		if (si_n < 0x0C)
		{
			while (true)
			{
				si_n = si_n;
				if (si_n == 0x00)
					break;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg5 = <invalid>;
				fn0800-854B(ds, 0x00, 0x01, stackArg5);
				Eq_n ds_n;
				word16 ax_n = (word16) fn0800-8359(ds, out ds_n);
				fn0800-8600(ds_n, SLICE(DPB(ax_n, (byte) ax_n ^ *((word32) ds_n + 11855), 0), byte, 0), out ds);
				if ((*((word32) ds + 11855) & 0x01) != 0x00)
					*((word32) ds + 11855) = *((word32) ds + 11855) >> 0x01 | 0x8000;
				else
					*((word32) ds + 11855) >>= 0x01;
				--si_n;
			}
		}
		else
		{
			while ((si_n & 0x03) != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg5 = <invalid>;
				fn0800-854B(ds, 0x00, 0x01, stackArg5);
				Eq_n ds_n;
				word16 ax_n = (word16) fn0800-8359(ds, out ds_n);
				fn0800-8600(ds_n, SLICE(DPB(ax_n, (byte) ax_n ^ *((word32) ds_n + 11855), 0), byte, 0), out ds);
				if ((*((word32) ds + 11855) & 0x01) != 0x00)
					*((word32) ds + 11855) = *((word32) ds + 11855) >> 0x01 | 0x8000;
				else
					*((word32) ds + 11855) >>= 0x01;
				--si_n;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg5 = <invalid>;
			fn0800-854B(ds, 0x17, 0x05, stackArg5);
			if (si_n >= 0x48)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg5 = <invalid>;
				fn0800-854B(ds, 0x0F, 0x04, stackArg5);
				word16 di_n = 0x00;
				while (di_n != 0x48)
				{
					Eq_n ds_n;
					word16 ax_n = (word16) fn0800-8359(ds, out ds_n);
					di_n = fn0800-8600(ds_n, SLICE(DPB(ax_n, (byte) ax_n ^ *((word32) ds_n + 11855), 0), byte, 0), out ds) + 0x01;
					Mem225 = Mem232;
				}
				if ((*((word32) ds + 11855) & 0x01) != 0x00)
					*((word32) ds + 11855) = *((word32) ds + 11855) >> 0x01 | 0x8000;
				else
					*((word32) ds + 11855) >>= 0x01;
				si_n = si_n - 0x48;
			}
			else
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg5 = <invalid>;
				fn0800-854B(ds, si_n - 0x0C >> 0x02, 0x04, stackArg5);
				while (true)
				{
					si_n = si_n;
					if (si_n == 0x00)
						break;
					Eq_n ds_n;
					word16 ax_n = (word16) fn0800-8359(ds, out ds_n);
					fn0800-8600(ds_n, SLICE(DPB(ax_n, (byte) ax_n ^ *((word32) ds_n + 11855), 0), byte, 0), out ds);
					--si_n;
					Mem155 = Mem162;
				}
				if ((*((word32) ds + 11855) & 0x01) != 0x00)
					*((word32) ds + 11855) = *((word32) ds + 11855) >> 0x01 | 0x8000;
				else
					*((word32) ds + 11855) >>= 0x01;
			}
		}
	}
}

// 0800:7FDC: Register Eq_n fn0800-7FDC(Register Eq_n ds)
Eq_n fn0800-7FDC(Eq_n ds)
{
	*((word32) ds + 0x0000466C) = 0x00;
	((word32) ds + 0x0000466A)->u0 = 0x00;
	((word32) ds + 11847)->u0 = 0x00;
	uint16 dx_n = *((word32) ds + 0x00002A0B);
	*((word32) ds + 0x00004670) = *((word32) ds + 0x00002A0D);
	*((word32) ds + 0x0000466E) = dx_n;
	fn0800_ACB3(ds, *((word32) ds + 0x000029E3), *((word32) ds + 0x000029E5), 0x00, out cx_n, out dx_n, out bx_n);
	fn0800_ACB3(ds, *((word32) ds + 10715), *((word32) ds + 0x000029DD), 0x00, out cx_n, out dx_n, out bx_n);
	union Eq_n Eq_n::* sp_n = fp - 0x06;
	while ((*((word32) ds + 0x00004676) | *((word32) ds + 18040)) != 0x00 || (*((word32) ds + 0x00004672) | *((word32) ds + 0x00004674)) != 0x00)
	{
		uint16 dx_n = ~0x00 - *((word32) ds + 11825);
		ui32 ax_dx_n = SEQ(0x00 - (dx_n < 0x00), dx_n) - SEQ(*((word32) ds + 0x00004674), *((word32) ds + 0x00004672));
		Eq_n ax_n = SLICE(ax_dx_n, word16, 16);
		Eq_n dx_n = (word16) ax_dx_n;
		Eq_n wLoc04_n = ax_n;
		Eq_n wLoc06_n = dx_n;
		Eq_n ax_n = *((word32) ds + 18040);
		Eq_n dx_n = *((word32) ds + 0x00004676);
		if (ax_n <= ax_n && (ax_n < ax_n || dx_n < dx_n))
		{
			wLoc04_n = *((word32) ds + 18040);
			wLoc06_n = *((word32) ds + 0x00004676);
		}
		Eq_n dx_n = (word32) *((word32) ds + 11889) + *((word32) ds + 11825);
		*((word32) ds + 11887) = *((word32) ds + 11891);
		*((word32) ds + 11885) = dx_n;
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds + 0x000029E5);
		ss->*(sp_n - 0x02) = *((word32) ds + 0x000029E3);
		ss->*(sp_n - 0x04) = wLoc04_n;
		ss->*(sp_n - 0x06) = wLoc06_n;
		Eq_n ax_n = (word32) *((word32) ds + 11885) + *((word32) ds + 0x00004672);
		ss->*(sp_n - 0x08) = *((word32) ds + 11891);
		ss->*(sp_n - 0x0A) = ax_n;
		fn0800-4110(ds, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out si_n, out di_n, out ds);
		*((word32) ds + 0x00004676) = v27_n;
		ui32 v28_v27_n = SEQ(*((word32) ds + 18040), *((word32) ds + 0x00004676)) - SEQ(wLoc04_n, wLoc06_n);
		*((word32) ds + 18040) = SLICE(v28_v27_n, word16, 16);
		*((word32) ds + 0x00004672) = v29_n;
		ui32 v30_v29_n = SEQ(*((word32) ds + 0x00004674), *((word32) ds + 0x00004672)) + SEQ(wLoc04_n, wLoc06_n);
		*((word32) ds + 0x00004674) = SLICE(v30_v29_n, word16, 16);
		Eq_n ax_n = *((word32) ds + 11887);
		cup16 dx_n = (word32) *((word32) ds + 11885) + *((word32) ds + 0x00004672);
		*((word32) ds + 11879) = ax_n;
		*((word32) ds + 11877) = dx_n;
		*((word32) ds + 11883) = ax_n;
		*((word32) ds + 11881) = dx_n;
		struct Eq_n Eq_n::* sp_n = (char *) sp_n + 0x02;
		Eq_n v27_n = (word16) v28_v27_n;
		uint16 v29_n = (word16) v30_v29_n;
		uint16 ax_n = *((word32) ds + 0x00004670);
		uint16 dx_n = *((word32) ds + 0x0000466E);
		if (ax_n <= *((word32) ds + 0x00004674) && (ax_n < *((word32) ds + 0x00004674) || dx_n < *((word32) ds + 0x00004672)))
		{
			cup16 dx_n = (word32) *((word32) ds + 11885) + *((word32) ds + 0x0000466E);
			*((word32) ds + 11879) = *((word32) ds + 11887);
			*((word32) ds + 11877) = dx_n;
		}
		while (*((word32) ds + 11877) - 0x01 > *((word32) ds + 11885) && (*((word32) ds + 0x0000466C) < 0x00 || *((word32) ds + 0x0000466C) == 0x00 && *((word32) ds + 0x0000466A) < ~0x01))
		{
			fn0800-8832(ds);
			if (*((word32) ds + 11817) >= 0x02)
			{
				if (Mem207[ds:11885:word16] + Mem207[ds:11817:word16] >u Mem207[ds:11877:word16])
				{
					if ((*((word32) ds + 0x0000466A) | *((word32) ds + 0x0000466C)) != 0x00)
						break;
					*((word32) ds + 11817) = *((word32) ds + 11877) - *((word32) ds + 11885);
				}
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = ds;
				(ss->*(sp_n - 0x02)).u0 = 10511;
				ss->*(sp_n - 0x04) = *((word32) ds + 11847);
				Eq_n ds_n = fn0800-831D(ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
				ss->*sp_n = ds_n;
				(ss->*(sp_n - 0x02)).u0 = 10127;
				ss->*(sp_n - 0x04) = *((word32) ds_n + 11817) - 0x02;
				Eq_n ds_n = fn0800-831D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
				ss->*sp_n = ds_n;
				(ss->*(sp_n - 0x02)).u0 = 10319;
				ss->*(sp_n - 0x04) = *((word32) ds_n + 11819) - 0x01;
				ds = fn0800-831D(ds_n, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
				ss->*sp_n = *((word32) ds + 11817);
				fn0800-89A8(ds, ss->*sp_n);
				Eq_n v40_n = (word32) *((word32) ds + 0x0000466A) + 0x01;
				*((word32) ds + 0x0000466A) = v40_n;
				*((word32) ds + 0x0000466C) = (cu16) ((bool) (v40_n < 0x00) + *((word32) ds + 0x0000466C));
				((word32) ds + 11847)->u0 = 0x00;
				*((word32) ds + 18012) = (cup16) ((word32) *((word32) ds + 11817) + *((word32) ds + 18012));
			}
			else
			{
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).u0 = 0x01;
				fn0800-89A8(ds, ss->*sp_n);
				*((word32) ds + 11847) = (word32) *((word32) ds + 11847) + 0x01;
				++*((word32) ds + 18012);
			}
			sp_n = sp_n;
			sp_n = sp_n;
			if (*((word32) ds + 18012) >= 0x0400)
			{
				Eq_n v45_n = (word32) *((word32) ds + 0x00004666) + *((word32) ds + 18012);
				*((word32) ds + 0x00004666) = v45_n;
				Mem379[ds:0x4668:word16] = Mem375[ds:0x4668:word16] + (v45_n <u 0x00);
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = *((word32) ds + 18048);
				ss->*(sp_n - 0x02) = *((word32) ds + 0x0000467E);
				Eq_n dx_n;
				Eq_n ax_n = fn0800-8F18(99, *((word32) ds + 0x00004668), 0x00, *((word32) ds + 0x00004666), out ch_n, out dx_n);
				ss->*(sp_n - 0x04) = dx_n;
				ss->*(sp_n - 0x06) = ax_n;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				Eq_n bx_n;
				Eq_n cx_n;
				Eq_n dx_n;
				Eq_n ax_n = fn0800-8BC2(stackArg0, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out cx_n, out dx_n, out bx_n);
				Eq_n sp_n = <invalid>;
				ss->*((word32) sp_n + 0x06) = dx_n;
				ss->*((word32) sp_n + 0x04) = ax_n;
				ss->*((word32) sp_n + 0x02) = ds;
				(ss->*sp_n).u0 = 0x2244;
				fn0800_B2EF(cx_n, dx_n, bx_n, ds, ss->*sp_n, ss->*((word32) sp_n + 0x02), out si_n, out di_n);
				*((word32) ds + 18012) = 0x00;
				sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x08);
			}
		}
		uint16 ax_n = *((word32) ds + 11881) - *((word32) ds + 11885);
		*((word32) ds + 0x00004674) = 0x00 - (ax_n < 0x00);
		*((word32) ds + 0x00004672) = ax_n;
		cup16 ax_n = *((word32) ds + 11885) - *((word32) ds + 11889);
		uint16 ax_n = ax_n - *((word32) ds + 11825);
		Eq_n ax_n = (word32) *((word32) ds + 11889) + ax_n;
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = *((word32) ds + 11885) - ax_n + *((word32) ds + 0x00004672);
		ss->*(sp_n - 0x02) = *((word32) ds + 11891);
		ss->*(sp_n - 0x04) = ax_n;
		ss->*(sp_n - 0x06) = *((word32) ds + 11891);
		ss->*(sp_n - 0x08) = *((word32) ds + 11889);
		fn0800_B0F3(ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n);
		ui16 dx_n = 0x00 - (ax_n < 0x00) - (ax_n < 0x00);
		sp_n = (union Eq_n Eq_n::*) ((char *) sp_n + 0x02);
		if (*((word32) ds + 11877) < *((word32) ds + 11881))
			break;
		cup16 dx_n = *((word32) ds + 11877);
		if (*((word32) ds + 11879) == *((word32) ds + 11883) && (dx_n == *((word32) ds + 11881) && (*((word32) ds + 0x00004676) | *((word32) ds + 18040)) == 0x00) || *((word32) ds + 0x0000466C) == 0x00 && *((word32) ds + 0x0000466A) == ~0x01)
			break;
		*((word32) ds + 0x0000466E) = v36_n;
		ui32 v37_v36_n = SEQ(*((word32) ds + 0x00004670), *((word32) ds + 0x0000466E)) - SEQ(dx_n, ax_n);
		*((word32) ds + 0x00004670) = SLICE(v37_v36_n, word16, 16);
		uint16 v36_n = (word16) v37_v36_n;
	}
	cup16 dx_n = *((word32) ds + 11877);
	if (*((word32) ds + 11879) == *((word32) ds + 11883) && (dx_n == *((word32) ds + 11881) && ((*((word32) ds + 0x00004676) | *((word32) ds + 18040)) == 0x00 && (*((word32) ds + 0x0000466C) != 0x00 || *((word32) ds + 0x0000466A) != ~0x01))))
		*((word32) ds + 11847) = (word32) *((word32) ds + 11847) + *((word32) ds + 0x00004672);
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	ss->*sp_n = ds;
	(ss->*(sp_n - 0x02)).u0 = 10511;
	ss->*(sp_n - 0x04) = *((word32) ds + 11847);
	Eq_n ds_n = fn0800-831D(ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02));
	Eq_n v18_n = (word32) *((word32) ds_n + 0x0000466A) + 0x01;
	*((word32) ds_n + 0x0000466A) = v18_n;
	*((word32) ds_n + 0x0000466C) = (cu16) ((bool) (v18_n < 0x00) + *((word32) ds_n + 0x0000466C));
	(ss->*sp_n).u0 = 0x00;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x00;
	ss->*(sp_n - 0x06) = *((word32) ds_n + 0x000029DD);
	ss->*(sp_n - 0x08) = *((word32) ds_n + 10715);
	fn0800_ACB3(ds_n, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*sp_n, out cx_n, out dx_n, out bx_n);
	return ds_n;
}

// 0800:831D: Register Eq_n fn0800-831D(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n ptrArg04)
Eq_n fn0800-831D(Eq_n ds, Eq_n wArg02, Eq_n ptrArg04)
{
	Eq_n ax_n;
	if (wArg02 > 0x01)
		ax_n = fn0800-0C08(wArg02);
	else
		ax_n = wArg02;
	struct Eq_n * es_n = SLICE(ptrArg04, selector, 16);
	word16 bx_n = (word16) (ptrArg04 + ax_n *s 0x0C);
	cup16 v14_n = (es_n->*bx_n).w0000 + 0x01;
	(es_n->*bx_n).w0000 = v14_n;
	(es_n->*bx_n).w0002 = (word16) ((bool) (v14_n < 0x00) + (es_n->*bx_n).w0002);
	Eq_n ds_n;
	fn0800-401E(ds, wArg02, *((word32) ds + 10715), *((word32) ds + 0x000029DD), out cx_n, out dx_n, out bx_n, out ds_n, out Top_n);
	return ds_n;
}

// 0800:8359: Register byte fn0800-8359(Register Eq_n ds, Register out (ptr16 Eq_n) dsOut)
byte fn0800-8359(Eq_n ds, struct Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	struct Eq_n * ds_n;
	Eq_n ax_n = fn0800-3DCF(ds, SEQ(*((word32) ds + 0x000029E5), *((word32) ds + 0x000029E3)), stackArg4, out ch_n, out dx_n, out di_n, out ds_n, out Top_n);
	byte al_n = (byte) ax_n;
	Eq_n ax_n = (&(ss->*(ss->*ds_n).a2A29))[(DPB(DPB(ax_n, ds_n->t2E4B ^ al_n, 0), 0x00, 8) & 0xFF) * 0x02] ^ ds_n->t2E4B >> 0x08;
	ds_n->t2E4B = ax_n;
	cup16 v17_n = ds_n->w29FF + 0x01;
	ds_n->w29FF = v17_n;
	ds_n->w2A01 = (word16) ((bool) (v17_n < 0x00) + ds_n->w2A01);
	dsOut = ds_n;
	return (byte) DPB(ax_n, al_n, 0);
}

// 0800:83A1: void fn0800-83A1(Register Eq_n ds, Stack segptr32 ptrArg02, Stack Eq_n psegArg04, Stack Eq_n wArg06)
void fn0800-83A1(Eq_n ds, segptr32 ptrArg02, Eq_n psegArg04, Eq_n wArg06)
{
	struct Eq_n * psegArg04_n = SLICE(ptrArg02, selector, 16);
	psegArg04_n = SLICE(ptrArg02, selector, 16);
	Eq_n di_n = wArg06;
	Eq_n si_n = wArg06;
	while (true)
	{
		word16 wArg02_n = SLICE(ptrArg02, word16, 0);
		wArg02_n = SLICE(ptrArg02, word16, 0);
		--si_n;
		if (si_n == 0x00 || (word16) ((word32) (si_n *s 0x0C) + ptrArg02) + 0x0A != 0x00)
			break;
		--di_n;
	}
	fn0800-8489(ds, di_n, 0x05);
	Eq_n si_n = 0x00;
	struct Eq_n Eq_n::* wLoc04_n = wArg02_n + 0x0A;
	if (di_n > 0x00)
	{
		do
		{
			fn0800-8489(ds, (psegArg04_n->*wLoc04_n).w0000, 0x04);
			++wLoc04_n;
			si_n = (word32) si_n + 0x01;
		} while (si_n < di_n);
	}
}

// 0800:8407: void fn0800-8407(Register Eq_n ds, Stack Eq_n wArg02, Stack segptr32 ptrArg04)
void fn0800-8407(Eq_n ds, Eq_n wArg02, segptr32 ptrArg04)
{
	Eq_n ax_n;
	if (wArg02 > 0x01)
		ax_n = fn0800-0C08(wArg02);
	else
		ax_n = wArg02;
	struct Eq_n * es_n = SLICE(ptrArg04, selector, 16);
	struct Eq_n Eq_n::* bx_n = (word16) ((word32) (ax_n *s 0x0C) + ptrArg04);
	fn0800-8489(ds, (es_n->*bx_n).t0006, (es_n->*bx_n).t000A);
	byte bLoc04_n = SLICE(ax_n, byte, 0);
	if (ax_n > 0x01)
		fn0800-8489(ds, wArg02 - (0x01 << bLoc04_n - 0x01), ax_n - 0x01);
}

// 0800:8465: void fn0800-8465(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04)
void fn0800-8465(Eq_n ds, Eq_n wArg02, Eq_n wArg04)
{
	if (*((word32) ds + 0x00002A21) != 0x02)
		fn0800-8489(ds, wArg02, wArg04);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg5 = <invalid>;
		fn0800-854B(ds, wArg02, SLICE(wArg04, byte, 0), stackArg5);
	}
}

// 0800:8489: void fn0800-8489(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04)
void fn0800-8489(Eq_n ds, Eq_n wArg02, Eq_n wArg04)
{
	Eq_n di_n = wArg02;
	while (true)
	{
		--wArg04;
		if (wArg04 == 0x00)
			break;
		*((word32) ds + 11843) >>= 0x01;
		if ((di_n & 0x01) != 0x00)
			*((word32) ds + 11843) |= 0x8000;
		*((word32) ds + 11845) = (word32) *((word32) ds + 11845) + 0x01;
		di_n >>= 0x01;
		Eq_n ax_n = *((word32) ds + 11845);
		if (ax_n == 0x10)
		{
			Eq_n ds_n;
			fn0800-8624(ds, SLICE(DPB(ax_n, *((word32) ds + 11843), 0), byte, 0), out di_n, out ds_n);
			word16 ax_n = (word16) fn0800-8624(ds_n, SLICE(*((word32) ds_n + 11843) >> 0x08, byte, 0), out di_n, out ds);
			word16 si_n = 18050;
			while (Mem95[ds:20098:word16] != 0x00)
			{
				ax_n = (word16) fn0800-8624(ds, SLICE(DPB(ax_n, ds->*si_n, 0), byte, 0), out di_n, out ds);
				--*((word32) ds + 20098);
				++si_n;
			}
			Eq_n ax_n = *((word32) ds + 0x00002A01);
			Eq_n dx_n = *((word32) ds + 0x000029FF);
			if (ax_n >= *((word32) ds + 10757) && (ax_n > *((word32) ds + 10757) || dx_n > *((word32) ds + 10755)))
			{
				ui32 ax_dx_n = SEQ(*((word32) ds + 0x00002A01), *((word32) ds + 0x000029FF)) - SEQ(*((word32) ds + 10757), *((word32) ds + 10755));
				Eq_n dx_n = (word16) ax_dx_n;
				uint16 ax_n = SLICE(ax_dx_n, word16, 16);
				if (ax_n >= *((word32) ds + 20106) && (ax_n > *((word32) ds + 20106) || dx_n > *((word32) ds + 0x00004E88)))
				{
					ui32 ax_dx_n = SEQ(*((word32) ds + 0x00002A01), *((word32) ds + 0x000029FF)) - SEQ(*((word32) ds + 10757), *((word32) ds + 10755));
					*((word32) ds + 20106) = SLICE(ax_dx_n, word16, 16);
					*((word32) ds + 0x00004E88) = (word16) ax_dx_n;
				}
			}
			((word32) ds + 11845)->u0 = 0x00;
			((word32) ds + 11843)->u0 = 0x00;
		}
	}
}

// 0800:854B: void fn0800-854B(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n bArg05)
void fn0800-854B(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n bArg05)
{
	byte bArg05_n = SLICE(wArg04, byte, 8);
	uint16 di_n = 0x01 << bArg04 - 0x01;
	Eq_n bArg05_n = SEQ(bArg05_n, bArg04);
	while (true)
	{
		bArg05_n.u0 = SLICE(bArg05_n - 0x01, byte, 8);
		if (bArg05_n == 0x00)
			break;
		*((word32) ds + 11843) <<= 0x01;
		if ((wArg02 & di_n) != 0x00)
			*((word32) ds + 11843) = (word32) *((word32) ds + 11843) + 0x01;
		*((word32) ds + 11845) = (word32) *((word32) ds + 11845) + 0x01;
		di_n >>= 0x01;
		Eq_n ax_n = *((word32) ds + 11845);
		if (ax_n == 0x08)
		{
			word16 ax_n = (word16) fn0800-8624(ds, SLICE(DPB(ax_n, *((word32) ds + 11843), 0), byte, 0), out di_n, out ds);
			word16 si_n = 18050;
			while (true)
			{
				bArg05_n.u0 = SLICE(bArg05_n, byte, 8);
				bArg05_n.u0 = SLICE(bArg05_n, byte, 8);
				if (Mem79[ds:20098:word16] == 0x00)
					break;
				ax_n = (word16) fn0800-8624(ds, SLICE(DPB(ax_n, ds->*si_n, 0), byte, 0), out di_n, out ds);
				--*((word32) ds + 20098);
				++si_n;
			}
			Eq_n ax_n = *((word32) ds + 0x00002A01);
			Eq_n dx_n = *((word32) ds + 0x000029FF);
			if (ax_n >= *((word32) ds + 10757) && (ax_n > *((word32) ds + 10757) || dx_n > *((word32) ds + 10755)))
			{
				ui32 ax_dx_n = SEQ(*((word32) ds + 0x00002A01), *((word32) ds + 0x000029FF)) - SEQ(*((word32) ds + 10757), *((word32) ds + 10755));
				Eq_n dx_n = (word16) ax_dx_n;
				uint16 ax_n = SLICE(ax_dx_n, word16, 16);
				if (ax_n >= *((word32) ds + 20106) && (ax_n > *((word32) ds + 20106) || dx_n > *((word32) ds + 0x00004E88)))
				{
					ui32 ax_dx_n = SEQ(*((word32) ds + 0x00002A01), *((word32) ds + 0x000029FF)) - SEQ(*((word32) ds + 10757), *((word32) ds + 10755));
					*((word32) ds + 20106) = SLICE(ax_dx_n, word16, 16);
					*((word32) ds + 0x00004E88) = (word16) ax_dx_n;
				}
			}
			((word32) ds + 11845)->u0 = 0x00;
			((word32) ds + 11843)->u0 = 0x00;
		}
	}
}

// 0800:8600: Register word16 fn0800-8600(Register Eq_n ds, Stack ui8 bArg02, Register out Eq_n dsOut)
word16 fn0800-8600(Eq_n ds, ui8 bArg02, union Eq_n & dsOut)
{
	word16 dx_n = DPB(dx, bArg02, 0);
	if (*((word32) ds + 11845) == 0x00)
	{
		word16 di_n;
		Eq_n ds_n;
		fn0800-8624(ds, SLICE(dx_n, byte, 0), out di_n, out ds_n);
		dsOut = ds_n;
		return di_n;
	}
	else
	{
		(ds->**((word32) ds + 20098)).b4682 = bArg02;
		*((word32) ds + 20098) = (struct Eq_n Eq_n::*) ((char *) *((word32) ds + 20098) + 0x01);
		dsOut = ds;
		return di;
	}
}

// 0800:8624: Register byte fn0800-8624(Register Eq_n ds, Stack Eq_n bArg02, Register out Eq_n diOut, Register out Eq_n dsOut)
byte fn0800-8624(Eq_n ds, Eq_n bArg02, union Eq_n & diOut, union Eq_n & dsOut)
{
	Eq_n ax_n = *((word32) ds + 10757);
	Eq_n dx_n = *((word32) ds + 10755);
	if (ax_n <= *((word32) ds + 20102) && (ax_n < *((word32) ds + 20102) || dx_n < *((word32) ds + 20100)))
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg6 = <invalid>;
		ax_n = SEQ(ds, 0x2A29)[(DPB(DPB(fn0800-4047(ds, SLICE(DPB(ax_n, bArg02, 0), byte, 0), SEQ(Mem7[ds:10721:word16], Mem23[ds:10719:word16]), stackArg6, out cx_n, out dx_n, out bx_n, out di, out ds, out Top_n), Mem32[ds:11849:byte] ^ bArg02, 0), 0x00, 8) & 0xFF) * 0x02] ^ Mem32[ds:11849:word16] >>u 0x08;
		*((word32) ds + 11849) = ax_n;
		Eq_n v18_n = (word32) *((word32) ds + 10755) + 0x01;
		*((word32) ds + 10755) = v18_n;
		Mem65[ds:0x2A05:word16] = Mem61[ds:0x2A05:word16] + (v18_n <u 0x00);
	}
	diOut = di;
	dsOut = ds;
	return (byte) ax_n;
}

// 0800:867A: Register word16 fn0800-867A(Stack Eq_n wArg04, Stack Eq_n psegArg06, Stack Eq_n wArg08, Stack Eq_n psegArg0A, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-867A(Eq_n wArg04, Eq_n psegArg06, Eq_n wArg08, Eq_n psegArg0A, struct Eq_n & dsOut)
{
	struct Eq_n Eq_n::* si_n = fn0800-87EF((word32) wArg04 + 0x04, psegArg06);
	ui8 al_n = (psegArg06->*si_n).b000A * 0x02 + true;
	Eq_n ds_n = psegArg06;
	Eq_n di_n = wArg08;
	Eq_n es_n = psegArg0A;
	Eq_n si_n = &(ss->*si_n).b000A + 0x01;
	uint8 al_n = al_n * 0x02;
	word16 ax_n = DPB(ax_n, al_n * 0x02, 0);
l0800_n:
	uint16 bx_n;
	uint8 al_n = al_n * 0x02;
	word16 ax_n = DPB(ax_n, al_n, 0);
	bool Z_n = SLICE(cond(al_n), bool, 2);
	al_n = al_n;
	if (al_n >= 0x00)
	{
		es_n->*di_n = ds_n->*si_n;
		si_n = (word32) si_n + 0x01;
		di_n = (word32) di_n + 0x01;
		al_n = al_n * 0x02;
		ax_n = DPB(ax_n, al_n * 0x02, 0);
		Z_n = SLICE(cond(al_n * 0x02), bool, 2);
		if (al_n * 0x02 >= 0x00)
			goto l0800_n;
	}
	word16 ax_n = DPB(ax_n, al_n, 0);
	if (!Z_n)
	{
l0800_n:
		uint8 al_n = al_n * 0x02;
		word16 cx_n = 0x02;
		ui8 bh_n = 0x00;
		word16 bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		bx_n = DPB(bx_n, 0x00, 8);
		word16 bx_n = DPB(bx_n, 0x00, 8);
		word16 ax_n = DPB(ax_n, al_n, 0);
		bool C_n = SLICE(cond(al_n), bool, 1);
		if (al_n == 0x00)
		{
			al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
			si_n = (word32) si_n + 0x01;
			ax_n = DPB(ax_n, al_n, 0);
			C_n = SLICE(cond(al_n), bool, 1);
		}
		word16 ax_n;
		word16 ax_n;
		if (!C_n)
		{
			al_n = al_n * 0x02;
			word16 ax_n = DPB(ax_n, al_n, 0);
			bool C_n = SLICE(cond(al_n), bool, 1);
			if (al_n == 0x00)
			{
				al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
				si_n = (word32) si_n + 0x01;
				ax_n = DPB(ax_n, al_n, 0);
				C_n = SLICE(cond(al_n), bool, 1);
			}
			ax_n = DPB(ax_n, al_n, 0);
			if (C_n)
			{
l0800_n:
				bx_n = DPB(bx_n, ds_n->*si_n, 0);
				__cli();
				word16 ax_n = DPB(ax_n, al_n, 0);
				ax_n = DPB(ax_n, al_n, 0);
				ax_n = DPB(ax_n, al_n, 0);
				Eq_n si_n = (word32) si_n + 0x01;
				byte Eq_n::* si_n = di_n - 0x01 - bx_n;
				for (; cx_n != 0x00; --cx_n)
				{
					es_n->*di_n = ds_n->*si_n;
					++si_n;
					di_n = (word32) di_n + 0x01;
					ax_n = ax_n;
				}
				__sti();
				si_n = si_n;
				goto l0800_n;
			}
			uint8 al_n = al_n * 0x02;
			cx_n = 0x03;
			ax_n = DPB(ax_n, al_n, 0);
			bool C_n = SLICE(cond(al_n), bool, 1);
			if (al_n == 0x00)
			{
				ui8 al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
				si_n = (word32) si_n + 0x01;
				ax_n = DPB(ax_n, al_n, 0);
				C_n = SLICE(cond(al_n), bool, 1);
			}
			al_n = (byte) ax_n;
			al_n = (byte) ax_n;
			ax_n = DPB(ax_n, al_n, 0);
			bx_n = bx_n;
			if (!C_n)
			{
				byte cl_n = ds_n->*si_n;
				si_n = (word32) si_n + 0x01;
				word16 cx_n = DPB(0x03, cl_n, 0);
				if (cl_n != 0x00)
				{
					cx_n = cx_n + 0x08;
					goto l0800_n;
				}
				word16 ax_n = ds_n + (si_n >>u 0x04);
				bui8 al_n = (byte) ax_n;
				di_n = (di_n & 0x0F) + 0x8000;
				es_n = es_n + (di_n >>u 0x04) - 0x0800;
				si_n &= 0x0F;
				bx_n = si_n >> 0x04;
				ds_n = ax_n;
				al_n = al_n * 0x02;
				word16 ax_n = DPB(ax_n, al_n * 0x02, 0);
				bool C_n = SLICE(cond(al_n * 0x02), bool, 1);
				if (al_n * 0x02 == 0x00)
				{
					al_n = ax_n->*(si_n & 0x0F) * 0x02 + (al_n * 0x02 < 0x00);
					si_n = (si_n & 0x0F) + 0x01;
					ax_n = DPB(ax_n, al_n, 0);
					C_n = SLICE(cond(al_n), bool, 1);
				}
				ax_n = DPB(ax_n, al_n, 0);
				if (C_n)
				{
					dsOut = psegLoc0A;
					return si;
				}
				Mem46 = Mem262;
				goto l0800_n;
			}
l0800_n:
			al_n *= 0x02;
			word16 ax_n = DPB(ax_n, al_n, 0);
			bool C_n = SLICE(cond(al_n), bool, 1);
			if (al_n == 0x00)
			{
				al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
				si_n = (word32) si_n + 0x01;
				ax_n = DPB(ax_n, al_n, 0);
				C_n = SLICE(cond(al_n), bool, 1);
			}
			ax_n = DPB(ax_n, al_n, 0);
			if (!C_n)
			{
				uint8 al_n = al_n * 0x02;
				word16 ax_n = DPB(ax_n, al_n, 0);
				bool C_n = SLICE(cond(al_n), bool, 1);
				if (al_n == 0x00)
				{
					al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
					si_n = (word32) si_n + 0x01;
					ax_n = DPB(ax_n, al_n, 0);
					C_n = SLICE(cond(al_n), bool, 1);
				}
				al_n = al_n * 0x02;
				word16 bx_n = DPB(bx_n, C_n, 8);
				bx_n = DPB(bx_n, C_n, 8);
				word16 bx_n = DPB(bx_n, C_n, 8);
				bx_n = DPB(bx_n, C_n, 8);
				word16 ax_n = DPB(ax_n, al_n, 0);
				bool C_n = SLICE(cond(al_n), bool, 1);
				if (al_n == 0x00)
				{
					al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
					si_n = (word32) si_n + 0x01;
					ax_n = DPB(ax_n, al_n, 0);
					C_n = SLICE(cond(al_n), bool, 1);
				}
				word16 bx_n;
				Eq_n bh_n;
				ax_n = DPB(ax_n, al_n, 0);
				word16 ax_n = DPB(ax_n, al_n, 0);
				if (!C_n)
				{
					bx_n = DPB(bx_n, C_n, 8);
					if (C_n != false)
						goto l0800_n;
					bh_n = C_n + 0x01;
					bx_n = DPB(bx_n, bh_n, 8);
l0800_n:
					uint8 al_n = al_n * 0x02;
					word16 bx_n = DPB(bx_n, bh_n, 8);
					bx_n = DPB(bx_n, bh_n, 8);
					word16 ax_n = DPB(ax_n, al_n, 0);
					al_n = al_n;
					if (al_n == 0x00)
					{
						al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
						si_n = (word32) si_n + 0x01;
						ax_n = DPB(ax_n, al_n, 0);
					}
					ax_n = DPB(ax_n, al_n, 0);
					bx_n = DPB(bx_n, bh_n * 0x02 + (al_n < 0x00), 8);
					goto l0800_n;
				}
				uint8 al_n;
				uint8 al_n = al_n * 0x02;
				word16 ax_n = DPB(ax_n, al_n, 0);
				if (al_n != 0x00)
					al_n = al_n;
				else
				{
					al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
					si_n = (word32) si_n + 0x01;
					ax_n = DPB(ax_n, al_n, 0);
				}
				ui8 bh_n = C_n * 0x02 + (al_n < 0x00);
				al_n = al_n * 0x02;
				bh_n = bh_n | 0x04;
				word16 bx_n = DPB(bx_n, bh_n | 0x04, 8);
				bx_n = DPB(bx_n, bh_n | 0x04, 8);
				bx_n = DPB(bx_n, bh_n | 0x04, 8);
				bx_n = DPB(bx_n, bh_n | 0x04, 8);
				word16 ax_n = DPB(ax_n, al_n, 0);
				bool C_n = SLICE(cond(al_n), bool, 1);
				if (al_n == 0x00)
				{
					al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
					si_n = (word32) si_n + 0x01;
					ax_n = DPB(ax_n, al_n, 0);
					C_n = SLICE(cond(al_n), bool, 1);
				}
				ax_n = DPB(ax_n, al_n, 0);
				ax_n = DPB(ax_n, al_n, 0);
				if (!C_n)
					goto l0800_n;
			}
			goto l0800_n;
		}
		uint8 al_n = al_n * 0x02;
		word16 ax_n = DPB(ax_n, al_n, 0);
		bool C_n = SLICE(cond(al_n), bool, 1);
		if (al_n == 0x00)
		{
			al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
			si_n = (word32) si_n + 0x01;
			ax_n = DPB(ax_n, al_n, 0);
			C_n = SLICE(cond(al_n), bool, 1);
		}
		al_n = al_n * 0x02;
		cx_n = DPB(0x02, C_n + 0x04, 0);
		word16 ax_n = DPB(ax_n, al_n, 0);
		bool C_n = SLICE(cond(al_n), bool, 1);
		if (al_n == 0x00)
		{
			al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
			si_n = (word32) si_n + 0x01;
			ax_n = DPB(ax_n, al_n, 0);
			C_n = SLICE(cond(al_n), bool, 1);
		}
		ax_n = DPB(ax_n, al_n, 0);
		bx_n = bx_n;
		if (C_n)
			goto l0800_n;
		uint8 al_n = al_n * 0x02;
		word16 ax_n = DPB(ax_n, al_n, 0);
		al_n = al_n;
		if (al_n == 0x00)
		{
			al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
			si_n = (word32) si_n + 0x01;
			ax_n = DPB(ax_n, al_n, 0);
		}
		ui8 cl_n = (byte) (cx_n - 0x01) * 0x02 + (al_n < 0x00);
		ax_n = DPB(ax_n, al_n, 0);
		word16 ax_n = DPB(ax_n, al_n, 0);
		cx_n = DPB(cx_n - 0x01, cl_n, 0);
		bx_n = bx_n;
		if (cl_n != 0x09)
			goto l0800_n;
		word16 cx_n;
		do
		{
			uint8 al_n = al_n * 0x02;
			bx_n = DPB(bx_n, bh_n, 8);
			bx_n = DPB(bx_n, bh_n, 8);
			ax_n = DPB(ax_n, al_n, 0);
			al_n = al_n;
			if (al_n == 0x00)
			{
				al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
				si_n = (word32) si_n + 0x01;
				ax_n = DPB(ax_n, al_n, 0);
			}
			bh_n = bh_n * 0x02 + (al_n < 0x00);
			word16 ax_n = DPB(ax_n, al_n, 0);
			ax_n = DPB(ax_n, al_n, 0);
			ax_n = DPB(ax_n, al_n, 0);
			bx_n = DPB(bx_n, bh_n, 8);
			--cx_n;
		} while (cx_n != 0x00);
		word16 cx_n;
		for (cx_n = DPB(cx_n, (bh_n + 0x03) * 0x02, 0); cx_n != 0x00; --cx_n)
		{
			es_n->*di_n = ds_n->*si_n;
			si_n = (word32) si_n + 0x02;
			di_n = (word32) di_n + 0x02;
			ax_n = ax_n;
		}
		goto l0800_n;
	}
	al_n = ds_n->*si_n * 0x02 + (al_n < 0x00);
	si_n = (word32) si_n + 0x01;
	ax_n = DPB(ax_n, al_n, 0);
	ax_n = DPB(ax_n, al_n, 0);
	if (al_n < 0x00)
		goto l0800_n;
l0800_n:
	es_n->*di_n = ds_n->*si_n;
	ax_n = DPB(ax_n, al_n, 0);
	si_n = (word32) si_n + 0x01;
	di_n = (word32) di_n + 0x01;
	goto l0800_n;
}

// 0800:87EF: Register word16 fn0800-87EF(Register word16 si, Register Eq_n ds)
word16 fn0800-87EF(word16 si, Eq_n ds)
{
	word16 si_n = fn0800-87F4(si, ds);
	return fn0800-87F4(si_n, ds);
}

// 0800:87F4: Register word16 fn0800-87F4(Register word16 si, Register Eq_n ds)
word16 fn0800-87F4(word16 si, Eq_n ds)
{
	return si + 0x02;
}

// 0800:87F8: void fn0800-87F8(Register Eq_n ds)
void fn0800-87F8(Eq_n ds)
{
	Eq_n es_di_n = *((word32) ds + 11831);
	struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
	word16 Eq_n::* di_n = (word16) es_di_n;
	uint16 ax_n = *((word32) ds + 11825);
	word16 cx_n;
	for (cx_n = 0x8000; cx_n != 0x00; --cx_n)
	{
		es_n->*di_n = ax_n;
		++di_n;
	}
	Eq_n es_di_n = *((word32) ds + 0x00002E33);
	struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
	word16 Eq_n::* di_n = (word16) es_di_n;
	uint16 ax_n = *((word32) ds + 11825);
	word16 cx_n;
	for (cx_n = 0x8000; cx_n != 0x00; --cx_n)
	{
		es_n->*di_n = ax_n;
		++di_n;
	}
	Eq_n es_di_n = *((word32) ds + 11835);
	struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
	word16 Eq_n::* di_n = (word16) es_di_n;
	uint16 cx_n;
	for (cx_n = *((word32) ds + 11825); cx_n != 0x00; --cx_n)
	{
		es_n->*di_n = 0x00;
		++di_n;
	}
	Eq_n es_di_n = *((word32) ds + 11839);
	struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
	word16 Eq_n::* di_n = (word16) es_di_n;
	word16 ax_n = 0x00;
	uint16 cx_n;
	do
	{
		es_n->*di_n = ax_n;
		++di_n;
		++ax_n;
		--cx_n;
	} while (cx_n != 0x00);
	*((word32) ds + 11821) = cx_n;
}

// 0800:8832: void fn0800-8832(Register Eq_n ds)
void fn0800-8832(Eq_n ds)
{
	fn0800-889A(ds);
	if (*((word32) ds + 11817) >= 0x02 && *((word32) ds + 11877) - *((word32) ds + 11885) >= 0x03)
	{
		uint16 ax_n = *((word32) ds + 11821);
		Eq_n si_n = *((word32) ds + 11817);
		Eq_n di_n = *((word32) ds + 11819);
		uint16 ax_n = ax_n + 0x01;
		if (ax_n + 0x01 == *((word32) ds + 11825))
			ax_n = 0x00;
		*((word32) ds + 11821) = ax_n;
		*((word32) ds + 11885) = (word32) *((word32) ds + 11885) + 0x01;
		fn0800-889A(ds);
		--*((word32) ds + 11885);
		*((word32) ds + 11821) = ax_n;
		if (*((word32) ds + 11817) > si_n)
		{
			((word32) ds + 11817)->u0 = 0x01;
			((word32) ds + 11819)->u0 = 0x00;
		}
		else
		{
			*((word32) ds + 11817) = si_n;
			*((word32) ds + 11819) = di_n;
		}
	}
}

// 0800:889A: void fn0800-889A(Register Eq_n ds)
void fn0800-889A(Eq_n ds)
{
	((word32) ds + 11819)->u0 = 0x00;
	((word32) ds + 11817)->u0 = 0x01;
	Eq_n es_di_n = *((word32) ds + 11885);
	Eq_n ax_n = *es_di_n;
	*((word32) ds + 20112) = ax_n;
	word16 di_n = (word16) es_di_n;
	word16 dx_n = *((word32) ds + 11881) - (di_n + 0x01);
	struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
	byte al_n = (byte) ax_n;
	byte Eq_n::* di_n = di_n + 0x01;
	bool Z_n = SLICE(cond(dx_n), bool, 2);
	word16 cx_n = dx_n;
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(al_n - es_n->*di_n), bool, 2);
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (al_n == es_n->*di_n)
			break;
	}
	if (!Z_n)
		--cx_n;
	*((word32) ds + 0x00004E94) = *((word32) ds + 11881) - (word16) (*((word32) ds + 11885));
	Eq_n dx_n = dx_n - cx_n;
	uint16 ax_n = (&(ss->*(ss->**((word32) ds + 11833)).a0000))[*((word32) ds + 20112) * 0x02];
	while (ax_n != *((word32) ds + 11825))
	{
		Eq_n di_n = ax_n << 0x01;
		*((word32) ds + 20114) = *((word32) ds + 11841)->*di_n;
		uint16 bx_n = *((word32) ds + 11821);
		if (bx_n <= ax_n)
			bx_n += *((word32) ds + 11825);
		Eq_n es_si_n = *((word32) ds + 11885);
		Eq_n bx_n = bx_n - ax_n;
		if (*((word32) ds + 20112) == SLICE(es_si_n, selector, 16)->*((word16) es_si_n - bx_n))
		{
			Eq_n cx_n = *((word32) ds + 11837)->*di_n;
			if (cx_n > bx_n)
			{
				bx_n.u0 = 0x01;
				cx_n = dx_n;
			}
			else
			{
				if (cx_n > dx_n)
				{
					bx_n -= cx_n - dx_n;
					cx_n = dx_n;
				}
				if (cx_n == dx_n)
				{
					Eq_n es_di_n = *((word32) ds + 11885);
					byte Eq_n::* di_n = (word32) cx_n + (word16) es_di_n;
					word16 ax_n = *((word32) ds + 0x00004E94) - cx_n;
					struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
					byte Eq_n::* si_n = di_n - bx_n;
					bool Z_n = SLICE(cond(ax_n), bool, 2);
					word16 cx_n = ax_n;
					Eq_n ds_n = *((word32) ds + 11887);
					while (cx_n != 0x00)
					{
						Z_n = SLICE(cond(ds_n->*si_n - es_n->*di_n), bool, 2);
						si_n = si_n + 0x01;
						di_n = di_n + 0x01;
						--cx_n;
						si_n = si_n;
						di_n = di_n;
						if (ds_n->*si_n == es_n->*di_n)
							break;
					}
					if (!Z_n)
						++cx_n;
					cx_n = (word32) dx_n + (ax_n - cx_n);
					Mem167 = Mem123;
				}
			}
			if (cx_n > *((word32) ds + 0x00002E2F))
				cx_n = *((word32) ds + 0x00002E2F);
			if (cx_n >= *((word32) ds + 11817))
			{
				*((word32) ds + 11817) = cx_n;
				*((word32) ds + 11819) = bx_n;
			}
		}
		ax_n = *((word32) ds + 20114);
	}
	if (*((word32) ds + 11817) == 0x02 && *((word32) ds + 11819) > 0x0100)
	{
		((word32) ds + 11817)->u0 = 0x01;
		((word32) ds + 11819)->u0 = 0x00;
	}
}

// 0800:89A8: void fn0800-89A8(Register Eq_n ds, Stack Eq_n wArg02)
void fn0800-89A8(Eq_n ds, Eq_n wArg02)
{
	uint16 dx_n = *((word32) ds + 11825);
l0800_nB1:
	uint16 di_n = *((word32) ds + 11821);
	struct Eq_n * es_n = *((word32) ds + 11841);
	uint16 ax_n = (&(ss->*(ss->*es_n).a0000))[di_n * 0x02];
	(&(ss->*(ss->*es_n).a0000))[di_n * 0x02] = dx_n;
	if (*((word32) ds + 11821) != ax_n)
	{
		Eq_n es_di_n = *((word32) ds + 11885);
		ui16 di_n = SLICE(es_di_n, selector, 16)->*((word16) es_di_n - dx_n);
		(&(ss->*(ss->**((word32) ds + 11833)).a0000))[di_n * 0x02] = ax_n;
		if (ax_n == dx_n)
			(&(ss->*(ss->**((word32) ds + 11829)).a0000))[di_n * 0x02] = dx_n;
	}
	Eq_n di_n = **((word32) ds + 11885);
	uint16 ax_n = *((word32) ds + 11821);
	struct Eq_n * es_n = *((word32) ds + 11833);
	if ((&(ss->*(ss->*es_n).a0000))[di_n * 0x02] == dx_n)
		(&(ss->*(ss->*es_n).a0000))[di_n * 0x02] = ax_n;
	else
		(&(ss->*(ss->**((word32) ds + 11841)).a0000))[(&(ss->*(ss->**((word32) ds + 11829)).a0000))[di_n * 0x02] * 0x02] = ax_n;
	(&(ss->*(ss->**((word32) ds + 11829)).a0000))[di_n * 0x02] = ax_n;
	Eq_n es_di_n = *((word32) ds + 11885);
	word16 di_n = (word16) es_di_n;
	word16 bx_n = *((word32) ds + 11881) - (di_n + 0x01);
	struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
	Eq_n al_n = *es_di_n;
	union Eq_n Eq_n::* di_n = di_n + 0x01;
	bool Z_n = SLICE(cond(bx_n), bool, 2);
	word16 cx_n = bx_n;
	while (cx_n != 0x00)
	{
		Z_n = SLICE(cond(al_n - es_n->*di_n), bool, 2);
		di_n = (union Eq_n Eq_n::*) ((char *) di_n + 0x01);
		--cx_n;
		di_n = di_n;
		if (al_n == es_n->*di_n)
			break;
	}
	if (!Z_n)
		--cx_n;
	cup16 bx_n = bx_n - cx_n;
	(&(ss->*(ss->**((word32) ds + 11837)).a0000))[*((word32) ds + 11821) * 0x02] = bx_n;
	while (true)
	{
		uint16 ax_n = *((word32) ds + 11821);
		uint16 ax_n = ax_n + 0x01;
		if (ax_n + 0x01 == dx_n)
			ax_n = 0x00;
		*((word32) ds + 11821) = ax_n;
		*((word32) ds + 11885) = (word32) *((word32) ds + 11885) + 0x01;
		Eq_n v20_n = wArg02 - 0x01;
		wArg02 = v20_n;
		if (v20_n == 0x00)
			break;
		--bx_n;
		if (bx_n <= 0x01)
		{
			Mem16 = Mem121;
			goto l0800_nB1;
		}
		uint16 di_n = *((word32) ds + 11821);
		(&(ss->*(ss->**((word32) ds + 11837)).a0000))[di_n * 0x02] = bx_n;
		struct Eq_n * es_n = *((word32) ds + 11841);
		uint16 v22_n = (&(ss->*(ss->*es_n).a0000))[di_n * 0x02];
		(&(ss->*(ss->*es_n).a0000))[di_n * 0x02] = *((word32) ds + 11821);
		if (*((word32) ds + 11821) != v22_n)
		{
			Eq_n es_di_n = *((word32) ds + 11885);
			ui16 di_n = SLICE(es_di_n, selector, 16)->*((word16) es_di_n - dx_n);
			(&(ss->*(ss->**((word32) ds + 11833)).a0000))[di_n * 0x02] = v22_n;
			if (v22_n == dx_n)
				(&(ss->*(ss->**((word32) ds + 11829)).a0000))[di_n * 0x02] = dx_n;
		}
	}
}

// 0800:8ACF: void fn0800-8ACF(Register word16 cx, Register Eq_n ds, Stack segptr32 ptrArg02, Stack (ptr32 word16) ptrArg06)
void fn0800-8ACF(word16 cx, Eq_n ds, segptr32 ptrArg02, word16 * ptrArg06)
{
	msdos_unknown_n();
	Eq_n ax_n = DPB(DPB(ax, 0x43, 8), 0x00, 0);
	if (Test(UGE,false))
		*ptrArg06 = cx;
	else
		fn0800-8D64(ds, ax_n);
}

// 0800:8B0D: Register word16 fn0800-8B0D(Register word16 ax, Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register mp16 bp, Register word16 si, Register Eq_n ds, Stack Eq_n wArg02, Stack word16 wArg04, Stack word16 wArg06, Register out Eq_n cxOut, Register out ptr16 dxOut, Register out Eq_n bxOut, Register out Eq_n siOut, Register out (ptr16 Eq_n) esOut, Register out Eq_n TopOut)
word16 fn0800-8B0D(word16 ax, Eq_n cx, Eq_n dx, Eq_n bx, mp16 bp, word16 si, Eq_n ds, Eq_n wArg02, word16 wArg04, word16 wArg06, union Eq_n & cxOut, ptr16 & dxOut, union Eq_n & bxOut, union Eq_n & siOut, struct Eq_n & esOut, union Eq_n & TopOut)
{
	Eq_n Top_n = 0x00;
	union Eq_n Eq_n::* sp_n = fp - 0x04;
	if (wArg06 == 0x00)
	{
		while (*((word32) ds + 0x0000224E) != 0x00)
		{
			--*((word32) ds + 0x0000224E);
			ui16 bx_n = *((word32) ds + 0x0000224E);
			SEQ(0x0800, SEQ(ds, 20118)[bx_n * 0x02])();
		}
		word16 bx_n;
		word16 dx_n;
		byte ah_n;
		(seg0800->**((word32) ds + 0x00002352))();
		word16 ax_n = DPB(ax, ah_n, 8);
	}
	ptr16 dx_n;
	word16 ax_n = fn0800-01B9(ds, out dx_n);
	fn0800-0163();
	if (wArg04 != 0x00)
	{
		Eq_n si_n = ss->*sp_n;
		cxOut = cx;
		dxOut = dx_n;
		bxOut = bx;
		siOut = si_n;
		esOut = es;
		TopOut = Top_n;
		return ax_n;
	}
	else
	{
		if (wArg06 == 0x00)
		{
			word16 sp_n;
			word16 cx_n;
			word16 bx_n;
			int8 Top_n;
			word16 ax_n;
			word16 dx_n;
			(seg0800->**((word32) ds + 9044))();
			(seg0800->**((word32) ds + 0x00002356))();
		}
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = wArg02;
		fn0800-0164(ss->*sp_n);
	}
}

// 0800:8B5A: Register word16 fn0800-8B5A(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register word16 si, Register Eq_n ds, Stack Eq_n wArg02, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut, Register out ptr16 siOut, Register out (ptr16 Eq_n) esOut, Register out Eq_n TopOut)
word16 fn0800-8B5A(Eq_n cx, Eq_n dx, Eq_n bx, word16 si, Eq_n ds, Eq_n wArg02, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut, ptr16 & siOut, struct Eq_n & esOut, union Eq_n & TopOut)
{
	ptr16 dx_n;
	Eq_n Top_n;
	ptr16 bx_n;
	ptr16 cx_n;
	struct Eq_n * es_n;
	ptr16 si_n;
	word16 ax_n = fn0800-8B0D(0x00, cx, dx, bx, fp - 0x02, si, ds, wArg02, 0x00, 0x00, out cx_n, out dx_n, out bx_n, out si_n, out es_n, out Top_n);
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	siOut = si_n;
	esOut = es_n;
	TopOut = Top_n;
	return ax_n;
}

// 0800:8B69: void fn0800-8B69(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register word16 si, Register Eq_n ds, Stack Eq_n wArg02)
void fn0800-8B69(Eq_n cx, Eq_n dx, Eq_n bx, word16 si, Eq_n ds, Eq_n wArg02)
{
	fn0800-8B0D(0x00, cx, dx, bx, fp - 0x02, si, ds, wArg02, 0x00, 0x01, out cx_n, out dx_n, out bx_n, out si_n, out es_n, out Top_n);
}

// 0800:8B95: void fn0800-8B95(Stack (ptr32 Eq_n) ptrArg02)
void fn0800-8B95(struct Eq_n * ptrArg02)
{
	byte dh_n;
	word16 cx_n;
	word16 dx_n = DPB(DPB(dx, dh_n, 8), msdos_get_system_date(out dh_n, out cx_n), 0);
	ptrArg02->w0000 = cx_n;
	ptrArg02->w0002 = dx_n;
}

// 0800:8BA8: void fn0800-8BA8(Stack (ptr32 Eq_n) ptrArg02)
void fn0800-8BA8(struct Eq_n * ptrArg02)
{
	byte ch_n;
	byte dh_n;
	byte dl_n;
	ptrArg02->w0000 = DPB(DPB(cx, ch_n, 8), msdos_get_system_time(out ch_n, out dh_n, out dl_n), 0);
	ptrArg02->w0002 = DPB(DPB(dx, dh_n, 8), dl_n, 0);
}

// 0800:8BBB: Register word16 fn0800-8BBB(Stack Eq_n wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut)
word16 fn0800-8BBB(Eq_n wArg00, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut)
{
	ptr16 bx_n;
	ptr16 cx_n;
	ptr16 dx_n;
	word16 ax_n = fn0800-8BD8(0x00, wArg02, wArg04, wArg06, wArg08, out cx_n, out dx_n, out bx_n);
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	return ax_n;
}

// 0800:8BC2: Register word16 fn0800-8BC2(Stack Eq_n wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut)
word16 fn0800-8BC2(Eq_n wArg00, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut)
{
	ptr16 bx_n;
	ptr16 cx_n;
	ptr16 dx_n;
	word16 ax_n = fn0800-8BD8(0x01, wArg02, wArg04, wArg06, wArg08, out cx_n, out dx_n, out bx_n);
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	return ax_n;
}

// 0800:8BCA: Register word16 fn0800-8BCA(Stack Eq_n wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 dxOut)
word16 fn0800-8BCA(Eq_n wArg00, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & dxOut)
{
	ptr16 dx_n;
	word16 ax_n = fn0800-8BD8(0x02, wArg02, wArg04, wArg06, wArg08, out cx_n, out dx_n, out bx_n);
	dxOut = dx_n;
	return ax_n;
}

// 0800:8BD8: Register Eq_n fn0800-8BD8(Register Eq_n cx, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A, Register out Eq_n cxOut, Register out Eq_n dxOut, Register out Eq_n bxOut)
Eq_n fn0800-8BD8(Eq_n cx, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A, union Eq_n & cxOut, union Eq_n & dxOut, union Eq_n & bxOut)
{
	Eq_n dx_n;
	Eq_n bx_n;
	Eq_n di_n = cx;
	Eq_n ax_n = wArg04;
	Eq_n cx_n = wArg0A;
	if (wArg0A == 0x00 && (wArg06 == 0x00 || wArg08 == 0x00))
	{
		uint32 dx_ax_n = SEQ(wArg06, wArg04);
		bx_n = wArg08;
		Eq_n dx_n = (uint16) (dx_ax_n % wArg08);
		ax_n = (uint16) (dx_ax_n /u wArg08);
		if ((cx & 0x02) != 0x00)
			ax_n = dx_n;
		dx_n.u0 = 0x00;
	}
	else
	{
		Eq_n bx_n = wArg08;
		dx_n = wArg06;
		if ((cx & 0x01) == 0x00)
		{
			dx_n = wArg06;
			if (wArg06 < 0x00)
			{
				ax_n = -wArg04;
				dx_n = -wArg06 - (ax_n == 0x00);
				di_n = cx | 0x0C;
			}
			cx_n = wArg0A;
			if (wArg0A < 0x00)
			{
				bx_n = -wArg08;
				cx_n = -wArg0A - (bx_n == 0x00);
				di_n = di_n ^ 0x04;
			}
		}
		cx_n.u0 = 0x20;
		Eq_n di_n = 0x00;
		Eq_n si_n = 0x00;
		do
		{
			ax_n <<= 0x01;
			dx_n = __rcl(dx_n, 0x01, SLICE(cond(ax_n), bool, 1));
			si_n = __rcl(si_n, 0x01, (dx_n & 0x8000) != 0x00);
			di_n = __rcl(di_n, 0x01, (si_n & 0x8000) != 0x00);
			if (di_n >= cx_n && (di_n > cx_n || si_n >= bx_n))
			{
				ui32 di_si_n = SEQ(di_n, si_n) - SEQ(cx_n, bx_n);
				si_n = (word16) di_si_n;
				di_n = SLICE(di_si_n, word16, 16);
				ax_n = (word32) ax_n + 0x01;
			}
			--cx_n;
		} while (cx_n != 0x00);
		bx_n = di_n;
		if ((di_n & 0x02) != 0x00)
		{
			ax_n = si_n;
			dx_n = di_n;
			bx_n = di_n >> 0x01;
		}
		if ((bx_n & 0x04) != 0x00)
		{
			ax_n = -ax_n;
			dx_n = -dx_n - (ax_n == 0x00);
		}
	}
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	return ax_n;
}

// 0800:8C69: Register Eq_n fn0800-8C69(Register Eq_n ax, Register Eq_n cl, Register Eq_n dx, Stack Eq_n wArg00, Register out Eq_n clOut, Register out Eq_n dxOut)
Eq_n fn0800-8C69(Eq_n ax, Eq_n cl, Eq_n dx, Eq_n wArg00, union Eq_n & clOut, union Eq_n & dxOut)
{
	if (cl >= 0x10)
	{
		clOut = cl - 0x10;
		dxOut = ax << cl - 0x10;
		return 0x00;
	}
	else
	{
		cu8 cl_n = -cl;
		clOut = cl_n + 0x10;
		dxOut = dx << cl | ax >> cl_n + 0x10;
		return ax << cl;
	}
}

// 0800:8C8A: Register Eq_n fn0800-8C8A(Register Eq_n ax, Register cu8 cl, Register Eq_n dx, Stack Eq_n wArg00, Register out Eq_n clOut, Register out Eq_n dxOut)
Eq_n fn0800-8C8A(Eq_n ax, cu8 cl, Eq_n dx, Eq_n wArg00, union Eq_n & clOut, union Eq_n & dxOut)
{
	if (cl >= 0x10)
	{
		clOut = cl - 0x10;
		int32 dx_ax_n = (int32) dx;
		dxOut = SLICE(dx_ax_n, word16, 16);
		return (word16) dx_ax_n >> cl - 0x10;
	}
	else
	{
		cu8 cl_n = -cl;
		clOut = cl_n + 0x10;
		dxOut = dx >> cl;
		return ax >> cl | dx << cl_n + 0x10;
	}
}

// 0800:8CAA: Register Eq_n fn0800-8CAA(Register Eq_n ax, Register cu8 cl, Register Eq_n dx, Stack Eq_n wArg00, Register out Eq_n dxOut)
Eq_n fn0800-8CAA(Eq_n ax, cu8 cl, Eq_n dx, Eq_n wArg00, union Eq_n & dxOut)
{
	if (cl >= 0x10)
	{
		dxOut.u0 = 0x00;
		return dx >> cl - 0x10;
	}
	else
	{
		dxOut = dx >> cl;
		return ax >> cl | dx << -cl + 0x10;
	}
}

// 0800:8CCB: Register Eq_n fn0800-8CCB(Register Eq_n ax, Register ci16 cx, Register Eq_n dx, Register Eq_n bx, Stack Eq_n psegArg00, Register out Eq_n chOut, Register out ptr16 dxOut)
Eq_n fn0800-8CCB(Eq_n ax, ci16 cx, Eq_n dx, Eq_n bx, Eq_n psegArg00, union Eq_n & chOut, ptr16 & dxOut)
{
	byte dh_n = SLICE(dx, byte, 8);
	Eq_n cl_n = (byte) cx;
	if (cx >= 0x00)
	{
		word16 ax_n = ax + bx;
		byte al_n = (byte) ax_n;
		ax_n = DPB(ax_n, al_n, 0);
		cu16 ax_n = DPB(ax_n, al_n, 0);
		if (ax_n < 0x00)
		{
			dx = (word32) dx + 0x00001000;
			dh_n = SLICE((word32) dx + 0x00001000, byte, 8);
		}
		chOut.u0 = <invalid>;
		dxOut = (ptr16) ((word32) DPB(dx, (word16) (cl_n << 0x04) + dh_n, 8) + (ax_n >> 0x04));
		return DPB(ax_n >> 0x04, al_n, 0) & 0x0F;
	}
	else
	{
		cup16 bx_n = ~bx;
		Eq_n cl_n = (byte) ((bool) (bx_n < 0x01) + ~cx);
		cup16 ax_n = ax - (bx_n + 0x01);
		byte al_n = (byte) ax_n;
		ax_n = DPB(ax_n, al_n, 0);
		cu16 ax_n = DPB(ax_n, al_n, 0);
		if (ax_n < 0x00)
			dx -= 0x1000;
		chOut.u0 = <invalid>;
		dxOut = dx - DPB(DPB(bx_n + 0x01, cl_n << 0x04, 8), 0x00, 0) + (ax_n >> 0x04);
		return DPB(ax_n >> 0x04, al_n, 0) & 0x0F;
	}
}

// 0800:8D2B: Register word16 fn0800-8D2B(Register Eq_n ds, Stack Eq_n wArg02)
word16 fn0800-8D2B(Eq_n ds, Eq_n wArg02)
{
	int16 si_n;
	Eq_n si_n = wArg02;
	if (wArg02 >= 0x00)
	{
		if (wArg02 <= 88)
			goto l0800_nD3E;
	}
	else
	{
		si_n = -wArg02;
		if (si_n <= 0x23)
		{
			((word32) ds + 9494)->u0 = ~0x00;
l0800_nD58:
			*((word32) ds + 0x007F) = si_n;
			return ~0x00;
		}
	}
	si_n.u0 = 0x57;
l0800_nD3E:
	*((word32) ds + 9494) = si_n;
	si_n = (int16) (ds->*((word32) si_n + 9496));
	goto l0800_nD58;
}

// 0800:8D64: void fn0800-8D64(Register Eq_n ds, Stack Eq_n wArg02)
void fn0800-8D64(Eq_n ds, Eq_n wArg02)
{
	fn0800-8D2B(ds, wArg02);
}

// 0800:8D76: Register cui16 fn0800-8D76(Stack int16 wArg02)
cui16 fn0800-8D76(int16 wArg02)
{
	cui16 dx_n;
	msdos_ioctl_get_device_info(wArg02, out dx_n);
	return dx_n & 0x80;
}

// 0800:8D87: Register word16 fn0800-8D87(Stack Eq_n bArg04, Stack Eq_n wArg06, Stack Eq_n ptrArg08, Stack Eq_n wArg0C, Stack Eq_n wArg0E, Register out Eq_n diOut)
word16 fn0800-8D87(Eq_n bArg04, Eq_n wArg06, Eq_n ptrArg08, Eq_n wArg0C, Eq_n wArg0E, union Eq_n & diOut)
{
	cu8 bl_n = (byte) wArg06;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	mp16 sp_n = fp - 0x2A;
	struct Eq_n * es_n = SLICE(ptrArg08, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg08;
	uint16 bx_n = DPB(wArg06, bl_n, 0);
	if (wArg06 > 0x24 || bl_n < 0x02)
	{
l0800_nDF7:
		es_n->*di_n = 0x00;
		struct Eq_n Eq_n::* sp_n = sp_n + 0x02;
		word16 si_n = (ss->*sp_n).w0002;
		diOut = (ss->*sp_n).t0000;
		return si_n;
	}
	Eq_n ax_n = wArg0C;
	Eq_n cx_n = wArg0E;
	if (wArg0E < 0x00 && bArg04 != 0x00)
	{
		*ptrArg08 = 0x2D;
		ax_n = -wArg0C;
		++di_n;
		cx_n = -wArg0E - (ax_n == 0x00);
	}
	byte Eq_n::* si_n = fp - 0x24;
	if (cx_n != 0x00)
	{
		do
		{
			uint32 dx_ax_n = (uint32) (uint16) cx_n;
			uint32 dx_ax_n = SEQ((uint16) (dx_ax_n % bx_n), ax_n);
			ss->*si_n = (byte) (uint16) (dx_ax_n % bx_n);
			Eq_n ax_n = (uint16) (dx_ax_n /u bx_n);
			cx_n = ax_n;
			ax_n = (uint16) (dx_ax_n /u bx_n);
			++si_n;
		} while (ax_n != 0x00);
l0800_nDD9:
		if (ax_n == 0x00)
		{
			word16 cx_n;
			do
			{
				byte al_n;
				--si_n;
				cu8 al_n = ss->*si_n;
				if (al_n < 0x0A)
					al_n = al_n + 0x30;
				else
					al_n = al_n - 0x0A + (ss->*bp_n).b0004;
				es_n->*di_n = al_n;
				++di_n;
				--cx_n;
			} while (cx_n != 0x00);
			goto l0800_nDF7;
		}
	}
	uint32 dx_ax_n = (uint32) (uint16) ax_n;
	ss->*si_n = (byte) (uint16) (dx_ax_n % bx_n);
	ax_n = (uint16) (dx_ax_n /u bx_n);
	++si_n;
	goto l0800_nDD9;
}

// 0800:8E09: Register word16 fn0800-8E09(Stack word16 wArg02, Stack word16 wArg04, Stack Eq_n wArg06, Register out ptr16 diOut)
word16 fn0800-8E09(word16 wArg02, word16 wArg04, Eq_n wArg06, ptr16 & diOut)
{
	ptr16 di_n;
	word16 si_n = fn0800-8D87(0x00, 0x0A, SEQ(wArg04, wArg02), wArg06, 0x00, out di_n);
	diOut = di_n;
	return si_n;
}

// 0800:8E29: Register Eq_n fn0800-8E29(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n bArg08, Register out Eq_n cxOut, Register out Eq_n dxOut, Register out Eq_n bxOut)
Eq_n fn0800-8E29(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n bArg08, union Eq_n & cxOut, union Eq_n & dxOut, union Eq_n & bxOut)
{
	SEQ(ds, 0x24EA)[wArg02 * 0x02] &= ~0x0200;
	Eq_n ax_n = DPB(DPB(ax, 66, 8), bArg08, 0);
	Eq_n dx_n = wArg04;
	if (msdos_set_file_position(wArg02, SEQ(wArg06, wArg04), bArg08, SEQ(wArg04, ax_n)))
	{
		word32 dx_ax_n = (word32) fn0800-8D2B(ds, ax_n);
		ax_n = (word16) dx_ax_n;
		dx_n = SLICE(dx_ax_n, word16, 16);
	}
	cxOut = wArg06;
	dxOut = dx_n;
	bxOut = wArg02;
	return ax_n;
}

// 0800:8E52: Register Eq_n fn0800-8E52(Register Eq_n al, Register Eq_n ds, Stack segptr32 ptrArg02)
Eq_n fn0800-8E52(Eq_n al, Eq_n ds, segptr32 ptrArg02)
{
	Eq_n ax_n;
	__syscall(33);
	Eq_n ax_n = DPB(ax, 0x39, 8);
	if (!C)
		ax_n.u0 = 0x00;
	else
		ax_n = fn0800-8D2B(ds, ax_n);
	return ax_n;
}

// 0800:8E6A: Register Eq_n fn0800-8E6A(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A, Register out Eq_n dxOut, Register out ptr16 siOut, Register out ptr16 diOut)
Eq_n fn0800-8E6A(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A, union Eq_n & dxOut, ptr16 & siOut, ptr16 & diOut)
{
	if ((wArg08 | wArg0A) == 0x00)
	{
		wArg0A = ds;
		wArg08.u0 = 20182;
	}
	Eq_n ax_n;
	Eq_n dx_n;
	if ((wArg04 | wArg06) == 0x00)
	{
		dx_n = ds;
		ax_n.u0 = 0x2572;
	}
	else
	{
		dx_n = wArg06;
		ax_n = wArg04;
	}
	word16 dx_n;
	ptr16 di_n;
	ptr16 si_n = fn0800-8E09(fn0800-9CE6(wArg08, wArg0A, ax_n, dx_n, out dx_n), dx_n, wArg02, out di_n);
	fn0800_BF5F(SEQ(wArg0A, wArg08), SEQ(ds, 9590));
	dxOut = wArg0A;
	siOut = si_n;
	diOut = di_n;
	return wArg08;
}

// 0800:8F18: Register Eq_n fn0800-8F18(Register Eq_n ax, Register Eq_n cx, Register uint16 dx, Register Eq_n bx, Register out Eq_n chOut, Register out ptr16 dxOut)
Eq_n fn0800-8F18(Eq_n ax, Eq_n cx, uint16 dx, Eq_n bx, union Eq_n & chOut, ptr16 & dxOut)
{
	uint16 ax_n = dx;
	if (dx != 0x00)
		ax_n = (word16) (bx * dx);
	if (cx != 0x00)
		ax_n = (word16) (ax * cx) + ax_n;
	chOut.u0 = <invalid>;
	uint32 dx_ax_n = bx * ax;
	dxOut = SLICE(dx_ax_n, word16, 16) + ax_n;
	return (word16) dx_ax_n;
}

// 0800:8F2F: FlagGroup Eq_n fn0800-8F2F(Register byte al, Register Eq_n ah, Register Eq_n cx, Register Eq_n dx, Register byte bl, Register Eq_n bh, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out Eq_n bxOut)
Eq_n fn0800-8F2F(byte al, Eq_n ah, Eq_n cx, Eq_n dx, byte bl, Eq_n bh, ptr16 & cxOut, ptr16 & dxOut, union Eq_n & bxOut)
{
	cu16 ax_n = DPB(ax, al, 0);
	cu16 bx_n = DPB(bx, bl, 0);
	ptr16 dx_n = (word32) dx + (ax_n >> 0x04);
	ptr16 cx_n = (word32) cx + (bx_n >> 0x04);
	Eq_n bx_n = DPB(bx_n >> 0x04, bl, 0) & 0x0F;
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	return <invalid>;
}

// 0800:8F50: Register Eq_n fn0800-8F50(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n ptrArg04, Stack Eq_n wArg08, Register out Eq_n chOut, Register out ptr16 dxOut)
Eq_n fn0800-8F50(Eq_n ds, Eq_n wArg02, Eq_n ptrArg04, Eq_n wArg08, union Eq_n & chOut, ptr16 & dxOut)
{
	Eq_n ax_n;
	Eq_n wLoc04_n;
	if ((SEQ(ds, 0x24EA)[wArg02 * 0x02] & 0x02) != 0x00)
		wLoc04_n.u0 = 0x05;
	else
	{
		dx = (word16) ptrArg04;
		if (!msdos_read_file(wArg02, wArg08, ptrArg04, out ax_n))
			goto l0800_nF7D;
		wLoc04_n = ax_n;
	}
	ax_n = fn0800-8D2B(ds, wLoc04_n);
l0800_nF7D:
	chOut.u0 = <invalid>;
	dxOut = dx;
	return ax_n;
}

// 0800:8F7F: Register word16 fn0800-8F7F(Register Eq_n al, Register Eq_n ds, Stack Eq_n ptrArg02)
word16 fn0800-8F7F(Eq_n al, Eq_n ds, Eq_n ptrArg02)
{
	word16 dx_n = (word16) ptrArg02;
	Eq_n ax_n = DPB(ax, 0x41, 8);
	if (msdos_delete_file(SLICE(ptrArg02, selector, 16), dx_n))
		fn0800-8D2B(ds, ax_n);
	return dx_n;
}

// 0800:8F97: Register byte fn0800-8F97(Register Eq_n cx, Register Eq_n dx, Register uint16 bx, Register mp16 bp, Register Eq_n si, Register Eq_n di, Register (ptr16 Eq_n) es, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack (memptr Eq_n Eq_n) wArg0A, Stack Eq_n psegArg0C, Register out ptr16 diOut)
byte fn0800-8F97(Eq_n cx, Eq_n dx, uint16 bx, mp16 bp, Eq_n si, Eq_n di, struct Eq_n * es, Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, struct Eq_n Eq_n::* wArg0A, Eq_n psegArg0C, ptr16 & diOut)
{
	mp16 fp;
	mp16 bp;
	selector ss;
	Eq_n si;
	Eq_n di;
	struct Eq_n * es;
	Eq_n ds;
	Eq_n cx;
	uint16 bx;
	Eq_n dx;
	struct Eq_n Eq_n::* wArg0A;
	Eq_n psegArg0C;
	Eq_n wArg08;
	Eq_n wArg06;
	Eq_n wArg02;
	word16 wLoc0C;
	byte bLoc03;
	Eq_n wArg04;
	word16 wLoc0A;
	Top_n = 0x00;
	wLoc06_n = 0x00;
	wLoc08_n.u0 = 0x00;
	sp_n = fp - 0x32;
l0800_nFC8:
	bLoc03_n = (bLoc03, bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n);
	wLoc0C_n = (wLoc0C, wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n);
	wLoc06_n = (wLoc06_n, wLoc06_n, wLoc06_n, wLoc06_n, wLoc06_n, wLoc06_n);
	wLoc08_n = (wLoc08_n, wLoc08_n, wLoc08_n, wLoc08_n, wLoc08_n, wLoc08_n);
	wArg0A_n = (wArg0A, wArg0A_n, wArg0A_n, wArg0A_n, wArg0A_n, wArg0A_n);
	Top_n = (Top_n, Top_n, Top_n, Top_n, Top_n, Top_n);
	dx_n = (dx, dx_n, dx_n, dx_n, dx_n, dx_n);
	bx_n = (bx, bx_n, bx_n, bx_n, bx_n, bx_n);
	cx_n = (cx, cx_n, cx_n, cx_n, cx_n, cx_n);
	sp_n = (sp_n, sp_n, sp_n, sp_n, sp_n, sp_n);
	di_n = (di, di_n, di_n, di_n, di_n, di_n);
	Mem51 = (Mem47, Mem1077, Mem1078, Mem1079, Mem595, Mem533);
	si_n = wArg0A_n;
	do
	{
l0800_nFCB:
		bLoc03_n = (bLoc03_n, bLoc03_n, bLoc03_n);
		wLoc0C_n = (wLoc0C_n, wLoc0C_n, wLoc0C_n);
		wArg0A_n = (wArg0A_n, wArg0A_n, wArg0A_n);
		wLoc08_n = (wLoc08_n, wLoc08_n, wLoc08_n);
		Top_n = (Top_n, Top_n, Top_n);
		dx_n = (dx_n, dx_n, dx_n);
		bx_n = (bx_n, bx_n, bx_n);
		cx_n = (cx_n, cx_n, cx_n);
		sp_n = (sp_n, sp_n, sp_n);
		di_n = (di_n, di_n, di_n);
		si_n = (si_n, si_n, si_n);
		Mem55 = (Mem1030, Mem893, Mem51);
		al_n = (ds->*si_n).b0000;
		si_n = &&(ss->*(ss->*si_n).b0001);
		al_n = al_n;
		if (al_n == 0x00)
		{
			fn0800-93A6(fp - 0x02, out bp_n, out di_n);
			diOut = di_n;
			return (byte) cx_n;
		}
		if (al_n == 0x25)
		{
			wLoc0C_n.u0 = ~0x00;
			es_n = psegArg0C;
			bLoc03_n = 0x20;
			while (true)
			{
				wLoc0C_n = (wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n, wLoc0C_n);
				bLoc03_n = (bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n, bLoc03_n);
				dx_n = (dx_n, dx_n, dx_n, dx_n, dx_n, dx_n, dx_n, dx_n, dx_n, dx_n);
				bx_n = (bx_n, bx_n, bx_n, bx_n, bx_n, bx_n, bx_n, bx_n, bx_n, bx_n);
				di_n = (di_n, di_n, di_n, di_n, di_n, di_n, di_n, di_n, di_n, di_n);
				Mem83 = (Mem80, Mem844, Mem503, Mem119, Mem123, Mem89, Mem499, Mem495, Mem831, Mem841);
				si_n = (si_n, si_n, si_n, si_n, si_n, si_n, si_n, si_n, si_n, si_n);
				si_n = &&(ss->*(ss->*si_n).b0001);
				ax_n = (int16) (ds->*si_n).b0000;
				wArg0A_n = si_n;
				ax_n = di_n;
				di_n = ax_n;
				if (ax_n < 0x00)
					break;
				bx_n = DPB(DPB(bx_n, ds->*((word16) ax_n + 9596), 0), 0x00, 8);
				if (bx_n > 0x15)
				{
					fn0800-93A6(fp - 0x02, out bp_n, out di_n);
					diOut = di_n;
					return (byte) cx_n;
				}
				bx_n = bx_n << 0x01;
				switch (bx_n << 0x01)
				{
				case 0x00:
				case 0x01:
				case 0x02:
					fn0800-93A6(fp - 0x02, out bp_n, out di_n);
					diOut = di_n;
					return (byte) cx_n;
				case 0x03:
					al_n = (byte) ax_n;
					di_n = di_n;
					goto l0800_nFD8;
				case 0x04:
					bLoc03_n = bLoc03_n | 0x01;
					break;
				case 0x05:
					wLoc0C_n = ax_n - 0x30;
					di_n = wLoc0C_n;
					if (wLoc0C_n >= 0x00)
					{
						dx_n = SLICE(wLoc0C_n * 0x0A, word16, 16);
						wLoc0C_n = (word16) (ax_n - 0x30) + (word16) (wLoc0C_n * 0x0A);
					}
					break;
				case 0x06:
					if ((bLoc03_n & 0x01) == 0x00)
						di_n = fn0800-8FAB(fp - 0x02, ds, out es_n);
					di_n = (di_n, di_n);
					es_n = (es_n, es_n);
					si_n = wLoc0C_n;
					if (wLoc0C_n < 0x00)
						si_n.u0 = 0x01;
					si_n = (si_n, si_n);
					if (wLoc0C_n != 0x00)
					{
						do
						{
							wLoc08_n = (wLoc08_n, wLoc08_n);
							Top_n = (Top_n, Top_n);
							dx_n = (dx_n, dx_n);
							bx_n = (bx_n, bx_n);
							cx_n = (cx_n, cx_n);
							ax_n = (ax_n, ax_n);
							di_n = (di_n, di_n);
							si_n = (si_n, si_n);
							es_n = (es_n, es_n);
							sp_n = (sp_n, sp_n);
							v65_n = (word16) wLoc08_n + 0x01;
							sp_n = sp_n - 0x02;
							ss->*sp_n = es_n;
							ss->*(sp_n - 0x02) = wArg08;
							ss->*(sp_n - 0x04) = wArg06;
							(seg0800->*wArg02)();
							al_n = (byte) ax_n;
							wLoc08_n = v65_n;
							cx_n = (ss->*sp_n).t0002;
							es_n = (ss->*sp_n).t0004;
							sp_n = (char *) &(ss->*sp_n).t0004 + 0x02;
							ax_n = DPB(ax_n, al_n, 0);
							ax_n = DPB(ax_n, al_n, 0);
							if (ax_n < 0x00)
							{
								fn0800-93A6(fp - 0x02, out bp_n, out di_n);
								diOut = di_n;
								return (byte) cx_n;
							}
							if ((bLoc03_n & 0x01) == 0x00)
							{
								es_n->*di_n = al_n;
								di_n = (word16) di_n + 0x01;
							}
							ax_n = (ax_n, ax_n);
							di_n = (di_n, di_n);
							Mem822 = (Mem768, Mem809);
							si_n = si_n - 0x01;
						} while (si_n > 0x00);
					}
					wLoc08_n = (wLoc08_n, wLoc08_n);
					Top_n = (Top_n, Top_n);
					dx_n = (dx_n, dx_n);
					bx_n = (bx_n, bx_n);
					cx_n = (cx_n, cx_n);
					sp_n = (sp_n, sp_n);
					di_n = (di_n, di_n);
					Mem820 = (Mem89, Mem822);
					if ((bLoc03_n & 0x01) == 0x00)
						wLoc06_n = wLoc06_n + 0x01;
					wLoc06_n = (wLoc06_n, wLoc06_n);
					Mem1078 = (Mem820, Mem827);
					goto l0800_nFC8;
				case 0x07:
				case 0x08:
					si_n.u0 = 0x0A;
					goto l0800_nCE;
				case 0x09:
					si_n.u0 = 0x00;
					goto l0800_nCE;
				case 0x0A:
					sp_n = sp_n - 0x02;
					ss->*sp_n = ss;
					ss->*(sp_n - 0x02) = fp - 0x0A;
					ss->*(sp_n - 0x04) = ss;
					ss->*(sp_n - 0x06) = fp - 0x08;
					ss->*(sp_n - 0x08) = wLoc0C_n & 0x7FFF;
					ss->*(sp_n - 0x0A) = wArg08;
					ss->*(sp_n - 0x0C) = wArg06;
					ss->*(sp_n - 0x0E) = wArg04;
					ss->*(sp_n - 0x0010) = wArg02;
					fn0800_A2D0(ds);
					sp_n.u0 = <invalid>;
					if (wLoc0A > 0x00)
					{
						if (((int16) bLoc03_n & 0x01) == 0x00)
						{
							di_n = fn0800-8FAB(fp - 0x02, ds, out es_n);
							wLoc06_n = wLoc06_n + 0x01;
							if ((bLoc03_n & 0x04) != 0x00)
								ax_n = 0x04;
							else if ((bLoc03_n & 0x08) != 0x00)
								ax_n = 0x08;
							else
								ax_n = 0x00;
							ax_n = (ax_n, ax_n, ax_n);
							ss->*((byte) sp_n.u0 + 0x0010) = ax_n;
							ss->*((byte) sp_n.u0 + 0x0E) = es_n;
							ss->*((byte) sp_n.u0 + 0x0C) = di_n;
							sp_n.u0 = <invalid>;
							Top_n = fn0800_A2D4(ds);
							sp_n = (byte) sp_n.u0 + 0x06;
						}
						else
						{
							Top_n = fn0800_A2D8(ds);
							sp_n.u0 = <invalid>;
						}
						goto l0800_nFC8;
					}
					fn0800_A2D8(ds);
					if (wLoc0A < 0x00)
					{
						fn0800-93A6(fp - 0x02, out bp_n, out di_n);
						diOut = di_n;
						return (byte) cx_n;
					}
					else
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg0.u0 = <invalid>;
						stackArg2.u0 = <invalid>;
						stackArg4.u0 = <invalid>;
						fn0800-93BE(fp - 0x02, stackArg0, stackArg2, stackArg4, out bp_n, out di_n);
						diOut = di_n;
						return (byte) cx_n;
					}
				case 11:
					bLoc03_n = bLoc03_n | 0x08;
					break;
				case 0x0C:
					bLoc03_n = bLoc03_n | 0x02;
					break;
				case 0x0D:
					bLoc03_n = bLoc03_n | 0x04;
					break;
				case 0x0E:
					si_n.u0 = 0x08;
					goto l0800_nCE;
				case 0x0F:
					ax_n = fn0800-920E(di_n, cx_n, bx_n << 0x01, fp - 0x02, ds, out cx_n, out bx_n, out bp_n, out di_n);
					fn0800-920E(ax_n, cx_n, bx_n, bp_n, ds, out cx_n, out bx_n, out bp_n, out di_n);
					diOut = di_n;
					return (byte) cx_n;
				case 0x10:
					sp_n = sp_n - 0x02;
					ss->*sp_n = psegArg0C;
					ss->*(sp_n - 0x02) = ss;
					es_n = ss->*(sp_n - 0x02);
					di_n = fp - 44;
					cx_n = 0x10;
					while (true)
					{
						di_n = (di_n, di_n);
						Mem175 = (Mem167, Mem464);
						cx_n = (cx_n, cx_n);
						if (cx_n == 0x00)
							break;
						es_n->*di_n = 0x00;
						di_n = di_n + 0x01;
						cx_n = cx_n - 0x01;
					}
					al_n = (ds->*si_n).b0000;
					v48_n = bLoc03_n & ~0x10;
					es_n = ss->*sp_n;
					sp_n = (char *) sp_n + 0x02;
					ax_n = (word16) al_n;
					si_n = &&(ss->*(ss->*si_n).b0001);
					bLoc03_n = v48_n;
					if (al_n == 0x5E)
					{
						al_n = (ds->*si_n).b0001;
						bLoc03_n = v48_n | 0x10;
						ax_n = DPB(ax_n, al_n, 0);
						si_n = &(ss->*si_n).b0001 + 0x01;
					}
					bLoc03_n = (bLoc03_n, bLoc03_n);
					si_n = (si_n, si_n);
					Mem1111 = (Mem184, Mem189);
					ax_n = (ax_n, ax_n);
					al_n = (al_n, al_n);
					ax_n = DPB(DPB(ax_n, 0x00, 8), al_n, 0);
l0800_nD2:
					dx_n = (dx_n, dx_n, dx_n, dx_n);
					si_n = (si_n, si_n, si_n, si_n);
					Mem209 = (Mem1111, Mem216, Mem216, Mem216);
					ax_n = (ax_n, ax_n, ax_n, ax_n);
					al_n = (al_n, al_n, al_n, al_n);
					ax_n = DPB(ax_n, al_n, 0);
					Mem211[ss:fp - 44 + (ax_n >>u 0x03):byte] = Mem209[ss:fp - 44 + (ax_n >>u 0x03):byte] | 0x80;
					dl_n = al_n;
					dx_n = DPB(dx_n, al_n, 0);
					di_n = ax_n >> 0x03;
					cx_n.u0 = 0x8007;
					while (true)
					{
						dx_n = (dx_n, dx_n, dx_n);
						cx_n = (cx_n, cx_n, cx_n);
						di_n = (di_n, di_n, di_n);
						ax_n = (ax_n, ax_n, ax_n);
						dl_n = (dl_n, dl_n, dl_n);
						Mem216 = (Mem211, Mem216, Mem454);
						si_n = (si_n, si_n, si_n);
						al_n = (ds->*si_n).b0000;
						ch_n.u0 = SLICE(cx_n, byte, 8);
						dx_n = DPB(dx_n, dl_n, 0);
						dx_n = DPB(dx_n, dl_n, 0);
						dx_n = DPB(dx_n, dl_n, 0);
						dx_n = DPB(dx_n, dl_n, 0);
						dx_n = DPB(dx_n, dl_n, 0);
						ax_n = DPB(ax_n, al_n, 0);
						ax_n = DPB(ax_n, al_n, 0);
						ax_n = DPB(ax_n, al_n, 0);
						ax_n = DPB(ax_n, al_n, 0);
						si_n = &&(ss->*(ss->*si_n).b0001);
						if (al_n == 0x00)
							break;
						if (al_n == 0x5D)
						{
							v64_n = wLoc0C_n & 0x7FFF;
							wArg0A_n = si_n;
							wLoc0C_n = v64_n;
							si_n = v64_n;
							if ((bLoc03_n & 0x01) == 0x00)
								di_n = fn0800-8FAB(fp - 0x02, ds, out es_n);
							while (true)
							{
								wLoc08_n = (wLoc08_n, wLoc08_n, wLoc08_n, wLoc08_n);
								Top_n = (Top_n, Top_n, Top_n, Top_n);
								dx_n = (dx_n, dx_n, dx_n, dx_n);
								bx_n = (bx_n, bx_n, bx_n, bx_n);
								cx_n = (cx_n, cx_n, cx_n, cx_n);
								ax_n = (ax_n, ax_n, ax_n, ax_n);
								di_n = (di_n, di_n, di_n, di_n);
								es_n = (es_n, es_n, es_n, es_n);
								sp_n = (sp_n, sp_n, sp_n, sp_n);
								Mem251 = (Mem233, Mem233, Mem264, Mem371);
								si_n = (si_n, si_n, si_n, si_n);
								si_n = si_n - 0x01;
								if (si_n < 0x00)
									break;
								v68_n = (word16) wLoc08_n + 0x01;
								sp_n = sp_n - 0x02;
								ss->*sp_n = es_n;
								ss->*(sp_n - 0x02) = wArg08;
								ss->*(sp_n - 0x04) = wArg06;
								(seg0800->*wArg02)();
								wLoc08_n = v68_n;
								cx_n = (ss->*sp_n).t0002;
								es_n = (ss->*sp_n).t0004;
								sp_n = (char *) &(ss->*sp_n).t0004 + 0x02;
								if (ax_n < 0x00)
								{
									if ((word16) si_n + 0x01 >= v64_n)
									{
										fn0800-93A6(fp - 0x02, out bp_n, out di_n);
										diOut = di_n;
										return (byte) cx_n;
									}
									if ((bLoc03_n & 0x01) != 0x00)
									{
										fn0800-93A6(fp - 0x02, out bp_n, out di_n);
										diOut = di_n;
										return (byte) cx_n;
									}
									else
									{
										es_n->*di_n = 0x00;
										fn0800-93A6(fp - 0x02, out bp_n, out di_n);
										diOut = di_n;
										return (byte) cx_n;
									}
								}
								al_n = (byte) ax_n;
								cx_n.u0 = 0x8007;
								si_n = si_n;
								ax_n = DPB(ax_n, al_n, 0);
								ax_n = DPB(ax_n, al_n, 0);
								ax_n = DPB(ax_n, al_n, 0);
								ax_n = DPB(ax_n, al_n, 0);
								bx_n = ax_n >> 0x03;
								if ((Mem264[ss:fp - 44 + (ax_n >>u 0x03):byte] & 0x80) != 0x00)
								{
									if ((bLoc03_n & 0x10) != 0x00)
										goto l0800_nD;
								}
								else if ((bLoc03_n & 0x10) == 0x00)
								{
l0800_nD:
									ax_n = (ax_n, ax_n);
									(ss->*sp_n).t0004 = es_n;
									(ss->*sp_n).t0002 = wArg08;
									(ss->*sp_n).t0000 = wArg06;
									(ss->*(sp_n - 0x02)).t0000 = ax_n;
									(seg0800->*wArg04)();
									es_n = (ss->*sp_n).t0006;
									sp_n = (char *) &(ss->*sp_n).t0006 + 0x02;
									if ((word16) si_n + 0x01 < v64_n)
										break;
									goto l0800_nE;
								}
								ax_n = (ax_n, ax_n);
								if ((bLoc03_n & 0x01) == 0x00)
								{
									es_n->*di_n = al_n;
									di_n = (word16) di_n + 0x01;
								}
							}
							Top_n = (Top_n, Top_n);
							dx_n = (dx_n, dx_n);
							bx_n = (bx_n, bx_n);
							cx_n = (cx_n, cx_n);
							sp_n = (sp_n, sp_n);
							es_n = (es_n, es_n);
							Mem415 = (Mem251, Mem409);
							if ((bLoc03_n & 0x01) == 0x00)
							{
								wLoc06_n = wLoc06_n + 0x01;
l0800_nE:
								wLoc06_n = (wLoc06_n, wLoc06_n);
								Top_n = (Top_n, Top_n);
								dx_n = (dx_n, dx_n);
								bx_n = (bx_n, bx_n);
								cx_n = (cx_n, cx_n);
								sp_n = (sp_n, sp_n);
								es_n = (es_n, es_n);
								es_n->*di_n = 0x00;
								di_n = (word16) di_n + 0x01;
							}
							wLoc06_n = (wLoc06_n, wLoc06_n);
							Top_n = (Top_n, Top_n);
							dx_n = (dx_n, dx_n);
							bx_n = (bx_n, bx_n);
							cx_n = (cx_n, cx_n);
							sp_n = (sp_n, sp_n);
							di_n = (di_n, di_n);
							Mem1079 = (Mem415, Mem427);
							wLoc08_n = wLoc08_n;
							goto l0800_nFC8;
						}
						if (al_n != 0x2D || (dl_n > (es_n->*si_n).b0000 || (es_n->*si_n).b0000 == 0x5D))
							goto l0800_nD2;
						al_n = (ds->*si_n).b0000 - dl_n;
						si_n = &&(ss->*(ss->*si_n).b0001);
						ax_n = DPB(ax_n, al_n, 0);
						if (al_n != 0x00)
						{
							dl_n = dl_n + al_n;
							dx_n = DPB(dx_n, dl_n, 0);
							dl_n = dl_n;
							do
							{
								al_n = (al_n, al_n);
								Mem452 = (Mem216, Mem454);
								di_n = (di_n, di_n);
								ch_n = (ch_n, ch_n);
								ch_n = __rol(ch_n, 0x01);
								di_n = di_n + ((ch_n & 0x80) != 0x00);
								Mem454[ss:fp - 44 + di_n:byte] = Mem452[ss:fp - 44 + di_n:byte] | ch_n;
								al_n = al_n - 0x01;
								cx_n = DPB(cx_n, ch_n, 8);
								ax_n = DPB(ax_n, al_n, 0);
							} while (al_n != 0x00);
						}
					}
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg0.u0 = <invalid>;
					stackArg2.u0 = <invalid>;
					stackArg4.u0 = <invalid>;
					fn0800-93BE(fp - 0x02, stackArg0, stackArg2, stackArg4, out bp_n, out di_n);
					diOut = di_n;
					return (byte) cx_n;
				case 0x11:
					ax_n = wLoc08_n;
					dx_n.u0 = 0x00;
					if ((bLoc03_n & 0x01) == 0x00)
						goto l0800_n;
					break;
				case 0x12:
					si_n.u0 = 0x10;
l0800_nCE:
					si_n = (si_n, si_n, si_n, si_n);
					if ((ax_n & 0x20) == 0x00 && ax_n != 88)
						bLoc03_n = bLoc03_n | 0x04;
					bLoc03_n = (bLoc03_n, bLoc03_n, bLoc03_n);
					sp_n = sp_n - 0x02;
					ss->*sp_n = ss;
					ss->*(sp_n - 0x02) = fp - 0x0A;
					ss->*(sp_n - 0x04) = ss;
					ss->*(sp_n - 0x06) = fp - 0x08;
					ss->*(sp_n - 0x08) = wLoc0C_n & 0x7FFF;
					ss->*(sp_n - 0x0A) = si_n;
					ss->*(sp_n - 0x0C) = wArg08;
					ss->*(sp_n - 0x0E) = wArg06;
					ss->*(sp_n - 0x0010) = wArg04;
					ss->*(sp_n - 0x0012) = wArg02;
					ax_n = fn0800-94B0(wLoc0C_n & 0x7FFF, cx_n, dx_n, bx_n << 0x01, fp - 0x02, si_n, ax_n, ds, ss->*(sp_n - 0x0012), ss->*(sp_n - 0x0010), ss->*(sp_n - 0x0E), ss->*(sp_n - 0x0C), ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), out cx_n, out dx_n, out bx_n, out di_n, out Top_n);
					if (wLoc0A > 0x00)
					{
						if ((bLoc03_n & 0x01) == 0x00)
						{
							wLoc06_n = wLoc06_n + 0x01;
l0800_n:
							wLoc06_n = (wLoc06_n, wLoc06_n);
							bLoc03_n = (bLoc03_n, bLoc03_n);
							Top_n = (Top_n, Top_n);
							bx_n = (bx_n, bx_n);
							cx_n = (cx_n, cx_n);
							dx_n = (dx_n, dx_n);
							ax_n = (ax_n, ax_n);
							di_n = fn0800-8FAB(fp - 0x02, ds, out es_n);
							es_n->*di_n = ax_n;
							di_n = (word16) di_n + 0x02;
							if ((bLoc03_n & 0x04) != 0x00)
							{
								es_n->*((word16) di_n + 0x02) = dx_n;
								dx_n = ax_n;
								di_n = (word16) di_n + 0x04;
							}
						}
						bLoc03_n = (bLoc03_n, bLoc03_n, bLoc03_n);
						wLoc06_n = (wLoc06_n, wLoc06_n, wLoc06_n);
						Top_n = (Top_n, Top_n, Top_n);
						dx_n = (dx_n, dx_n, dx_n);
						bx_n = (bx_n, bx_n, bx_n);
						cx_n = (cx_n, cx_n, cx_n);
						di_n = (di_n, di_n, di_n);
						Mem1077 = (Mem722, Mem731, Mem658);
						sp_n = sp_n;
						goto l0800_nFC8;
					}
					if (wLoc0A < 0x00)
					{
						fn0800-93A6(fp - 0x02, out bp_n, out di_n);
						diOut = di_n;
						return (byte) cx_n;
					}
					else
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg0.u0 = <invalid>;
						stackArg2.u0 = <invalid>;
						stackArg4.u0 = <invalid>;
						fn0800-93BE(fp - 0x02, stackArg0, stackArg2, stackArg4, out bp_n, out di_n);
						diOut = di_n;
						return (byte) cx_n;
					}
				case 0x13:
					ax_n = fn0800-912A(di_n, cx_n, bx_n << 0x01, fp - 0x02, ds, out cx_n, out bx_n, out bp_n, out di_n);
					fn0800-912A(ax_n, cx_n, bx_n, bp_n, ds, out cx_n, out bx_n, out bp_n, out di_n);
					diOut = di_n;
					return (byte) cx_n;
				case 0x14:
					bLoc03_n = bLoc03_n & 223;
					break;
				case 0x15:
					bLoc03_n = bLoc03_n | 0x20;
					break;
				}
			}
			fn0800-93A6(fp - 0x02, out bp_n, out di_n);
			diOut = di_n;
			return (byte) cx_n;
		}
l0800_nFD8:
		bLoc03_n = (bLoc03_n, bLoc03_n);
		wLoc0C_n = (wLoc0C_n, wLoc0C_n);
		wArg0A_n = (wArg0A_n, wArg0A_n);
		dx_n = (dx_n, dx_n);
		bx_n = (bx_n, bx_n);
		si_n = (si_n, si_n);
		di_n = (di_n, di_n);
		al_n = (al_n, al_n);
		v17_n = (word16) wLoc08_n + 0x01;
		sp_n = sp_n - 0x02;
		ss->*sp_n = wArg08;
		ss->*(sp_n - 0x02) = wArg06;
		(seg0800->*wArg02)();
		ax_n = (int16) al_n;
		wLoc08_n = v17_n;
		cx_n = (ss->*sp_n).t0002;
		sp_n = (char *) &(ss->*sp_n).t0002 + 0x02;
		al_n = (byte) ax_n;
		if (ax_n < 0x00)
		{
l0800_n:
			cx_n = (cx_n, cx_n);
			fn0800-93A6(fp - 0x02, out bp_n, out di_n);
			diOut = di_n;
			return (byte) cx_n;
		}
		ax_n = (int16) al_n;
		di_n = ax_n;
		if (ax_n >= 0x00 && ds->*((word16) ax_n + 9596) == 0x01)
		{
			do
			{
				wLoc08_n = (wLoc08_n, wLoc08_n);
				Top_n = (Top_n, Top_n);
				dx_n = (dx_n, dx_n);
				cx_n = (cx_n, cx_n);
				sp_n = (sp_n, sp_n);
				Mem987 = (Mem893, Mem1040);
				bx_n = (bx_n, bx_n);
				ax_n = (ax_n, ax_n);
				bl_n = (byte) ax_n;
				bx_n = DPB(ax_n, bl_n, 0);
				if (bl_n < 0x00 || ds->*((word16) bx_n + 9596) != 0x01)
				{
					sp_n = sp_n - 0x02;
					ss->*sp_n = wArg08;
					ss->*(sp_n - 0x02) = wArg06;
					ss->*(sp_n - 0x04) = bx_n;
					(seg0800->*wArg04)();
					sp_n = sp_n + 0x06;
					wLoc08_n = wLoc08_n - 0x01;
					goto l0800_nFCB;
				}
				v26_n = (word16) wLoc08_n + 0x01;
				sp_n = sp_n - 0x02;
				ss->*sp_n = wArg08;
				ss->*(sp_n - 0x02) = wArg06;
				(seg0800->*wArg02)();
				wLoc08_n = v26_n;
				cx_n = (ss->*sp_n).t0002;
				sp_n = (char *) &(ss->*sp_n).t0002 + 0x02;
				ax_n = ax_n;
			} while (ax_n > 0x00);
			goto l0800_n;
		}
	} while (ax_n == ax_n);
	(ss->*sp_n).t0002 = wArg08;
	(ss->*sp_n).t0000 = wArg06;
	(ss->*(sp_n - 0x02)).t0000 = ax_n;
	(seg0800->*wArg04)();
	fn0800-93A6(fp - 0x02, out bp_n, out di_n);
	diOut = di_n;
	return (byte) cx_n;
}

// 0800:8FAB: Register word16 fn0800-8FAB(Register (memptr Eq_n Eq_n) bp, Register Eq_n ds, Register out Eq_n esOut)
word16 fn0800-8FAB(struct Eq_n Eq_n::* bp, Eq_n ds, union Eq_n & esOut)
{
	Eq_n es_di_n = (ss->*bp).t0010;
	union Eq_n Eq_n::* di_n = (word16) es_di_n;
	if (((ss->*(bp - 0x01)).t0000 & 0x20) == 0x00)
	{
		word16 di_n = *es_di_n;
		(ss->*bp).t0010.u0 = (word16) (ss->*bp).t0010.u0 + 0x02;
		esOut = ds;
		return di_n;
	}
	else
	{
		Eq_n es_di_n = ds->*di_n;
		(ss->*bp).t0010.u0 = (word16) (ss->*bp).t0010.u0 + 0x04;
		esOut = SLICE(es_di_n, selector, 16);
		return (word16) es_di_n;
	}
}

// 0800:912A: Register Eq_n fn0800-912A(Register Eq_n ax, Register Eq_n cx, Register Eq_n bx, Register Eq_n bp, Register Eq_n ds, Register out ptr16 cxOut, Register out ptr16 bxOut, Register out ptr16 bpOut, Register out ptr16 diOut)
Eq_n fn0800-912A(Eq_n ax, Eq_n cx, Eq_n bx, Eq_n bp, Eq_n ds, ptr16 & cxOut, ptr16 & bxOut, ptr16 & bpOut, ptr16 & diOut)
{
	ptr16 bx_n;
	ptr16 cx_n;
	ptr16 bp_n;
	ptr16 di_n;
	Eq_n ax_n = fn0800-93C5(ax, cx, bx, bp, ds, out cx_n, out bx_n, out bp_n, out di_n);
	cxOut = cx_n;
	bxOut = bx_n;
	bpOut = bp_n;
	diOut = di_n;
	return ax_n;
}

// 0800:9145: void fn0800-9145(Register ci16 ax, Register Eq_n bp)
void fn0800-9145(ci16 ax, Eq_n bp)
{
	fn0800-93EF(ax, bp);
}

// 0800:9169: void fn0800-9169(Register ci16 ax, Register Eq_n bp)
void fn0800-9169(ci16 ax, Eq_n bp)
{
	fn0800-93EF(ax, bp);
}

// 0800:920E: Register Eq_n fn0800-920E(Register Eq_n ax, Register Eq_n cx, Register Eq_n bx, Register Eq_n bp, Register Eq_n ds, Register out ptr16 cxOut, Register out ptr16 bxOut, Register out ptr16 bpOut, Register out ptr16 diOut)
Eq_n fn0800-920E(Eq_n ax, Eq_n cx, Eq_n bx, Eq_n bp, Eq_n ds, ptr16 & cxOut, ptr16 & bxOut, ptr16 & bpOut, ptr16 & diOut)
{
	ptr16 bx_n;
	ptr16 cx_n;
	ptr16 bp_n;
	ptr16 di_n;
	Eq_n ax_n = fn0800-93C5(ax, cx, bx, bp, ds, out cx_n, out bx_n, out bp_n, out di_n);
	cxOut = cx_n;
	bxOut = bx_n;
	bpOut = bp_n;
	diOut = di_n;
	return ax_n;
}

// 0800:93A6: Register word16 fn0800-93A6(Register Eq_n bp, Register out ptr16 bpOut, Register out ptr16 diOut)
word16 fn0800-93A6(Eq_n bp, ptr16 & bpOut, ptr16 & diOut)
{
	(seg0800->*(ss->*((word32) bp + 0x06)))();
	(ss->*(bp - 0x04)).t0000 = (ss->*(bp - 0x04)).t0000 - ((ss->*(bp - 0x04)).t0000 < 0x01);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n stackArg2 = <invalid>;
	Eq_n stackArg4 = <invalid>;
	ptr16 bp_n;
	ptr16 di_n;
	word16 ax_n = fn0800-93BE(bp, stackArg0, stackArg2, stackArg4, out bp_n, out di_n);
	bpOut = bp_n;
	diOut = di_n;
	return ax_n;
}

// 0800:93BE: Register Eq_n fn0800-93BE(Register Eq_n bp, Stack Eq_n psegArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n bpOut, Register out Eq_n diOut)
Eq_n fn0800-93BE(Eq_n bp, Eq_n psegArg00, Eq_n wArg02, Eq_n wArg04, union Eq_n & bpOut, union Eq_n & diOut)
{
	Eq_n ax_n = ss->*(bp - 0x04);
	bpOut = ss->*bp;
	diOut = wArg02;
	return ax_n;
}

// 0800:93C5: Register Eq_n fn0800-93C5(Register Eq_n ax, Register Eq_n cx, Register Eq_n bx, Register Eq_n bp, Register Eq_n ds, Register out Eq_n cxOut, Register out Eq_n bxOut, Register out Eq_n bpOut, Register out ptr16 diOut)
Eq_n fn0800-93C5(Eq_n ax, Eq_n cx, Eq_n bx, Eq_n bp, Eq_n ds, union Eq_n & cxOut, union Eq_n & bxOut, union Eq_n & bpOut, ptr16 & diOut)
{
	struct Eq_n Eq_n::* sp_n = fp;
	int8 Top_n = 0x00;
	do
	{
		ss->*(bp - 0x06) = (word16) (ss->*(bp - 0x06)) + 0x01;
		word16 Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = ss->*((word32) bp + 0x0A);
		ss->*(sp_n - 0x02) = ss->*((word32) bp + 0x08);
		struct Eq_n Eq_n::* sp_n;
		Eq_n ax_n;
		Eq_n bx_n;
		(seg0800->*(ss->*((word32) bp + 0x04)))();
		cx = (ss->*sp_n).t0002;
		sp_n = (struct Eq_n Eq_n::*) &(ss->*sp_n).t0004;
		ax = ax_n;
		ci8 al_n = (byte) ax_n;
		if (ax_n <= 0x00)
		{
			if (ax_n == 0x00)
				break;
			Eq_n cx_n = (ss->*sp_n).t0004;
			Eq_n bp_n;
			ptr16 di_n;
			Eq_n ax_n = fn0800-93A6(bp, out bp_n, out di_n);
			cxOut = cx_n;
			bxOut = bx_n;
			bpOut = bp_n;
			diOut = di_n;
			return ax_n;
		}
		ax = DPB(ax_n, al_n, 0);
		if (al_n < 0x00)
			break;
		bx = bx_n;
	} while (ds->*((word32) ax + 9596) == 0x01);
	Eq_n cx_n = (ss->*sp_n).t0004;
	Eq_n cx_n;
	Eq_n ax_n;
	Eq_n bx_n;
	(ss->*((word32) cx_n + 0x03))();
	cxOut = cx_n;
	bxOut = bx_n;
	bpOut = bp;
	diOut = di;
	return ax_n;
}

// 0800:93EF: void fn0800-93EF(Register ci16 ax, Register Eq_n bp)
void fn0800-93EF(ci16 ax, Eq_n bp)
{
	struct Eq_n Eq_n::* sp_n = fp;
	int8 Top_n = 0x00;
	ui16 dx_n = 0x00;
	ui16 cx_n = 0x04;
	while (true)
	{
		ci16 v8_n = (ss->*(bp - 0x0A)).w0000 - 0x01;
		(ss->*(bp - 0x0A)).w0000 = v8_n;
		ci8 cl_n = (byte) cx_n;
		if (v8_n < 0x00)
			break;
		ui16 Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = dx_n;
		ss->*(sp_n - 0x02) = cx_n;
		++ss->*(bp - 0x06);
		ss->*(sp_n - 0x04) = ss->*((word32) bp + 0x0A);
		ss->*(sp_n - 0x06) = ss->*((word32) bp + 0x08);
		struct Eq_n Eq_n::* sp_n;
		ci16 ax_n;
		(seg0800->*(ss->*((word32) bp + 0x04)))();
		word16 cx_n = (ss->*sp_n).w0004;
		cu8 al_n = (byte) ax_n;
		cl_n = (byte) cx_n;
		dx_n = (ss->*sp_n).w0006;
		sp_n = (struct Eq_n Eq_n::*) (&(ss->*sp_n).w0006 + 0x01);
		ax = ax_n;
		ax = DPB(ax_n, al_n, 0);
		ax = DPB(ax_n, al_n, 0);
		if (ax_n <= 0x00)
			goto l0800_n;
		word16 cx_n;
		word16 cx_n;
		word16 cx_n;
		word16 cx_n;
		word16 cx_n;
		word16 cx_n;
		--cl_n;
		word16 cx_n = DPB(cx_n, cl_n - 0x01, 0);
		word16 cx_n = DPB(cx_n, cl_n - 0x01, 0);
		word16 cx_n = DPB(cx_n, cl_n - 0x01, 0);
		word16 cx_n = DPB(cx_n, cl_n - 0x01, 0);
		word16 cx_n = DPB(cx_n, cl_n - 0x01, 0);
		word16 cx_n = DPB(cx_n, cl_n - 0x01, 0);
		cx_n = DPB(cx_n, cl_n - 0x01, 0);
		if (cl_n < 0x01)
			goto l0800_n;
		cu8 ch_n = al_n - 0x30;
		cx_n = DPB(cx_n, al_n - 0x30, 8);
		cx_n = DPB(cx_n, al_n - 0x30, 8);
		if (al_n < 0x30)
			goto l0800_n;
		if (al_n >= 0x3A)
		{
			cu8 ch_n = al_n - 0x41;
			cx_n = DPB(cx_n, al_n - 0x41, 8);
			cx_n = DPB(cx_n, al_n - 0x41, 8);
			if (al_n < 0x41)
				goto l0800_n;
			if (al_n >= 0x47)
			{
				ch_n = al_n - 0x61;
				cx_n = DPB(cx_n, al_n - 0x61, 8);
				cx_n = DPB(cx_n, al_n - 0x61, 8);
				if (al_n < 0x61 || al_n >= 0x67)
					goto l0800_n;
			}
			ch_n = ch_n + 0x0A;
			cx_n = DPB(cx_n, ch_n, 8);
		}
		cx_n = DPB(cx_n, ch_n, 8);
		dx_n = DPB(dx_n << 0x04, (byte) (dx_n << 0x04) + ch_n, 0);
	}
	ax = 0x00;
l0800_n:
	if (cl_n == 0x04)
		fn0800-93A6(bp, out bp_n, out di_n);
	else
	{
		Eq_n cx_n = (ss->*sp_n).t0000;
		(ss->*((word32) cx_n + 0x03))();
	}
}

// 0800:9485: FlagGroup bool fn0800-9485(Register cu8 cl, Register Eq_n bl, Register out ptr16 bxOut)
bool fn0800-9485(cu8 cl, Eq_n bl, ptr16 & bxOut)
{
	cu8 bl_n = (byte) bx;
	bool C_n;
	ptr16 bx_n;
	cu8 bl_n = bl_n - 0x30;
	word16 bx_n = DPB(bx, bl_n - 0x30, 0);
	if (bl_n >= 0x30)
	{
		if (bl_n <= 0x39)
		{
l0800_nA2:
			word16 bx_n = DPB(bx_n, bl_n, 0);
			if (bl_n < cl)
			{
				C_n = false;
				bx_n = DPB(bx_n, 0x00, 8);
l0800_nAF:
				bxOut = bx_n;
				return C_n;
			}
			goto l0800_nAD;
		}
		word16 bx_n;
		if (bl_n <= 0x5A)
		{
			bl_n = bl_n - 55;
			bx_n = DPB(bx, bl_n - 55, 0);
		}
		else
		{
			bl_n = bl_n - 0x57;
			bx_n = DPB(bx, bl_n - 0x57, 0);
		}
		bx_n = DPB(bx_n, bl_n, 0);
		if (bl_n > 0x09)
			goto l0800_nA2;
	}
l0800_nAD:
	bx_n = bx;
	C_n = true;
	goto l0800_nAF;
}

// 0800:94B0: Register Eq_n fn0800-94B0(Register Eq_n ax, Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register mp16 bp, Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A, Stack Eq_n wArg0C, Register out Eq_n cxOut, Register out Eq_n dxOut, Register out Eq_n bxOut, Register out Eq_n diOut, Register out Eq_n TopOut)
Eq_n fn0800-94B0(Eq_n ax, Eq_n cx, Eq_n dx, Eq_n bx, mp16 bp, Eq_n si, Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A, Eq_n wArg0C, union Eq_n & cxOut, union Eq_n & dxOut, union Eq_n & bxOut, union Eq_n & diOut, union Eq_n & TopOut)
{
	Eq_n Top_n = 0x00;
	mp16 wLoc02_n = bp;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	Eq_n wLoc0A_n = si;
	struct Eq_n Eq_n::* sp_n = fp - 0x0C;
	Eq_n wLoc0C_n = di;
	byte bLoc03_n = 0x00;
	word16 wLoc06_n = 0x00;
	word16 wLoc08_n = 0x01;
	do
	{
		Eq_n ax_n;
		Eq_n dx_n;
		word16 wLoc08_n;
		word16 v8_n = wLoc06_n + 0x01;
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = wArg08;
		ss->*(sp_n - 0x02) = wArg06;
		struct Eq_n Eq_n::* sp_n;
		Eq_n ax_n;
		Eq_n bx_n;
		(seg0800->*wArg02)();
		wLoc06_n = v8_n;
		cx = (ss->*sp_n).t0002;
		sp_n = (struct Eq_n Eq_n::*) ((char *) &(ss->*sp_n).t0002 + 0x02);
		Eq_n ax_n = ax_n;
		byte al_n = (byte) ax_n;
		if (ax_n < 0x00)
			goto l0800_n;
		Eq_n ax_n = (int16) al_n;
		ax = bx_n;
		bx = ax_n;
	} while (((byte) ax_n & 0x80) == 0x00 && (ds->*((word32) ax_n + 0x00002251) & 0x01) != 0x00);
	byte al_n = (byte) ax_n;
	ax_n = ax_n;
	ax_n = DPB(ax_n, al_n, 0);
	ax_n = DPB(ax_n, al_n, 0);
	--wArg0C;
	if (wArg0C < 0x01)
	{
l0800_n:
		wLoc08_n = 0x00;
l0800_n:
		struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).t0000 = wArg08;
		(ss->*(sp_n - 0x02)).t0000 = wArg06;
		(ss->*(sp_n - 0x04)).t0000 = ax_n;
		word16 sp_n;
		(seg0800->*wArg04)();
		sp_n = sp_n + 0x06;
		ax_n.u0 = 0x00;
		dx_n.u0 = 0x00;
		goto l0800_n;
	}
	if (al_n != 0x2B)
	{
		if (al_n != 0x2D)
			goto l0800_nF;
		bLoc03_n = 0x01;
	}
	wArg0C -= 0x02;
	if (wArg0C < 0x02)
		goto l0800_n;
	(ss->*sp_n).t0002 = wArg08;
	(ss->*sp_n).t0000 = wArg06;
	struct Eq_n Eq_n::* sp_n;
	Eq_n ax_n;
	(seg0800->*wArg02)();
	wLoc06_n = v8_n + 0x01;
	cx = (ss->*sp_n).t0002;
	sp_n = (struct Eq_n Eq_n::*) ((char *) &(ss->*sp_n).t0002 + 0x02);
	ax_n = ax_n;
	al_n = (byte) ax_n;
	if (ax_n < 0x00)
	{
l0800_n:
		wLoc08_n = ~0x00;
		goto l0800_n;
	}
l0800_nF:
	cu8 cl_n = (byte) wArg0A;
	ax_n = DPB(ax_n, al_n, 0);
	ax_n = DPB(ax_n, al_n, 0);
	ax_n = DPB(ax_n, al_n, 0);
	Eq_n ax_n = DPB(ax_n, al_n, 0);
	Eq_n si_n = 0x00;
	Eq_n di_n = 0x00;
	cx = wArg0A;
	cx = DPB(wArg0A, cl_n, 0);
	cx = DPB(wArg0A, cl_n, 0);
	if (wArg0A != 0x00)
	{
		if (wArg0A > 0x24 || cl_n < 0x02)
			goto l0800_n;
		if (al_n == 0x30)
		{
			if (cl_n != 0x10)
				goto l0800_nC;
			Eq_n v31_n = wArg0C - 0x01;
			wArg0C = v31_n;
			if (v31_n >= 0x00)
			{
				word16 v32_n = wLoc06_n + 0x01;
				struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).t0000 = wArg08;
				(ss->*(sp_n - 0x02)).t0000 = wArg06;
				struct Eq_n Eq_n::* sp_n;
				(seg0800->*wArg02)();
				byte al_n = (byte) ax_n;
				wLoc06_n = v32_n;
				ax_n = DPB(ax_n, al_n, 0);
				cx = (ss->*sp_n).t0002;
				sp_n = (struct Eq_n Eq_n::*) ((char *) &(ss->*sp_n).t0002 + 0x02);
				if (al_n != 0x78 && al_n != 88)
					goto l0800_nC8;
				goto l0800_nC;
			}
l0800_nB:
			goto l0800_n;
		}
	}
	else
	{
		wArg0A.u0 = 0x0A;
		if (al_n == 0x30)
		{
			Eq_n v70_n = wArg0C - 0x01;
			wArg0C = v70_n;
			if (v70_n >= 0x00)
			{
				word16 v71_n = wLoc06_n + 0x01;
				struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).t0000 = wArg08;
				(ss->*(sp_n - 0x02)).t0000 = wArg06;
				struct Eq_n Eq_n::* sp_n;
				(seg0800->*wArg02)();
				byte al_n = (byte) ax_n;
				wLoc06_n = v71_n;
				ax_n = DPB(ax_n, al_n, 0);
				cx = (ss->*sp_n).t0002;
				sp_n = (struct Eq_n Eq_n::*) ((char *) &(ss->*sp_n).t0002 + 0x02);
				wArg0A.u0 = 0x08;
				if (al_n != 0x78 && al_n != 88)
				{
l0800_nC8:
					cx = (ss->*bp_n).t000C;
					Eq_n ax_n = bx_n;
					Eq_n bx_n;
					if (!fn0800-9485((byte) cx, ax_n, out bx_n))
					{
l0800_n:
						struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
						(ss->*sp_n).t0000 = (ss->*bp_n).t000A;
						(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0008;
						(ss->*(sp_n - 0x04)).t0000 = ax_n;
						word16 sp_n;
						(seg0800->*(ss->*bp_n).ptr0006)();
						(ss->*(bp_n - 0x04)).t0000 = (ss->*(bp_n - 0x04)).t0000 - 0x01;
						sp_n = sp_n + 0x06;
l0800_n:
						dx_n = di_n;
						ax_n = si_n;
						if ((ss->*(bp_n - 0x01)).t0000 != 0x00)
						{
							ax_n = -si_n;
							dx_n = -di_n - (ax_n == 0x00);
						}
						goto l0800_n;
					}
					Eq_n dx_ax_n = (ss->*bp_n).t000C * si_n;
					ui32 di_si_n = (word32) dx_ax_n + SEQ(di_n, bx_n);
					ax_n = (word16) dx_ax_n;
					dx = SLICE(dx_ax_n, word16, 16);
					si_n = (word16) di_si_n;
					di_n = SLICE(di_si_n, word16, 16);
					if (di_n != 0x00)
					{
						do
						{
							ci16 v54_n = (ss->*bp_n).w000E - 0x01;
							(ss->*bp_n).w000E = v54_n;
							if (v54_n < 0x00)
								goto l0800_n;
							(ss->*(bp_n - 0x04)).t0000 = (word32) (ss->*(bp_n - 0x04)).t0000 + 0x01;
							struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
							(ss->*sp_n).t0000 = (ss->*bp_n).t000A;
							(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0008;
							word16 sp_n;
							Eq_n ax_n;
							Eq_n bx_n;
							(seg0800->*(ss->*bp_n).ptr0004)();
							cx = (ss->*bp_n).t000C;
							sp_n = sp_n + 0x04;
							ax_n = bx_n;
							bx_n = bx_n;
							Eq_n bx_n;
							if (!fn0800-9485((byte) cx, ax_n, out bx_n))
								goto l0800_n;
							Eq_n dx_ax_n = cx * si_n;
							Eq_n dx_ax_n = cx * di_n;
							ui32 ax_si_n = (word32) dx_ax_n + SEQ((word16) dx_ax_n, bx_n);
							Eq_n ax_n = SLICE(ax_si_n, word16, 16);
							byte dl_n = (bool) (ax_n < 0x00) + (SLICE(dx_ax_n, byte, 16) + SLICE(dx_ax_n, byte, 24));
							cx = SLICE(dx_ax_n, word16, 16);
							si_n = (word16) ax_si_n;
							ax_n = (word16) dx_ax_n;
							di_n = ax_n;
							dx = DPB(SLICE(dx_ax_n, word16, 16), dl_n, 0);
						} while (dl_n == 0x00);
						bool C_n = SLICE(cond((byte) (ss->*(bp_n - 0x01)).t0000.u0 + 0x00FF), bool, 1);
						(ss->*(bp_n - 0x06)).t0000.u0 = 0x02;
						ax_n = DPB(~0x00, C_n + ~0x00, 8);
						dx_n = SLICE(cond(C_n + ~0x00), bool, 1) + 0x7FFF;
l0800_n:
						word16 * es_di_n = (ss->*bp_n).ptr0010;
						*es_di_n = (word16) ((word32) (ss->*(bp_n - 0x04)).t0000 + *es_di_n);
						Eq_n bx_n = (ss->*(bp_n - 0x06)).t0000;
						*(ss->*bp_n).ptr0014 = (union Eq_n *) bx_n;
						Eq_n di_n = (ss->*sp_n).t0000;
						cxOut = cx;
						dxOut = dx_n;
						bxOut = bx_n;
						diOut = di_n;
						TopOut = Top_n;
						return ax_n;
					}
l0800_nB5:
					ci16 v44_n = (ss->*bp_n).w000E - 0x01;
					(ss->*bp_n).w000E = v44_n;
					if (v44_n < 0x00)
						goto l0800_n;
					(ss->*(bp_n - 0x04)).t0000 = (word32) (ss->*(bp_n - 0x04)).t0000 + 0x01;
					struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
					(ss->*sp_n).t0000 = (ss->*bp_n).t000A;
					(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0008;
					word16 sp_n;
					(seg0800->*(ss->*bp_n).ptr0004)();
					sp_n = sp_n + 0x04;
					goto l0800_nC8;
				}
				wArg0A.u0 = 0x10;
l0800_nC:
				goto l0800_nB5;
			}
			goto l0800_nB;
		}
	}
	cx = wArg0A;
	ax_n = bx_n;
	Eq_n bx_n;
	if (!fn0800-9485((byte) wArg0A, ax_n, out bx_n))
	{
		ax_n.u0 = 0x00;
		si_n = bx_n;
		goto l0800_nB5;
	}
	goto l0800_n;
}

// 0800:9652: void fn0800-9652(Stack segptr32 ptrArg02)
void fn0800-9652(segptr32 ptrArg02)
{
	__syscall(33);
}

// 0800:9667: void fn0800-9667(Stack segptr32 ptrArg02)
void fn0800-9667(segptr32 ptrArg02)
{
	__syscall(33);
}

// 0800:9764: Register ptr16 fn0800-9764(Register Eq_n ds, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bpOut)
ptr16 fn0800-9764(Eq_n ds, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bpOut)
{
	fn0800-8B95(fp - 0x06);
	fn0800-8BA8(fp - 0x0A);
	struct Eq_n Eq_n::* bp_n;
	ptr16 cx_n;
	ptr16 dx_n;
	ptr16 ax_n = fn0800_C04F(ds, out cx_n, out dx_n, out bp_n);
	ss->*(bp_n - 0x0A) = dx_n;
	ss->*(bp_n - 0x0C) = ax_n;
	if (((ss->*bp_n).t0004 | (ss->*bp_n).w0006) != 0x00)
	{
		Eq_n es_bx_n = (ss->*bp_n).t0004;
		ptr16 dx_n = (ss->*(bp_n - 0x0C)).ptr0000;
		*((word32) es_bx_n + 0x02) = (ss->*(bp_n - 0x0A)).ptr0000;
		*es_bx_n = dx_n;
	}
	ptr16 dx_n = (ss->*(bp_n - 0x0A)).ptr0000;
	ptr16 ax_n = (ss->*(bp_n - 0x0C)).ptr0000;
	ptr16 bp_n = (ss->*bp_n).ptr0000;
	cxOut = cx_n;
	dxOut = dx_n;
	bpOut = bp_n;
	return ax_n;
}

// 0800:97B6: Register word16 fn0800-97B6(Register Eq_n ds, Stack Eq_n wArg02, Register out ptr16 dxOut)
word16 fn0800-97B6(Eq_n ds, Eq_n wArg02, ptr16 & dxOut)
{
	ptr16 dx_n;
	word16 ax_n = fn0800-8E29(ds, wArg02, 0x00, 0x00, 0x01, out cx_n, out dx_n, out bx_n);
	dxOut = dx_n;
	return ax_n;
}

// 0800:97CC: Register byte fn0800-97CC(Register Eq_n ds, Stack int16 wArg02)
byte fn0800-97CC(Eq_n ds, int16 wArg02)
{
	struct Eq_n Eq_n::* ax_n;
	byte dl_n = (byte) wArg02;
	if (wArg02 == ~0x00)
		ax_n = ~0x00;
	else
	{
		struct Eq_n Eq_n::* ax_n = DPB(DPB(ax, dl_n, 0), 0x00, 8);
		if (((ds->*ax_n).b2251 & 0x08) != 0x00)
			ax_n = (struct Eq_n Eq_n::*) (&(ss->*DPB(DPB(ax_n, dl_n, 0), 0x00, 8)).b2251 + 0x0000DD8F);
		else
			ax_n = (struct Eq_n Eq_n::*) DPB(DPB(ax_n, dl_n, 0), 0x00, 8);
	}
	return (byte) ax_n;
}

// 0800:97F8: Register word16 fn0800-97F8(Register Eq_n al, Register Eq_n ds, Stack Eq_n ptrArg02)
word16 fn0800-97F8(Eq_n al, Eq_n ds, Eq_n ptrArg02)
{
	word16 dx_n = (word16) ptrArg02;
	Eq_n ax_n = DPB(ax, 0x41, 8);
	if (msdos_delete_file(SLICE(ptrArg02, selector, 16), dx_n))
		fn0800-8D2B(ds, ax_n);
	return dx_n;
}

// 0800:9810: Register (memptr Eq_n byte) fn0800-9810(Register byte dh, Register byte dl, Register (memptr Eq_n byte) di, Register Eq_n es)
byte Eq_n::* fn0800-9810(byte dh, byte dl, byte Eq_n::* di, Eq_n es)
{
	byte Eq_n::* di_n = fn0800-9817(dh, di, es);
	return fn0800-9817(dl, di_n, es);
}

// 0800:9817: Register (memptr Eq_n byte) fn0800-9817(Register byte al, Register (memptr Eq_n byte) di, Register Eq_n es)
byte Eq_n::* fn0800-9817(byte al, byte Eq_n::* di, Eq_n es)
{
	word16 ax_n = __aam(al);
	byte al_n = (byte) ax_n;
	byte Eq_n::* di_n = fn0800-9820(SLICE(ax_n, byte, 8), di, es);
	return fn0800-9820(al_n, di_n, es);
}

// 0800:9820: Register (memptr Eq_n byte) fn0800-9820(Register byte al, Register (memptr Eq_n byte) di, Register Eq_n es)
byte Eq_n::* fn0800-9820(byte al, byte Eq_n::* di, Eq_n es)
{
	byte al_n = (bool) __daa(al + 0x90, &(al + 0x90)) + (al + 0xD0);
	__daa(al_n, &al_n);
	es->*di = al_n;
	return di + 0x01;
}

// 0800:9828: Register Eq_n fn0800-9828(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register Eq_n ds, Stack Eq_n wArg02, Stack segptr32 ptrArg04, Stack Eq_n psegArg06, Register out ptr16 siOut, Register out ptr16 diOut)
Eq_n fn0800-9828(Eq_n cx, Eq_n dx, Eq_n bx, Eq_n ds, Eq_n wArg02, segptr32 ptrArg04, Eq_n psegArg06, ptr16 & siOut, ptr16 & diOut)
{
	ci8 bLoc16_n = 0x50;
	Eq_n sp_n = fp - 0x9E;
	struct Eq_n Eq_n::* wLoc06_n = fp - 0x98;
l0800_n:
	struct Eq_n Eq_n::* di_n = wLoc06_n;
l0800_n:
	psegArg06_n = SLICE(psegArg06_n, selector, 16);
	byte Eq_n::* si_n = (word16) psegArg06_n;
	Eq_n es_n = SLICE(psegArg06_n, selector, 16);
	while (true)
	{
		byte al_n = ds->*si_n;
		++si_n;
		byte al_n = al_n;
		word16 ax_n = DPB(ax, al_n, 0);
		if (al_n == 0x00)
			break;
		if (al_n == 0x25)
		{
			al_n = ds->*si_n;
			ax_n = (word16) DPB(ax, al_n, 0);
			word16 ax_n = DPB(ax, al_n, 0);
			++si_n;
			if (al_n != 0x25)
			{
				wLoc06_n = di_n;
				word16 cx_n = 0x00;
				cu8 ch_n = 0x00;
				Eq_n wLoc10_n = 0x00;
				cui16 wLoc04_n = 0x20;
				byte bLoc0D_n = 0x00;
				Eq_n wLoc0A_n = ~0x00;
				Eq_n wLoc0C_n = ~0x00;
				Mem74 = Mem62;
				while (true)
				{
					Eq_n ax_n = DPB(ax_n, 0x00, 8);
					byte dl_n = (byte) ax_n;
					cu8 bl_n = (byte) ax_n;
					cx = DPB(cx_n, ch_n, 8);
					cx = DPB(cx_n, ch_n, 8);
					word16 cx_n = DPB(cx_n, ch_n, 8);
					cx = DPB(cx_n, ch_n, 8);
					word16 cx_n = DPB(cx_n, ch_n, 8);
					cx = DPB(cx, ch_n, 8);
					cx_n = (word16) DPB(cx, ch_n, 8);
					cx = DPB(cx_n, ch_n, 8);
					cx = DPB(cx_n, ch_n, 8);
					cx_n = DPB(cx_n, ch_n, 8);
					cx = DPB(cx_n, ch_n, 8);
					cx_n = (word16) DPB(cx, ch_n, 8);
					cx = DPB(cx_n, ch_n, 8);
					word16 cx_n = DPB(cx_n, ch_n, 8);
					cx_n = DPB(cx_n, ch_n, 8);
					cx_n = DPB(cx_n, ch_n, 8);
					cx = DPB(cx_n, ch_n, 8);
					cx = DPB(cx_n, ch_n, 8);
					dx = ax_n;
					dx = DPB(ax_n, dl_n, 0);
					dx = DPB(ax_n, dl_n, 0);
					dx_n = DPB(ax_n, dl_n, 0);
					Eq_n dx_n = DPB(ax_n, dl_n, 0);
					dx_n = DPB(ax_n, dl_n, 0);
					dx = DPB(ax_n, dl_n, 0);
					bx = DPB(ax_n, bl_n - 0x20, 0);
					if (bl_n >= 0x80)
						break;
					bx = DPB(ax_n, ds->*((word32) bx + 9733), 0);
					if (bx > 0x17)
						goto l0800_nC82;
					byte bLoc08_n;
					Eq_n es_n;
					Eq_n cx_n;
					Eq_n di_n;
					ui16 bx_n;
					ui16 bx_n;
					ui16 bx_n;
					byte bh_n;
					Eq_n dx_n;
					Eq_n ax_n;
					bx <<= 0x01;
					cx_n = cx;
					switch (bx << 0x01)
					{
					case 0x00:
						if (ch_n > 0x00)
							goto l0800_nFE;
						if (bLoc0D_n != 0x2B)
						{
							bLoc0D_n = dl_n;
							Mem996 = Mem978;
						}
						goto l0800_nDB;
					case 0x01:
						if (ch_n > 0x00)
							goto l0800_nFE;
						wLoc04_n |= 0x01;
						Mem993 = Mem971;
						goto l0800_nDB;
					case 0x02:
						ax_n = ss->*wArg02;
						wArg02 = (word32) wArg02 + 0x02;
						if (ch_n >= 0x02)
						{
							if (ch_n != 0x04)
								goto l0800_n;
							++ch_n;
							wLoc0C_n = ax_n;
							cx_n = DPB(cx_n, ch_n, 8);
							Mem993 = Mem951;
							goto l0800_nDB;
						}
						else
						{
							if (ax_n < 0x00)
							{
								ax_n = -ax_n;
								wLoc04_n |= 0x02;
							}
							wLoc0A_n = ax_n;
							ch_n = 0x03;
							cx_n = DPB(cx_n, 0x03, 8);
							Mem995 = Mem966;
							goto l0800_nA;
						}
					case 0x03:
						if (ch_n > 0x00)
							goto l0800_nFE;
						wLoc04_n |= 0x02;
						Mem993 = Mem940;
						goto l0800_nDB;
					case 0x04:
						if (ch_n >= 0x04)
							goto l0800_n;
						ch_n = 0x04;
						cx_n = DPB(cx_n, 0x04, 8);
						wLoc0C_n = (word32) wLoc0C_n + 0x01;
						Mem993 = Mem935;
						goto l0800_nDB;
					case 0x05:
l0800_n:
						dx = ax_n;
						Eq_n ax_n = (int16) (dl_n - 0x30);
						if (ch_n <= 0x02)
						{
							ch_n = 0x02;
							cx_n = DPB(cx_n, 0x02, 8);
							cx_n = DPB(cx_n, 0x02, 8);
							wLoc0A_n = ax_n;
							ax_n = wLoc0A_n;
							Mem995 = Mem917;
							if (wLoc0A_n < 0x00)
								goto l0800_nA;
							ax_n = (wLoc0A_n << 0x03) + (wLoc0A_n << 0x01);
							wLoc0A_n = ax_n + ax_n;
							Mem993 = Mem929;
							goto l0800_nDB;
						}
						if (ch_n != 0x04)
						{
l0800_n:
							goto l0800_nC82;
						}
						else
						{
							wLoc0C_n = ax_n;
							ax_n = wLoc0C_n;
							Mem995 = Mem901;
							if (wLoc0C_n == 0x00)
								goto l0800_nA;
							ax_n = (wLoc0C_n << 0x03) + (wLoc0C_n << 0x01);
							wLoc0C_n = ax_n + ax_n;
							Mem993 = Mem913;
							goto l0800_nDB;
						}
					case 0x06:
						wLoc04_n |= 0x10;
						Mem994 = Mem880;
						break;
					case 0x07:
						wLoc04_n |= 0x0100;
						goto l0800_nD1;
					case 0x08:
l0800_nD1:
						wLoc04_n &= ~0x10;
						Mem994 = Mem876;
						break;
					case 0x09:
						cx_n = cx;
						if (ch_n > 0x00)
							goto l0800_n;
						if ((wLoc04_n & 0x02) == 0x00)
						{
							wLoc04_n |= 0x08;
							ch_n = 0x01;
							cx_n = DPB(cx_n, 0x01, 8);
							Mem993 = Mem864;
						}
						else
						{
l0800_nA:
							cx_n = DPB(cx_n, ch_n, 8);
						}
						goto l0800_nDB;
					case 0x0A:
						int32 dx_ax_n = (int32) (ss->*wArg02);
						bh_n = 0x0A;
						bx_n = DPB(bx << 0x01, 0x0A, 8);
						bLoc08_n = 0x01;
						ax_n = (word16) dx_ax_n;
						dx_n = SLICE(dx_ax_n, word16, 16);
						goto l0800_nA0A;
					case 11:
						bh_n = 0x08;
						bx_n = DPB(bx << 0x01, 0x08, 8);
						goto l0800_nE6;
					case 0x0C:
						bh_n = 0x0A;
						bx_n = DPB(bx << 0x01, 0x0A, 8);
						goto l0800_nEA;
					case 0x0D:
						bh_n = 0x10;
						bx_n = DPB(DPB(bx << 0x01, 0x10, 8), dl_n + 233, 0);
l0800_nE6:
						bx_n = DPB(bx_n, bh_n, 8);
						bLoc0D_n = 0x00;
l0800_nEA:
						bx_n = DPB(bx_n, bh_n, 8);
						dx_n.u0 = 0x00;
						bLoc08_n = 0x00;
						ax_n = ss->*wArg02;
l0800_nA0A:
						struct Eq_n Eq_n::* di_n = (word32) wArg02 + 0x01;
						ui16 bx_n = DPB(bx_n, bh_n, 8);
						bx_n = DPB(bx_n, bh_n, 8);
						ui16 bx_n = DPB(bx_n, bh_n, 8);
						bx_n = DPB(bx_n, bh_n, 8);
						bx = DPB(bx_n, bh_n, 8);
						bx = DPB(bx_n, bh_n, 8);
						Eq_n bx_n = DPB(bx, bh_n, 8);
						Eq_n di_n = &(ss->*di_n).t0001;
						psegArg06_n = SEQ(psegArg06_n, si_n);
						if ((wLoc04_n & 0x10) != 0x00)
						{
							dx_n = (ss->*di_n).t0001;
							di_n = (char *) &(ss->*di_n).t0001 + 0x02;
						}
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						wArg02 = di_n;
						ax = ax_n;
						bx_n = bx_n;
						if (ax_n == 0x00)
						{
							dx = dx_n;
							bx_n = bx_n;
							if (dx_n != 0x00)
								goto l0800_nA32;
							bx_n = bx;
							if (wLoc0C_n == 0x00)
								goto l0800_n;
						}
						else
						{
l0800_nA32:
							wLoc04_n |= 0x04;
						}
						union Eq_n Eq_n::* sp_n = sp_n - 0x02;
						ss->*sp_n = dx_n;
						ss->*(sp_n - 0x02) = ax_n;
						ss->*(sp_n - 0x04) = ss;
						ss->*(sp_n - 0x06) = fp - 0x47;
						Eq_n ax_n = (int16) bh_n;
						ss->*(sp_n - 0x08) = ax_n;
						ss->*(sp_n - 0x0A) = DPB(ax_n, bLoc08_n, 0);
						ss->*(sp_n - 0x0C) = bx_n;
						fn0800-8D87(ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x02), ss->*sp_n, out di_n);
						ss->*sp_n = ss;
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						es_n = ss->*sp_n;
						sp_n = (char *) sp_n + 0x02;
						dx_n = wLoc0C_n;
						if (wLoc0C_n < 0x00)
							goto l0800_nB46;
						goto l0800_nB54;
					case 0x0E:
						union Eq_n Eq_n::* sp_n = sp_n - 0x02;
						ss->*sp_n = ss->*wArg02;
						byte Eq_n::* di_n = fp - 0x48;
						wArg02 = (word32) wArg02 + 0x02;
						if ((wLoc04_n & 0x20) != 0x00)
						{
							word16 dx_n = ss->*((word32) wArg02 + 0x02);
							ss->*(sp_n - 0x02) = ss;
							Eq_n es_n = ss->*(sp_n - 0x02);
							byte Eq_n::* di_n = fn0800-9810(SLICE(dx_n, byte, 8), (byte) dx_n, fp - 0x48, es_n);
							es_n->*di_n = 0x3A;
							Eq_n sp_n = <invalid>;
							wArg02 = (word32) wArg02 + 0x04;
							sp_n = (union Eq_n Eq_n::*) ((word32) sp_n + 0x0000FFFE);
							di_n = di_n + 0x01;
						}
						struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
						(ss->*sp_n).t0000 = ss;
						word16 dx_n = (ss->*sp_n).w0002;
						es_n = (ss->*sp_n).t0000;
						byte Eq_n::* di_n = fn0800-9810(SLICE(dx_n, byte, 8), (byte) dx_n, di_n, es_n);
						ss->*di_n = 0x00;
						Eq_n sp_n = <invalid>;
						sp_n = (word32) sp_n + 0x0000FFFE;
						wLoc04_n &= ~0x04;
						Eq_n di_n = di_n - (fp - 0x48);
						di_n = fp - 0x48;
						dx_n = wLoc0C_n;
						if (wLoc0C_n <= di_n)
							dx_n = di_n;
						Mem487 = Mem322;
						goto l0800_nB46;
					case 0x0F:
						Eq_n cx_n = wLoc0C_n;
						if (wLoc0C_n < 0x00)
							cx_n.u0 = 0x06;
						Eq_n ax_n;
						union Eq_n Eq_n::* sp_n = sp_n - 0x02;
						ss->*sp_n = ss;
						ss->*(sp_n - 0x02) = wArg02;
						ss->*(sp_n - 0x04) = cx_n;
						ss->*(sp_n - 0x06) = ss;
						ss->*(sp_n - 0x08) = fp - 0x47;
						ss->*(sp_n - 0x0A) = dx_n;
						ss->*(sp_n - 0x0C) = wLoc04_n & 0x01;
						if ((wLoc04_n & 0x0100) != 0x00)
						{
							ax_n.u0 = 0x08;
							wArg02 = (word32) wArg02 + 0x0A;
						}
						else
						{
							wArg02 = (word32) wArg02 + 0x08;
							ax_n.u0 = 0x06;
						}
						ss->*(sp_n - 0x0E) = ax_n;
						fn0800_A2CC(ds);
						Eq_n sp_n = <invalid>;
						ss->*(sp_n - 0x02) = ss;
						es_n = ss->*(sp_n - 0x02);
						sp_n = sp_n;
						di_n = fp - 0x47;
l0800_nB46:
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						if ((wLoc04_n & 0x08) != 0x00)
						{
							dx_n = wLoc0A_n;
							if (wLoc0A_n > 0x00)
							{
l0800_nB54:
								psegArg06_n = SLICE(psegArg06_n, selector, 16);
								Eq_n cx_n = fn0800-9842(di_n, es_n);
								if (es_n->*di_n.u0 == 0x2D)
									--cx_n;
								psegArg06_n = SLICE(psegArg06_n, selector, 16);
								dx_n -= cx_n;
								if (dx_n > 0x00)
								{
									wLoc10_n = dx_n;
									Mem528 = Mem523;
								}
							}
						}
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						if (es_n->*di_n.u0 != 0x2D)
						{
							if (bLoc0D_n == 0x00)
								goto l0800_nB86;
							--di_n;
							es_n->*di_n.u0 = bLoc0D_n;
						}
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						if (wLoc10_n > 0x00 && wLoc0C_n < 0x00)
						{
							--wLoc10_n;
							Mem576 = Mem553;
						}
l0800_nB86:
						cx_n = fn0800-9842(di_n, es_n);
						goto l0800_nB89;
					case 0x10:
						union Eq_n Eq_n::* sp_n = sp_n - 0x02;
						ss->*sp_n = ss;
						wArg02 = (word32) wArg02 + 0x02;
						es_n = ss->*sp_n;
						sp_n = (char *) sp_n + 0x02;
						di_n = fp - 0x47;
						cx_n.u0 = 0x01;
						Mem574 = Mem200;
						goto l0800_nB89;
					case 0x11:
						bool Z_n;
						if ((wLoc04_n & 0x20) == 0x00)
						{
							Eq_n di_n = ss->*wArg02;
							union Eq_n Eq_n::* sp_n = sp_n - 0x02;
							ss->*sp_n = ds;
							wArg02 = (word32) wArg02 + 0x02;
							es_n = ss->*sp_n;
							di_n = di_n;
							Z_n = SLICE(cond(di_n), bool, 2);
						}
						else
						{
							Eq_n es_di_n = ds->*wArg02;
							es_n = SLICE(es_di_n, selector, 16);
							di_n = (word16) es_di_n;
							wArg02 = (word32) wArg02 + 0x04;
							Z_n = SLICE(cond(es_n | di_n), bool, 2);
							Mem181 = Mem139;
						}
						if (!Z_n)
						{
							union Eq_n Eq_n::* sp_n = sp_n - 0x02;
							ss->*sp_n = ds;
							es_n = ss->*sp_n;
							di_n.u0 = 0x25FE;
						}
						cx_n = fn0800-9842(di_n, es_n);
						if (cx_n > wLoc0C_n)
							cx_n = wLoc0C_n;
l0800_nB89:
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						psegArg06_n = SLICE(psegArg06_n, selector, 16);
						Eq_n si_n = di_n;
						Eq_n bx_n = wLoc0A_n;
						ax = wLoc04_n & 0x05;
						if (ax == 0x05)
						{
							ax = DPB(ax, dl_n, 8);
							ax = DPB(ax, dl_n, 8);
							ax = DPB(ax, dl_n, 8);
							if (dl_n != 111)
							{
								if (dl_n == 0x78 || dl_n == 88)
								{
									Eq_n v40_n = wLoc10_n - 0x02;
									psegArg06_n = SLICE(psegArg06_n, selector, 16);
									wLoc04_n |= 0x40;
									bx_n = wLoc0A_n - 0x02;
									wLoc10_n = v40_n;
									Mem616 = Mem600;
									if (v40_n < 0x00)
									{
										wLoc10_n.u0 = 0x00;
										Mem616 = Mem603;
									}
								}
l0800_nBCC:
								psegArg06_n = SLICE(psegArg06_n, selector, 16);
								cx = cx_n + wLoc10_n;
								if ((wLoc04_n & 0x02) == 0x00)
								{
									while (true)
									{
										psegArg06_n = SLICE(psegArg06_n, selector, 16);
										if (bx_n <= cx)
											break;
										ax = DPB(ax, 0x20, 0);
										di_n = fn0800-984F(0x20, cx, dx_n, bx_n, fp - 0x02, di_n, es_n);
										sp_n = (word32) sp_n + 0x0000FFFE;
										--bx_n;
									}
								}
								psegArg06_n = SLICE(psegArg06_n, selector, 16);
								if ((wLoc04_n & 0x40) != 0x00)
								{
									ax = DPB(ax, dl_n, 0);
									di_n = fn0800-984F(dl_n, cx, dx_n, bx_n, fp - 0x02, fn0800-984F(0x30, cx, dx_n, bx_n, fp - 0x02, di_n, es_n), es_n);
									sp_n = (word32) sp_n + 0x0000FFFC;
								}
								psegArg06_n = SLICE(psegArg06_n, selector, 16);
								dx = wLoc10_n;
								if (wLoc10_n > 0x00)
								{
									byte al_n = es_n->*di_n.u0;
									Eq_n cx_n = cx - wLoc10_n;
									bx_n -= wLoc10_n;
									ax = DPB(ax, al_n, 0);
									ax = DPB(ax, al_n, 0);
									ax = DPB(ax, al_n, 0);
									if (al_n == 0x2D || (al_n == 0x20 || al_n == 0x2B))
									{
										byte al_n = ds->*di_n.u0;
										ax = DPB(ax, al_n, 0);
										si_n = (word16) di_n.u0 + 0x01;
										di_n = fn0800-984F(al_n, cx_n, wLoc10_n, bx_n, fp - 0x02, di_n, es_n);
										sp_n = (word32) sp_n + 0x0000FFFE;
										--cx_n;
										--bx_n;
									}
									Eq_n cx_n = wLoc10_n;
									if (wLoc10_n != 0x00)
									{
										do
										{
											psegArg06_n = SLICE(ptrArg04_n, selector, 16);
											ax = DPB(ax, 0x30, 0);
											di_n = fn0800-984F(0x30, cx_n, cx_n, bx_n, fp - 0x02, di_n, es_n);
											sp_n = (word32) sp_n + 0x0000FFFE;
											--cx_n;
											ptrArg04_n = psegArg06_n;
										} while (cx_n != 0x00);
									}
									dx = cx_n;
									cx = cx_n;
								}
								psegArg06_n = SLICE(psegArg06_n, selector, 16);
								if (cx != 0x00)
								{
									bx_n -= cx;
									do
									{
										byte al_n = ds->*si_n;
										(ss->*di_n).b0000 = al_n;
										ci8 v45_n = bLoc16_n - 0x01;
										psegArg06_n = SLICE(psegArg06_n, selector, 16);
										ax = DPB(ax, al_n, 0);
										si_n = (word32) si_n + 0x01;
										++di_n;
										bLoc16_n = v45_n;
										if (v45_n <= 0x00)
											di_n = fn0800-9858(cx, dx, bx_n, fp - 0x02, di_n, es_n);
										psegArg06_n = SLICE(psegArg06_n, selector, 16);
										--cx;
										Mem812 = Mem821;
										Mem1113 = Mem821;
									} while (cx != 0x00);
								}
								psegArg06_n = SLICE(psegArg06_n, selector, 16);
								bx = bx_n;
								if (bx_n > 0x00)
								{
									cx = bx_n;
									do
									{
										psegArg06_n = SLICE(ptrArg04_n, selector, 16);
										ax = DPB(ax, 0x20, 0);
										di_n = fn0800-984F(0x20, cx, dx, bx_n, fp - 0x02, di_n, es_n);
										sp_n = (word32) sp_n + 0x0000FFFE;
										--cx;
										ptrArg04_n = psegArg06_n;
									} while (cx != 0x00);
								}
								goto l0800_n;
							}
							if (wLoc10_n <= 0x00)
							{
								wLoc10_n.u0 = 0x01;
								Mem617 = Mem606;
							}
						}
						goto l0800_nBCC;
					case 0x12:
						struct Eq_n Eq_n::* di_n;
						Eq_n es_n;
						if ((wLoc04_n & 0x20) == 0x00)
						{
							di_n = ss->*wArg02;
							union Eq_n Eq_n::* sp_n = sp_n - 0x02;
							ss->*sp_n = ds;
							wArg02 = (word32) wArg02 + 0x02;
							es_n = ss->*sp_n;
						}
						else
						{
							Eq_n es_di_n = ds->*wArg02;
							es_n = SLICE(es_di_n, selector, 16);
							di_n = (word16) es_di_n;
							wArg02 = (word32) wArg02 + 0x04;
						}
						Eq_n ax_n = DPB(0x50, 0x50 - bLoc16_n, 0);
						(es_n->*di_n).t0000 = ax_n;
						ax = ax_n;
						if ((wLoc04_n & 0x10) != 0x00)
							(es_n->*di_n).w0002 = 0x00;
						goto l0800_n;
					case 0x13:
					case 0x14:
					case 0x15:
l0800_nC82:
						byte Eq_n::* si_n = si_n;
						es_n = psegArg06_n;
						byte al_n = 0x25;
						do
						{
							di_n = fn0800-984F(al_n, cx, dx, bx, fp - 0x02, di_n, psegArg06_n);
							byte al_n = ds->*si_n;
							sp_n = (word32) sp_n + 0x0000FFFE;
							++si_n;
							al_n = al_n;
						} while (al_n != 0x00);
						goto l0800_nC96;
					case 22:
						wLoc04_n &= ~0x20;
						Mem994 = Mem88;
						break;
					case 0x17:
						wLoc04_n |= 0x20;
						Mem994 = Mem84;
						break;
					}
					ch_n = 0x05;
					cx_n = DPB(cx_n, 0x05, 8);
l0800_nDB:
					cx_n = DPB(cx_n, ch_n, 8);
					ax_n = (word16) DPB(ax_n, ds->*si_n, 0);
					++si_n;
				}
l0800_nFE:
				goto l0800_nC82;
			}
		}
		(ss->*di_n).b0000 = al_n;
		ci8 v16_n = bLoc16_n - 0x01;
		ax = DPB(ax_n, al_n, 0);
		++di_n;
		bLoc16_n = v16_n;
		Mem36 = Mem1085;
		if (v16_n <= 0x00)
		{
			di_n = fn0800-9858(cx, dx, bx, fp - 0x02, di_n, es_n);
			Mem36 = Mem1085;
		}
	}
l0800_nC96:
	if (bLoc16_n < 0x50)
		fn0800-9858(cx, dx, bx, fp - 0x02, di_n, es_n);
	Eq_n ax_n;
	struct Eq_n Eq_n::* sp_n = (word32) sp_n + 0x02;
	if (0x00 != 0x00)
		ax_n.u0 = ~0x00;
	else
		ax_n.u0 = 0x00;
	ptr16 di_n = (ss->*sp_n).ptr0000;
	siOut = (ss->*sp_n).ptr0002;
	diOut = di_n;
	return ax_n;
}

// 0800:9842: Register word16 fn0800-9842(Register Eq_n di, Register Eq_n es)
word16 fn0800-9842(Eq_n di, Eq_n es)
{
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		di = (word16) di_n + 0x01;
		--cx_n;
		di_n = di;
		if (es->*di_n != 0x00)
			return ~cx_n - 0x01;
	}
	return ~cx_n - 0x01;
}

// 0800:984F: Register (memptr Eq_n Eq_n) fn0800-984F(Register byte al, Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register (memptr Eq_n Eq_n) bp, Register (memptr Eq_n Eq_n) di, Register Eq_n es)
struct Eq_n Eq_n::* fn0800-984F(byte al, Eq_n cx, Eq_n dx, Eq_n bx, struct Eq_n Eq_n::* bp, struct Eq_n Eq_n::* di, Eq_n es)
{
	(ss->*di).b0000 = al;
	Eq_n v8_n = ss->*(bp - 0x14) - 0x01;
	ss->*(bp - 0x14) = v8_n;
	if (v8_n != 0x00)
		return di + 0x01;
	return fn0800-9858(cx, dx, bx, bp, di + 0x01, es);
}

// 0800:9858: Register (memptr Eq_n Eq_n) fn0800-9858(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register (memptr Eq_n Eq_n) bp, Register (memptr Eq_n Eq_n) di, Register Eq_n es)
struct Eq_n Eq_n::* fn0800-9858(Eq_n cx, Eq_n dx, Eq_n bx, struct Eq_n Eq_n::* bp, struct Eq_n Eq_n::* di, Eq_n es)
{
	word16 di_n = di - (bp - 0x96);
	word16 ax_n;
	(seg0800->*(ss->*bp).ptr000E)();
	if (ax_n == 0x00)
		(ss->*(bp - 22)).t0000.u1 = 0x01;
	(ss->*(bp - 0x14)).t0000.u1 = 0x50;
	(ss->*(bp - 0x12)).t0000.u1 = (word16) (ss->*(bp - 0x12)).t0000.u1 + di_n;
	return bp - 0x96;
}

// 0800:9CE6: Register word16 fn0800-9CE6(Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out Eq_n dxOut)
word16 fn0800-9CE6(Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, union Eq_n & dxOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n ax_n = fn0800_BFC7(SEQ(wArg08, wArg06), stackArg4, out cx_n);
	Eq_n stackArg4 = <invalid>;
	fn0800_B03B(SEQ(wArg04, wArg02), stackArg4, SEQ(wArg08, wArg06), (word32) ax_n + 0x01);
	dxOut = wArg04;
	return wArg02 + ax_n;
}

// 0800:9D41: Register word16 fn0800-9D41(Register Eq_n dx, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut)
word16 fn0800-9D41(Eq_n dx, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut)
{
	Eq_n ds_n;
	Eq_n wLoc02_n;
	if (dx != seg0800->t9D35)
	{
		Eq_n ds_n = *((word32) dx + 0x02);
		if (*((word32) ds_n + 0x02) != 0x00)
		{
			seg0800->t9D37 = ds_n;
l0800_nD94:
			ds_n = seg0800->t9D3B;
			wLoc02_n = dx;
			goto l0800_nD9D;
		}
		if (ds_n != seg0800->t9D35)
		{
			seg0800->t9D37 = *((word32) ds_n + 0x08);
			fn0800-9E15(ds_n);
			wLoc02_n = ds_n;
			ds_n = seg0800->t9D3B;
l0800_nD9D:
			ptr16 bx_n;
			ptr16 cx_n;
			ptr16 dx_n;
			word16 ax_n = fn0800_A1D6(ds_n, 0x00, wLoc02_n, out cx_n, out dx_n, out bx_n);
			cxOut = cx_n;
			dxOut = dx_n;
			bxOut = bx_n;
			return ax_n;
		}
		dx = seg0800->t9D35;
	}
	seg0800->t9D35.u0 = 0x00;
	seg0800->t9D37.u0 = 0x00;
	seg0800->t9D39.u0 = 0x00;
	goto l0800_nD94;
}

// 0800:9DA4: Register Eq_n fn0800-9DA4(Register Eq_n dx, Register out Eq_n bxOut)
Eq_n fn0800-9DA4(Eq_n dx, union Eq_n & bxOut)
{
	Eq_n bx_n;
	Eq_n es_n = *((word32) dx + 0x02);
	((word32) dx + 0x02)->u0 = 0x00;
	*((word32) dx + 0x08) = es_n;
	Eq_n wLoc02_n = dx;
	if (dx != seg0800->t9D35 && *((word32) es_n + 0x02) == 0x00)
	{
		Eq_n ax_n = *dx;
		Mem31[es_n:0x00:word16] = Mem29[es_n:0x00:word16] + ax_n;
		bx_n = dx;
		wLoc02_n = es_n;
		word16 dx_n = dx + ax_n;
		if (dx_n->t0002 == 0x00)
			dx_n->t0008 = es_n;
		else
			dx_n->t0002 = es_n;
	}
	else
		bx_n = fn0800-9E3E(dx);
	word16 ax_n = wLoc02_n + Mem43[wLoc02_n:0x00:word16];
	if (*((word16) ax_n + 0x02) == 0x00)
	{
		Mem54[wLoc02_n:0x00:word16] = Mem43[wLoc02_n:0x00:word16] + Mem43[ax_n:0x00:word16];
		Mem60[ax_n + Mem54[ax_n:0x00:word16]:0x02:word16] = wLoc02_n;
		bxOut = fn0800-9E15(ax_n);
		return wLoc02_n;
	}
	else
	{
		bxOut = bx_n;
		return ax_n;
	}
}

// 0800:9E15: Register word16 fn0800-9E15(Register Eq_n ds)
word16 fn0800-9E15(Eq_n ds)
{
	if (ds == *((word32) ds + 0x06))
	{
		seg0800->t9D39.u0 = 0x00;
		return;
	}
	else
	{
		Eq_n es_n = *((word32) ds + 0x06);
		Eq_n ds_n = *((word32) ds + 0x04);
		*((word32) ds_n + 0x06) = es_n;
		*((word32) es_n + 0x04) = ds_n;
		seg0800->t9D39 = ds_n;
		return;
	}
}

// 0800:9E3E: Register (ptr16 Eq_n) fn0800-9E3E(Register Eq_n ds)
struct Eq_n * fn0800-9E3E(Eq_n ds)
{
	Eq_n ax_n = seg0800->t9D39;
	if (ax_n == 0x00)
	{
		seg0800->t9D39 = ds;
		*((word32) ds + 0x04) = ds;
		*((word32) ds + 0x06) = ds;
		return bx;
	}
	else
	{
		__cli();
		Eq_n es_n = *((word32) ax_n + 0x06);
		*((word32) ax_n + 0x06) = ds;
		*((word32) ds + 0x04) = ax_n;
		*((word32) es_n + 0x04) = ds;
		*((word32) ds + 0x06) = es_n;
		return ss;
	}
}

// 0800:9E75: Register word16 fn0800-9E75(Register Eq_n ds, Stack Eq_n wArg04, Register out ptr16 cxOut, Register out Eq_n dxOut, Register out ptr16 bxOut, Register out Eq_n dsOut)
word16 fn0800-9E75(Eq_n ds, Eq_n wArg04, ptr16 & cxOut, union Eq_n & dxOut, ptr16 & bxOut, union Eq_n & dsOut)
{
	seg0800->t9D3B = ds;
	Eq_n dx_n = wArg04;
	if (wArg04 != 0x00)
	{
		if (wArg04 == seg0800->t9D37)
			ax = fn0800-9D41(wArg04, out cx, out dx_n, out bx);
		else
			ax = fn0800-9DA4(wArg04, out bx);
	}
	Eq_n ds_n = seg0800->t9D3B;
	cxOut = cx;
	dxOut = dx_n;
	bxOut = bx;
	dsOut = ds_n;
	return ax;
}

// 0800:9E9E: Register Eq_n fn0800-9E9E(Register Eq_n ax, Register out Eq_n dxOut)
Eq_n fn0800-9E9E(Eq_n ax, union Eq_n & dxOut)
{
	cui16 ax_n = fn0800_A215(seg0800->t9D3B, 0x00, 0x00, out dx_n);
	if ((ax_n & 0x0F) != 0x00)
		fn0800_A215(seg0800->t9D3B, 0x10 - (ax_n & 0x0F), 0x00, out dx_n);
	Eq_n dx_n;
	if (fn0800_A215(seg0800->t9D3B, ax << 0x04, (word16) SLICE(ax, byte, 8) >> 0x04, out dx_n) == ~0x00)
	{
		dxOut.u0 = 0x00;
		return 0x00;
	}
	else
	{
		seg0800->t9D35 = dx_n;
		seg0800->t9D37 = dx_n;
		*dx_n = ax;
		*((word32) dx_n + 0x02) = dx_n;
		dxOut = dx_n;
		return 0x04;
	}
}

// 0800:9F02: Register Eq_n fn0800-9F02(Register Eq_n ax, Register out Eq_n dxOut)
Eq_n fn0800-9F02(Eq_n ax, union Eq_n & dxOut)
{
	byte ah_n = SLICE(ax, byte, 8);
	Eq_n ds_n = seg0800->t9D3B;
	Eq_n dx_n;
	cui16 ax_n = fn0800_A215(ds_n, ax << 0x04, (word16) ah_n >> 0x04, out dx_n);
	if (ax_n != ~0x00)
	{
		if ((ax_n & 0x0F) == 0x00)
		{
l0800_nF25:
			Eq_n cx_n = seg0800->t9D37;
			seg0800->t9D37 = dx_n;
			*dx_n = ax;
			*((word32) dx_n + 0x02) = cx_n;
			dxOut = dx_n;
			return 0x04;
		}
		if (fn0800_A215(ds_n, -(ax_n & 0x0F) + 0x10, 0x00, out dx_n) != ~0x00)
		{
			dx_n = (word32) dx_n + 0x01;
			goto l0800_nF25;
		}
	}
	dxOut.u0 = 0x00;
	return 0x00;
}

// 0800:9F5C: Register Eq_n fn0800-9F5C(Register Eq_n ax, Register Eq_n dx, Register Eq_n ds, Register out (ptr16 Eq_n) dxOut)
Eq_n fn0800-9F5C(Eq_n ax, Eq_n dx, Eq_n ds, struct Eq_n & dxOut)
{
	*ds -= ax;
	struct Eq_n * dx_n = (word32) dx + *ds;
	dx_n->t0000 = ax;
	dx_n->t0002 = dx;
	Mem19[dx_n + Mem14[dx_n:0x00:word16]:0x02:word16] = dx_n;
	dxOut = dx_n;
	return 0x04;
}

// 0800:9F7F: Register word16 fn0800-9F7F(Stack Eq_n wArg02, Register out ptr16 dxOut, Register out Eq_n bpOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-9F7F(Eq_n wArg02, ptr16 & dxOut, union Eq_n & bpOut, ptr16 & siOut, ptr16 & diOut, struct Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n bp_n;
	struct Eq_n * ds_n;
	ptr16 dx_n;
	ptr16 di_n;
	ptr16 si_n;
	word16 ax_n = fn0800-9F92(stackArg0, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	dxOut = dx_n;
	bpOut = bp_n;
	siOut = si_n;
	diOut = di_n;
	dsOut = ds_n;
	return ax_n;
}

// 0800:9F89: Register word16 fn0800-9F89(Stack Eq_n wArg02, Stack Eq_n wArg04, Register out ptr16 dxOut, Register out ptr16 bpOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out (ptr16 Eq_n) dsOut)
word16 fn0800-9F89(Eq_n wArg02, Eq_n wArg04, ptr16 & dxOut, ptr16 & bpOut, ptr16 & siOut, ptr16 & diOut, struct Eq_n & dsOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	ptr16 bp_n;
	struct Eq_n * ds_n;
	ptr16 dx_n;
	ptr16 di_n;
	ptr16 si_n;
	word16 ax_n = fn0800-9F92(stackArg0, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	dxOut = dx_n;
	bpOut = bp_n;
	siOut = si_n;
	diOut = di_n;
	dsOut = ds_n;
	return ax_n;
}

// 0800:9F92: Register cu16 fn0800-9F92(Stack Eq_n wArg00, Register out Eq_n dxOut, Register out Eq_n bpOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
cu16 fn0800-9F92(Eq_n wArg00, union Eq_n & dxOut, union Eq_n & bpOut, ptr16 & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	seg0800->t9D3B = ds;
	if ((ax | dx) == 0x00)
	{
		Eq_n ds_n = seg0800->t9D3B;
		dxOut = dx;
		bpOut = wArg00;
		siOut = si;
		diOut = di;
		dsOut = ds_n;
		return ax;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		Eq_n bp_n;
		ptr16 di_n;
		Eq_n ds_n;
		Eq_n dx_n;
		ptr16 si_n;
		cu16 ax_n = fn0800-9F9F(ax, dx, stackArg0, stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
		dxOut = dx_n;
		bpOut = bp_n;
		siOut = si_n;
		diOut = di_n;
		dsOut = ds_n;
		return ax_n;
	}
}

// 0800:9F9F: Register cu16 fn0800-9F9F(Register cu16 ax, Register Eq_n dx, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n dxOut, Register out Eq_n bpOut, Register out Eq_n siOut, Register out Eq_n diOut, Register out Eq_n dsOut)
cu16 fn0800-9F9F(cu16 ax, Eq_n dx, Eq_n wArg00, Eq_n wArg02, Eq_n wArg04, union Eq_n & dxOut, union Eq_n & bpOut, union Eq_n & siOut, union Eq_n & diOut, union Eq_n & dsOut)
{
	cu16 ax_n;
	Eq_n dx_n;
	word16 dx_n = dx + (ax <u 0x13);
	if (dx_n >= 0x00 && (dx_n & ~0x0F) == 0x00)
	{
		uint16 ax_n = ax + 0x13 >> 0x04;
		Eq_n ax_n = DPB(ax_n, SLICE(ax_n, byte, 8) | (byte) (dx_n << 0x04), 8);
		if (seg0800->t9D35 != 0x00)
		{
			Eq_n dx_n = seg0800->t9D39;
			dx_n = dx_n;
			if (dx_n != 0x00)
			{
				do
				{
					if (*dx_n >= ax_n)
					{
						if (*dx_n <= ax_n)
						{
							fn0800-9E15(dx_n);
							*((word32) dx_n + 0x02) = *((word32) dx_n + 0x08);
							ax_n = 0x04;
						}
						else
							ax_n = fn0800-9F5C(ax_n, dx_n, dx_n, out dx_n);
						goto l0800_nFFD;
					}
					dx_n = *((word32) dx_n + 0x06);
				} while (dx_n != dx_n);
			}
			ax_n = fn0800-9F02(ax_n, out dx_n);
		}
		else
			ax_n = fn0800-9E9E(ax_n, out dx_n);
	}
	else
	{
		ax_n = 0x00;
		dx_n.u0 = 0x00;
	}
l0800_nFFD:
	Eq_n ds_n = seg0800->t9D3B;
	dxOut = dx_n;
	bpOut = wArg04;
	siOut = wArg02;
	diOut = wArg00;
	dsOut = ds_n;
	return ax_n;
}

// 0800:A006: void fn0800_A006(Register Eq_n bx)
void fn0800_A006(Eq_n bx)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg2 = <invalid>;
	Eq_n stackArg4 = <invalid>;
	struct Eq_n * dx_n;
	fn0800-9F89(stackArg2, stackArg4, out dx_n, out bp_n, out si_n, out di_n, out ds_n);
	if (dx_n == 0x00)
		return;
	word16 dx_n = *bx;
	word16 Eq_n::* di_n = Eq_n::a0004;
	word16 si_n = 0x04;
	word16 cx_n;
	for (cx_n = 0x06; cx_n != 0x00; --cx_n)
	{
		dx_n->*di_n = bx->*si_n;
		++si_n;
		++di_n;
	}
	cu16 dx_n = dx_n - 0x01;
	if (dx_n != 0x01)
	{
		struct Eq_n * es_n = (char *) dx_n + 0x01;
		struct Eq_n * ds_n = (word32) bx + 0x01;
		while (true)
		{
			word16 Eq_n::* di_n = Eq_n::a0000;
			word16 Eq_n::* si_n = &Eq_n::t0000;
			cu16 cx_n = dx_n;
			if (dx_n > 0x1000)
				cx_n = 0x1000;
			ui16 cx_n;
			for (cx_n = cx_n << 0x03; cx_n != 0x00; --cx_n)
			{
				es_n->*di_n = ds_n->*si_n;
				++si_n;
				++di_n;
			}
			dx_n -= 0x1000;
			if (dx_n <= 0x00)
				break;
			es_n = (struct Eq_n *) (es_n->a0000 + 0x0800);
			ds_n = (struct Eq_n *) ((char *) &ds_n->t0000 + 0x00001000);
		}
	}
	fn0800-9E75(seg0800->t9D3B, bx, out cx_n, out dx_n, out bx_n, out ds_n);
}

// 0800:A080: void fn0800_A080(Register int16 ax, Register int16 cx, Register Eq_n bx, Register Eq_n ds)
void fn0800_A080(int16 ax, int16 cx, Eq_n bx, Eq_n ds)
{
	if (bx == seg0800->t9D37)
	{
		*bx = ax;
		fn0800_A1D6(ds, 0x00, (word32) bx + ax, out cx_n, out dx_n, out bx_n);
	}
	else
	{
		Eq_n di_n = (word32) bx + ax;
		*di_n = cx - ax;
		*((word32) di_n + 0x02) = bx;
		*bx = ax;
		struct Eq_n * dx_n = (word32) bx + cx;
		if (dx_n->t0002 != 0x00)
			dx_n->t0002 = di_n;
		else
			dx_n->t0008 = di_n;
		fn0800-9E75(ds, di_n, out cx_n, out dx_n, out bx_n, out ds_n);
	}
}

// 0800:A162: Register word16 fn0800_A162(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n cxOut, Register out Eq_n dxOut, Register out ptr16 bxOut)
word16 fn0800_A162(Eq_n ds, Eq_n wArg02, Eq_n wArg04, union Eq_n & cxOut, union Eq_n & dxOut, ptr16 & bxOut)
{
	Eq_n dx_n;
	word16 ax_n;
	Eq_n cx_n = DPB(cx, 0x06, 0);
	uint16 si_n = (word32) wArg04 + 0x01 - *((word32) ds + 0x007B) + 0x3F >> 0x06;
	if (si_n != *((word32) ds + 9880))
	{
		Eq_n si_n = si_n << 0x06;
		Eq_n dx_n = *((word32) ds + 0x0091);
		Eq_n ax_n = *((word32) ds + 0x007B) + (si_n << 0x06);
		if (ax_n > dx_n)
			si_n = dx_n - *((word32) ds + 0x007B);
		Eq_n ax_n = fn0800_A401(ax_n, ds, *((word32) ds + 0x007B), si_n, out bx);
		cx_n = si_n;
		dx_n = ax_n;
		if (ax_n != ~0x00)
		{
			Mem54[ds:0x91:word16] = Mem39[ds:0x7B:word16] + ax_n;
			((word32) ds + 0x008F)->u1 = 0x00;
			ax_n = 0x00;
l0800_A1D1:
			cxOut = cx_n;
			dxOut = dx_n;
			bxOut = bx;
			return ax_n;
		}
		*((word32) ds + 9880) = si_n >> 0x06;
		cx_n = DPB(si_n, 0x06, 0);
	}
	*((word32) ds + 141) = wArg04;
	*((word32) ds + 0x008B) = wArg02;
	dx_n = wArg02;
	ax_n = 0x01;
	goto l0800_A1D1;
}

// 0800:A1D6: Register word16 fn0800_A1D6(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut)
word16 fn0800_A1D6(Eq_n ds, Eq_n wArg02, Eq_n wArg04, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut)
{
	word16 ax_n;
	Eq_n bx_n = *((word32) ds + 0x0087);
	ptr16 bx_n;
	ptr16 cx_n;
	ptr16 dx_n;
	fn0800-8F2F((byte) wArg02, wArg02, *((word32) ds + 0x0089), wArg04, (byte) bx_n, bx_n, out cx_n, out dx_n, out bx_n);
	Eq_n C_n = <invalid>;
	if (!C_n)
	{
		Eq_n bx_n = *((word32) ds + 0x008F);
		fn0800-8F2F((byte) wArg02, wArg02, *((word32) ds + 0x0091), wArg04, (byte) bx_n, bx_n, out cx_n, out dx_n, out bx_n);
		Eq_n Z_n = <invalid>;
		Eq_n C_n = <invalid>;
		if (!(Z_n | C_n) && fn0800_A162(ds, wArg02, wArg04, out cx_n, out dx_n, out bx_n) != 0x00)
		{
			ax_n = 0x00;
l0800_A213:
			cxOut = cx_n;
			dxOut = dx_n;
			bxOut = bx_n;
			return ax_n;
		}
	}
	ax_n = ~0x00;
	goto l0800_A213;
}

// 0800:A215: Register Eq_n fn0800_A215(Register Eq_n ds, Stack Eq_n dwArg02, Stack uint16 wArg04, Register out Eq_n dxOut)
Eq_n fn0800_A215(Eq_n ds, Eq_n dwArg02, uint16 wArg04, union Eq_n & dxOut)
{
	Eq_n dx_n;
	Eq_n ax_n;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	word16 dx_n;
	word16 ax_n = fn0800-8C69(*((word32) ds + 141), 0x04, 0x00, stackArg0, out cl_n, out dx_n) + Mem7[ds:0x8B:word16];
	ui32 dwArg02_n = SEQ(wArg04, wArg02);
	ui32 dx_ax_n = SEQ(dx_n + (ax_n < 0x00), ax_n) + dwArg02_n;
	ci16 wArg04_n = SLICE(dwArg02_n, word16, 16);
	wArg04_n = SLICE(dwArg02_n, word16, 16);
	Eq_n wArg02_n = SLICE(dwArg02_n, word16, 0);
	wArg02_n = SLICE(dwArg02_n, word16, 0);
	cup16 ax_n = (word16) dx_ax_n;
	ci16 dx_n = SLICE(dx_ax_n, word16, 16);
	if (dx_n < 0x0F || dx_n <= 0x0F && ax_n <= ~0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-8CCB(*((word32) ds + 0x008B), wArg04_n, *((word32) ds + 141), wArg02_n, stackArg0, out ch_n, out dx_n);
		Eq_n bx_n = *((word32) ds + 0x0087);
		fn0800-8F2F((byte) ax_n, ax_n, *((word32) ds + 0x0089), dx_n, (byte) bx_n, bx_n, out cx_n, out dx_n, out bx_n);
		Eq_n sp_n = <invalid>;
		Eq_n C_n = <invalid>;
		if (!C_n)
		{
			Eq_n bx_n = *((word32) ds + 0x008F);
			fn0800-8F2F((byte) ax_n, ax_n, *((word32) ds + 0x0091), dx_n, (byte) bx_n, bx_n, out cx_n, out dx_n, out bx_n);
			Eq_n Z_n = <invalid>;
			Eq_n C_n = <invalid>;
			if (!(Z_n | C_n))
			{
				Eq_n ax_n = *((word32) ds + 141);
				Eq_n dx_n = *((word32) ds + 0x008B);
				ss->*(sp_n - 0x02) = dx_n;
				ss->*(sp_n - 0x04) = ax_n;
				if (fn0800_A162(ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n) != 0x00)
				{
					dx_n = ax_n;
					ax_n = dx_n;
l0800_A29F:
					dxOut = dx_n;
					return ax_n;
				}
			}
		}
	}
	dx_n.u0 = ~0x00;
	ax_n.u0 = ~0x00;
	goto l0800_A29F;
}

// 0800:A2A3: Register Eq_n fn0800_A2A3(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n bArg05, Stack Eq_n ptrArg06, Stack Eq_n wArg0A, Register out Eq_n cxOut)
Eq_n fn0800_A2A3(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n bArg05, Eq_n ptrArg06, Eq_n wArg0A, union Eq_n & cxOut)
{
	byte bArg05_n = SLICE(wArg04, byte, 8);
	msdos_unknown_n();
	Eq_n dx_n = (word16) ptrArg06;
	Eq_n ax_n = DPB(DPB(ax, 0x44, 8), bArg04, 0);
	byte bArg05_n = SLICE(SEQ(bArg05_n, bArg04), byte, 8);
	if (!C)
	{
		if (SEQ(bArg05_n, bArg04) == 0x00)
			ax_n = dx_n;
	}
	else
		ax_n = fn0800-8D2B(ds, ax_n);
	cxOut = wArg0A;
	return ax_n;
}

// 0800:A2CC: void fn0800_A2CC(Register Eq_n ds)
void fn0800_A2CC(Eq_n ds)
{
	(*((word32) ds + 9972))();
}

// 0800:A2D0: void fn0800_A2D0(Register Eq_n ds)
void fn0800_A2D0(Eq_n ds)
{
	(*((word32) ds + 0x000026F6))();
}

// 0800:A2D4: Register int8 fn0800_A2D4(Register Eq_n ds)
int8 fn0800_A2D4(Eq_n ds)
{
	int8 Top_n;
	(*((word32) ds + 9976))();
	return Top_n;
}

// 0800:A2D8: Register int8 fn0800_A2D8(Register Eq_n ds)
int8 fn0800_A2D8(Eq_n ds)
{
	int8 Top_n;
	(*((word32) ds + 9978))();
	return Top_n;
}

// 0800:A36D: void fn0800_A36D(Register word16 ax, Register word16 cx, Register (memptr (ptr16 Eq_n) Eq_n) si, Register (memptr (ptr16 Eq_n) byte) di, Register (ptr16 Eq_n) es, Register (ptr16 Eq_n) ds)
void fn0800_A36D(word16 ax, word16 cx, struct Eq_n Eq_n::* si, byte Eq_n::* di, struct Eq_n * es, struct Eq_n * ds)
{
	byte al_n = (byte) ax;
	if (ax != 0x00)
		es->*di = al_n;
	if (cx != 0x00)
	{
		byte al_n = (ds->*si).b0000;
		if (al_n != 0x22)
		{
			if (al_n == 0x5C)
				(ds->*si).b0001 != 0x22;
		}
	}
}

// 0800:A401: Register ptr16 fn0800_A401(Register Eq_n al, Register Eq_n ds, Stack (ptr16 Eq_n) psegArg02, Stack Eq_n wArg04, Register out ptr16 bxOut)
ptr16 fn0800_A401(Eq_n al, Eq_n ds, struct Eq_n * psegArg02, Eq_n wArg04, ptr16 & bxOut)
{
	ptr16 ax_n;
	Eq_n ax_n = DPB(ax, 0x4A, 8);
	ptr16 bx_n;
	if (!msdos_resize_memory_block(psegArg02, wArg04, out bx_n))
		ax_n = ~0x00;
	else
	{
		fn0800-8D2B(ds, ax_n);
		ax_n = bx_n;
	}
	bxOut = bx_n;
	return ax_n;
}

// 0800:A471: Register uint16 fn0800_A471(Register Eq_n ds, Stack segptr32 ptrArg02, Register out Eq_n dxOut, Register out Eq_n bpOut)
uint16 fn0800_A471(Eq_n ds, segptr32 ptrArg02, union Eq_n & dxOut, union Eq_n & bpOut)
{
	struct Eq_n Eq_n::* sp_n = fp - 0x0A;
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* si_n = (word16) ptrArg02;
	uint16 ax_n = 0x00;
	Eq_n dx_n = 0x00;
	uint16 cx_n = 0x0A;
	struct Eq_n Eq_n::* bx_n = DPB(bx, 0x00, 8);
	do
	{
		cu8 bl_n = es_n->*si_n;
		bx_n = DPB(bx_n, bl_n, 0);
		uint16 bx_n = DPB(bx_n, bl_n, 0);
		bx_n = (uint16) DPB(bx_n, bl_n, 0);
		++si_n;
	} while (((ds->*bx_n).b2251 & 0x01) != 0x00);
	ci16 bp_n = 0x00;
	if (bl_n != 0x2B)
	{
		if (bl_n != 0x2D)
		{
l0800_A4A2:
			if (bl_n > 0x39)
			{
l0800_A4D6:
				if (bp_n >= 0x01)
				{
					ax_n = -ax_n;
					dx_n = -dx_n - (ax_n == 0x00);
				}
				Eq_n bp_n = (ss->*sp_n).t0008;
				dxOut = dx_n;
				bpOut = bp_n;
				return ax_n;
			}
			cu8 bl_n = bl_n - 0x30;
			bx_n = DPB(bx_n, bl_n, 0);
			if (bl_n < 0x00)
				goto l0800_A4D6;
			Eq_n dx_ax_n = cx_n * ax_n;
			ui32 dl_ax_n = dx_ax_n + SEQ(SLICE(dx_ax_n, byte, 24), bx_n);
			byte dl_n = SLICE(dl_ax_n, byte, 16);
			ax_n = (word16) dl_ax_n;
			dx_n = DPB(SLICE(dx_ax_n, word16, 16), dl_n, 0);
			if (dl_n != 0x00)
			{
				while (true)
				{
					cu8 bl_n = es_n->*si_n;
					++si_n;
					if (bl_n > 0x39)
						break;
					bx_n = DPB(bx_n, bl_n - 0x30, 0);
					if (bl_n < 0x30)
						break;
					Eq_n dx_ax_n = ax_n * 0x0A;
					int32 dx_ax_n = SEQ((word16) (dx_n * 0x0A), (word16) dx_ax_n) + SEQ(SLICE(dx_ax_n, word16, 16), bx_n);
					ax_n = (word16) dx_ax_n;
					dx_n = SLICE(dx_ax_n, word16, 16);
				}
				goto l0800_A4D6;
			}
			goto l0800_A49E;
		}
		bp_n = 0x01;
	}
l0800_A49E:
	bl_n = es_n->*si_n;
	bx_n = DPB(bx_n, bl_n, 0);
	++si_n;
	goto l0800_A4A2;
}

// 0800:A4F6: void fn0800_A4F6(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06)
void fn0800_A4F6(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg8 = <invalid>;
	if (fn0800_A53C(ds, SEQ(wArg04, wArg02), 0x00, stackArg8, out cx_n) == ~0x00)
		return;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg8 = <invalid>;
	if (fn0800_A53C(ds, SEQ(wArg04, wArg02), 0x01, stackArg8, out cx_n) == ~0x00)
		;
}

// 0800:A53C: Register Eq_n fn0800_A53C(Register Eq_n ds, Stack segptr32 ptrArg02, Stack byte bArg06, Stack Eq_n wArg08, Register out Eq_n cxOut)
Eq_n fn0800_A53C(Eq_n ds, segptr32 ptrArg02, byte bArg06, Eq_n wArg08, union Eq_n & cxOut)
{
	Eq_n ax_n;
	msdos_unknown_n();
	Eq_n cx_n = wArg08;
	Eq_n ax_n = DPB(DPB(ax, 0x43, 8), bArg06, 0);
	if (!C)
	{
		ax_n = wArg08;
		cx_n = ax_n;
	}
	else
		ax_n = fn0800-8D2B(ds, ax_n);
	cxOut = cx_n;
	return ax_n;
}

// 0800:A559: Register Eq_n fn0800_A559(Register Eq_n ax, Register Eq_n ds, Stack Eq_n wArg02, Register out Eq_n dxOut)
Eq_n fn0800_A559(Eq_n ax, Eq_n ds, Eq_n wArg02, union Eq_n & dxOut)
{
	Eq_n ax_n;
	if (wArg02 >= *((word32) ds + 9448))
		ax_n = fn0800-8D2B(ds, 0x06);
	else
	{
		SEQ(ds, 0x24EA)[wArg02 * 0x02] = 0x00;
		ax_n = fn0800_A57F(ax, ds, wArg02);
	}
	dxOut = wArg02;
	return ax_n;
}

// 0800:A57F: Register Eq_n fn0800_A57F(Register Eq_n al, Register Eq_n ds, Stack Eq_n wArg02)
Eq_n fn0800_A57F(Eq_n al, Eq_n ds, Eq_n wArg02)
{
	Eq_n ax_n;
	Eq_n ax_n = DPB(ax, 0x3E, 8);
	if (!msdos_close_file(wArg02))
	{
		SEQ(ds, 0x24EA)[wArg02 * 0x02] = 0x00;
		ax_n.u0 = 0x00;
	}
	else
		ax_n = fn0800-8D2B(ds, ax_n);
	return ax_n;
}

// 0800:A59D: Register Eq_n fn0800_A59D(Register Eq_n ds, Stack Eq_n wArg02, Register out ptr16 dxOut)
Eq_n fn0800_A59D(Eq_n ds, Eq_n wArg02, ptr16 & dxOut)
{
	Eq_n wLoc08_n;
	Eq_n ax_n;
	if (wArg02 >= *((word32) ds + 9448))
	{
		wLoc08_n.u0 = 0x06;
		goto l0800_A60D;
	}
	if ((SEQ(ds, 0x24EA)[wArg02 * 0x02] & 0x0200) != 0x00)
	{
l0800_A5BF:
		ax_n.u0 = 0x01;
		goto l0800_A610;
	}
	byte dl_n = (byte) dx;
	Eq_n ax_n = 0x4400;
	dx = DPB(dx, dl_n, 0);
	if (!msdos_ioctl_get_device_info(wArg02, out dx))
	{
		if ((dl_n & 0x80) != 0x00)
		{
l0800_A608:
			ax_n.u0 = 0x00;
l0800_A610:
			dxOut = dx;
			return ax_n;
		}
		ax_n.u0 = 0x4201;
		dx = 0x00;
		if (!msdos_set_file_position(wArg02, 0x00, 0x01, 0x4201))
		{
			ax_n.u0 = 0x4202;
			dx = 0x4201;
			if (!msdos_set_file_position(wArg02, 0x00, 0x02, 0x4202))
			{
				ax_n.u0 = 0x4200;
				if (!msdos_set_file_position(wArg02, 0x4201, 0x00, 0x42014200))
				{
					if (true && (false || true))
						goto l0800_A5BF;
					goto l0800_A608;
				}
			}
		}
	}
	wLoc08_n = ax_n;
l0800_A60D:
	ax_n = fn0800-8D2B(ds, wLoc08_n);
	goto l0800_A610;
}

// 0800:A614: Register word16 fn0800_A614(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out Eq_n cxOut, Register out ptr16 dxOut, Register out Eq_n bpOut, Register out Eq_n siOut, Register out ptr16 diOut, Register out Eq_n dsOut)
word16 fn0800_A614(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, union Eq_n & cxOut, ptr16 & dxOut, union Eq_n & bpOut, union Eq_n & siOut, ptr16 & diOut, union Eq_n & dsOut)
{
	word16 wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	struct Eq_n Eq_n::* sp_n = fp - 0x04;
	word16 si_n = ~0x00;
	if (*((word32) ptrArg02 + 0x0012) == wArg02_n)
	{
		Eq_n bx_n = (word16) ptrArg02;
		if (*((word32) ptrArg02 + 0x06) != 0x00)
		{
			if (*ptrArg02 < 0x00)
			{
				Eq_n ax_n = fn0800_A6B7(ds, bx_n, wArg04_n, out dx, out bx_n, out bp_n);
				Eq_n sp_n = <invalid>;
				cx = ss->*((word32) sp_n + 0x02);
				sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
				if (ax_n != 0x00)
					goto l0800_A6B2;
			}
			struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
			if ((es_bx_n->w0002 & 0x04) != 0x00)
			{
				struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).t0000 = es_bx_n->t000A;
				(ss->*(sp_n - 0x02)).t0000 = es_bx_n->t0008;
				fn0800-9E75(ds, (ss->*sp_n).t0000, out cx_n, out dx, out bx_n, out ds);
				cx = (ss->*sp_n).t0000;
				sp_n = (struct Eq_n Eq_n::*) &sp_n->t0002;
			}
		}
		struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
		if (es_bx_n->b0004 >= 0x00)
		{
			Eq_n ax_n = (int16) es_bx_n->b0004;
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).t0000 = ax_n;
			word16 ax_n = fn0800_A559(ax_n, ds, (ss->*sp_n).t0000, out dx);
			cx = (ss->*sp_n).t0000;
			si_n = ax_n;
		}
		struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
		es_bx_n->w0002 = 0x00;
		es_bx_n->w0006 = 0x00;
		es_bx_n->w0000 = 0x00;
		es_bx_n->b0004 = ~0x00;
		if (es_bx_n->t0010 != 0x00)
		{
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x02)).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x04)).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x06)).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x08)).t0000 = es_bx_n->t0010;
			Eq_n dx_n;
			Eq_n ax_n = fn0800-8E6A(ds, (ss->*(sp_n - 0x08)).t0000, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out dx_n, out si_n, out di);
			(ss->*sp_n).t0000 = dx_n;
			(ss->*(sp_n - 0x02)).t0000 = ax_n;
			dx = fn0800-97F8(ax_n, ds, (ss->*(sp_n - 0x02)).t0000);
			cx = (ss->*sp_n).t0000;
			(ss->*bp_n).ptr0004->t0010.u0 = 0x00;
			sp_n = (struct Eq_n Eq_n::*) &sp_n->t0002;
		}
	}
l0800_A6B2:
	Eq_n si_n = (ss->*sp_n).t0000;
	Eq_n bp_n = (ss->*sp_n).t0002;
	cxOut = cx;
	dxOut = dx;
	bpOut = bp_n;
	siOut = si_n;
	diOut = di;
	dsOut = ds;
	return si_n;
}

// 0800:A6B7: Register word16 fn0800_A6B7(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out ptr16 dxOut, Register out Eq_n bxOut, Register out Eq_n bpOut)
word16 fn0800_A6B7(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, ptr16 & dxOut, union Eq_n & bxOut, union Eq_n & bpOut)
{
	Eq_n bx_n;
	word16 ax_n;
	struct Eq_n * ptrArg02_n = SEQ(wArg04, wArg02);
	word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
	word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
	Eq_n wArg04_n = SLICE(ptrArg02_n, word16, 16);
	if ((wArg02 | wArg04) == 0x00)
	{
		dx = fn0800_A877(ds, out bx_n);
		goto l0800_A778;
	}
	bx_n = (word16) ptrArg02_n;
	if (ptrArg02_n->w0012 != wArg02_n)
	{
l0800_A6D5:
		ax_n = ~0x00;
l0800_A77A:
		dxOut = dx;
		bxOut = bx_n;
		bpOut = bp;
		return ax_n;
	}
	bx_n = (word16) ptrArg02_n;
	if (ptrArg02_n->w0000 < 0x00)
	{
		ci16 ax_n = ptrArg02_n->w0006 + ptrArg02_n->w0000;
		ptrArg02_n->w0000 -= ax_n + 0x01;
		Eq_n ax_n = ptrArg02_n->t000A;
		word16 dx_n = ptrArg02_n->w0008;
		ptrArg02_n->t000E = ax_n;
		ptrArg02_n->w000C = dx_n;
		if (fn0800_C632(ds, (int16) ptrArg02_n->b0004, dx_n, ax_n, ax_n + 0x01, out dx, out bx_n) != ax_n + 0x01)
		{
			bx_n = (word16) ptrArg02_n;
			if ((ptrArg02_n->w0002 & 0x0200) == 0x00)
			{
				ptrArg02_n->w0002 |= 0x10;
				goto l0800_A6D5;
			}
		}
		goto l0800_A778;
	}
	struct Eq_n * ptrArg02_n = SEQ(wArg04_n, wArg02_n);
	if ((ptrArg02_n->w0002 & 0x08) != 0x00)
	{
l0800_A701:
		ptrArg02_n->w0000 = 0x00;
		word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
		bx_n = (word16) ptrArg02_n;
		dx = wArg02_n + 0x05;
		if (ptrArg02_n->w000E == SLICE(ptrArg02_n, word16, 16) && ptrArg02_n->ptr000C == wArg02_n + 0x05)
		{
			dx = ptrArg02_n->ptr0008;
			ptrArg02_n->w000E = ptrArg02_n->w000A;
			ptrArg02_n->ptr000C = dx;
		}
		goto l0800_A778;
	}
	else
	{
		dx = wArg02_n + 0x05;
		ptrArg02_n = SEQ(wArg04_n, wArg02_n);
		if (ptrArg02_n->t000E == wArg04_n)
		{
			if (ptrArg02_n->w000C == wArg02_n + 0x05)
				goto l0800_A701;
		}
l0800_A778:
		ax_n = 0x00;
		goto l0800_A77A;
	}
}

// 0800:A77D: Register word16 fn0800_A77D(Register Eq_n ds, Stack word16 wArg02, Stack Eq_n wArg04, Stack ci16 wArg06, Stack (ptr32 Eq_n) ptrArg08, Stack Eq_n wArg0A, Register out Eq_n dxOut)
word16 fn0800_A77D(Eq_n ds, word16 wArg02, Eq_n wArg04, ci16 wArg06, struct Eq_n * ptrArg08, Eq_n wArg0A, union Eq_n & dxOut)
{
	ci16 di_n = wArg06;
	Eq_n cx_n = 0x00;
	byte * ptrLoc06_n = SEQ(wArg04, wArg02);
	while (true)
	{
		word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		Eq_n wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		word16 wArg0A_n = SLICE(ptrArg08, word16, 16);
		word16 wArg08_n = SLICE(ptrArg08, word16, 0);
		if (cx_n == 0x0A)
			break;
		--di_n;
		if (di_n <= 0x00)
			break;
		Eq_n ax_n;
		ci16 v17_n = ptrArg08->w0000 - 0x01;
		ptrArg08->w0000 = v17_n;
		if (v17_n >= 0x00)
		{
			struct Eq_n * ax_n = ptrArg08->ptr000E;
			byte Eq_n::* si_n = ptrArg08->ptr000C;
			++ptrArg08->ptr000C;
			ax_n = DPB(DPB(ax_n, ax_n->*si_n, 0), 0x00, 8);
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			ax_n = fn0800_AEC2(ds, SEQ(wArg0A_n, wArg08_n), stackArg4, out ch_n, out dx_n);
			ptrArg08 = SEQ(wArg0A_n, wArg08_n);
		}
		byte cl_n = (byte) ax_n;
		cx_n = ax_n;
		cx_n = DPB(ax_n, cl_n, 0);
		if (ax_n == ~0x00)
			break;
		*ptrLoc06_n = cl_n;
		ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
		Mem32 = Mem85;
	}
	word16 ax_n;
	Eq_n dx_n;
	byte * ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n);
	if (cx_n == ~0x00)
	{
		ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n);
		ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n);
		if (wLoc04_n == wArg04)
		{
			if (wLoc06_n == wArg02)
			{
				dx_n.u0 = 0x00;
				ax_n = 0x00;
				goto l0800_A811;
			}
		}
	}
	*ptrLoc06_n = 0x00;
	if ((ptrArg08->w0002 & 0x10) != 0x00)
	{
		dx_n.u0 = 0x00;
		ax_n = 0x00;
	}
	else
	{
		dx_n = wArg04;
		ax_n = wArg02;
	}
l0800_A811:
	dxOut = dx_n;
	return ax_n;
}

// 0800:A817: Register Eq_n fn0800_A817(Register Eq_n al, Register Eq_n ds, Stack segptr32 ptrArg02, Stack Eq_n ptrArg06, Stack cui16 wArg0A, Register out Eq_n cxOut, Register out ptr16 dxOut)
Eq_n fn0800_A817(Eq_n al, Eq_n ds, segptr32 ptrArg02, Eq_n ptrArg06, cui16 wArg0A, union Eq_n & cxOut, ptr16 & dxOut)
{
	Eq_n ax_n;
	word32 es_bx_n = msdos_get_disk_transfer_area_address();
	msdos_set_DTA(SLICE(ptrArg06, selector, 16), (word16) ptrArg06);
	ptr16 bx_n = (word16) es_bx_n;
	Eq_n cx_n = msdos_find_first_file(wArg0A, SLICE(ptrArg02, selector, 16), (word16) ptrArg02) | SZDOP;
	msdos_set_DTA(SLICE(es_bx_n, selector, 16), bx_n);
	Eq_n ax_n = DPB(ax, 0x4E, 8);
	if (!(fp - 0x06))
		ax_n.u0 = 0x00;
	else
		ax_n = fn0800-8D2B(ds, ax_n);
	cxOut = cx_n;
	dxOut = bx_n;
	return ax_n;
}

// 0800:A84A: Register Eq_n fn0800_A84A(Register Eq_n al, Register Eq_n ds, Stack segptr32 ptrArg02, Register out Eq_n cxOut, Register out ptr16 dxOut)
Eq_n fn0800_A84A(Eq_n al, Eq_n ds, segptr32 ptrArg02, union Eq_n & cxOut, ptr16 & dxOut)
{
	Eq_n ax_n;
	word32 es_bx_n = msdos_get_disk_transfer_area_address();
	msdos_set_DTA(SLICE(ptrArg02, selector, 16), (word16) ptrArg02);
	ptr16 bx_n = (word16) es_bx_n;
	Eq_n cx_n = msdos_find_next_file() | SZDOP;
	msdos_set_DTA(SLICE(es_bx_n, selector, 16), bx_n);
	Eq_n ax_n = DPB(ax, 0x4F, 8);
	if (!(fp - 0x06))
		ax_n.u0 = 0x00;
	else
		ax_n = fn0800-8D2B(ds, ax_n);
	cxOut = cx_n;
	dxOut = bx_n;
	return ax_n;
}

// 0800:A877: Register Eq_n fn0800_A877(Register Eq_n ds, Register out Eq_n bxOut)
Eq_n fn0800_A877(Eq_n ds, union Eq_n & bxOut)
{
	mp16 sp_n = fp - 0x0A;
	Eq_n si_n = *((word32) ds + 9448);
	struct Eq_n * ptrLoc06_n = SEQ(ds, 0x2358);
	while (true)
	{
		ptrLoc06_n.u0 = SLICE(ptrLoc06_n, word16, 16);
		wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		Eq_n ptrLoc06_n = SLICE(ptrLoc06_n, word16, 16);
		--si_n;
		if (si_n == 0x00)
			break;
		bx.u0 = (word16) ptrLoc06_n;
		if ((ptrLoc06_n->w0002 & 0x03) != 0x00)
		{
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = ptrLoc06_n;
			ss->*(sp_n - 0x02) = bx;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			Eq_n stackArg4 = <invalid>;
			fn0800_A6B7(ds, stackArg2, stackArg4, out dx_n, out bx, out bp_n);
			Eq_n sp_n = <invalid>;
			sp_n = (mp16) ((word32) sp_n + 0x04);
		}
		ptrLoc06_n = SEQ(SLICE(ptrLoc06_n, word16, 16), wLoc06_n + 0x14);
		Mem32 = Mem65;
	}
	bxOut = bx;
	return <invalid>;
}

// 0800:A8B7: Register cui16 fn0800_A8B7(Register Eq_n ds, Stack (ptr32 word16) ptrArg02, Stack (ptr32 cui16) ptrArg06, Stack (ptr32 Eq_n) ptrArg0A, Stack Eq_n wArg0C, Register out Eq_n clOut)
cui16 fn0800_A8B7(Eq_n ds, word16 * ptrArg02, cui16 * ptrArg06, union Eq_n * ptrArg0A, Eq_n wArg0C, union Eq_n & clOut)
{
	word16 wArg0A_n = SLICE(ptrArg0A, word16, 0);
	word16 wArg0C_n = SLICE(ptrArg0A, word16, 16);
	word16 wArg0C_n = SLICE(ptrArg0A, word16, 16);
	cui16 ax_n;
	cui16 si_n;
	cui16 dx_n;
	word16 di_n = 0x00;
	Eq_n cl_n = *ptrArg0A;
	union Eq_n * ptrArg0A_n = SEQ(wArg0C_n, wArg0A_n + 0x01);
	ptrArg0A_n = SEQ(wArg0C_n, wArg0A_n + 0x01);
	if (cl_n == 114)
	{
		dx_n = 0x01;
		si_n = 0x01;
	}
	else
	{
		if (cl_n == 0x77)
			dx_n = 770;
		else
		{
			if (cl_n != 0x61)
			{
				ax_n = 0x00;
l0800_A967:
				clOut = cl_n;
				return ax_n;
			}
			dx_n = 0x0902;
		}
		di_n = 0x80;
		si_n = 0x02;
	}
	word16 wArg0A_n = SLICE(ptrArg0A_n, word16, 0);
	word16 wArg0C_n = SLICE(ptrArg0A_n, word16, 16);
	word16 wArg0C_n = SLICE(ptrArg0A_n, word16, 16);
	cl_n = *ptrArg0A_n;
	ptrArg0A_n = SEQ(wArg0C_n, wArg0A_n + 0x01);
	union Eq_n * ptrArg0A_n = SEQ(wArg0C_n, wArg0A_n + 0x01);
	if (cl_n != 0x2B)
	{
		if (*ptrArg0A_n != 0x2B || cl_n != 116 && cl_n != 0x62)
			goto l0800_A92B;
	}
	if (cl_n == 0x2B)
		cl_n = *ptrArg0A_n;
	dx_n = dx_n & ~0x03 | 0x04;
	di_n = 0x0180;
	si_n = 0x03;
l0800_A92B:
	cui16 dx_n;
	if (cl_n == 116)
	{
		dx_n = dx_n | 0x4000;
		goto l0800_A953;
	}
	if (cl_n == 0x62)
		dx_n = dx_n | 0x8000;
	else
	{
		dx_n = dx_n | *((word32) ds + 0x00002512) & 0xC000;
		if ((dx_n & 0x8000) == 0x00)
			goto l0800_A953;
	}
	si_n |= 0x40;
l0800_A953:
	*((word32) ds + 9044) = 51125;
	*ptrArg06 = dx_n;
	*ptrArg02 = di_n;
	ax_n = si_n;
	goto l0800_A967;
}

// 0800:A96D: Register Eq_n fn0800_A96D(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack cui16 wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A, Stack (ptr32 Eq_n) ptrArg0C, Stack Eq_n wArg0E, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out Eq_n bpOut, Register out Eq_n siOut, Register out Eq_n diOut, Register out Eq_n dsOut)
Eq_n fn0800_A96D(Eq_n si, Eq_n di, Eq_n ds, cui16 wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A, struct Eq_n * ptrArg0C, Eq_n wArg0E, ptr16 & cxOut, ptr16 & dxOut, union Eq_n & bpOut, union Eq_n & siOut, union Eq_n & diOut, union Eq_n & dsOut)
{
	word16 wArg0E_n = SLICE(ptrArg0C, word16, 16);
	wArg0E_n = SLICE(ptrArg0C, word16, 16);
	word16 wArg0C_n = SLICE(ptrArg0C, word16, 0);
	wArg0C_n = SLICE(ptrArg0C, word16, 0);
	ptr16 dx_n;
	Eq_n ax_n;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg12 = <invalid>;
	byte cl_n;
	cui16 ax_n = fn0800_A8B7(ds, fp - 0x06, fp - 0x04, SEQ(wArg06, wArg04), stackArg12, out cl_n);
	ptrArg0C->w0002 = ax_n;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	ptr16 cx_n = DPB(cx, cl_n, 0);
	if (ax_n == 0x00)
	{
l0800_A9B9:
		ptrArg0C->b0004 = ~0x00;
		ptrArg0C->w0002 = 0x00;
		goto l0800_A9C7;
	}
	else
	{
		if (ptrArg0C->b0004 < 0x00)
		{
			ci8 al_n = (byte) (word16) fn0800_B140(si, di, ds, wArg08, wArg0A, wLoc04 | wArg02, wLoc06, out cx_n, out si, out di);
			ptrArg0C->b0004 = al_n;
			if (al_n < 0x00)
				goto l0800_A9B9;
		}
		if (fn0800-8D76((int16) ptrArg0C->b0004) != 0x00)
			ptrArg0C->w0002 |= 0x0200;
		ci16 ax_n;
		if ((ptrArg0C->w0002 & 0x0200) != 0x00)
			ax_n = 0x01;
		else
			ax_n = 0x00;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		Eq_n sp_n = <invalid>;
		if (fn0800_BA89(ds, SEQ(wArg0E_n, wArg0C_n), stackArg4, 0x00, 0x00, ax_n, 0x0200, out cx_n, out bp_n, out si, out di, out ds) == 0x00)
		{
			*((word32) (ss->*bp_n).t000E + 0x0010) = 0x00;
			dx_n = (ss->*bp_n).ptr0010;
			ax_n = (ss->*bp_n).t000E;
			goto l0800_AA2E;
		}
		ss->*((word32) sp_n + 0x0A) = (ss->*bp_n).ptr0010;
		ss->*((word32) sp_n + 0x08) = (ss->*bp_n).t000E;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800_A614(ds, ss->*((word32) sp_n + 0x08), stackArg4, out cx_n, out dx_n, out bp_n, out si, out di, out ds);
		Eq_n sp_n = <invalid>;
		cx_n = ss->*((word32) sp_n + 0x02);
l0800_A9C7:
		dx_n = 0x00;
		ax_n.u0 = 0x00;
l0800_AA2E:
		Eq_n bp_n = (ss->*bp_n).t0000;
		cxOut = cx_n;
		dxOut = dx_n;
		bpOut = bp_n;
		siOut = si;
		diOut = di;
		dsOut = ds;
		return ax_n;
	}
}

// 0800:AA34: Register word16 fn0800_AA34(Register Eq_n ds, Register out ptr16 dxOut)
word16 fn0800_AA34(Eq_n ds, ptr16 & dxOut)
{
	struct Eq_n * ptrLoc06_n = SEQ(ds, 0x2358);
	do
	{
		cup16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		if (ptrLoc06_n->b0004 < 0x00)
			break;
		ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x14);
		ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x14);
		Mem16 = Mem27;
	} while (wLoc06_n < (word16) (*((word32) ds + 9448) *s 0x14) + 0x2358);
	ptr16 dx_n;
	word16 ax_n;
	ptr16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
	word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
	if (ptrLoc06_n->b0004 >= 0x00)
	{
		dx_n = 0x00;
		ax_n = 0x00;
	}
	else
	{
		dx_n = wLoc04_n;
		ax_n = wLoc06_n;
	}
	dxOut = dx_n;
	return ax_n;
}

// 0800:AA7E: Register word16 fn0800_AA7E(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bpOut, Register out Eq_n siOut, Register out Eq_n diOut, Register out Eq_n dsOut)
word16 fn0800_AA7E(Eq_n si, Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bpOut, union Eq_n & siOut, union Eq_n & diOut, union Eq_n & dsOut)
{
	ptr16 dx_n;
	word16 ax_n;
	cui16 dx_n;
	cui16 ax_n = fn0800_AA34(ds, out dx_n);
	ptr16 Eq_n::* bp_n = fp - 0x02;
	if ((ax_n | dx_n) == 0x00)
	{
		dx_n = 0x00;
		ax_n = 0x00;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg14 = <invalid>;
		ax_n = fn0800_A96D(si, di, ds, 0x00, wArg06, wArg08, wArg02, wArg04, SEQ(dx_n, ax_n), stackArg14, out cx, out dx_n, out bp_n, out si, out di, out ds);
	}
	ptr16 bp_n = ss->*bp_n;
	cxOut = cx;
	dxOut = dx_n;
	bpOut = bp_n;
	siOut = si;
	diOut = di;
	dsOut = ds;
	return ax_n;
}

// 0800:AAB3: Register Eq_n fn0800_AAB3(Register Eq_n dx, Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n ptrArg08, Stack Eq_n wArg0A, Register out Eq_n chOut)
Eq_n fn0800_AAB3(Eq_n dx, Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, Eq_n wArg06, Eq_n ptrArg08, Eq_n wArg0A, union Eq_n & chOut)
{
	do
	{
		if (wArg06 == 0x00)
			goto l0800_AB9A;
		Eq_n ax_n;
		Eq_n v10_n = (word32) wArg06 + 0x01;
		wArg06 = v10_n;
		if (*((word32) ptrArg02 + 0x06) > v10_n)
			ax_n = v10_n;
		else
			ax_n = *((word32) ptrArg02 + 0x06);
		Eq_n di_n = ax_n;
		byte * ptrArg08_n = SEQ(wArg0A, wArg08);
		if ((*((word32) ptrArg02 + 0x02) & 0x40) == 0x00)
		{
l0800_AB50:
			while (true)
			{
				Eq_n v18_n = wArg06 - 0x01;
				word16 wArg08_n = SLICE(ptrArg08_n, word16, 0);
				word16 wArg0A_n = SLICE(ptrArg08_n, word16, 16);
				wArg0A = SLICE(ptrArg08_n, word16, 16);
				wArg0A = SLICE(ptrArg08_n, word16, 16);
				wArg0A = SLICE(ptrArg08_n, word16, 16);
				wArg08 = SLICE(ptrArg08_n, word16, 0);
				wArg08 = SLICE(ptrArg08_n, word16, 0);
				wArg08 = SLICE(ptrArg08_n, word16, 0);
				word16 wArg04_n = SLICE(ptrArg02, word16, 16);
				word16 wArg02_n = SLICE(ptrArg02, word16, 0);
				wArg06 = v18_n;
				if (v18_n == 0x00)
					break;
				--di_n;
				if (di_n == 0x00)
					break;
				Eq_n ax_n;
				ci16 v19_n = *ptrArg02 - 0x01;
				*ptrArg02 = v19_n;
				if (v19_n >= 0x00)
				{
					Eq_n ax_n = *((word32) ptrArg02 + 0x0E);
					struct Eq_n Eq_n::* si_n = *((word32) ptrArg02 + 0x0C);
					*((word32) ptrArg02 + 0x0C) = (word32) *((word32) ptrArg02 + 0x0C) + 0x01;
					ax_n = DPB(DPB(ax_n, (ax_n->*si_n).t0000, 0), 0x00, 8);
				}
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					ax_n = fn0800_AEC2(ds, SEQ(wArg04_n, wArg02_n), stackArg4, out ch_n, out dx_n);
					ptrArg02 = SEQ(wArg04_n, wArg02_n);
					Mem110 = Mem78;
				}
				byte dl_n = (byte) ax_n;
				dx = ax_n;
				dx = DPB(ax_n, dl_n, 0);
				if (ax_n == ~0x00)
					break;
				*ptrArg08_n = dl_n;
				ptrArg08_n = SEQ(wArg0A_n, wArg08_n + 0x01);
			}
			if (dx != ~0x00)
				continue;
			goto l0800_AB3D;
		}
		ptrArg08_n = SEQ(wArg0A, wArg08);
		if (*((word32) ptrArg02 + 0x06) == 0x00)
			goto l0800_AB50;
		ptrArg08_n = SEQ(wArg0A, wArg08);
		if (*((word32) ptrArg02 + 0x06) >= v10_n)
			goto l0800_AB50;
		ptrArg08_n = SEQ(wArg0A, wArg08);
		if (*ptrArg02 != 0x00)
			goto l0800_AB50;
		Eq_n di_n = 0x00;
		for (wArg06 = v10_n - 0x01; *((word32) ptrArg02 + 0x06) <= wArg06; wArg06 -= *((word32) ptrArg02 + 0x06))
		{
			di_n += Mem133[ptrArg02 + 0x06:word16];
			Mem133 = Mem147;
		}
		Eq_n ax_n = fn0800-8F50(ds, (int16) *((word32) ptrArg02 + 0x04), SEQ(wArg0A, wArg08), di_n, out ch_n, out dx_n);
		dx = ax_n;
		wArg08 = (word16) ((word32) ax_n + wArg08);
	} while (ax_n == di_n);
	wArg06 = (word32) wArg06 + (di_n - ax_n);
l0800_AB3D:
	*((word32) ptrArg02 + 0x02) |= 0x20;
l0800_AB9A:
	chOut.u0 = <invalid>;
	return wArg06;
}

// 0800:ABA3: Register uint16 fn0800_ABA3(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A, Stack Eq_n wArg0C, Register out Eq_n chOut, Register out ptr16 siOut, Register out Eq_n diOut)
uint16 fn0800_ABA3(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A, Eq_n wArg0C, union Eq_n & chOut, ptr16 & siOut, union Eq_n & diOut)
{
	uint16 ax_n;
	Eq_n sp_n = fp - 0x0A;
	if (wArg06 == 0x00)
		ax_n = 0x00;
	else
	{
		Eq_n dx_n;
		Eq_n ax_n = fn0800-8F18(wArg08, 0x00, 0x00, wArg06, out ch_n, out dx_n);
		if (dx_n <= 0x01 && (dx_n < 0x01 || Test(ULT,false)))
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			sp_n = fp - 0x0A;
			ax_n = (uint16) ((uint32) (uint16) (ax_n - fn0800_AAB3(dx_n, ds, SEQ(wArg0C, wArg0A), stackArg4, ax_n, wArg02, wArg04, out ch_n)) /u wArg06);
		}
		else
		{
			word16 si_n = (word32) wArg08 + 0x01;
			while (true)
			{
				Eq_n dx_n;
				--si_n;
				if (si_n == 0x00)
					break;
				struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).t0000 = wArg04;
				(ss->*(sp_n - 0x02)).t0000 = wArg02;
				(ss->*(sp_n - 0x04)).t0000 = wArg06;
				(ss->*(sp_n - 0x06)).t0000 = wArg0C;
				(ss->*(sp_n - 0x08)).t0000 = wArg0A;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				if (fn0800_AAB3(dx_n, ds, (ss->*(sp_n - 0x08)).t0000, stackArg4, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out ch_n) != 0x00)
					break;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				sp_n.u0 = <invalid>;
				wArg04 = dx_n;
				wArg02 = fn0800-8CCB(wArg02, 0x00, wArg04, wArg06, stackArg0, out ch_n, out dx_n);
				Mem57 = Mem107;
				dx_n = dx_n;
			}
			ax_n = wArg08 - si_n;
		}
	}
	Eq_n di_n = ss->*sp_n;
	ptr16 si_n = ss->*((word32) sp_n + 0x02);
	chOut.u0 = <invalid>;
	siOut = si_n;
	diOut = di_n;
	return ax_n;
}

// 0800:AC31: Register ui16 fn0800_AC31(Stack Eq_n ptrArg02)
ui16 fn0800_AC31(Eq_n ptrArg02)
{
	ui16 cx_n;
	ui16 si_n;
	if (*ptrArg02 < 0x00)
	{
		word16 cx_n = Mem12[ptrArg02 + 0x06:word16] + Mem12[ptrArg02 + 0x00:word16];
		cx_n = cx_n + 0x01;
		si_n = cx_n + 0x01;
	}
	else
	{
		int32 dx_ax_n = (int32) *ptrArg02;
		ui16 dx_n = SLICE(dx_ax_n, word16, 16);
		ui16 ax_n = ((word16) dx_ax_n ^ dx_n) - dx_n;
		cx_n = ax_n;
		si_n = ax_n;
	}
	if ((*((word32) ptrArg02 + 0x02) & 0x40) == 0x00)
	{
		struct Eq_n Eq_n::* dx_n = *((word32) ptrArg02 + 0x0C);
		Eq_n ax_n = *((word32) ptrArg02 + 0x0E);
		struct Eq_n Eq_n::* wLoc06_n = dx_n;
		byte * ptrLoc06_n = SEQ(ax_n, dx_n);
		if (*ptrArg02 < 0x00)
		{
			Eq_n ptrLoc06_n = SEQ(ax_n, dx_n);
			while (true)
			{
				word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
				ptrLoc06_n.u0 = SLICE(ptrLoc06_n, word16, 16);
				ptrLoc06_n.u0 = SLICE(ptrLoc06_n, word16, 16);
				--cx_n;
				if (cx_n == 0x00)
					break;
				struct Eq_n Eq_n::* v18_n = wLoc06_n - 0x01;
				wLoc06_n = v18_n;
				if (*SEQ(wLoc04_n, v18_n) == 0x0A)
					++si_n;
			}
		}
		else
		{
			while (true)
			{
				word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
				word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
				word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
				--cx_n;
				if (cx_n == 0x00)
					break;
				ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
				ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
				if (*ptrLoc06_n == 0x0A)
					++si_n;
			}
		}
	}
	return si_n;
}

// 0800:ACB3: Register word16 fn0800_ACB3(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg0A, Register out Eq_n cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut)
word16 fn0800_ACB3(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg0A, union Eq_n & cxOut, ptr16 & dxOut, ptr16 & bxOut)
{
	word16 ax_n;
	Eq_n cx_n = wArg04;
	struct Eq_n Eq_n::* bp_n;
	ptr16 bx_n;
	ptr16 dx_n;
	if (fn0800_A6B7(ds, wArg02, wArg04, out dx_n, out bx_n, out bp_n) != 0x00)
		ax_n = ~0x00;
	else
	{
		if (wArg0A == 0x01)
		{
			struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
			word16 bx_n = (word16) es_bx_n;
			if (es_bx_n->w0000 > 0x00)
			{
				int32 dx_ax_n = (int32) fn0800_AC31(SEQ((ss->*bp_n).w0006, bx_n));
				(ss->*bp_n).t0008 = v19_n;
				(ss->*bp_n).t0008 = SEQ((ss->*bp_n).t000A, (ss->*bp_n).t0008);
				ui32 v21_v19_n = (ss->*bp_n).t0008 - dx_ax_n;
				(ss->*bp_n).t000A = SLICE(v21_v19_n, word16, 16);
				Eq_n v19_n = (word16) v21_v19_n;
			}
		}
		struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
		es_bx_n->w0002 &= ~0x01A0;
		es_bx_n->w0000 = 0x00;
		word16 dx_n = es_bx_n->w0008;
		es_bx_n->w000E = es_bx_n->w000A;
		es_bx_n->w000C = dx_n;
		word16 ax_n = fn0800-8E29(ds, (int16) es_bx_n->b0004, (ss->*bp_n).t0008, (ss->*bp_n).t000A, SLICE(wArg0A, byte, 0), out cx_n, out dx_n, out bx_n);
		if (dx_n == ~0x00 && ax_n == ~0x00)
			ax_n = ~0x00;
		else
			ax_n = 0x00;
	}
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	return ax_n;
}

// 0800:AD2F: Register uint16 fn0800_AD2F(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out Eq_n dxOut)
uint16 fn0800_AD2F(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, union Eq_n & dxOut)
{
	word16 wArg04_n = SLICE(ptrArg02, word16, 16);
	word16 wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n dx_n;
	uint16 ax_n = fn0800-97B6(ds, (int16) *((word32) ptrArg02 + 0x04), out dx_n);
	Eq_n wLoc04_n = dx_n;
	uint16 wLoc06_n = ax_n;
	if (dx_n != ~0x00 || ax_n != ~0x00)
	{
		if (*ptrArg02 < 0x00)
		{
			ui32 v19_v17_n = SEQ(dx_n, v17_n) + (int32) fn0800_AC31(ptrArg02);
			uint16 v17_n = (word16) v19_v17_n;
			wLoc06_n = v17_n;
			wLoc04_n = SLICE(v19_v17_n, word16, 16);
		}
		else
		{
			ui32 v23_v22_n = SEQ(dx_n, v22_n) - (int32) fn0800_AC31(SEQ(wArg04_n, wArg02_n));
			uint16 v22_n = (word16) v23_v22_n;
			wLoc06_n = v22_n;
			wLoc04_n = SLICE(v23_v22_n, word16, 16);
		}
	}
	dxOut = wLoc04_n;
	return wLoc06_n;
}

// 0800:AD85: Register uint16 fn0800_AD85(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A, Stack Eq_n wArg0C, Register out ptr16 bpOut)
uint16 fn0800_AD85(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A, Eq_n wArg0C, ptr16 & bpOut)
{
	uint16 ax_n;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	Eq_n sp_n = fp - 0x0A;
	Eq_n di_n = wArg06;
	if (wArg06 != 0x00)
	{
		cup16 dx_n;
		Eq_n ax_n = fn0800-8F18(wArg08, 0x00, 0x00, wArg06, out ch_n, out dx_n);
		if (dx_n <= 0x01 && (dx_n < 0x01 || Test(ULT,false)))
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			uint16 di_n;
			ax_n = (uint16) ((uint32) (uint16) fn0800_B4BE(ds, SEQ(wArg0C, wArg0A), stackArg4, ax_n, wArg02, wArg04, out bp_n, out si_n, out di_n) /u di_n);
l0800_AE0A:
			bpOut = (ss->*bp_n).ptr0000;
			return ax_n;
		}
		if (wArg08 > 0x00)
		{
			do
			{
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				ss->*sp_n = (ss->*bp_n).t0006;
				ss->*(sp_n - 0x02) = (ss->*bp_n).t0004;
				ss->*(sp_n - 0x04) = di_n;
				ss->*(sp_n - 0x06) = (ss->*bp_n).t000E;
				ss->*(sp_n - 0x08) = (ss->*bp_n).t000C;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg4 = <invalid>;
				uint16 si_n;
				Eq_n ax_n = fn0800_B4BE(ds, ss->*(sp_n - 0x08), stackArg4, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out bp_n, out si_n, out di_n);
				if (false || ax_n != di_n)
				{
					ax_n = si_n;
					goto l0800_AE0A;
				}
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				Eq_n dx_n;
				Eq_n ax_n = fn0800-8CCB((ss->*bp_n).t0004, 0x00, (ss->*bp_n).t0006, di_n, stackArg0, out ch_n, out dx_n);
				(ss->*bp_n).t0006 = dx_n;
				(ss->*bp_n).t0004 = ax_n;
				sp_n.u0 = <invalid>;
			} while (si_n + 0x01 < (ss->*bp_n).w000A);
		}
	}
	ax_n = (ss->*bp_n).w000A;
	goto l0800_AE0A;
}

// 0800:AE10: Register Eq_n fn0800_AE10(Register Eq_n ds)
Eq_n fn0800_AE10(Eq_n ds)
{
	union Eq_n Eq_n::* bp_n = fp - 0x02;
	mp16 sp_n = fp - 0x08;
	word16 si_n = 0x14;
	while (true)
	{
		--si_n;
		if (si_n == 0x00)
			break;
		Eq_n es_bx_n = ss->*(bp_n - 0x04);
		Eq_n bx_n = (word16) es_bx_n;
		if ((*((word32) es_bx_n + 0x02) & 0x0300) == 0x0300)
		{
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = ss->*(bp_n - 0x02);
			ss->*(sp_n - 0x02) = bx_n;
			fn0800_A6B7(ds, ss->*(sp_n - 0x02), ss->*sp_n, out dx_n, out bx_n, out bp_n);
			Eq_n sp_n = <invalid>;
			sp_n = (mp16) ((word32) sp_n + 0x04);
		}
		ss->*(bp_n - 0x04) = (word16) (ss->*(bp_n - 0x04)) + 0x0014;
	}
	return ss->*bp_n;
}

// 0800:AE4C: Register word16 fn0800_AE4C(Register Eq_n ds, Stack (ptr32 Eq_n) ptrArg02, Register out ptr16 dxOut, Register out Eq_n bpOut)
word16 fn0800_AE4C(Eq_n ds, struct Eq_n * ptrArg02, ptr16 & dxOut, union Eq_n & bpOut)
{
	Eq_n sp_n = fp - 0x02;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	if ((ptrArg02->w0002 & 0x0200) != 0x00)
	{
		bp_n = fn0800_AE10(ds);
		sp_n.u0 = <invalid>;
	}
	word16 ax_n;
	struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
	struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
	(ss->*sp_n).t0000 = es_bx_n->t0006;
	Eq_n ax_n = es_bx_n->t000A;
	Eq_n dx_n = es_bx_n->t0008;
	es_bx_n->t000E = ax_n;
	es_bx_n->t000C = dx_n;
	ss->*(sp_n - 0x02) = ax_n;
	ss->*(sp_n - 0x04) = dx_n;
	ss->*(sp_n - 0x06) = (int16) es_bx_n->b0004;
	ptr16 dx_n;
	ci16 ax_n = fn0800_B97F(ds, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), (ss->*sp_n).t0000, out dx_n);
	struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
	es_bx_n->w0000 = ax_n;
	if (ax_n > 0x00)
	{
		es_bx_n->w0002 &= ~0x20;
		ax_n = 0x00;
	}
	else
	{
		struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
		if (es_bx_n->w0000 == 0x00)
			es_bx_n->w0002 = es_bx_n->w0002 & 65151 | 0x20;
		else
		{
			struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
			es_bx_n->w0000 = 0x00;
			es_bx_n->w0002 |= 0x10;
		}
		ax_n = ~0x00;
	}
	Eq_n bp_n = (ss->*sp_n).t0002;
	dxOut = dx_n;
	bpOut = bp_n;
	return ax_n;
}

// 0800:AEC2: Register word16 fn0800_AEC2(Register Eq_n ds, Stack (ptr32 word16) ptrArg02, Stack Eq_n wArg04, Register out Eq_n chOut, Register out ptr16 dxOut)
word16 fn0800_AEC2(Eq_n ds, word16 * ptrArg02, Eq_n wArg04, union Eq_n & chOut, ptr16 & dxOut)
{
	cui16 wArg04_n = SLICE(ptrArg02, word16, 16);
	++*ptrArg02;
	ptr16 dx_n;
	word16 ax_n = fn0800_AED6(ds, (word16) ptrArg02, wArg04_n, out dx_n);
	chOut.u0 = <invalid>;
	dxOut = dx_n;
	return ax_n;
}

// 0800:AED6: Register word16 fn0800_AED6(Register Eq_n ds, Stack Eq_n ptrArg02, Stack cui16 wArg04, Register out ptr16 dxOut)
word16 fn0800_AED6(Eq_n ds, Eq_n ptrArg02, cui16 wArg04, ptr16 & dxOut)
{
	word16 ax_n;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	Eq_n sp_n = fp - 0x04;
	struct Eq_n * ptrArg02_n = SEQ(wArg04, wArg02);
	if ((wArg02 | wArg04) == 0x00)
	{
l0800_AEE2:
		ax_n = ~0x00;
		goto l0800_AFBD;
	}
	word16 ax_n;
	if (ptrArg02_n->w0000 <= 0x00)
	{
		if (ptrArg02_n->w0000 < 0x00 || ((ptrArg02_n->w0002 & 0x0110) != 0x00 || (ptrArg02_n->w0002 & 0x01) == 0x00))
		{
l0800_AF7F:
			struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
			es_bx_n->w0002 |= 0x10;
			goto l0800_AEE2;
		}
		ptrArg02_n->w0002 |= 0x80;
		if (ptrArg02_n->w0006 == 0x00)
		{
			do
			{
				if (((ss->*bp_n).ptr0004->w0002 & 0x0200) != 0x00)
				{
					bp_n = fn0800_AE10(ds);
					sp_n.u0 = <invalid>;
				}
				union Eq_n Eq_n::* sp_n = sp_n - 0x02;
				(ss->*sp_n).u0 = 0x01;
				ss->*(sp_n - 0x02) = ds;
				(ss->*(sp_n - 0x04)).u0 = 0x4EE4;
				ss->*(sp_n - 0x06) = (int16) (ss->*bp_n).ptr0004->b0004;
				ci16 ax_n = fn0800_B97F(ds, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx);
				sp_n = (char *) sp_n + 0x02;
				if (ax_n == 0x00)
				{
					ss->*sp_n = (int16) (ss->*bp_n).ptr0004->b0004;
					if (fn0800_A59D(ds, ss->*sp_n, out dx) != 0x01)
						goto l0800_AF7F;
					struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
					es_bx_n->w0002 = es_bx_n->w0002 & 65151 | 0x20;
					goto l0800_AEE2;
				}
			} while (*((word32) ds + 0x00004EE4) == 0x0D && (((ss->*bp_n).ptr0004)->w0002 & 0x40) == 0x00);
			struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
			es_bx_n->w0002 &= ~0x20;
			ax_n = DPB(ax_n, *((word32) ds + 0x00004EE4), 0);
l0800_AFBB:
			ax_n = DPB(ax_n, 0x00, 8);
l0800_AFBD:
			dxOut = dx;
			return ax_n;
		}
		if (fn0800_AE4C(ds, ptrArg02_n, out dx, out bp_n) != 0x00)
			goto l0800_AEE2;
	}
	struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
	--es_bx_n->w0000;
	Eq_n ax_n = es_bx_n->t000E;
	Eq_n si_n = es_bx_n->t000C;
	es_bx_n->t000C = (word32) es_bx_n->t000C + 0x01;
	ax_n = (word16) DPB(ax_n, ax_n->*si_n, 0);
	goto l0800_AFBB;
}

// 0800:AFCB: Register Eq_n fn0800_AFCB(Register Eq_n ds, Stack (ptr32 byte) ptrArg02, Register out (ptr16 Eq_n) dxOut)
Eq_n fn0800_AFCB(Eq_n ds, byte * ptrArg02, struct Eq_n & dxOut)
{
	Eq_n ax_n;
	struct Eq_n * dx_n;
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	Eq_n di_n = (word16) ptrArg02;
	if ((es_n | di_n) != 0x00)
	{
		byte ah_n = *ptrArg02;
		word16 cx_n = ~0x00;
		while (cx_n != 0x00)
		{
			di_n = (word16) di_n + 0x01;
			--cx_n;
			di_n = di_n;
			if (es_n->*di_n != 0x00)
				break;
		}
		Eq_n cx_n = ~cx_n;
		if (cx_n != 0x01)
		{
			Eq_n es_di_n = *((word32) ds + 9898);
			Eq_n di_n = (word16) es_di_n;
			Eq_n wLoc06_n = di_n;
			Eq_n ptrLoc06_n = es_di_n;
			if ((SLICE(es_di_n, selector, 16) | di_n) != 0x00)
			{
				while (true)
				{
					byte * es_di_n = ds->*di_n;
					struct Eq_n * es_n = SLICE(es_di_n, selector, 16);
					Eq_n di_n = (word16) es_di_n;
					ptrLoc06_n.u1 = SLICE(ptrLoc06_n, word16, 16);
					word16 cx_n = cx_n - 0x01;
					if ((es_n | di_n) == 0x00)
						break;
					byte al_n = *es_di_n;
					if (al_n == 0x00)
						break;
					if (ah_n == al_n)
					{
						bool Z_n = SLICE(cond(Mem62[es_n:cx_n - 0x01 + di_n:byte] - 0x3D), bool, 2);
						if (Mem62[es_n:cx_n - 0x01 + di_n:byte] == 0x3D)
						{
							struct Eq_n * ds_n = SLICE(ptrArg02, selector, 16);
							byte Eq_n::* si_n = (word16) ptrArg02;
							do
							{
								ptrLoc06_n.u1 = SLICE(ptrLoc06_n, word16, 16);
								if (cx_n == 0x00)
									break;
								Z_n = SLICE(cond(ds_n->*si_n - es_n->*di_n), bool, 2);
								si_n = si_n + 0x01;
								di_n = (word32) di_n + 0x01;
								--cx_n;
								si_n = si_n;
							} while (ds_n->*si_n != es_n->*di_n);
							if (!Z_n)
							{
								ax_n = (word32) di_n + 0x01;
								dx_n = es_n;
								goto l0800_B035;
							}
						}
					}
					Eq_n v23_n = (word32) wLoc06_n + 0x04;
					wLoc06_n = v23_n;
					di_n = (word16) SEQ(SLICE(ptrLoc06_n, word16, 16), v23_n);
					ptrLoc06_n = SEQ(SLICE(ptrLoc06_n, word16, 16), v23_n);
					Mem62 = Mem121;
				}
			}
		}
	}
	dx_n = 0x00;
	ax_n.u0 = 0x00;
l0800_B035:
	dxOut = dx_n;
	return ax_n;
}

// 0800:B03B: void fn0800_B03B(Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack Eq_n ptrArg06, Stack Eq_n wArg0A)
void fn0800_B03B(Eq_n ptrArg02, Eq_n wArg04, Eq_n ptrArg06, Eq_n wArg0A)
{
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	struct Eq_n Eq_n::* di_n = (word16) ptrArg02;
	struct Eq_n * ds_n = SLICE(ptrArg06, selector, 16);
	struct Eq_n Eq_n::* si_n = (word16) ptrArg06;
	uint16 cx_n;
	for (cx_n = wArg0A >> 0x01; cx_n != 0x00; --cx_n)
	{
		(es_n->*di_n).t0000 = (ds_n->*si_n).t0000;
		++si_n;
		++di_n;
	}
	if (wArg0A >> 0x01 < 0x00)
		(es_n->*di_n).t0000 = (ds_n->*si_n).t0000;
}

// 0800:B05F: void fn0800_B05F(Stack (ptr32 byte) ptrArg02, Stack cu16 wArg06, Stack byte bArg08)
void fn0800_B05F(byte * ptrArg02, cu16 wArg06, byte bArg08)
{
	word16 ax_n = DPB(DPB(ax, bArg08, 0), bArg08, 8);
	Eq_n di_n = (word16) ptrArg02;
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	cu16 cx_n = wArg06;
	ax_n = DPB(ax_n, bArg08, 0);
	word16 ax_n = DPB(ax_n, bArg08, 0);
	if ((di_n & 0x01) != 0x00)
	{
		if (wArg06 == 0x00)
			return;
		*ptrArg02 = bArg08;
		di_n = (word32) di_n + 0x01;
		cx_n = wArg06 - 0x01;
	}
	uint16 cx_n = cx_n >> 0x01;
	cx_n = cx_n;
	while (true)
	{
		uint16 cx_n;
		ax_n = DPB(ax_n, bArg08, 0);
		if (cx_n == 0x00)
			break;
		es_n->*di_n = ax_n;
		di_n = (word32) di_n + 0x02;
		--cx_n;
	}
	if (cx_n < 0x00)
		es_n->*di_n = bArg08;
}

// 0800:B083: void fn0800_B083(Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n bArg06, Stack cu16 wArg08)
void fn0800_B083(Eq_n wArg02, Eq_n wArg04, Eq_n bArg06, cu16 wArg08)
{
	fn0800_B05F(SEQ(wArg04, wArg02), wArg08, SLICE(DPB(ax, bArg06, 0), byte, 0));
}

// 0800:B0A1: void fn0800_B0A1(Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack Eq_n ptrArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A)
void fn0800_B0A1(Eq_n ptrArg02, Eq_n wArg04, Eq_n ptrArg06, Eq_n wArg08, Eq_n wArg0A)
{
	Eq_n ax_n;
	fn0800-8F2F((byte) wArg02, wArg02, wArg08, wArg04, (byte) wArg06, wArg06, out cx_n, out dx_n, out bx_n);
	Eq_n C_n = <invalid>;
	segptr32 ptrArg02_n = SEQ(wArg04, wArg02);
	ptrArg02_n = SEQ(wArg04, wArg02);
	segptr32 ptrArg06_n = SEQ(wArg08, wArg06);
	ptrArg06_n = SEQ(wArg08, wArg06);
	if (!C_n)
		ax_n.u0 = 0x01;
	else
		ax_n.u0 = 0x00;
	byte Eq_n::* si_n = (word16) ptrArg02_n;
	struct Eq_n * ds_n = SLICE(ptrArg02_n, selector, 16);
	Eq_n di_n = (word16) ptrArg06_n;
	struct Eq_n * es_n = SLICE(ptrArg06_n, selector, 16);
	Eq_n cx_n = wArg0A;
	if (ax_n != 0x00)
	{
		si_n = si_n + wArg0A - 0x01;
		di_n = di_n + wArg0A - 0x01;
	}
	if ((di_n & 0x01) != 0x00)
	{
		if (wArg0A == 0x00)
			return;
		es_n->*di_n = ds_n->*si_n;
		++si_n;
		di_n = (word32) di_n + 0x01;
		cx_n = wArg0A - 0x01;
	}
	word16 Eq_n::* si_n = si_n - ax_n;
	Eq_n di_n = di_n - ax_n;
	uint16 cx_n = cx_n >> 0x01;
	cx_n = cx_n;
	while (true)
	{
		uint16 cx_n;
		if (cx_n == 0x00)
			break;
		es_n->*di_n = ds_n->*si_n;
		++si_n;
		di_n = (word32) di_n + 0x02;
		--cx_n;
	}
	if (cx_n < 0x00)
		Mem95[es_n:di_n + ax_n:byte] = Mem92[ds_n:si_n + ax_n:byte];
}

// 0800:B0F3: void fn0800_B0F3(Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A)
void fn0800_B0F3(Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A)
{
	fn0800_B0A1(wArg06, wArg08, wArg02, wArg04, wArg0A);
}

// 0800:B113: Register Eq_n fn0800_B113(Register Eq_n ds, Stack Eq_n wArg02, Stack segptr32 ptrArg04, Register out Eq_n cxOut)
Eq_n fn0800_B113(Eq_n ds, Eq_n wArg02, segptr32 ptrArg04, union Eq_n & cxOut)
{
	Eq_n ax_n;
	if (msdos_create_truncate_file(wArg02, SLICE(ptrArg04, selector, 16), (word16) ptrArg04, out ax_n))
		ax_n = fn0800-8D2B(ds, ax_n);
	cxOut = wArg02;
	return ax_n;
}

// 0800:B12E: Register word16 fn0800_B12E(Register Eq_n ds, Stack Eq_n wArg02)
word16 fn0800_B12E(Eq_n ds, Eq_n wArg02)
{
	word16 ax_n;
	msdos_write_file(wArg02, 0x00, SEQ(ds, 0x00), out ax_n);
	return 0x00;
}

// 0800:B140: Register byte fn0800_B140(Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack cui16 wArg06, Stack cui16 wArg08, Register out ptr16 cxOut, Register out ptr16 siOut, Register out ptr16 diOut)
byte fn0800_B140(Eq_n si, Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, cui16 wArg06, cui16 wArg08, ptr16 & cxOut, ptr16 & siOut, ptr16 & diOut)
{
	cui16 si_n = wArg06;
	Eq_n ptrLoc0A_n = SEQ(si, di);
	ptrLoc0A_n = SEQ(si, di);
	if ((wArg06 & 0xC000) == 0x00)
		si_n = wArg06 | *((word32) ds + 0x00002512) & 0xC000;
	Eq_n ax_n;
	Eq_n di_n;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg8 = <invalid>;
	ptr16 cx_n;
	Eq_n ax_n = fn0800_A53C(ds, SEQ(wArg04, wArg02), 0x00, stackArg8, out cx_n);
	wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	ptr16 wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	wLoc0A_n = SLICE(ptrLoc0A_n, word16, 0);
	wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	ptr16 wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	wLoc08_n = SLICE(ptrLoc0A_n, word16, 16);
	Eq_n wLoc04_n = ax_n;
	if ((si_n & 0x0100) != 0x00)
	{
		cui16 di_n = wArg08 & *((word32) ds + 9492);
		if ((di_n & 0x0180) == 0x00)
			fn0800-8D2B(ds, 0x01);
		Eq_n wLoc0C_n;
		if (ax_n == ~0x00)
		{
			if (*((word32) ds + 9494) != 0x02)
			{
				wLoc0C_n = *((word32) ds + 9494);
				goto l0800_B197;
			}
			Eq_n ax_n;
			if ((di_n & 0x80) != 0x00)
				ax_n.u0 = 0x00;
			else
				ax_n.u0 = 0x01;
			wLoc04_n = ax_n;
			if ((si_n & 0xF0) == 0x00)
			{
				Eq_n ax_n = fn0800_B113(ds, ax_n, SEQ(wArg04, wArg02), out cx_n);
				di_n = ax_n;
				if (ax_n < 0x00)
					goto l0800_B298;
l0800_B265:
				if (di_n >= 0x00)
				{
					cui16 ax_n;
					if ((si_n & 0x0300) != 0x00)
						ax_n = 0x1000;
					else
						ax_n = 0x00;
					cui16 ax_n;
					cui16 dx_n = si_n & ~0x0700 | ax_n;
					if ((wLoc04_n & 0x01) != 0x00)
						ax_n = 0x00;
					else
						ax_n = 0x0100;
					SEQ(ds, 0x24EA)[di_n * 0x02] = dx_n | ax_n;
				}
				goto l0800_B298;
			}
			Eq_n ax_n = fn0800_B113(ds, 0x00, SEQ(wArg04, wArg02), out cx_n);
			di_n = ax_n;
			if (ax_n < 0x00)
			{
l0800_B298:
				ax_n = di_n;
				goto l0800_B29A;
			}
			fn0800_A57F(ax_n, ds, ax_n);
		}
		else if ((si_n & 0x0400) != 0x00)
		{
			wLoc0C_n.u0 = 0x50;
l0800_B197:
			ax_n = fn0800-8D2B(ds, wLoc0C_n);
l0800_B29A:
			cxOut = cx_n;
			siOut = wLoc08_n;
			diOut = wLoc0A_n;
			return (byte) ax_n;
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg7 = <invalid>;
	Eq_n ax_n = fn0800_B2A0(ds, SEQ(wArg04, wArg02), si_n, stackArg7, out cx_n);
	di_n = ax_n;
	if (ax_n >= 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg5 = <invalid>;
		Eq_n stackArg10 = <invalid>;
		cui16 ax_n = fn0800_A2A3(ds, stackArg2, 0x00, stackArg5, ptrLoc0A_n, stackArg10, out cx_n);
		cx_n = 0x00;
		if ((ax_n & 0x80) != 0x00)
		{
			si_n |= 0x2000;
			if ((si_n & 0x8000) != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg2 = <invalid>;
				Eq_n stackArg5 = <invalid>;
				Eq_n stackArg10 = <invalid>;
				fn0800_A2A3(ds, stackArg2, 0x01, stackArg5, (uint32) (uint16) (ax_n & 0xFF | 0x20), stackArg10, out cx_n);
			}
		}
		else if ((si_n & 0x0200) != 0x00)
			cx_n = fn0800_B12E(ds, ax_n);
		if ((wLoc04_n & 0x01) != 0x00 && ((si_n & 0x0100) != 0x00 && (si_n & 0xF0) != 0x00))
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg8 = <invalid>;
			fn0800_A53C(ds, SEQ(wArg04, wArg02), 0x01, stackArg8, out cx_n);
		}
	}
	goto l0800_B265;
}

// 0800:B2A0: Register Eq_n fn0800_B2A0(Register Eq_n ds, Stack segptr32 ptrArg02, Stack cui16 wArg06, Stack Eq_n bArg07, Register out Eq_n cxOut)
Eq_n fn0800_B2A0(Eq_n ds, segptr32 ptrArg02, cui16 wArg06, Eq_n bArg07, union Eq_n & cxOut)
{
	byte bArg06_n = SLICE(wArg06, byte, 0);
	bArg06_n = SLICE(wArg06, byte, 0);
	byte bArg07_n = SLICE(wArg06, byte, 8);
	bArg07_n = SLICE(wArg06, byte, 8);
	byte al_n = 0x01;
	if ((wArg06 & 0x02) == 0x00)
	{
		al_n = 0x02;
		if ((wArg06 & 0x04) == 0x00)
			al_n = 0x00;
	}
	Eq_n ax_n;
	byte cl_n = bArg06_n & 0xF0;
	byte bArg07_n = SLICE(bArg07_n, byte, 8);
	Eq_n cx_n = DPB(wArg06, cl_n, 0);
	Eq_n ax_n;
	cui16 wArg06_n = SEQ(bArg07_n, bArg06_n);
	if (!msdos_open_file(ptrArg02, al_n | cl_n, out ax_n))
	{
		SEQ(ds, 0x24EA)[ax_n * 0x02] = wArg06_n & ~0x4700 | 0x8000;
		ax_n = ax_n;
	}
	else
		ax_n = fn0800-8D2B(ds, ax_n);
	cxOut = cx_n;
	return ax_n;
}

// 0800:B2EF: Register word16 fn0800_B2EF(Register Eq_n cx, Register Eq_n dx, Register Eq_n bx, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out ptr16 siOut, Register out ptr16 diOut)
word16 fn0800_B2EF(Eq_n cx, Eq_n dx, Eq_n bx, Eq_n ds, Eq_n wArg02, Eq_n wArg04, ptr16 & siOut, ptr16 & diOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg6 = <invalid>;
	ptr16 di_n;
	ptr16 si_n;
	word16 ax_n = fn0800-9828(cx, dx, bx, ds, fp + 0x06, SEQ(wArg04, wArg02), stackArg6, out si_n, out di_n);
	siOut = si_n;
	diOut = di_n;
	return ax_n;
}

// 0800:B30A: Register word16 fn0800_B30A(Register Eq_n ds, Stack byte bArg02, Stack Eq_n ptrArg04, Stack Eq_n wArg06, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut)
word16 fn0800_B30A(Eq_n ds, byte bArg02, Eq_n ptrArg04, Eq_n wArg06, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut)
{
	--*ptrArg04;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg6 = <invalid>;
	ptr16 bx_n;
	ptr16 cx_n;
	ptr16 dx_n;
	word16 ax_n = fn0800_B324(ds, SLICE((int16) bArg02, byte, 0), ptrArg04, stackArg6, out cx_n, out dx_n, out bx_n, out bp_n);
	cxOut = cx_n;
	dxOut = dx_n;
	bxOut = bx_n;
	return ax_n;
}

// 0800:B324: Register (ptr16 Eq_n) fn0800_B324(Register Eq_n ds, Stack Eq_n bArg02, Stack Eq_n ptrArg04, Stack Eq_n wArg06, Register out Eq_n cxOut, Register out ptr16 dxOut, Register out Eq_n bxOut, Register out Eq_n bpOut)
struct Eq_n * fn0800_B324(Eq_n ds, Eq_n bArg02, Eq_n ptrArg04, Eq_n wArg06, union Eq_n & cxOut, ptr16 & dxOut, union Eq_n & bxOut, union Eq_n & bpOut)
{
	struct Eq_n Eq_n::* wArg04_n = SLICE(ptrArg04, word16, 0);
	word16 wArg06_n = SLICE(ptrArg04, word16, 16);
	Eq_n wArg06_n = SLICE(ptrArg04, word16, 16);
	Eq_n wArg06_n = SLICE(ptrArg04, word16, 16);
	Eq_n wArg04_n = SLICE(ptrArg04, word16, 0);
	Eq_n ax_n;
	struct Eq_n * ax_n;
	*((word32) ds + 0x00004EE6) = bArg02;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	struct Eq_n Eq_n::* sp_n = fp - 0x04;
	Eq_n bx_n = (word16) ptrArg04;
	if (*ptrArg04 < ~0x00)
	{
		*ptrArg04 = (word32) *ptrArg04 + 0x01;
		ax_n = *((word32) ptrArg04 + 0x0E);
		Eq_n si_n = *((word32) ptrArg04 + 0x0C);
		*((word32) ptrArg04 + 0x0C) = (word32) *((word32) ptrArg04 + 0x0C) + 0x01;
		Eq_n dl_n = *((word32) ds + 0x00004EE6);
		ax_n->*si_n = dl_n;
		dx = DPB(dx, dl_n, 0);
		if ((*((word32) ptrArg04 + 0x02) & 0x08) == 0x00 || *((word32) ds + 0x00004EE6) != 0x0A && *((word32) ds + 0x00004EE6) != 0x0D)
			goto l0800_B4A3;
		Eq_n ax_n = fn0800_A6B7(ds, wArg04_n, wArg06_n, out dx, out bx_n, out bp_n);
		Eq_n sp_n = <invalid>;
		cx = ss->*((word32) sp_n + 0x02);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
		ax_n = ax_n;
		if (ax_n == 0x00)
			goto l0800_B4A3;
		goto l0800_B380;
	}
	if ((*((word32) ptrArg04 + 0x02) & 0x90) != 0x00 || (*((word32) ptrArg04 + 0x02) & 0x02) == 0x00)
	{
l0800_B39C:
		*((word32) ptrArg04 + 0x02) |= 0x10;
		sp_n = fp - 0x04;
		bx_n = (word16) ptrArg04;
		goto l0800_B380;
	}
	*((word32) ptrArg04 + 0x02) |= 0x0100;
	Eq_n bx_n = (word16) ptrArg04;
	if (*((word32) ptrArg04 + 0x06) != 0x00)
	{
		if (*ptrArg04 != 0x00)
		{
			Eq_n ax_n = fn0800_A6B7(ds, bx_n, wArg06_n, out dx, out bx_n, out bp_n);
			Eq_n sp_n = <invalid>;
			cx = ss->*((word32) sp_n + 0x02);
			sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
			if (ax_n != 0x00)
				goto l0800_B380;
		}
		Eq_n es_bx_n = (ss->*bp_n).t0006;
		*es_bx_n = -*((word32) es_bx_n + 0x06);
		ax_n = *((word32) es_bx_n + 0x0E);
		struct Eq_n Eq_n::* si_n = *((word32) es_bx_n + 0x0C);
		*((word32) es_bx_n + 0x0C) = (word32) *((word32) es_bx_n + 0x0C) + 0x01;
		Eq_n dl_n = *((word32) ds + 0x00004EE6);
		(ax_n->*si_n).t0000 = dl_n;
		bx_n = (word16) es_bx_n;
		dx = DPB(dx, dl_n, 0);
		if (((ss->*bp_n).t0008->*((word32) bx_n + 0x02) & 0x08) == 0x00 || *((word32) ds + 0x00004EE6) != 0x0A && *((word32) ds + 0x00004EE6) != 0x0D)
			goto l0800_B4A3;
		struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).t0000 = (ss->*bp_n).t0008;
		(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t0006;
		Eq_n ax_n = fn0800_A6B7(ds, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out dx, out bx_n, out bp_n);
		Eq_n sp_n = <invalid>;
		cx = ss->*((word32) sp_n + 0x02);
		sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
		ax_n = ax_n;
		if (ax_n == 0x00)
		{
l0800_B4A3:
			ax_n = (struct Eq_n *) DPB(DPB(ax_n, *((word32) ds + 0x00004EE6), 0), 0x00, 8);
			goto l0800_B4A8;
		}
l0800_B380:
		ax_n = ~0x00;
l0800_B4A8:
		Eq_n bp_n = (ss->*sp_n).t0002;
		cxOut = cx;
		dxOut = dx;
		bxOut = bx_n;
		bpOut = bp_n;
		return ax_n;
	}
	struct Eq_n * es_n = SLICE(ptrArg04, selector, 16);
	if ((SEQ(ds, 0x24EA)[(int16) Mem33[ptrArg04 + 0x04:byte] * 0x02] & 0x0800) != 0x00)
	{
		fn0800-8E29(ds, (int16) (es_n->*wArg04_n).b0004, 0x00, 0x00, 0x02, out cx_n, out dx_n, out bx_n);
		ptrArg04 = SEQ(wArg06_n, wArg04_n);
	}
	ptrArg04 = SLICE(ptrArg04, word16, 0);
	word16 wArg06_n = SLICE(ptrArg04, word16, 16);
	word16 wArg06_n = SLICE(ptrArg04, word16, 16);
	if (*((word32) ds + 0x00004EE6) == 0x0A)
	{
		ptrArg04 = SEQ(wArg06_n, ptrArg04);
		if ((*((word32) ptrArg04 + 0x02) & 0x40) == 0x00)
		{
			ax_n = fn0800_C779(ds, (int16) *((word32) ptrArg04 + 0x04), SEQ(ds, 9902), 0x01, out cx, out dx, out bx_n);
			ptrArg04 = SEQ(wArg06_n, ptrArg04);
			if (ax_n != 0x01)
			{
l0800_B495:
				sp_n = fp - 0x04;
				bx_n = (word16) ptrArg04;
				if ((*((word32) ptrArg04 + 0x02) & 0x0200) != 0x00)
					goto l0800_B4A3;
				goto l0800_B39C;
			}
		}
	}
	ptrArg04 = SLICE(ptrArg04, word16, 16);
	ax_n = fn0800_C779(ds, (int16) *((word32) ptrArg04 + 0x04), SEQ(ds, 0x4EE6), 0x01, out cx, out dx, out bx_n);
	sp_n = fp - 0x04;
	if (ax_n == 0x01)
		goto l0800_B4A3;
	goto l0800_B495;
}

// 0800:B4BE: Register Eq_n fn0800_B4BE(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n ptrArg08, Stack Eq_n wArg0A, Register out Eq_n bpOut, Register out ptr16 siOut, Register out Eq_n diOut)
Eq_n fn0800_B4BE(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04, Eq_n wArg06, Eq_n ptrArg08, Eq_n wArg0A, union Eq_n & bpOut, ptr16 & siOut, union Eq_n & diOut)
{
	word16 wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	Eq_n wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n wArg04_n = SLICE(ptrArg02, word16, 16);
	struct Eq_n Eq_n::* wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n ax_n;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	struct Eq_n Eq_n::* sp_n = fp - 0x08;
	Eq_n di_n = wArg06;
	if ((*((word32) ptrArg02 + 0x02) & 0x08) != 0x00)
	{
		do
		{
			--di_n;
			if (di_n == 0x00)
				goto l0800_B69D;
			union Eq_n Eq_n::* sp_n = sp_n - 0x02;
			ss->*sp_n = (ss->*bp_n).t0006;
			ss->*(sp_n - 0x02) = (ss->*bp_n).t0004;
			Eq_n es_bx_n = (ss->*bp_n).t000A;
			(ss->*bp_n).t000A = (word32) (ss->*bp_n).t000A + 0x01;
			(ss->*(sp_n - 0x04)).u0 = (int16) *es_bx_n;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n sp_n = <invalid>;
			Eq_n stackArg6 = <invalid>;
			sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x06);
		} while (fn0800_B324(ds, ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), stackArg6, out cx_n, out dx_n, out bx_n, out bp_n) != ~0x00);
		goto l0800_B4F5;
	}
	Eq_n bx_n = (word16) ptrArg02;
	if ((*((word32) ptrArg02 + 0x02) & 0x40) == 0x00)
	{
		union Eq_n * ptrArg08_n = SEQ(wArg0A, wArg08);
		if (*((word32) ptrArg02 + 0x06) != 0x00)
		{
			do
			{
				word16 wArg08_n = SLICE(ptrArg08_n, word16, 0);
				word16 wArg08_n = SLICE(ptrArg08_n, word16, 0);
				word16 wArg0A_n = SLICE(ptrArg08_n, word16, 16);
				word16 wArg0A_n = SLICE(ptrArg08_n, word16, 16);
				word16 wArg04_n = SLICE(ptrArg02, word16, 16);
				word16 wArg02_n = SLICE(ptrArg02, word16, 0);
				sp_n = fp - 0x08;
				--di_n;
				if (di_n == 0x00)
					goto l0800_B69D;
				Eq_n ax_n;
				int16 v19_n = (word32) *ptrArg02 + 0x01;
				*ptrArg02 = v19_n;
				if (v19_n < 0x00)
				{
					Eq_n ax_n = *((word32) ptrArg02 + 0x0E);
					struct Eq_n Eq_n::* si_n = *((word32) ptrArg02 + 0x0C);
					*((word32) ptrArg02 + 0x0C) = (word32) *((word32) ptrArg02 + 0x0C) + 0x01;
					Eq_n dl_n = *ptrArg08_n;
					(ax_n->*si_n).t0000 = dl_n;
					ax_n = DPB(DPB(ax_n, dl_n, 0), 0x00, 8);
					ptrArg08_n = SEQ(wArg0A_n, wArg08_n + 0x01);
				}
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg6 = <invalid>;
					ax_n = fn0800_B30A(ds, SLICE(DPB(di_n, *ptrArg08_n, 0), byte, 0), SEQ(wArg04_n, wArg02_n), stackArg6, out cx_n, out dx_n, out bx_n);
					ptrArg02 = SEQ(wArg04_n, wArg02_n);
					ptrArg08_n = SEQ(wArg0A_n, wArg08_n + 0x01);
					Mem435 = Mem342;
				}
				sp_n = fp - 0x08;
			} while (ax_n != ~0x00);
			goto l0800_B4F5;
		}
		sp_n = fp - 0x08;
		if (fn0800_C632(ds, (int16) *((word32) ptrArg02 + 0x04), wArg08, wArg0A, wArg06, out dx_n, out bx_n) < wArg06)
			goto l0800_B4F5;
	}
	else if (*((word32) ptrArg02 + 0x06) == 0x00)
	{
		struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
		if ((SEQ(ds, 0x24EA)[(int16) Mem17[ptrArg02 + 0x04:byte] * 0x02] & 0x0800) != 0x00)
		{
			fn0800-8E29(ds, (int16) (es_n->*wArg02_n).b0004, 0x00, 0x00, 0x02, out cx_n, out dx_n, out bx_n);
			ptrArg02 = SEQ(wArg04_n, wArg02_n);
		}
		sp_n = fp - 0x08;
		if (fn0800_C779(ds, (int16) *((word32) ptrArg02 + 0x04), SEQ(wArg0A, wArg08), wArg06, out cx_n, out dx_n, out bx_n) < wArg06)
			goto l0800_B4F5;
	}
	else if (*((word32) ptrArg02 + 0x06) < wArg06)
	{
		if (*ptrArg02 != 0x00)
		{
			Eq_n sp_n = <invalid>;
			sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
			if (fn0800_A6B7(ds, bx_n, wArg04_n, out dx_n, out bx_n, out bp_n) != 0x00)
				goto l0800_B4F5;
		}
		Eq_n es_bx_n = (ss->*bp_n).t0004;
		struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
		if ((SEQ(ds, 0x24EA)[(int16) Mem141[es_bx_n + 0x04:byte] * 0x02] & 0x0800) != 0x00)
		{
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).t0000.u0 = 0x02;
			(ss->*(sp_n - 0x02)).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x04)).t0000.u0 = 0x00;
			(ss->*(sp_n - 0x06)).t0000 = (int16) (es_n->*((word32) (ss->*bp_n).t0004 + 0x04));
			fn0800-8E29(ds, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, (ss->*(sp_n - 0x02)).t0000, (ss->*sp_n).t0000, out cx_n, out dx_n, out bx_n);
		}
		struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).t0000 = wArg06;
		(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t000C;
		(ss->*(sp_n - 0x04)).t0000 = (ss->*bp_n).t000A;
		(ss->*(sp_n - 0x06)).t0000 = (int16) *((word32) (ss->*bp_n).t0004 + 0x04);
		sp_n = (struct Eq_n Eq_n::*) &&(ds_n->*(ds_n->*sp_n).ptr0002);
		if (fn0800_C779(ds, (ss->*(sp_n - 0x06)).t0000, (ss->*(sp_n - 0x04)).t0000, (ss->*sp_n).t0000, out cx_n, out dx_n, out bx_n) < wArg06)
		{
l0800_B4F5:
			ax_n.u0 = 0x00;
l0800_B6A0:
			Eq_n di_n = (ss->*sp_n).t0000;
			ptr16 si_n = (ss->*sp_n).ptr0002;
			bpOut = (ss->*bp_n).t0000;
			siOut = si_n;
			diOut = di_n;
			return ax_n;
		}
	}
	else
	{
		if (Mem17[ptrArg02 + 0x00:word16] + wArg06 >= 0x00)
		{
			if (*ptrArg02 == 0x00)
				*ptrArg02 = ~0x00 - *((word32) ptrArg02 + 0x06);
			else
			{
				Eq_n sp_n = <invalid>;
				sp_n = (struct Eq_n Eq_n::*) ((word32) sp_n + 0x04);
				if (fn0800_A6B7(ds, wArg02_n, wArg04_n, out dx_n, out bx_n, out bp_n) != 0x00)
					goto l0800_B4F5;
			}
		}
		struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).t0000 = wArg06;
		(ss->*(sp_n - 0x02)).t0000 = (ss->*bp_n).t000C;
		(ss->*(sp_n - 0x04)).t0000 = (ss->*bp_n).t000A;
		Eq_n es_bx_n = (ss->*bp_n).t0004;
		(ss->*(sp_n - 0x06)).t0000 = *((word32) es_bx_n + 0x0E);
		(ss->*(sp_n - 0x08)).t0000 = *((word32) es_bx_n + 0x0C);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800_B03B((ss->*(sp_n - 0x08)).t0000, stackArg4, (ss->*(sp_n - 0x04)).t0000, (ss->*sp_n).t0000);
		Eq_n es_bx_n = (ss->*bp_n).t0004;
		Mem109[es_bx_n + 0x00:word16] = Mem93[es_bx_n + 0x00:word16] + wArg06;
		Mem111[es_bx_n + 0x0C:word16] = Mem109[es_bx_n + 0x0C:word16] + wArg06;
		sp_n = (struct Eq_n Eq_n::*) &&(ds_n->*(ds_n->*sp_n).ptr0002);
	}
l0800_B69D:
	ax_n = (ss->*(bp_n - 0x02)).t0000;
	goto l0800_B6A0;
}

// 0800:B6A8: Register word16 fn0800_B6A8(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n ptrArg06, Register out Eq_n cxOut)
word16 fn0800_B6A8(Eq_n ds, Eq_n ptrArg02, Eq_n ptrArg06, union Eq_n & cxOut)
{
	word16 ax_n;
	Eq_n cx_n = *((word32) ds + 20200);
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	word16 Eq_n::* di_n = (word16) ptrArg02;
	struct Eq_n * ds_n = SLICE(ptrArg06, selector, 16);
	word16 Eq_n::* si_n = (word16) ptrArg06;
	Eq_n cx_n = cx_n >> 0x01;
	if (cx_n >> 0x01 < 0x00)
	{
		byte al_n = *ptrArg02;
		*ptrArg02 = *ptrArg06;
		*ptrArg06 = al_n;
		ax_n = DPB(ax, al_n, 0);
		si_n = (word16 Eq_n::*) ((char *) si_n + 0x01);
		di_n = (word16 Eq_n::*) ((char *) di_n + 0x01);
		if (cx_n >> 0x01 == 0x00)
		{
l0800_B6CF:
			cxOut = cx_n;
			return ax_n;
		}
	}
	do
	{
		ax_n = es_n->*di_n;
		es_n->*di_n = ds_n->*si_n;
		++si_n;
		ds_n->*(si_n - 0x02) = ax_n;
		++di_n;
		--cx_n;
	} while (cx_n != 0x00);
	goto l0800_B6CF;
}

// 0800:B6D6: Register word16 fn0800_B6D6(Register word16 cx, Register Eq_n bx, Register mp16 bp, Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Register out Eq_n bxOut, Register out Eq_n TopOut)
word16 fn0800_B6D6(word16 cx, Eq_n bx, mp16 bp, Eq_n si, Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, union Eq_n & bxOut, union Eq_n & TopOut)
{
	Eq_n Top_n = 0x00;
	Eq_n sp_n = fp - 0x1A;
	Eq_n si_n = wArg02;
	while (true)
	{
		struct Eq_n Eq_n::* sp_n;
		if (si_n <= 0x02)
			break;
		Eq_n bx_n = (word32) wArg04 + (word16) (*((word32) ds + 20200) *s (si_n - 0x01));
		word16 ax_n = (word16) (*((word32) ds + 20200) *s (si_n >> 0x01));
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = wArg06;
		ss->*(sp_n - 0x02) = bx_n;
		ss->*(sp_n - 0x04) = wArg06;
		Eq_n bx_n = (word32) wArg04 + ax_n;
		ss->*(sp_n - 0x06) = bx_n;
		struct Eq_n Eq_n::* sp_n;
		ci16 ax_n;
		word16 dx_n;
		word16 bx_n;
		int8 Top_n;
		(seg0800->**((word32) ds + 20202))();
		Eq_n wLoc0A_n = bx_n;
		ci16 ax_n = ax_n;
		if (ax_n > 0x00)
		{
			(ss->*sp_n).t0006 = wArg06;
			(ss->*sp_n).t0004 = bx_n;
			(ss->*sp_n).t0002 = wArg06;
			(ss->*sp_n).t0000 = bx_n;
			ax_n = fn0800_B6A8(ds, (ss->*sp_n).t0000, (ss->*sp_n).t0004, out cx);
		}
		word16 cx_n;
		struct Eq_n Eq_n::* sp_n;
		struct Eq_n Eq_n::* sp_n;
		(ss->*sp_n).t0006 = wArg06;
		(ss->*sp_n).t0004 = wArg04;
		(ss->*sp_n).t0002 = wArg06;
		(ss->*sp_n).t0000 = bx_n;
		struct Eq_n Eq_n::* sp_n;
		ci16 ax_n;
		word16 dx_n;
		word16 cx_n;
		(seg0800->**((word32) ds + 20202))();
		if (ax_n > 0x00)
		{
			sp_n[0x03] = wArg06;
			sp_n[0x02] = bx_n;
			sp_n[0x01] = wArg06;
			(ss->*sp_n).ptr0000 = wArg04;
			sp_n = sp_n;
			goto l0800_B7BD;
		}
		sp_n[0x03] = wArg06;
		sp_n[0x02] = bx_n;
		sp_n[0x01] = wArg06;
		(ss->*sp_n).ptr0000 = wArg04;
		struct Eq_n Eq_n::* sp_n;
		ci16 ax_n;
		(seg0800->**((word32) ds + 20202))();
		sp_n = (struct Eq_n Eq_n::*) (sp_n + 0x04);
		if (ax_n > 0x00)
		{
			sp_n[0x03] = wArg06;
			sp_n[0x02] = wArg04;
			sp_n[0x01] = wArg06;
			(ss->*sp_n).ptr0000 = bx_n;
			sp_n = sp_n;
l0800_B7BD:
			fn0800_B6A8(ds, (ss->*sp_n).ptr0000, sp_n[0x02], out cx_n);
			sp_n = (struct Eq_n Eq_n::*) (sp_n + 0x04);
		}
		if (si_n == 0x03)
		{
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).ptr0000 = wArg06;
			(ss->*(sp_n - 0x02)).ptr0000 = wArg04;
			(ss->*(sp_n - 0x04)).ptr0000 = wArg06;
			(ss->*(sp_n - 0x06)).ptr0000 = bx_n;
			sp_n = sp_n - 0x06;
			goto l0800_B720;
		}
		word16 dx_n = wArg04 + Mem194[ds:20200:word16];
		Eq_n ax_n = wArg06;
		wLoc0C = wArg06;
		wLoc0E = dx_n;
		wLoc06 = dx_n;
		do
		{
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).ptr0000 = wArg06;
			(ss->*(sp_n - 0x02)).ptr0000 = wArg04;
			(ss->*(sp_n - 0x04)).ptr0000 = wArg06;
			(ss->*(sp_n - 0x06)).ptr0000 = wLoc06;
			struct Eq_n Eq_n::* sp_n;
			ci16 ax_n;
			(seg0800->**((word32) ds + 20202))();
			sp_n = (struct Eq_n Eq_n::*) ((char *) &(ds_n->*sp_n).t0006 + 0x02);
			if (ax_n <= 0x00)
			{
				if (ax_n == 0x00)
				{
					(ss->*sp_n).t0006 = wArg06;
					(ss->*sp_n).t0004 = wLoc06;
					(ss->*sp_n).t0002 = wArg06;
					(ss->*sp_n).t0000 = wLoc0E;
					fn0800_B6A8(ds, (ss->*sp_n).t0000, (ss->*sp_n).t0004, out cx_n);
					wLoc0E += Mem256[ds:20200:word16];
					Mem272 = Mem268;
				}
				sp_n = (struct Eq_n Eq_n::*) ((char *) &(ds_n->*sp_n).t0006 + 0x02);
				ax_n = wLoc06;
				if (wLoc06 >= wLoc0A_n)
					break;
				ax_n = *((word32) ds + 20200);
				wLoc06 += ax_n;
				continue;
			}
			if (wLoc06 < wLoc0A_n)
			{
				do
				{
					struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
					(ss->*sp_n).ptr0000 = wArg06;
					(ss->*(sp_n - 0x02)).ptr0000 = wLoc0A_n;
					(ss->*(sp_n - 0x04)).ptr0000 = wArg06;
					(ss->*(sp_n - 0x06)).ptr0000 = wArg04;
					struct Eq_n Eq_n::* sp_n;
					ci16 ax_n;
					(seg0800->**((word32) ds + 20202))();
					sp_n = (struct Eq_n Eq_n::*) ((char *) &(ds_n->*sp_n).t0006 + 0x02);
					if (ax_n >= 0x00)
					{
						(ss->*sp_n).t0006 = wArg06;
						(ss->*sp_n).t0004 = wLoc06;
						(ss->*sp_n).t0002 = wArg06;
						(ss->*sp_n).t0000 = wLoc0A_n;
						fn0800_B6A8(ds, (ss->*sp_n).t0000, (ss->*sp_n).t0004, out cx_n);
						sp_n = (struct Eq_n Eq_n::*) ((char *) &(ds_n->*sp_n).t0006 + 0x02);
						if (ax_n != 0x00)
						{
							Eq_n ax_n = *((word32) ds + 20200);
							wLoc06 += ax_n;
							wLoc0A_n -= ax_n;
						}
						break;
					}
					Eq_n v59_n = wLoc0A_n - *((word32) ds + 20200);
					wLoc0A_n = v59_n;
				} while (wLoc06 < v59_n);
			}
			ax_n = wLoc06;
		} while (wLoc06 < wLoc0A_n);
		struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).ptr0000 = wArg06;
		(ss->*(sp_n - 0x02)).ptr0000 = wArg04;
		(ss->*(sp_n - 0x04)).ptr0000 = wArg06;
		(ss->*(sp_n - 0x06)).ptr0000 = wLoc06;
		struct Eq_n Eq_n::* sp_n;
		ci16 ax_n;
		(seg0800->**((word32) ds + 20202))();
		if (ax_n <= 0x00)
		{
			wLoc06 += Mem383[ds:20200:word16];
			Mem427 = Mem424;
		}
		wLoc04 = wArg06;
		wLoc14 = wArg06;
		wLoc16 = wLoc06 - *((word32) ds + 20200);
		wLoc10 = wArg06;
		wLoc12 = wArg04;
		while (wLoc12 < wLoc0E && wLoc16 >= wLoc0E)
		{
			(ss->*sp_n).t0006 = wArg06;
			(ss->*sp_n).t0004 = wLoc12;
			(ss->*sp_n).t0002 = wArg06;
			(ss->*sp_n).t0000 = wLoc16;
			fn0800_B6A8(ds, (ss->*sp_n).t0000, (ss->*sp_n).t0004, out cx_n);
			Eq_n ax_n = *((word32) ds + 20200);
			wLoc12 += ax_n;
			wLoc16 -= ax_n;
		}
		(ss->*sp_n).t0006.u0 = 0x00;
		(ss->*sp_n).t0004 = *((word32) ds + 20200);
		Eq_n ax_n = wLoc06 - wLoc0E;
		(ss->*sp_n).t0002 = 0x00 - (ax_n < 0x00);
		(ss->*sp_n).t0000 = ax_n;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n ax_n = fn0800-8BBB(stackArg0, (ss->*sp_n).t0000, (ss->*sp_n).t0002, (ss->*sp_n).t0004, (ss->*sp_n).t0006, out cx_n, out dx_n, out bx_n);
		Eq_n sp_n = <invalid>;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		ss->*(sp_n - 0x04) = *((word32) ds + 20200);
		Eq_n dx_n = (word32) wArg04 + (word16) (*((word32) ds + 20200) *s si_n) - wLoc06;
		ss->*(sp_n - 0x06) = 0x00 - (dx_n < 0x00);
		ss->*(sp_n - 0x08) = dx_n;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n bx_n;
		word16 cx_n;
		Eq_n ax_n = fn0800-8BBB(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
		Eq_n sp_n = <invalid>;
		si_n = ax_n;
		if (ax_n < ax_n)
		{
			ss->*(sp_n - 0x02) = wArg06;
			ss->*(sp_n - 0x04) = wLoc06;
			ss->*(sp_n - 0x06) = ax_n;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			cx = fn0800_B6D6(cx_n, bx_n, fp - 0x02, ax_n, ax_n, ds, stackArg2, wArg02, wArg04, out bx, out Top_n);
			sp_n = sp_n;
			si_n = ax_n;
		}
		else
		{
			ss->*(sp_n - 0x02) = wArg06;
			ss->*(sp_n - 0x04) = wArg04;
			ss->*(sp_n - 0x06) = ax_n;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg2 = <invalid>;
			cx = fn0800_B6D6(cx_n, bx_n, fp - 0x02, ax_n, ax_n, ds, stackArg2, wArg02, wArg04, out bx, out Top_n);
			sp_n = sp_n;
			wArg04 = wLoc06;
			Mem24 = Mem569;
		}
	}
	if (si_n == 0x02)
	{
		word16 dx_n = wArg04 + Mem24[ds:20200:word16];
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = wArg06;
		ss->*(sp_n - 0x02) = dx_n;
		ss->*(sp_n - 0x04) = wArg06;
		ss->*(sp_n - 0x06) = wArg04;
		struct Eq_n Eq_n::* sp_n;
		ci16 ax_n;
		(seg0800->**((word32) ds + 20202))();
		if (ax_n > 0x00)
		{
			sp_n[0x03] = wArg06;
			sp_n[0x02] = wArg04;
			sp_n[0x01] = wArg06;
			(ss->*sp_n).ptr0000 = dx_n;
			sp_n = sp_n;
l0800_B720:
			fn0800_B6A8(ds, (ss->*sp_n).ptr0000, sp_n[0x02], out cx);
		}
	}
	bxOut = bx;
	TopOut = Top_n;
	return cx;
}

// 0800:B95E: void fn0800_B95E(Register word16 cx, Register Eq_n bx, Register Eq_n si, Register Eq_n di, Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack Eq_n wArg0A)
void fn0800_B95E(word16 cx, Eq_n bx, Eq_n si, Eq_n di, Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, Eq_n wArg0A)
{
	*((word32) ds + 20200) = wArg08;
	if (wArg08 != 0x00)
	{
		*((word32) ds + 20202) = wArg0A;
		fn0800_B6D6(cx, bx, fp - 0x02, si, di, ds, wArg06, wArg02, wArg04, out bx_n, out Top_n);
	}
}

// 0800:B97F: Register Eq_n fn0800_B97F(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n ptrArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out ptr16 dxOut)
Eq_n fn0800_B97F(Eq_n ds, Eq_n wArg02, Eq_n ptrArg04, Eq_n wArg06, Eq_n wArg08, ptr16 & dxOut)
{
	Eq_n ax_n;
	if (wArg02 >= *((word32) ds + 9448))
		ax_n = fn0800-8D2B(ds, 0x06);
	else if (wArg08 >= 0x01 && (SEQ(ds, 0x24EA)[wArg02 * 0x02] & 0x0200) == 0x00)
	{
		do
		{
			Eq_n ax_n = fn0800-8F50(ds, wArg02, SEQ(wArg06, wArg04), wArg08, out ch_n, out dx);
			segptr32 ptrArg04_n = SEQ(wArg06, wArg04);
			wArg06 = SLICE(ptrArg04_n, word16, 16);
			wArg04 = SLICE(ptrArg04_n, word16, 0);
			if (ax_n < 0x01)
			{
l0800_B9DD:
				ax_n = ax_n;
				goto l0800_BA44;
			}
			if ((SEQ(ds, 0x24EA)[wArg02 * 0x02] & 0x4000) == 0x00)
				goto l0800_B9DD;
			Eq_n si_n = (word16) ptrArg04_n;
			Eq_n cx_n;
			struct Eq_n * es_n = SLICE(ptrArg04_n, selector, 16);
			Eq_n di_n = si_n;
			si_n = si_n;
			do
			{
				Eq_n si_n;
				byte al_n = ds->*si_n;
				si_n = (word32) si_n + 0x01;
				if (al_n == 0x1A)
				{
					Eq_n cx_n = -cx_n;
					fn0800-8E29(ds, wArg02, cx_n, 0x00 - (cx_n == 0x00), 0x01, out cx_n, out dx, out bx_n);
					SEQ(ds, 0x24EA)[wArg02 * 0x02] |= 0x0200;
					goto l0800_BA41;
				}
				if (al_n != 0x0D)
				{
					es_n->*di_n = al_n;
					di_n = (word32) di_n + 0x01;
					--cx_n;
					if (cx_n == 0x00)
						goto l0800_BA19;
					continue;
				}
				--cx_n;
			} while (cx_n != 0x00);
			fn0800-8F50(ds, wArg02, fp - 0x05, 0x01, out ch_n, out dx);
			es_n->*di_n = bLoc05;
			di_n = (word32) di_n + 0x01;
l0800_BA19:
		} while (di_n == si_n);
l0800_BA41:
		ax_n = di_n - si_n;
	}
	else
		ax_n.u0 = 0x00;
l0800_BA44:
	dxOut = dx;
	return ax_n;
}

// 0800:BA4A: Register Eq_n fn0800_BA4A(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n ptrArg06)
Eq_n fn0800_BA4A(Eq_n ds, Eq_n ptrArg02, Eq_n ptrArg06)
{
	Eq_n ax_n;
	Eq_n ax_n;
	if (!msdos_rename_file(ptrArg02, ptrArg06, out ax_n))
		ax_n.u0 = 0x00;
	else
		ax_n = fn0800-8D2B(ds, ax_n);
	return ax_n;
}

// 0800:BA67: void fn0800_BA67(Register Eq_n ds, Stack Eq_n ptrArg02, Stack Eq_n wArg04)
void fn0800_BA67(Eq_n ds, Eq_n ptrArg02, Eq_n wArg04)
{
	struct Eq_n * ptrArg02_n = SEQ(wArg04, wArg02);
	if (fn0800_ACB3(ds, wArg02, wArg04, 0x00, out cx_n, out dx_n, out bx_n) == 0x00)
		ptrArg02_n->w0002 &= ~0x10;
}

// 0800:BA89: Register word16 fn0800_BA89(Register Eq_n ds, Stack (ptr32 Eq_n) ptrArg02, Stack Eq_n wArg04, Stack cui16 wArg06, Stack cui16 wArg08, Stack ci16 wArg0A, Stack cup16 wArg0C, Register out Eq_n cxOut, Register out Eq_n bpOut, Register out ptr16 siOut, Register out Eq_n diOut, Register out Eq_n dsOut)
word16 fn0800_BA89(Eq_n ds, struct Eq_n * ptrArg02, Eq_n wArg04, cui16 wArg06, cui16 wArg08, ci16 wArg0A, cup16 wArg0C, union Eq_n & cxOut, union Eq_n & bpOut, ptr16 & siOut, union Eq_n & diOut, union Eq_n & dsOut)
{
	word16 wArg02_n = SLICE(ptrArg02, word16, 0);
	word16 wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n ptrArg02_n = SLICE(ptrArg02, word16, 16);
	word16 ax_n;
	struct Eq_n Eq_n::* bp_n = fp - 0x02;
	union Eq_n Eq_n::* sp_n = fp - 0x06;
	ci16 di_n = wArg0A;
	if (ptrArg02->w0012 != wArg02_n || (wArg0A > 0x02 || wArg0C > 0x7FFF))
	{
l0800_BAAB:
		ax_n = ~0x00;
		goto l0800_BB94;
	}
	if (*((word32) ds + 0x000026B2) == 0x00)
	{
		ptrArg02_n = SEQ(ptrArg02_n, wArg02_n);
		if (wArg02_n == 0x236C)
		{
			*((word32) ds + 0x000026B2) = 0x01;
l0800_BADB:
			Eq_n wArg04_n = SLICE(ptrArg02_n, word16, 16);
			word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
			Eq_n bx_n = (word16) ptrArg02_n;
			if (*ptrArg02_n != 0x00)
			{
				fn0800_ACB3(ds, bx_n, wArg04_n, 0x01, out cx, out dx_n, out bx_n);
				ptrArg02_n = SEQ(wArg04_n, wArg02_n);
			}
			word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
			word16 wArg04_n = SLICE(ptrArg02_n, word16, 16);
			word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
			word16 wArg04_n = SLICE(ptrArg02_n, word16, 16);
			struct Eq_n * ptrArg02_n = SEQ(wArg04_n, wArg02_n);
			ptrArg02_n = SEQ(wArg04_n, wArg02_n);
			if ((*((word32) ptrArg02_n + 0x02) & 0x04) != 0x00)
			{
				Eq_n v18_n = *((word32) ptrArg02_n + 0x0A);
				fn0800-9E75(ds, v18_n, out cx_n, out dx_n, out bx_n, out ds);
				cx = v18_n;
			}
			ptrArg02_n->w0002 &= ~0x0C;
			ptrArg02_n->w0006 = 0x00;
			word16 wArg04_n = SLICE(ptrArg02_n, word16, 16);
			ptrArg02_n->w000A = wArg04_n;
			word16 wArg02_n = SLICE(ptrArg02_n, word16, 0);
			ptrArg02_n->w0008 = wArg02_n + 0x05;
			ptrArg02_n->w000E = wArg04_n;
			ptrArg02_n->w000C = wArg02_n + 0x05;
			sp_n = fp - 0x06;
			if (wArg0A != 0x02)
			{
				cup16 si_n = wArg0C;
				if (wArg0C > 0x00)
				{
					*((word32) ds + 0x00002352) = ~0x380F;
					if ((wArg06 | wArg08) == 0x00)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_n stackArg2 = <invalid>;
						cui16 dx_n;
						cui16 ax_n = fn0800-9F7F(stackArg2, out dx_n, out bp_n, out si_n, out di_n, out ds);
						Eq_n sp_n = <invalid>;
						cx = ss->*sp_n;
						(ss->*bp_n).w000A = dx_n;
						(ss->*bp_n).w0008 = ax_n;
						sp_n = (union Eq_n Eq_n::*) ((word32) sp_n + 0x02);
						if ((ax_n | dx_n) == 0x00)
							goto l0800_BAAB;
						struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
						es_bx_n->w0002 |= 0x04;
					}
					struct Eq_n * es_bx_n = (ss->*bp_n).ptr0004;
					cui16 ax_n = (ss->*bp_n).w000A;
					cui16 dx_n = (ss->*bp_n).w0008;
					es_bx_n->w000E = ax_n;
					es_bx_n->w000C = dx_n;
					es_bx_n->w000A = ax_n;
					es_bx_n->w0008 = dx_n;
					es_bx_n->w0006 = si_n;
					if (di_n == 0x01)
						es_bx_n->w0002 |= 0x08;
				}
			}
			ax_n = 0x00;
l0800_BB94:
			struct Eq_n Eq_n::* sp_n = (char *) sp_n + 0x02;
			Eq_n di_n = ss->*sp_n;
			ptr16 si_n = (ss->*sp_n).ptr0000;
			Eq_n bp_n = (ss->*sp_n).t0002;
			cxOut = cx;
			bpOut = bp_n;
			siOut = si_n;
			diOut = di_n;
			dsOut = ds;
			return ax_n;
		}
	}
	if (*((word32) ds + 9904) == 0x00 && wArg02_n == 0x2358)
		*((word32) ds + 9904) = 0x01;
	goto l0800_BADB;
}

// 0800:BB98: void fn0800_BB98(Stack Eq_n wArg02, Stack word16 wArg04, Stack word16 wArg06, Stack segptr32 ptrArg08, Stack cui16 wArg0A)
void fn0800_BB98(Eq_n wArg02, word16 wArg04, word16 wArg06, segptr32 ptrArg08, cui16 wArg0A)
{
	if ((wArg08 | wArg0A) != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		if (fn0800_BFC7(SEQ(wArg06, wArg04), stackArg4, out cx_n) >= wArg02)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			fn0800_C01E(SEQ(wArg0A, wArg08), stackArg4, SEQ(wArg06, wArg04), wArg02);
			Mem90[SEQ(wArg0A, wArg08) + wArg02:byte] = 0x00;
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			fn0800_BF9E(SEQ(wArg0A, wArg08), stackArg4, SEQ(wArg06, wArg04));
		}
	}
}

// 0800:BBE9: void fn0800_BBE9(Register word16 bp, Stack Eq_n ptrArg02, Stack word16 wArg04)
void fn0800_BBE9(word16 bp, Eq_n ptrArg02, word16 wArg04)
{
	word16 wArg02_n = SLICE(ptrArg02, word16, 0);
	word16 wArg02_n = SLICE(ptrArg02, word16, 0);
	Eq_n ptrArg02_n = SLICE(ptrArg02, word16, 16);
	ptrArg02_n.u0 = SLICE(ptrArg02, word16, 16);
	if (*(ptrArg02 - 0x01) == 0x2E)
		wArg02_n = wArg02_n - 0x01;
	word16 v12_n = wArg02_n - 0x01;
	int16 ax_n = (int16) *SEQ(SLICE(ptrArg02_n, word16, 16), v12_n);
	word16 cx_n;
	struct Eq_n Eq_n::* bx_n = Eq_n::aFFFFBC39;
	segptr32 ptrArg02_n = SEQ(SLICE(ptrArg02_n, word16, 16), v12_n);
	for (cx_n = 0x04; cx_n != 0x00; --cx_n)
	{
		word16 wArg04_n = SLICE(ptrArg02_n, word16, 16);
		int16 ax_n = (seg0800->*bx_n).w0000;
		if (ax_n == ax_n)
		{
			bx_n[0x04]();
			return;
		}
		++bx_n;
	}
}

// 0800:BC49: Register word16 fn0800_BC49(Register mp16 bp, Register Eq_n si, Register Eq_n di, Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack Eq_n ptrArg06, Stack (ptr16 Eq_n) wArg08, Stack Eq_n ptrArg0A, Stack (ptr16 Eq_n) wArg0C, Stack Eq_n ptrArg0E, Stack (ptr16 Eq_n) wArg10, Stack Eq_n ptrArg12, Stack (ptr16 Eq_n) wArg14)
word16 fn0800_BC49(mp16 bp, Eq_n si, Eq_n di, Eq_n ptrArg02, Eq_n wArg04, Eq_n ptrArg06, struct Eq_n * wArg08, Eq_n ptrArg0A, struct Eq_n * wArg0C, Eq_n ptrArg0E, struct Eq_n * wArg10, Eq_n ptrArg12, struct Eq_n * wArg14)
{
	byte * ptrArg06_n = wArg06;
	wArg06 = SLICE(ptrArg06_n, word16, 0);
	wArg08 = SLICE(ptrArg06_n, word16, 16);
	if ((wArg06 | wArg08) != 0x00)
		*ptrArg06_n = 0x00;
	byte * ptrArg0A_n = wArg0A;
	wArg0A = SLICE(ptrArg0A_n, word16, 0);
	wArg0C = SLICE(ptrArg0A_n, word16, 16);
	if ((wArg0A | wArg0C) != 0x00)
		*ptrArg0A_n = 0x00;
	byte * ptrArg0E_n = wArg0E;
	wArg0E = SLICE(ptrArg0E_n, word16, 0);
	wArg10 = SLICE(ptrArg0E_n, word16, 16);
	if ((wArg0E | wArg10) != 0x00)
		*ptrArg0E_n = 0x00;
	byte * ptrArg12_n = wArg12;
	wArg12 = SLICE(ptrArg12_n, word16, 0);
	wArg14 = SLICE(ptrArg12_n, word16, 16);
	if ((wArg12 | wArg14) != 0x00)
		*ptrArg12_n = 0x00;
	byte * ptrLoc06_n = fp - 0x5A;
	word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
	word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
	word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
	word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
	while (true)
	{
		word16 wArg02_n = SLICE(ptrArg02, word16, 0);
		word16 wArg04_n = SLICE(ptrArg02, word16, 16);
		word16 wArg02_n = SLICE(ptrArg02, word16, 0);
		word16 wArg04_n = SLICE(ptrArg02, word16, 16);
		if (*ptrArg02 != 0x20)
			break;
		ptrArg02 = SEQ(wArg04_n, wArg02_n + 0x01);
		Mem69 = Mem76;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	Eq_n ax_n = fn0800_BFC7(ptrArg02, stackArg4, out cx_n);
	Eq_n si_n = ax_n;
	if (ax_n > 0x50)
		si_n.u0 = 0x50;
	*ptrLoc06_n = 0x00;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	word16 v23_n = (word32) si_n + (wLoc06_n + 0x01);
	word16 dx_n = fn0800_C01E(SEQ(wLoc04_n, wLoc06_n + 0x01), stackArg4, SEQ(wArg04_n, wArg02_n), si_n);
	*SEQ(wLoc04_n, v23_n) = 0x00;
	word16 wLoc06_n = v23_n;
	segptr32 ptrLoc06_n = SEQ(wLoc04_n, v23_n);
	segptr32 ptrArg02_n = SEQ(wArg04_n, wArg02_n);
	while (true)
	{
		word16 v24_n = wLoc06_n - 0x01;
		word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		wLoc06_n = v24_n;
		int16 ax_n = (int16) *SEQ(SLICE(ptrLoc06_n, word16, 16), v24_n);
		word16 cx_n;
		struct Eq_n Eq_n::* bx_n = Eq_n::aFFFFBE1F;
		for (cx_n = 0x07; cx_n != 0x00; --cx_n)
		{
			word16 wArg04_n = SLICE(ptrArg02_n, word16, 16);
			int16 ax_n = (seg0800->*bx_n).w0000;
			if (ax_n == ax_n)
			{
				word16 bx_n;
				bx_n[0x07]();
				return bx_n;
			}
			++bx_n;
		}
		ptrLoc06_n = SEQ(wLoc04_n, v24_n);
	}
}

// 0800:BE3B: Register word16 fn0800_BE3B(Register Eq_n si, Register Eq_n di, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack (ptr16 Eq_n) wArg08, Stack Eq_n wArg0A, Stack (ptr16 Eq_n) wArg0C, Stack Eq_n wArg0E, Stack (ptr16 Eq_n) wArg10, Stack Eq_n wArg12, Stack (ptr16 Eq_n) wArg14)
word16 fn0800_BE3B(Eq_n si, Eq_n di, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, struct Eq_n * wArg08, Eq_n wArg0A, struct Eq_n * wArg0C, Eq_n wArg0E, struct Eq_n * wArg10, Eq_n wArg12, struct Eq_n * wArg14)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg4 = <invalid>;
	return fn0800_BC49(fp - 0x02, si, di, SEQ(wArg04, wArg02), stackArg4, wArg06, wArg08, wArg0A, wArg0C, wArg0E, wArg10, wArg12, wArg14);
}

// 0800:BEA2: Register word16 fn0800_BEA2(Register Eq_n cx, Register Eq_n dx, Register Eq_n ds, Stack (ptr32 byte) ptrArg02, Stack word16 wArg06, Stack Eq_n wArg08, Register out ptr16 diOut)
word16 fn0800_BEA2(Eq_n cx, Eq_n dx, Eq_n ds, byte * ptrArg02, word16 wArg06, Eq_n wArg08, ptr16 & diOut)
{
	*ptrArg02 = 0x00;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg6 = <invalid>;
	ptr16 di_n;
	word16 si_n;
	fn0800-9828(cx, dx, (word16) ptrArg02, ds, fp + 0x0A, SEQ(wArg08, wArg06), stackArg6, out si_n, out di_n);
	diOut = di_n;
	return si_n;
}

// 0800:BF18: Register byte fn0800_BF18(Register Eq_n cx, Register Eq_n dx, Register uint16 bx, Register Eq_n si, Register Eq_n di, Register (ptr16 Eq_n) es, Register Eq_n ds, Stack (memptr Eq_n Eq_n) wArg06, Stack Eq_n wArg08, Register out ptr16 diOut)
byte fn0800_BF18(Eq_n cx, Eq_n dx, uint16 bx, Eq_n si, Eq_n di, struct Eq_n * es, Eq_n ds, struct Eq_n Eq_n::* wArg06, Eq_n wArg08, ptr16 & diOut)
{
	ptr16 di_n;
	word16 cx_n = (word16) fn0800-8F97(cx, dx, bx, fp - 0x02, si, di, es, ds, ~0x411A, ~0x40F2, fp + 0x02, ss, wArg06, wArg08, out di_n);
	diOut = di_n;
	return (byte) cx_n;
}

// 0800:BF5F: void fn0800_BF5F(Stack segptr32 ptrArg02, Stack segptr32 ptrArg06)
void fn0800_BF5F(segptr32 ptrArg02, segptr32 ptrArg06)
{
	byte Eq_n::* di_n = (word16) ptrArg02;
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	struct Eq_n Eq_n::* si_n = di_n - 0x01;
	struct Eq_n * es_n = SLICE(ptrArg06, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg06;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		++di_n;
		--cx_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	cu16 cx_n = ~cx_n;
	Eq_n di_n = di_n - cx_n;
	struct Eq_n Eq_n::* di_n = si_n;
	Eq_n si_n = di_n;
	if ((di_n & 0x01) != 0x00)
	{
		(es_n->*si_n).t0000 = es_n->*di_n;
		si_n = (word32) di_n + 0x01;
		di_n = (struct Eq_n Eq_n::*) ((char *) &si_n->t0000 + 0x01);
		--cx_n;
	}
	uint16 cx_n = cx_n >> 0x01;
	cx_n = cx_n;
	while (true)
	{
		uint16 cx_n;
		if (cx_n == 0x00)
			break;
		(es_n->*di_n).t0000 = es_n->*si_n;
		si_n = (word32) si_n + 0x02;
		++di_n;
		--cx_n;
	}
	if (cx_n < 0x00)
		(es_n->*di_n).t0000 = es_n->*si_n;
}

// 0800:BF9E: void fn0800_BF9E(Stack segptr32 ptrArg02, Stack Eq_n wArg04, Stack segptr32 ptrArg06)
void fn0800_BF9E(segptr32 ptrArg02, Eq_n wArg04, segptr32 ptrArg06)
{
	byte Eq_n::* di_n = (word16) ptrArg06;
	struct Eq_n * es_n = SLICE(ptrArg06, selector, 16);
	byte Eq_n::* si_n = di_n;
	word16 cx_n = ~0x00;
	while (cx_n != 0x00)
	{
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	word16 cx_n;
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	for (cx_n = ~cx_n; cx_n != 0x00; --cx_n)
	{
		es_n->*di_n = es_n->*si_n;
		++si_n;
		++di_n;
	}
}

// 0800:BFC7: Register ptr16 fn0800_BFC7(Stack Eq_n ptrArg02, Stack Eq_n wArg04, Register out ptr16 cxOut)
ptr16 fn0800_BFC7(Eq_n ptrArg02, Eq_n wArg04, ptr16 & cxOut)
{
	word16 wArg04_n = SLICE(ptrArg02, word16, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	ptr16 ax_n = 0x00;
	if (wArg04_n != 0x00 || di_n != &Eq_n::b0000)
	{
		word16 cx_n = ~0x00;
		do
		{
			ax_n = DPB(ax_n, 0x00, 0);
			ax_n = DPB(ax_n, 0x00, 0);
			if (cx_n == 0x00)
				break;
			di_n = di_n + 0x01;
			--cx_n;
			di_n = di_n;
		} while (es_n->*di_n == 0x00);
		cx = ax_n;
		ax_n = ~cx_n - 0x01;
	}
	cxOut = cx;
	return ax_n;
}

// 0800:BFE6: Register Eq_n fn0800_BFE6(Stack Eq_n ptrArg02, Stack Eq_n ptrArg06, Stack Eq_n wArg0A)
Eq_n fn0800_BFE6(Eq_n ptrArg02, Eq_n ptrArg06, Eq_n wArg0A)
{
	byte Eq_n::* di_n = (word16) ptrArg06;
	struct Eq_n * es_n = SLICE(ptrArg06, selector, 16);
	Eq_n ax_n = wArg0A;
	Eq_n cx_n = wArg0A;
	if (wArg0A != 0x00)
	{
		word16 ax_n = DPB(wArg0A, 0x00, 0);
		di_n = di_n;
		do
		{
			byte Eq_n::* di_n;
			ax_n = DPB(ax_n, 0x00, 0);
			ax_n = DPB(ax_n, 0x00, 0);
			if (cx_n == 0x00)
				break;
			di_n = di_n + 0x01;
			--cx_n;
			di_n = di_n;
		} while (es_n->*di_n == 0x00);
		word16 bx_n = wArg0A - cx_n;
		word16 cx_n = bx_n;
		byte Eq_n::* di_n = di_n;
		struct Eq_n * ds_n = SLICE(ptrArg02, selector, 16);
		byte Eq_n::* si_n = (word16) ptrArg02;
		while (cx_n != 0x00)
		{
			++si_n;
			++di_n;
			--cx_n;
			if (ds_n->*si_n == es_n->*di_n)
				break;
		}
		ax_n = DPB(DPB(ax_n, ds_n->*(si_n - 0x01), 0), 0x00, 8) - DPB(DPB(bx_n, es_n->*(di_n - 0x01), 0), 0x00, 8);
	}
	return ax_n;
}

// 0800:C01E: Register word16 fn0800_C01E(Stack Eq_n ptrArg02, Stack Eq_n wArg04, Stack Eq_n ptrArg06, Stack Eq_n wArg0A)
word16 fn0800_C01E(Eq_n ptrArg02, Eq_n wArg04, Eq_n ptrArg06, Eq_n wArg0A)
{
	word16 wArg04_n = SLICE(ptrArg02, word16, 16);
	byte Eq_n::* di_n = (word16) ptrArg06;
	struct Eq_n * es_n = SLICE(ptrArg06, selector, 16);
	byte Eq_n::* si_n = di_n;
	Eq_n cx_n = wArg0A;
	while (cx_n != 0x00)
	{
		di_n = di_n + 0x01;
		--cx_n;
		di_n = di_n;
		if (es_n->*di_n != 0x00)
			break;
	}
	struct Eq_n * es_n = SLICE(ptrArg02, selector, 16);
	byte Eq_n::* di_n = (word16) ptrArg02;
	word16 cx_n;
	for (cx_n = wArg0A - cx_n; cx_n != 0x00; --cx_n)
	{
		es_n->*di_n = es_n->*si_n;
		++si_n;
		++di_n;
	}
	Eq_n cx_n;
	for (cx_n = cx_n; cx_n != 0x00; --cx_n)
	{
		es_n->*di_n = 0x00;
		++di_n;
	}
	return wArg04_n;
}

// 0800:C04F: Register Eq_n fn0800_C04F(Register Eq_n ds, Register out ptr16 cxOut, Register out Eq_n dxOut, Register out Eq_n bpOut)
Eq_n fn0800_C04F(Eq_n ds, ptr16 & cxOut, union Eq_n & dxOut, union Eq_n & bpOut)
{
	struct Eq_n Eq_n::* bp_n = fn0800_C379(ds);
	Eq_n dx_n = *((word32) ds + 0x000026E2);
	ss->*(bp_n - 0x02) = (bool) (dx_n < 0xA600) + (*((word32) ds + 9956) + 4814);
	ss->*(bp_n - 0x04) = (word32) dx_n + 0x0000A600;
	ci16 si_n = *(ss->*bp_n).t0004;
	int32 dx_ax_n = (int32) (si_n + 63556 >> 0x02);
	Eq_n sp_n = <invalid>;
	ss->*(sp_n - 0x02) = (word16) dx_ax_n;
	ss->*(sp_n - 0x04) = SLICE(dx_ax_n, word16, 16);
	int16 dx_n;
	Eq_n ax_n = fn0800-8F18(0x1F80, ss->*(sp_n - 0x04), 0x0786, ss->*(sp_n - 0x02), out ch_n, out dx_n);
	(ss->*(bp_n - 0x04)).t0000 = v16_n;
	ui32 v17_v16_n = SEQ((ss->*(bp_n - 0x02)).t0000, (ss->*(bp_n - 0x04)).t0000) + SEQ(dx_n, ax_n);
	(ss->*(bp_n - 0x02)).t0000 = SLICE(v17_v16_n, word16, 16);
	int32 dx_ax_n = (int32) (si_n + 63556 & 0x03);
	ss->*(sp_n - 0x02) = (word16) dx_ax_n;
	ss->*(sp_n - 0x04) = SLICE(dx_ax_n, word16, 16);
	int16 dx_n;
	Eq_n ax_n = fn0800-8F18(0x3380, ss->*(sp_n - 0x04), 0x01E1, ss->*(sp_n - 0x02), out ch_n, out dx_n);
	(ss->*(bp_n - 0x04)).t0000 = v19_n;
	ui32 v20_v19_n = SEQ((ss->*(bp_n - 0x02)).t0000, (ss->*(bp_n - 0x04)).t0000) + SEQ(dx_n, ax_n);
	(ss->*(bp_n - 0x02)).t0000 = SLICE(v20_v19_n, word16, 16);
	Eq_n v16_n = (word16) v17_v16_n;
	Eq_n v19_n = (word16) v20_v19_n;
	if ((si_n + 63556 & 0x03) != 0x00)
	{
		(ss->*(bp_n - 0x04)).t0000 = v22_n;
		0x00015180 = (ui32) 0x5180;
		ui32 v23_v22_n = SEQ((ss->*(bp_n - 0x02)).t0000, (ss->*(bp_n - 0x04)).t0000) + 0x00015180;
		(ss->*(bp_n - 0x02)).t0000 = SLICE(v23_v22_n, word16, 16);
		Eq_n v22_n = (word16) v23_v22_n;
	}
	word16 cx_n = 0x00;
	Eq_n si_n = (int16) *((word32) (ss->*bp_n).t0004 + 0x03) - 0x01;
	while (si_n > 0x00)
	{
		--si_n;
		cx_n += (int16) (ds->*((word32) si_n + 9908));
	}
	Eq_n es_bx_n = (ss->*bp_n).t0004;
	int16 ax_n = (int16) *((word32) es_bx_n + 0x02);
	Eq_n cx_n = cx_n + (ax_n - 0x01);
	if (*((word32) es_bx_n + 0x03) > 0x02 && (*es_bx_n & 0x03) == 0x00)
		cx_n = (word32) cx_n + 0x01;
	Eq_n es_bx_n = (ss->*bp_n).t0008;
	ss->*(sp_n - 0x02) = DPB(DPB(ax_n - 0x01, *((word32) es_bx_n + 0x01), 0), 0x00, 8);
	word16 ax_n = (word16) (ss->*(sp_n - 0x02)) + (word16) (cx_n *s 0x18);
	word16 si_n = ax_n;
	if (*((word32) ds + 0x000026E6) != 0x00)
	{
		ss->*(sp_n - 0x02) = DPB(DPB(ax_n, *((word32) es_bx_n + 0x01), 0), 0x00, 8);
		ss->*(sp_n - 0x04) = cx_n;
		(ss->*(sp_n - 0x06)).u0 = 0x00;
		ss->*(sp_n - 0x08) = (word32) *(ss->*bp_n).t0004 + 63566;
		if (fn0800_C553(ds, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02)) != 0x00)
			si_n = ax_n - 0x01;
	}
	int32 dx_ax_n = (int32) si_n;
	ss->*(sp_n - 0x02) = (word16) dx_ax_n;
	ss->*(sp_n - 0x04) = SLICE(dx_ax_n, word16, 16);
	int16 dx_n;
	Eq_n ax_n = fn0800-8F18(0x0E10, ss->*(sp_n - 0x04), 0x00, ss->*(sp_n - 0x02), out ch_n, out dx_n);
	(ss->*(bp_n - 0x04)).t0000 = v26_n;
	ui32 v27_v26_n = SEQ((ss->*(bp_n - 0x02)).t0000, (ss->*(bp_n - 0x04)).t0000) + SEQ(dx_n, ax_n);
	(ss->*(bp_n - 0x02)).t0000 = SLICE(v27_v26_n, word16, 16);
	int32 dx_ax_n = (int32) DPB(DPB(ax_n, *(ss->*bp_n).t0008, 0), 0x00, 8);
	ss->*(sp_n - 0x02) = (word16) dx_ax_n;
	ss->*(sp_n - 0x04) = SLICE(dx_ax_n, word16, 16);
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8F18(0x3C, ss->*(sp_n - 0x04), 0x00, ss->*(sp_n - 0x02), out ch_n, out dx_n);
	Eq_n es_bx_n = (ss->*bp_n).t0008;
	word16 bx_n = DPB(DPB((word16) es_bx_n, *((word32) es_bx_n + 0x03), 0), 0x00, 8);
	ss->*(sp_n - 0x02) = ax_n;
	ss->*(sp_n - 0x04) = dx_n;
	ui32 bx_cx_n = SEQ(ss->*(sp_n - 0x04), ss->*(sp_n - 0x02)) + (int32) bx_n;
	(ss->*(bp_n - 0x04)).t0000 = v30_n;
	ui32 v31_v30_n = SEQ((ss->*(bp_n - 0x02)).t0000, (ss->*(bp_n - 0x04)).t0000) + bx_cx_n;
	(ss->*(bp_n - 0x02)).t0000 = SLICE(v31_v30_n, word16, 16);
	Eq_n dx_n = (ss->*(bp_n - 0x02)).t0000;
	Eq_n ax_n = (ss->*(bp_n - 0x04)).t0000;
	Eq_n bp_n = (ss->*bp_n).t0000;
	cxOut = (word16) bx_cx_n;
	dxOut = dx_n;
	bpOut = bp_n;
	Eq_n v26_n = (word16) v27_v26_n;
	Eq_n v30_n = (word16) v31_v30_n;
	return ax_n;
}

// 0800:C177: void fn0800_C177(Register Eq_n ds)
void fn0800_C177(Eq_n ds)
{
	struct Eq_n Eq_n::* bp_n = fn0800_C379(ds);
	ax_n = (ui16) ((bool) (*((word32) ds + 0x000026E2) < 0xA600) + (*((word32) ds + 9956) + 4814));
	(ss->*bp_n).t0004 = v10_n;
	(ss->*bp_n).t0004 = SEQ((ss->*bp_n).t0006, (ss->*bp_n).t0004);
	ui32 v11_v10_n = (ss->*bp_n).t0004 - SEQ(ax_n, dx_n + 0xA600);
	(ss->*bp_n).t0006 = SLICE(v11_v10_n, word16, 16);
	(ss->*bp_n).ptr000C->b0002 = 0x00;
	Eq_n sp_n = <invalid>;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x3C;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	(ss->*bp_n).ptr000C->b0003 = (byte) fn0800-8BCA(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n);
	Eq_n sp_n = <invalid>;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x3C;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BBB(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
	(ss->*bp_n).t0006 = dx_n;
	(ss->*bp_n).t0004 = ax_n;
	Eq_n sp_n = <invalid>;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x3C;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	(ss->*bp_n).ptr000C->b0000 = (byte) fn0800-8BCA(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n);
	Eq_n sp_n = <invalid>;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x3C;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BBB(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
	(ss->*bp_n).t0006 = dx_n;
	(ss->*bp_n).t0004 = ax_n;
	Eq_n sp_n = <invalid>;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x88F8;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	*(ss->*bp_n).t0008 = (fn0800-8BBB(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n) << 0x02) + 0x07BC;
	Eq_n sp_n = <invalid>;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x88F8;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BCA(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n);
	(ss->*bp_n).t0006 = dx_n;
	(ss->*bp_n).t0004 = ax_n;
	Eq_n v10_n = (word16) v11_v10_n;
	Eq_n sp_n = <invalid>;
	if ((ss->*bp_n).t0006 >= 0x00 && ((ss->*bp_n).t0006 != 0x00 || (ss->*bp_n).t0004 >= 0x2250))
	{
		Eq_n v31_n = (ss->*bp_n).t0004 - 0x2250;
		(ss->*bp_n).t0004 = v31_n;
		(ss->*bp_n).t0006 -= v31_n < 0x00;
		Eq_n es_bx_n = (ss->*bp_n).t0008;
		*es_bx_n = (word32) *es_bx_n + 0x01;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x2238;
		ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
		ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n ax_n = fn0800-8BBB(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
		Eq_n es_bx_n = (ss->*bp_n).t0008;
		Mem248[es_bx_n + 0x00:word16] = Mem234[es_bx_n + 0x00:word16] + ax_n;
		Eq_n sp_n = <invalid>;
		(ss->*(sp_n - 0x02)).u0 = 0x00;
		(ss->*(sp_n - 0x04)).u0 = 0x2238;
		ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
		ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n dx_n;
		Eq_n ax_n = fn0800-8BCA(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out dx_n);
		(ss->*bp_n).t0006 = dx_n;
		(ss->*bp_n).t0004 = ax_n;
		sp_n.u0 = <invalid>;
	}
	if (*((word32) ds + 0x000026E6) != 0x00)
	{
		union Eq_n Eq_n::* sp_n = sp_n - 0x02;
		(ss->*sp_n).u0 = 0x00;
		(ss->*(sp_n - 0x02)).u0 = 0x18;
		ss->*(sp_n - 0x04) = (ss->*bp_n).t0006;
		ss->*(sp_n - 0x06) = (ss->*bp_n).t0004;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = fn0800-8BCA(stackArg0, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n);
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		(ss->*(sp_n - 0x06)).u0 = 0x18;
		ss->*(sp_n - 0x08) = (ss->*bp_n).t0006;
		ss->*(sp_n - 0x0A) = (ss->*bp_n).t0004;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n sp_n = <invalid>;
		ss->*(sp_n - 0x02) = fn0800-8BBB(stackArg0, ss->*(sp_n - 0x0A), ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), out cx_n, out dx_n, out bx_n);
		(ss->*(sp_n - 0x04)).u0 = 0x00;
		ss->*(sp_n - 0x06) = (word32) *(ss->*bp_n).t0008 + 63566;
		sp_n = (word32) sp_n + 0x02;
		if (fn0800_C553(ds, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n) != 0x00)
		{
			Eq_n v43_n = (word32) (ss->*bp_n).t0004 + 0x01;
			(ss->*bp_n).t0004 = v43_n;
			Mem361[ss:bp_n + 0x06:word16] = Mem357[ss:bp_n + 0x06:word16] + (v43_n <u 0x00);
		}
	}
	union Eq_n Eq_n::* sp_n = sp_n - 0x02;
	(ss->*sp_n).u0 = 0x00;
	(ss->*(sp_n - 0x02)).u0 = 0x18;
	ss->*(sp_n - 0x04) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	(ss->*bp_n).ptr000C->b0001 = (byte) fn0800-8BCA(stackArg0, ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), ss->*sp_n, out dx_n);
	Eq_n sp_n = <invalid>;
	(ss->*(sp_n - 0x02)).u0 = 0x00;
	(ss->*(sp_n - 0x04)).u0 = 0x18;
	ss->*(sp_n - 0x06) = (ss->*bp_n).t0006;
	ss->*(sp_n - 0x08) = (ss->*bp_n).t0004;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg0 = <invalid>;
	Eq_n dx_n;
	Eq_n ax_n = fn0800-8BBB(stackArg0, ss->*(sp_n - 0x08), ss->*(sp_n - 0x06), ss->*(sp_n - 0x04), ss->*(sp_n - 0x02), out cx_n, out dx_n, out bx_n);
	(ss->*bp_n).t0006 = dx_n;
	(ss->*bp_n).t0004 = ax_n;
	Eq_n v49_n = (word32) (ss->*bp_n).t0004 + 0x01;
	(ss->*bp_n).t0004 = v49_n;
	Mem424[ss:bp_n + 0x06:word16] = Mem420[ss:bp_n + 0x06:word16] + (v49_n <u 0x00);
	if ((*(ss->*bp_n).t0008 & 0x03) == 0x00)
	{
		if ((ss->*bp_n).t0006 >= 0x00 && ((ss->*bp_n).t0006 > 0x00 || (ss->*bp_n).t0004 > 0x3C))
		{
			Eq_n v52_n = (ss->*bp_n).t0004 - 0x01;
			(ss->*bp_n).t0004 = v52_n;
			(ss->*bp_n).t0006 -= v52_n < 0x00;
		}
		else if ((ss->*bp_n).t0006 == 0x00 && (ss->*bp_n).t0004 == 0x3C)
		{
			Eq_n es_bx_n = (ss->*bp_n).t0008;
			*((word32) es_bx_n + 0x03) = 0x02;
			*((word32) es_bx_n + 0x02) = 0x1D;
			return;
		}
	}
	*((word32) (ss->*bp_n).t0008 + 0x03) = 0x00;
	while (true)
	{
		int32 dx_ax_n = (int32) (int16) ((int16) *((word32) (ss->*bp_n).t0008 + 0x03) + 9908);
		Eq_n dx_n = SLICE(dx_ax_n, word16, 16);
		Eq_n ax_n = (word16) dx_ax_n;
		if (dx_n >= (ss->*bp_n).t0006 && (dx_n != (ss->*bp_n).t0006 || ax_n >= (ss->*bp_n).t0004))
			break;
		Eq_n es_bx_n = (ss->*bp_n).t0008;
		int32 dx_ax_n = (int32) (int16) ((int16) *((word32) es_bx_n + 0x03) + 9908);
		(ss->*bp_n).t0004 = v56_n;
		(ss->*bp_n).t0004 = SEQ((ss->*bp_n).t0006, (ss->*bp_n).t0004);
		ui32 v57_v56_n = (ss->*bp_n).t0004 - dx_ax_n;
		(ss->*bp_n).t0006 = SLICE(v57_v56_n, word16, 16);
		struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
		Eq_n bx_n = (ss->*bp_n).t0008;
		++es_n->*((word32) bx_n + 0x03);
		Eq_n v56_n = (word16) v57_v56_n;
	}
	Eq_n es_bx_n = (ss->*bp_n).t0008;
	*((word32) es_bx_n + 0x03) = (word32) *((word32) es_bx_n + 0x03) + 0x01;
	*((word32) es_bx_n + 0x02) = (ss->*bp_n).t0004;
}

// 0800:C379: Register Eq_n fn0800_C379(Register Eq_n ds)
Eq_n fn0800_C379(Eq_n ds)
{
	cui16 dx_n;
	cui16 ax_n = fn0800_AFCB(ds, SEQ(ds, 9960), out dx_n);
	union Eq_n Eq_n::* bp_n = fp - 0x02;
	if ((ax_n | dx_n) != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		byte * ptrLoc06_n = SEQ(dx_n, ax_n);
		struct Eq_n Eq_n::* wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		Eq_n ptrLoc06_n = SLICE(ptrLoc06_n, word16, 16);
		if (fn0800_BFC7(SEQ(dx_n, ax_n), stackArg4, out cx_n) < 0x04)
			goto l0800_C42C;
		struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
		if (((int16) ((int16) *ptrLoc06_n + 0x2251) & 0x0C) == 0x00 || (((int16) ((int16) (es_n->*wLoc06_n).b0001 + 0x2251) & 0x0C) == 0x00 || ((int16) ((int16) (es_n->*wLoc06_n).b0002 + 0x2251) & 0x0C) == 0x00))
			goto l0800_C42C;
		ptrLoc06_n = SEQ(ptrLoc06_n, wLoc06_n);
		if ((es_n->*wLoc06_n).b0003 != 0x2D)
		{
			if ((es_n->*wLoc06_n).b0003 != 0x2B && ((int16) (es_n->*wLoc06_n).b0003 + 0x2251 & 0x02) == 0x00)
				goto l0800_C42C;
		}
		wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
		struct Eq_n Eq_n::* wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
		struct Eq_n * es_n = SLICE(ptrLoc06_n, selector, 16);
		if (((int16) ((int16) *((word32) ptrLoc06_n + 0x03) + 0x2251) & 0x02) != 0x00 || ((int16) ((int16) (es_n->*wLoc06_n).b0004 + 0x2251) & 0x02) != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg6 = <invalid>;
			fn0800_B083(*((word32) ds + 9950), *((word32) ds + 9952), stackArg6, 0x04);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_n stackArg4 = <invalid>;
			fn0800_C01E(SEQ(*((word32) ds + 9948), *((word32) ds + 9946)), stackArg4, SEQ(wLoc04_n, wLoc06_n), 0x03);
			((word32) ds + 9946)->u1->b0003 = 0x00;
			Eq_n sp_n = <invalid>;
			Eq_n dx_n;
			ss->*((word32) sp_n + 0x02) = fn0800_A471(ds, SEQ(wLoc04_n, (char *) wLoc06_n + 0x03), out dx_n, out bp_n);
			ss->*sp_n = dx_n;
			word16 dx_n;
			Eq_n ax_n = fn0800-8F18(0x0E10, ss->*sp_n, 0x00, ss->*((word32) sp_n + 0x02), out ch_n, out dx_n);
			*((word32) ds + 9956) = dx_n;
			*((word32) ds + 0x000026E2) = ax_n;
			*((word32) ds + 0x000026E6) = 0x00;
			Eq_n si_n = 0x03;
			while (Mem231[Mem231[ss:bp_n - 0x04 + 0x00:segptr32] + si_n:byte] != 0x00)
			{
				if ((Mem231[ds:(int16) Mem231[Mem231[ss:bp_n - 0x04 + 0x00:segptr32] + si_n:byte] + 0x2251:byte] & 0x0C) != 0x00)
				{
					word16 ax_n = Mem231[ss:bp_n - 0x04 + 0x00:word16] + si_n;
					ss->*((word32) sp_n + 0x02) = ss->*(bp_n - 0x02);
					ss->*sp_n = ax_n;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_n stackArg4 = <invalid>;
					if (fn0800_BFC7(ss->*sp_n, stackArg4, out cx_n) >= 0x03)
					{
						Eq_n es_bx_n = ss->*(bp_n - 0x04);
						struct Eq_n * es_n = SLICE(es_bx_n, selector, 16);
						if (((int16) Mem262[ds:(int16) Mem262[es_n:(word16) es_bx_n + 0x01 + si_n:byte] + 0x2251:byte] & 0x0C) != 0x00 && ((int16) ((int16) (es_n->*((word32) si_n + ((word16) (ss->*(bp_n - 0x04)) + 0x02))) + 0x2251) & 0x0C) != 0x00)
						{
							(ss->*((word32) sp_n + 0x02)).u0 = 0x03;
							word16 ax_n = Mem299[ss:bp_n - 0x04 + 0x00:word16] + si_n;
							ss->*sp_n = ss->*(bp_n - 0x02);
							(ss->*(sp_n - 0x02)).t0000 = ax_n;
							(ss->*(sp_n - 0x04)).t0000 = *((word32) ds + 9952);
							(ss->*(sp_n - 0x06)).t0000 = *((word32) ds + 9950);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_n stackArg4 = <invalid>;
							fn0800_C01E((ss->*(sp_n - 0x06)).t0000, stackArg4, (ss->*(sp_n - 0x02)).t0000, ss->*((word32) sp_n + 0x02));
							*((word32) *((word32) ds + 9950) + 0x03) = 0x00;
							*((word32) ds + 0x000026E6) = 0x01;
						}
					}
					return ss->*bp_n;
				}
				si_n = (word32) si_n + 0x01;
			}
			return ss->*bp_n;
		}
		goto l0800_C42C;
	}
	else
	{
l0800_C42C:
		*((word32) ds + 0x000026E6) = 0x01;
		*((word32) ds + 9956) = 0x00;
		((word32) ds + 0x000026E2)->u0 = 18000;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800_BF9E(SEQ(*((word32) ds + 9948), *((word32) ds + 9946)), stackArg4, SEQ(ds, 9963));
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg4 = <invalid>;
		fn0800_BF9E(SEQ(*((word32) ds + 9952), *((word32) ds + 9950)), stackArg4, SEQ(ds, 9967));
		return ss->*bp_n;
	}
}

// 0800:C553: Register word16 fn0800_C553(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n bArg08)
word16 fn0800_C553(Eq_n ds, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n bArg08)
{
	if (wArg04 == 0x00)
	{
		Eq_n si_n = wArg06;
		if (wArg06 >= 0x3B && ((word32) wArg02 + 0x0046 & 0x03) == 0x00)
			si_n = wArg06 - 0x01;
		wArg04.u0 = 0x00;
		while (SEQ(ds, 9920)[wArg04 * 0x02] <=u si_n)
		{
			wArg04 = (byte) wArg04.u0 + 0x01;
			Mem55 = Mem63;
		}
	}
	else
	{
		if (wArg04 < 0x03 || ((word32) wArg02 + 0x0046 & 0x03) != 0x00)
			--wArg06;
		wArg06 += SEQ(ds, 9920)[(wArg04 - 0x01) * 0x02];
	}
	word16 ax_n;
	if (wArg04 < 0x04)
	{
l0800_C62B:
		ax_n = 0x00;
		return ax_n;
	}
	if (wArg04 != 0x04)
	{
		if (wArg04 > 0x0A)
			goto l0800_C62B;
		if (wArg04 != 0x0A)
			goto l0800_C626;
	}
	Eq_n cx_n;
	if (wArg02 > 0x10 && wArg04 == 0x04)
		cx_n = SEQ(ds, 9918)[wArg04 * 0x02] + 0x07;
	else
		cx_n = SEQ(ds, 9920)[wArg04 * 0x02];
	if (((byte) ((word32) wArg02 + 0x07B2) & 0x03) != 0x00)
		--cx_n;
	Eq_n cx_n = cx_n - (uint16) ((uint32) ((uint16) (((word16) (wArg02 * 0x016D) + ((word32) cx_n + ((word32) wArg02 + 0x01 >> 0x02))) + 0x04)) % 0x07);
	if (wArg04 == 0x04)
	{
		if (wArg06 <= cx_n && (wArg06 != cx_n || bArg08 < 0x02))
			goto l0800_C62B;
	}
	else if (wArg06 >= cx_n && (wArg06 != cx_n || bArg08 > 0x01))
		goto l0800_C62B;
l0800_C626:
	ax_n = 0x01;
	return ax_n;
}

// 0800:C632: Register Eq_n fn0800_C632(Register Eq_n ds, Stack Eq_n wArg02, Stack word16 wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Register out Eq_n dxOut, Register out Eq_n bxOut)
Eq_n fn0800_C632(Eq_n ds, Eq_n wArg02, word16 wArg04, Eq_n wArg06, Eq_n wArg08, union Eq_n & dxOut, union Eq_n & bxOut)
{
	Eq_n ax_n;
	if (wArg02 >= *((word32) ds + 9448))
		ax_n = fn0800-8D2B(ds, 0x06);
	else if (wArg08 < 0x01)
		ax_n.u0 = 0x00;
	else
	{
		if ((SEQ(ds, 0x24EA)[wArg02 * 0x02] & 0x0800) != 0x00)
			fn0800-8E29(ds, wArg02, 0x00, 0x00, 0x02, out cx_n, out dx_n, out bx_n);
		if ((SEQ(ds, 0x24EA)[wArg02 * 0x02] & 0x4000) == 0x00)
			ax_n = fn0800_C779(ds, wArg02, SEQ(wArg06, wArg04), wArg08, out cx_n, out dx, out bx);
		else
		{
			SEQ(ds, 0x24EA)[wArg02 * 0x02] &= ~0x0200;
			bx = wArg02 << 0x01;
			Eq_n wLoc08_n = wArg08;
			byte * ptrLoc0E_n = SEQ(wArg06, wArg04);
			do
			{
				mp16 wLoc06_n = fp - 0x90;
				Eq_n ptrLoc06_n = fp - 0x90;
				do
				{
					Eq_n si_n;
					Eq_n ax_n;
					word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
					word16 wLoc0E_n = SLICE(ptrLoc0E_n, word16, 0);
					word16 wLoc0C_n = SLICE(ptrLoc0E_n, word16, 16);
					word16 wLoc0C_n = SLICE(ptrLoc0E_n, word16, 16);
					byte * ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n);
					word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
					word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
					if (wLoc08_n == 0x00)
					{
						si_n = wLoc06_n - (fp - 0x90);
						dx = 0x00 - (si_n < 0x00);
						if (si_n > 0x00)
						{
							Eq_n ax_n = fn0800_C779(ds, wArg02, fp - 0x90, si_n, out cx_n, out dx_n, out bx);
							dx = ax_n;
							if (ax_n != si_n)
							{
								if (ax_n == ~0x00)
									goto l0800_C71A;
								ax_n = wArg08;
								goto l0800_C76A;
							}
						}
						ax_n = wArg08;
						goto l0800_C773;
					}
					Eq_n v20_n = wLoc08_n - 0x01;
					wLoc08_n = v20_n;
					byte al_n = *ptrLoc0E_n;
					byte * ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n);
					ptrLoc0E_n = SEQ(wLoc0C_n, wLoc0E_n + 0x01);
					ptrLoc0E_n = SEQ(wLoc0C_n, wLoc0E_n + 0x01);
					if (al_n == 0x0A)
					{
						*ptrLoc06_n = 0x0D;
						ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
					}
					*ptrLoc06_n = al_n;
					word16 wLoc06_n = SLICE(ptrLoc06_n, word16, 0);
					cup16 dx_n = wLoc06_n + 0x01 - (fp - 0x90);
					Eq_n bx_n = 0x00 - (dx_n < 0x00);
					word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
					word16 wLoc04_n = SLICE(ptrLoc06_n, word16, 16);
					wLoc06_n = wLoc06_n + 0x01;
					bx = bx_n;
					ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
					if (bx_n < 0x00)
						continue;
					if (bx_n != 0x00)
						break;
					ptrLoc06_n = SEQ(wLoc04_n, wLoc06_n + 0x01);
				} while (dx_n < 0x80);
				si_n = wLoc06_n + 0x01 - (fp - 0x90);
				Eq_n ax_n = fn0800_C779(ds, wArg02, fp - 0x90, si_n, out cx_n, out dx_n, out bx);
				dx = ax_n;
			} while (ax_n == si_n);
			if (ax_n == ~0x00)
			{
l0800_C71A:
				ax_n.u0 = ~0x00;
			}
			else
			{
				ax_n = wArg08 - v20_n;
l0800_C76A:
				ax_n = ax_n + dx - si_n;
			}
		}
	}
l0800_C773:
	dxOut = dx;
	bxOut = bx;
	return ax_n;
}

// 0800:C779: Register Eq_n fn0800_C779(Register Eq_n ds, Stack Eq_n wArg02, Stack Eq_n ptrArg04, Stack Eq_n wArg08, Register out Eq_n cxOut, Register out ptr16 dxOut, Register out Eq_n bxOut)
Eq_n fn0800_C779(Eq_n ds, Eq_n wArg02, Eq_n ptrArg04, Eq_n wArg08, union Eq_n & cxOut, ptr16 & dxOut, union Eq_n & bxOut)
{
	Eq_n ax_n;
	Eq_n wLoc04_n;
	Eq_n bx_n = wArg02 << 0x01;
	if ((SEQ(ds, 0x24EA)[wArg02 * 0x02] & 0x01) != 0x00)
		wLoc04_n.u0 = 0x05;
	else
	{
		bx_n = wArg02;
		cx = wArg08;
		dx = (word16) ptrArg04;
		Eq_n ax_n;
		if (!msdos_write_file(wArg02, wArg08, ptrArg04, out ax_n))
		{
			SEQ(ds, 0x24EA)[wArg02 * 0x02] |= 0x1000;
			bx_n = wArg02 << 0x01;
			ax_n = ax_n;
l0800_C7B3:
			cxOut = cx;
			dxOut = dx;
			bxOut = bx_n;
			return ax_n;
		}
		wLoc04_n = ax_n;
	}
	ax_n = fn0800-8D2B(ds, wLoc04_n);
	goto l0800_C7B3;
}

// 1483:0ADB: void fn1483-0ADB()
void fn1483-0ADB()
{
}

// 1483:0ADC: void fn1483-0ADC(Register int16 ax, Register uint8 ch, Register byte cl, Register byte dh, Register byte dl, Register byte bl, Register byte bh, Register Eq_n bp, Register Eq_n si, Register Eq_n di, Register Eq_n es, Register Eq_n ds, Register byte FPUF, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack word16 wArg04, Stack word16 wArg06, Stack word16 wArg08, Stack word16 wArg0A, Stack word16 wArg0C, Stack word16 wArg0E)
void fn1483-0ADC(int16 ax, uint8 ch, byte cl, byte dh, byte dl, byte bl, byte bh, Eq_n bp, Eq_n si, Eq_n di, Eq_n es, Eq_n ds, byte FPUF, Eq_n wArg00, Eq_n wArg02, word16 wArg04, word16 wArg06, word16 wArg08, word16 wArg0A, word16 wArg0C, word16 wArg0E)
{
	Eq_n cx_n = DPB(cx, ch, 8);
	Eq_n bx_n = DPB(bx, bl, 0);
	Eq_n dx_n = DPB(dx, dh, 8);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_n stackArg8 = <invalid>;
	struct Eq_n * es_n;
	union Eq_n * Top_n;
	*Top_n = (union Eq_n *) ((es_n->*fn1483-0D3F(ax, ch, cx_n, dh, dx_n, bl, bx_n, bp, si, di, es, ds, FPUF, wLoc02, wArg00, wArg02, wArg04, stackArg8, wArg0A, out es_n, out Top_n)).rE086 - *Top_n);
}

// 1483:0C11: Register Eq_n fn1483-0C11(Register cu8 al, Register word32 ecx, Register word16 bx, Register word16 bp, Register Eq_n si, Register Eq_n di, Register (ptr16 Eq_n) es, Register Eq_n ds)
Eq_n fn1483-0C11(cu8 al, word32 ecx, word16 bx, word16 bp, Eq_n si, Eq_n di, struct Eq_n * es, Eq_n ds)
{
	Eq_n bx_n = (word16) ebx;
	if (al != ss->*si)
	{
		word32 eax_n = DPB(eax, al + 0x01, 0);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		return fn1483-0C55((word16) eax_n, ds, stackArg0, stackArg2, stackArg4);
	}
	else
	{
		word32 ecx_n = DPB(ecx, cx - 0x01, 0);
		if (al - 0x8C - (al < ss->*si) != 0x00 && cx != 0x01)
		{
			__daa(0x55, &0x55);
			Eq_n dx_n = <invalid>;
			struct Eq_n Eq_n::* bx_n;
			word16 di_n;
			Eq_n ds_n;
			struct Eq_n * es_n;
			struct Eq_n Eq_n::* si_n;
			ui32 dh_ax_n = SEQ(SLICE(dx_n, byte, 8), fn1483-1BB8(0x55, 0x1955, ecx_n, 0x8000, bx_n, bp, si, di, es, ds, out cx_n, out dl_n, out bx_n, out si_n, out di_n, out es_n, out ds_n)) + SEQ((ds_n->*si_n).b147C, (ds_n->*bx_n).w3303);
			Eq_n ss_n = <invalid>;
			Eq_n sp_n = <invalid>;
			Eq_n di_n = di_n + (ds_n->*bx_n).w0000;
			struct Eq_n Eq_n::* ax_n = (word16) dh_ax_n;
			struct Eq_n Eq_n::* sp_n = ss_n->*sp_n;
			word16 v23_n = Mem44[ds_n:ax_n + 0x020E + di_n:word16] + di_n;
			Mem100[ds_n:ax_n + 0x020E + di_n:word16] = v23_n;
			Eq_n ecx_n = <invalid>;
			word16 cx_n = (word16) ecx_n;
			byte al_n = (byte) (bx_n - 0x0903 - (SLICE(dh_ax_n, byte, 16) < 0x00));
			byte ch_n = SLICE(cx_n - 0x01, byte, 8);
			word32 ecx_n = DPB(ecx_n, cx_n - 0x01, 0);
			if (v23_n != 0x00 && cx_n != 0x01)
			{
				Eq_n Top_n;
				fn1483-0CA0(al_n, (ss_n->*sp_n).t0002, (ss_n->*sp_n).t0004, (ss_n->*sp_n).t0006, out Top_n);
				return Top_n;
			}
			else
			{
				Eq_n ax_n = (ds_n->*ax_n).a0000[0x00];
				(ss_n->*sp_n).ptr0000 = si_n;
				es_n->*di_n = (ds_n->*si_n).b0000;
				word32 ecx_n = DPB(ecx_n, ch_n + (byte) ax_n, 8);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				Eq_n stackArg2 = <invalid>;
				Eq_n stackArg4 = <invalid>;
				Eq_n stackArg6 = <invalid>;
				Eq_n Top_n;
				fn1483-0C91(ax_n * 0x02, (byte) ecx_n, (word16) ecx_n, ax_n, &(ds_n->*si_n).b0000 + 0x01, ds_n, stackArg0, stackArg2, stackArg4, stackArg6, out es_n, out Top_n);
				return Top_n;
			}
		}
		else
			es->*di = 0x1955;
	}
}

// 1483:0C55: Register int8 fn1483-0C55(Register word16 ax, Register Eq_n ds, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04)
int8 fn1483-0C55(word16 ax, Eq_n ds, Eq_n wArg00, Eq_n wArg02, Eq_n wArg04)
{
	if (Z)
		return fn1483-0C11((byte) ax, ecx, bx, bp, si, di, es, ds);
	return 0x00;
}

// 1483:0C91: Register word16 fn1483-0C91(Register Eq_n al, Register byte ch, Register Eq_n cl, Register (memptr Eq_n Eq_n) bx, Register Eq_n si, Register Eq_n ds, Stack Eq_n psegArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Register out Eq_n esOut, Register out Eq_n TopOut)
word16 fn1483-0C91(Eq_n al, byte ch, Eq_n cl, struct Eq_n Eq_n::* bx, Eq_n si, Eq_n ds, Eq_n psegArg00, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, union Eq_n & esOut, union Eq_n & TopOut)
{
	byte al_n = (byte) ax;
	word16 cx_n = DPB(cx, ch, 8);
	byte al_n = al_n + ch;
	word16 ax_n = DPB(ax, al_n, 0);
	if (!OVERFLOW(al_n))
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg2 = <invalid>;
		Eq_n stackArg4 = <invalid>;
		Eq_n Top_n = fn1483-0C55(ax_n, ds, wArg02, stackArg2, stackArg4);
		esOut.u0 = <invalid>;
		TopOut = Top_n;
		return di;
	}
	else if (Mem0[ds:bx + si:word16] *s 0x18 == 0x00 && cx_n != 0x01)
	{
		Eq_n Top_n;
		word16 di_n = fn1483-0CA0(al_n, wArg02, wArg04, wArg06, out Top_n);
		esOut.u0 = <invalid>;
		TopOut = Top_n;
		return di_n;
	}
	else
	{
		Mem49[ds:bx + 0x2203 + si:word16] = Mem0[ds:bx + 0x2203 + si:word16] + (cx_n - 0x01);
		Eq_n Top_n;
		word16 di_n = fn1483-0CA0(al_n, wArg02, wArg04, wArg06, out Top_n);
		esOut.u0 = <invalid>;
		TopOut = Top_n;
		return di_n;
	}
}

// 1483:0CA0: Register Eq_n fn1483-0CA0(Register byte al, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Register out Eq_n TopOut)
Eq_n fn1483-0CA0(byte al, Eq_n wArg00, Eq_n wArg02, Eq_n wArg04, union Eq_n & TopOut)
{
	ax_n = DPB(ax, al, 0);
	fn1483_FD4E();
	ah_n = SLICE(ax_n, byte, 8);
	bl_n = (byte) bx_n;
	ax_n = DPB(ax_n, ah_n, 8);
	dx_n = (ds->*si).w173E *s 0x0C62;
	ds->*bx_n = v22;
	bl_n = bl_n + ah_n;
	bx_n = DPB(bx_n, bl_n, 0);
	Mem121[ds:bx_n - 0x56 + di:byte] = __rol(Mem112[ds:bx_n - 0x56 + di:byte], 226);
	(ss->*bp).w007B = __ror((ss->*bp).w007B, 0x01);
	ds->*bx_n = v28;
	bx_n = DPB(bx_n, bl_n & ds->*bx_n, 0);
	es->*di = (byte) (ax_n - 12972);
	ds->*bx_n = v29;
	ds->*((word32) di + 0x0015) = ax_n - ~0x4234;
	fn1483-4FE0();
	ds->wF7E3 = v31;
	bx_n[(word32) di + 0x01] = v32;
	__inw(0x8B);
	TopOut = Top_n;
	return <invalid>;
}

// 1483:0CED: Register Eq_n fn1483-0CED(Register Eq_n ax, Register (memptr Eq_n Eq_n) bx, Register Eq_n si, Register Eq_n di, Register Eq_n es, Register Eq_n ds, Stack Eq_n wArg00, Stack int16 wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack Eq_n wArg08, Stack word16 wArg0A, Stack word16 wArg10, Register out Eq_n esOut, Register out Eq_n TopOut)
Eq_n fn1483-0CED(Eq_n ax, struct Eq_n Eq_n::* bx, Eq_n si, Eq_n di, Eq_n es, Eq_n ds, Eq_n wArg00, int16 wArg02, Eq_n wArg04, Eq_n wArg06, Eq_n wArg08, word16 wArg0A, word16 wArg10, union Eq_n & esOut, union Eq_n & TopOut)
{
	byte bl_n = (byte) bx;
	byte al_n = (byte) ax;
	word16 si_n = si + Mem0[ds:di + 0x00:word16];
	word16 v8_n = (&&(ds->*(ds->*(ds->*bx).aF7E2).w0000))[si_n / 0x0000F7E2] + fp;
	(&&(ds->*(ds->*(ds->*bx).aF7E2).w0000))[si_n / 0x0000F7E2] = v8_n;
	es->*di = ax;
	bool C_n = SLICE(cond(v8_n), bool, 1);
	struct Eq_n Eq_n::* bx_n = DPB(bx, bl_n + 0x01, 0);
	if (bl_n != 0x01)
	{
		esOut = es;
		TopOut.u0 = 0x00;
		return (word32) di + 0x02;
	}
	else
	{
		bx_n[si_n / 0x0000F7E2] = __rcr(bx_n[si_n / 0x0000F7E2], 0xAC, C_n);
		Eq_n es_n;
		Eq_n Top_n;
		Eq_n di_n = fn1483-0CFC(al_n, bl_n + 0x01, wArg02, wArg04, wArg06, wArg08, wArg0A, wArg10, out es_n, out Top_n);
		esOut = es_n;
		TopOut = Top_n;
		return di_n;
	}
}

// 1483:0CFA: Register Eq_n fn1483-0CFA(Register byte al, Register uint8 ch, Register byte bl, Register Eq_n si, Register Eq_n ds, Stack int16 wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack word16 wArg08, Stack word16 wArg0E, Register out (ptr16 Eq_n) esOut, Register out Eq_n TopOut)
Eq_n fn1483-0CFA(byte al, uint8 ch, byte bl, Eq_n si, Eq_n ds, int16 wArg00, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, word16 wArg08, word16 wArg0E, struct Eq_n & esOut, union Eq_n & TopOut)
{
	ds->*((word32) si + 55346) = ds->*((word32) si + 55346) - ch - C;
	struct Eq_n * es_n;
	Eq_n Top_n;
	Eq_n di_n = fn1483-0CFC(al, bl, wArg00, wArg02, wArg04, wArg06, wArg08, wArg0E, out es_n, out Top_n);
	esOut = es_n;
	TopOut = Top_n;
	return di_n;
}

// 1483:0CFC: Register int16 fn1483-0CFC(Register byte al, Register byte bl, Stack int16 wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack Eq_n wArg06, Stack word16 wArg08, Stack word16 wArg0E, Register out (ptr16 Eq_n) esOut, Register out Eq_n TopOut)
int16 fn1483-0CFC(byte al, byte bl, int16 wArg00, Eq_n wArg02, Eq_n wArg04, Eq_n wArg06, word16 wArg08, word16 wArg0E, struct Eq_n & esOut, union Eq_n & TopOut)
{
	bx_n = DPB(bx, bl ^ al, 0);
	ax_n = DPB(ax, bx_n[di / 57867], 0);
	Mem55[ss:bp + si:word16] = ~0x2E00;
	if (cx == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		stackArg0.u0 = <invalid>;
		di_n = fn1483-0C91(ax_n, ch_n, cx_n, bx_n, si, ds, stackArg0, wArg02, wArg04, wArg06, out es_n, out Top_n);
		esOut = es_n;
		TopOut = Top_n;
		return di_n;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		stackArg2.u0 = <invalid>;
		stackArg10.u0 = <invalid>;
		stackArg12.u0 = <invalid>;
		di_n = fn1483-0D06(ax_n, dx, bx_n, ds, fs, wArg00, stackArg2, wArg04, wArg08, stackArg10, stackArg12, wArg0E);
		esOut = es;
		TopOut.u0 = 0x00;
		return di_n;
	}
}

// 1483:0D06: Register int16 fn1483-0D06(Register Eq_n ax, Register (memptr Eq_n Eq_n) dx, Register (memptr Eq_n Eq_n) bx, Register Eq_n ds, Register (ptr16 Eq_n) fs, Stack int16 wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack word16 wArg08, Stack Eq_n wArg0A, Stack Eq_n wArg0C, Stack word16 wArg0E)
int16 fn1483-0D06(Eq_n ax, struct Eq_n Eq_n::* dx, struct Eq_n Eq_n::* bx, Eq_n ds, struct Eq_n * fs, int16 wArg00, Eq_n wArg02, Eq_n wArg04, word16 wArg08, Eq_n wArg0A, Eq_n wArg0C, word16 wArg0E)
{
	(ds->*bx).wE209 = (ds->*bx).wE209 - dx - C;
	if (bx != dx)
	{
		msdos_display_string(SEQ(ds, 3361));
		(word32) wArg04 + 0x0052 + wArg00 &= (byte) wArg0E;
		di = wArg00;
	}
	return di;
}

// 1483:0D3F: Register Eq_n fn1483-0D3F(Register int16 ax, Register uint8 ch, Register Eq_n cl, Register byte dh, Register Eq_n dl, Register byte bl, Register Eq_n bh, Register Eq_n bp, Register Eq_n si, Register Eq_n di, Register Eq_n es, Register Eq_n ds, Register byte FPUF, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack word16 wArg06, Stack Eq_n wArg08, Stack word16 wArg0C, Register out Eq_n esOut, Register out Eq_n TopOut)
Eq_n fn1483-0D3F(int16 ax, uint8 ch, Eq_n cl, byte dh, Eq_n dl, byte bl, Eq_n bh, Eq_n bp, Eq_n si, Eq_n di, Eq_n es, Eq_n ds, byte FPUF, Eq_n wArg00, Eq_n wArg02, Eq_n wArg04, word16 wArg06, Eq_n wArg08, word16 wArg0C, union Eq_n & esOut, union Eq_n & TopOut)
{
	byte al_n = (byte) ax;
	if (P)
	{
		Eq_n es_n;
		Eq_n Top_n;
		Eq_n di_n = fn1483-0CFA(al_n, ch, bl, si, ds, ax, wArg00, wArg02, wArg04, wArg06, wArg0C, out es_n, out Top_n);
		esOut = es_n;
		TopOut = Top_n;
		return di_n;
	}
	ui16 ax_ch_n = SEQ(DPB(ax, al_n + ch, 0), ch) - SEQ(64616, Mem7[ds:(bx_n + 0x02) + si:byte]);
	byte ch_n = (byte) ax_ch_n;
	Eq_n ax_n = SLICE(ax_ch_n, word16, 8);
	struct Eq_n Eq_n::* bx_n = DPB(bx, 0xB4, 0);
	word16 cx_n = DPB(cx, ch_n, 8);
	cx_n = DPB(cx, ch_n, 8);
	word16 cx_n = DPB(cx_n, ch_n, 8);
	byte ah_n = SLICE(ax_n, byte, 8);
	word16 dx_n = DPB(dx, dh ^ 0x17, 8);
	if ((dh ^ 0x17) < 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_n stackArg0 = <invalid>;
		Eq_n Top_n;
		Eq_n es_n;
		Eq_n di_n = fn1483-0CED(ax_n, bx_n, si, di, es, ds, stackArg0, ax, wArg00, wArg02, wArg04, wArg06, wArg0C, out es_n, out Top_n);
		esOut = es_n;
		TopOut = Top_n;
		return di_n;
	}
	word16 ax_n = DPB(ax_n, (word32) (ds->*di) + ah_n, 8);
	word16 v19_n = Mem67[ds:bx_n + 0x43 + si:word16];
	Mem70[ds:bx_n + 0x43 + si:word16] = bp;
	ds->*di <<= 0x68;
	Eq_n v22_n = -(ss->*(v19_n - 0x06));
	ss->*(v19_n - 0x06) = v22_n;
	Eq_n bp_n = v19_n;
	if (OVERFLOW(v22_n))
		__syscall(0x04);
	bool S_n;
	ds->*((word32) si + 0x00005C87) = ch_n;
	Eq_n sp_n;
	Eq_n ax_n;
	Eq_n cx_n;
	Eq_n bx_n;
	Eq_n dx_n;
	Eq_n Top_n;
	Eq_n SCZDOP_n;
	fn1483-8A82();
	ss->*(sp_n - 0x02) = ax_n;
	ss->*(sp_n - 0x04) = cx_n;
	ss->*(sp_n - 0x06) = dx_n;
	ss->*(sp_n - 0x08) = bx_n;
	ss->*(sp_n - 0x0A) = sp_n;
	ss->*(sp_n - 0x0C) = v19_n;
	ss->*(sp_n - 0x0E) = si;
	ss->*(sp_n - 0x0010) = di;
	Eq_n bx_n = (word32) SCZDOP_n + ((word16) bx_n.u0 + ds->*((word32) di + (bx_n - 121)));
	byte dh_n = SLICE(dx_n, byte, 8);
	ss->*((word32) di + ((word16) v19_n + 0x0000F512)) = (bool) (bx_n < 0x00) + ((word32) (ss->*((word32) di + ((word16) v19_n + 0x0000F512))) + dh_n);
	ds->*((word32) bx_n + 0x007D) &= (byte) ax_n;
	byte ch_n = SLICE(cx_n, byte, 8);
	word16 ax_n = __aad(si);
	Eq_n ax_n = DPB(ax_n - 0x8747, (bool) (ax_n < 0x8747) + ((byte) (ax_n - 0x8747) + ch_n), 0);
	Eq_n v31_n = ds->*((word32) ax_n + 0x0000995D);
	ds->*((word32) ax_n + 0x0000995D) = ax_n;
	ss->*(sp_n - 0x0012) = sp_n - 0x0010;
	word16 bx_n = bx_n + Mem166[ds:bx_n + v31_n:word16];
	cu8 al_n = (byte) ax_n;
	byte bh_n = SLICE(bx_n, byte, 8);
	cu8 al_n = al_n + 0x2A + ch_n;
	byte cl_n = (byte) (cx_n - 0x01);
	byte ah_n = SLICE(ax_n, byte, 8);
	Eq_n si_n = v31_n;
	word16 dx_n = DPB(dx_n, dh_n - SLICE(bx_n, byte, 8) - (al_n < 0x2A), 8);
	byte bl_n = (byte) bx_n;
	bx_n = DPB(bx_n, bh_n, 8);
	struct Eq_n Eq_n::* ax_n = DPB(ax_n, al_n, 0);
	al_n = al_n;
	struct Eq_n Eq_n::* sp_n = sp_n - 0x0010;
	word16 cx_n = DPB(DPB(cx_n - 0x01, cl_n, 0), cl_n, 0);
	if (!(sp_n - 0x0012) || cx_n == 0x01)
	{
		byte v36_n = Mem166[ds:bx_n + 0x28 + di:byte] - ah_n - (sp_n - 0x0012);
		Mem382[ds:bx_n + 0x28 + di:byte] = v36_n;
		ds->*((word32) v31_n + 0x005A) = ds->*((word32) v31_n + 0x005A) - bh_n - (v36_n < 0x00);
	}
	else
	{
		byte v37_n = Mem166[ds:bx_n + v31_n:byte] - bl_n;
		Mem181[ds:bx_n + v31_n:byte] = v37_n;
		Eq_n CZ_n = SLICE(cond(v37_n), bool, 2);
		if (v37_n < 0x00)
		{
			while (true)
			{
				uint8 dl_n = (byte) dx_n;
				dx_n = DPB(dx_n, dl_n, 0);
				word16 dx_n = DPB(dx_n, dl_n, 0);
				word16 cx_n = DPB(cx_n, cl_n, 0);
				word16 cx_n = DPB(cx_n, cl_n, 0);
				if (!CZ_n)
					break;
				Mem191[ss:bp_n + di:byte] = Mem188[ss:bp_n + di:byte] ^ cl_n;
				S_n = SLICE(cond(Mem191[ss:bp_n + di:byte]), bool, 0);
				__inw(dx_n);
				if (Mem191[ss:bp_n + di:byte] != 0x00)
					goto l1483_nDA8;
				word16 cx_n;
				*Top_n = __rndint(*Top_n);
				struct Eq_n Eq_n::* sp_n = (char *) &(ss->*sp_n).ptr0000 + 0x02;
				es = (ss->*sp_n).ptr0000;
				(ss->*(sp_n - 414)).w0000 = sp_n - 0x1C;
				++si_n;
				byte ah_n = SLICE(sp_n + 36356, byte, 8) | Mem211[ss:(sp_n + 0x0BE9) + si_n:byte];
				++bx_n;
				ax_n = (struct Eq_n Eq_n::*) DPB(&(ss->*sp_n).b0DFA + 0x0000800A, ah_n, 8);
				cl_n = (byte) (cx_n - 0x01);
				byte ch_n = SLICE(cx_n - 0x01, byte, 8);
				ds = bx_n;
				bp_n = sp_n - 0x1C;
				byte bl_n = (byte) bx_n;
				sp_n = sp_n - 414;
				byte al_n = (byte) ax_n;
				cx_n = DPB(cx_n - 0x01, cl_n, 0);
				word16 cx_n = DPB(cx_n, ch_n, 8);
				if (ah_n != 0x00 || cx_n == 0x01)
				{
					struct Eq_n Eq_n::* ax_n;
					Mem230[bx_n:bx_n + si_n:word16] = Mem211[bx_n:bx_n + si_n:word16] + ax_n;
					(ss->*(sp_n - 0x08)).w0000 = bx_n->*si_n;
					(ss->*(sp_n - 0x07)).w0000 = 0x00;
					(ss->*sp_n).b0DFA = v56_n;
					(ss->*(sp_n - 0x01A0)).w0000 = es;
					(ss->*(sp_n - 0x18)).w0000 = ss;
					ui16 v57_v56_n = SEQ((ss->*sp_n).b011B, (ss->*sp_n).b0DFA) + SEQ(232, dl_n);
					(ss->*sp_n).b011B = SLICE(v57_v56_n, byte, 8);
					(ss->*(sp_n - 0x01A2)).w0000 = cs;
					byte cl_n = cl_n - bx_n->*((word32) si_n + 0x005F);
					bx_n->*((word32) si_n + 25415) = bx_n->*((word32) si_n + 25415) ^ cl_n;
					Mem259[ss:sp_n - 0x01A4 + 0x00:word16] = si_n + 0x01;
					byte al_n = al_n | ch_n;
					word16 si_n = si_n + 0x01;
					Eq_n di_n = 0x00;
					uint8 v56_n = (byte) v57_v56_n;
					cx_n = DPB(cx_n - 0x01, cl_n, 0);
					struct Eq_n Eq_n::* ax_n = DPB(ax_n, al_n, 0);
					word16 ax_n = DPB(ax_n, al_n, 0);
					if (al_n == 0x00)
					{
						while (cx_n != 0x00)
						{
							word16 si_n = si_n + 0x02;
							word16 cx_n;
							word16 ax_n = DPB(__aad(bx_n->*si_n + dx_n), 0x00, 8);
							do
							{
								ax_n = DPB(ax_n, bx_n->*si_n, 0);
								di_n = (word32) di_n + ax_n;
								(es->*di_n).u1 = (word16) (es->*di_n).u1 + dx_n;
								++si_n;
								--cx_n;
								ax_n = ax_n;
							} while (cx_n != 0x00);
							al_n = bx_n->*si_n;
							ax_n = DPB(ax_n, al_n, 0);
							si_n = si_n + 0x01;
							cx_n = DPB(cx_n, al_n, 0);
						}
						word16 si_n = *((word16) bx_n + 0x00009004);
						*((word16) bx_n + 0x0300) = DPB(ax_n, al_n | 0x20, 0) + *((word16) bx_n + 0x0300) / 414;
						__cli();
						*((word16) bx_n + 34306) += dx_n;
						Eq_n Top_n;
						fn3024-8E10();
						esOut = es;
						TopOut = Top_n;
						return di_n;
					}
					else
					{
						(ss->*(sp_n - 422)).w0000 = cs;
						ax_n = (struct Eq_n Eq_n::*) DPB(ax_n, FPUF, 8);
						if ((ch_n | al_n) == 0x00)
							__outw(dx_n, ax_n + 0xE80C);
						esOut = es;
						TopOut = Top_n;
						return 0x00;
					}
				}
				Mem226[bx_n:bx_n + si_n:byte] = Mem211[bx_n:bx_n + si_n:byte] + bl_n;
				CZ_n.u0 = SLICE(cond(ax_n - (sp_n - 0x1C)), bool, 2);
			}
			ptr32 ds_bp_n = Mem188[ss:bp_n + di:segptr32];
			struct Eq_n Eq_n::* sp_n = sp_n - 0x02;
			(ss->*sp_n).w0000 = es;
			Eq_n Top_n;
			fn1483_E62A();
			esOut = es;
			TopOut = Top_n;
			return di;
		}
	}
	Eq_n al_n = al_n | 0x3F;
	ci8 v39_n = ds->*((word32) di + 0x002D) - al_n;
	ds->*((word32) di + 0x002D) = v39_n;
	es->*di = al_n;
	S_n = SLICE(cond(v39_n), bool, 0);
	di = (word32) di + 0x01;
	if (v39_n < 0x00)
	{
		es->*((word32) di + 0x01) = al_n;
		di = (word32) di + 0x02;
l1483_nDA8:
		if (S_n)
		{
l1483_nDBF:
			(ss->*(sp_n - 0x02)).w0000 = cs;
			*((word16) ss + 0x0B01) = es;
			*((word32) ds + 0x00008C00) += cl_n;
			ss->*((word32) bp_n + 0x00008CC3) = __ror(ss->*((word32) bp_n + 0x00008CC3), cl_n);
			esOut = es;
			TopOut = Top_n;
			return di;
		}
		Mem422[ss:bp_n + si_n:word16] = -Mem412[ss:bp_n + si_n:word16];
		__cli();
		--di;
		Mem430[ds:bx_n + 0x45 + di:word16] = Mem422[ss:sp_n + 0x00:word16];
		union Eq_n Eq_n::* bp_n = (word32) bp_n + 0x01;
		Mem436[ds:bx_n + 0xC079 + si_n:word16] = Mem430[ds:bx_n + 0xC079 + si_n:word16] + bp_n;
		sp_n = (struct Eq_n Eq_n::*) ((char *) &(ds->*sp_n).ptr0000 + 0x04);
		bp_n = bp_n - 0x01;
	}
	Mem449[ds:bx_n + di:byte] = Mem442[ds:bx_n + di:byte] >>u 0x01;
	Mem455[ds:bx_n + 0x02 + di:byte] = Mem449[ds:bx_n + 0x02 + di:byte] + cl_n;
	sp_n = (struct Eq_n Eq_n::*) ((char *) &(ds->*sp_n).ptr0000 + 0x02);
	goto l1483_nDBF;
}

// 1483:1104: void fn1483-1104(Register cup16 ax, Register byte dl, Register (memptr (ptr16 Eq_n) Eq_n) bx, Register (memptr (ptr16 Eq_n) Eq_n) bp, Register int16 si, Register int16 di, Register (ptr16 Eq_n) es, Register (ptr16 Eq_n) ds)
void fn1483-1104(cup16 ax, byte dl, struct Eq_n Eq_n::* bx, struct Eq_n Eq_n::* bp, int16 si, int16 di, struct Eq_n * es, struct Eq_n * ds)
{
	struct Eq_n * Eq_n::* sp_n = fp;
	Eq_n Top_n = 0x00;
	struct Eq_n * dx_n = DPB(dx, 0x26, 8);
	cu8 al_n = (byte) __aam((byte) (ax - 23959)) - 117 - (ax < 23959);
	while (true)
	{
		(ss->*bp).w450F = (word16) ((bool) (al_n < 0x00) + ((ss->*bp).w450F + si));
		struct Eq_n * Eq_n::* sp_n = sp_n - 0x02;
		ss->*sp_n = es;
		dx_n = DPB(dx_n, 0x34, 8);
		((char *) bp + 0x005E)[si] = dx_n;
		(&&(ds->*(ds->*(ds->*bx).a675E).w0000))[di / 26462] -= 0x7D;
		ss->*(sp_n - 0x02) = dx_n;
		*((word32) Top_n + 0x01) *= lg2(*Top_n + 1.0);
		Eq_n es_bx_n = ds->t9F59;
		Top_n = (word32) Top_n + 0x01;
		*Top_n = scalbn(*Top_n, *((word32) Top_n + 0x01));
		(ss->*bp).w1EC4 = bp + (ss->*bp).w1EC4 / 0x00004511;
		sp_n = sp_n;
		si = ~0x60A6;
		es = SLICE(es_bx_n, selector, 16);
		bx = (word16) es_bx_n;
		di = 49092;
	}
}

// 1483:1B91: FlagGroup Eq_n fn1483-1B91(Register ui16 cx, Register uint8 bh, Register Eq_n bl, Register Eq_n di, Register Eq_n ds, Stack Eq_n psegArg00, Register out Eq_n ecxOut, Register out Eq_n TopOut)
Eq_n fn1483-1B91(ui16 cx, uint8 bh, Eq_n bl, Eq_n di, Eq_n ds, Eq_n psegArg00, union Eq_n & ecxOut, union Eq_n & TopOut)
{
	Eq_n bx_n = DPB(bx, bh, 8);
	ds->*((word16) di.u0 + ((word32) bx_n + 4344)) = ~(ds->*((word16) di.u0 + ((word32) bx_n + 4344)));
	Eq_n v18_n = psegArg00->*((word16) di.u0 + ((word32) bx_n + 12801));
	psegArg00->*((word16) di.u0 + ((word32) bx_n + 12801)) = di;
	word16 ax_n = DPB(ax, al - 0x28, 0);
	__inb(0x41);
	__sti();
	++*((word32) psegArg00 + 0x0000FF1F);
	ui16 ax_al_n = SEQ(cx, (byte) (ax_n ^ 12025)) - SEQ(0xA587, bh);
	word32 ecx_n = DPB(ecx, DPB(ax_n ^ 12025, (byte) ax_al_n, 0), 0);
	Eq_n ax_n = DPB(SLICE(ax_al_n, word16, 8), __inb(fp) - ~0x07 & 0x0A, 0);
	Eq_n ecx_n;
	Eq_n Top_n;
	fn1483-1BB9(ax_n, ecx_n, fp, bx_n, bp, si, v18_n, es, psegArg00, out ecx_n, out dl_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	ecxOut = ecx_n;
	TopOut = Top_n;
	return <invalid>;
}

// 1483:1BB8: Register word16 fn1483-1BB8(Register byte al, Register Eq_n ah, Register word32 ecx, Register mp16 dx, Register Eq_n bx, Register word16 bp, Register Eq_n si, Register Eq_n di, Register (ptr16 Eq_n) es, Register Eq_n ds, Register out Eq_n cxOut, Register out Eq_n dlOut, Register out ptr16 bxOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out (ptr16 Eq_n) esOut, Register out (ptr16 Eq_n) dsOut)
word16 fn1483-1BB8(byte al, Eq_n ah, word32 ecx, mp16 dx, Eq_n bx, word16 bp, Eq_n si, Eq_n di, struct Eq_n * es, Eq_n ds, union Eq_n & cxOut, union Eq_n & dlOut, ptr16 & bxOut, ptr16 & siOut, ptr16 & diOut, struct Eq_n & esOut, struct Eq_n & dsOut)
{
	word32 ecx_n = DPB(ecx, cx, 0);
	Eq_n ax_n = DPB(ax, al | ds->*si, 0);
	ptr16 bx_n;
	ptr16 di_n;
	struct Eq_n * ds_n;
	ptr16 si_n;
	struct Eq_n * es_n;
	word16 ax_n = fn1483-1BB9(ax_n, ecx_n, dx, bx, bp, si, di, es, ds, out ecx_n, out dl_n, out bx_n, out si_n, out di_n, out es_n, out ds_n, out Top_n);
	cxOut.u0 = <invalid>;
	dlOut.u0 = <invalid>;
	bxOut = bx_n;
	siOut = si_n;
	diOut = di_n;
	esOut = es_n;
	dsOut = ds_n;
	return ax_n;
}

// 1483:1BB9: Register Eq_n fn1483-1BB9(Register Eq_n ax, Register word32 ecx, Register mp16 dx, Register Eq_n bx, Register word16 bp, Register Eq_n si, Register Eq_n di, Register (ptr16 Eq_n) es, Register Eq_n ds, Register out Eq_n ecxOut, Register out Eq_n dlOut, Register out Eq_n bxOut, Register out Eq_n siOut, Register out Eq_n diOut, Register out (ptr16 Eq_n) esOut, Register out Eq_n dsOut, Register out Eq_n TopOut)
Eq_n fn1483-1BB9(Eq_n ax, word32 ecx, mp16 dx, Eq_n bx, word16 bp, Eq_n si, Eq_n di, struct Eq_n * es, Eq_n ds, union Eq_n & ecxOut, union Eq_n & dlOut, union Eq_n & bxOut, union Eq_n & siOut, union Eq_n & diOut, struct Eq_n & esOut, union Eq_n & dsOut, union Eq_n & TopOut)
{
	word32 ecx_n = DPB(ecx, cx, 0);
	Eq_n sp_n = fp;
	Eq_n Top_n = 0x00;
	while (true)
	{
		byte bh_n = SLICE(bx, byte, 8);
		bx = DPB(bx, bh_n, 8);
		byte bh_n = SLICE(bx, byte, 8);
		byte al_n = (byte) ax;
		byte al_n = (byte) ax;
		word32 ecx_n = DPB(ecx_n, cx, 0);
		byte cl_n = (byte) cx;
		if (C)
			break;
		word16 dx_n = dx - 0x01;
		byte dh_n = SLICE(dx_n, byte, 8);
		if (dx_n == 0x00)
		{
			ui16 cx_n = cx - 0x01;
			Eq_n ecx_n = DPB(ecx_n, cx_n, 0);
			if (dx_n != 0x00 || cx_n == 0x00)
			{
				struct Eq_n * es_n = ss->*sp_n;
				Eq_n sp_n = (word32) sp_n + 0x02;
				if (si != bx)
				{
					byte al_n = (bool) (si < bx) + ((byte) sp_n + bh_n);
					Eq_n ax_n = si - 0x01;
					byte ah_n = SLICE(sp_n, byte, 8);
					struct Eq_n Eq_n::* ax_n = DPB(sp_n, al_n, 0);
					if (al_n == 0x00)
					{
						__sti();
						Eq_n Top_n;
						Eq_n ecx_n;
						Eq_n ax_n;
						Eq_n bx_n;
						(seg1483->*bx)();
						ecxOut = ecx_n;
						dlOut.u0 = <invalid>;
						bxOut = bx_n;
						siOut = ax;
						diOut = di;
						esOut = es_n;
						dsOut.u0 = <invalid>;
						TopOut = Top_n;
						return ax_n;
					}
					(ds->*ax).u0 = (byte) (ds->*ax).u0 + ah_n;
					ss->*(ax_n - 0x02) = cs;
					sp_n = ax_n - 0x02;
				}
				es = ss->*sp_n;
				es->t02FB = ds->*ax;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_n stackArg0 = <invalid>;
				word32 ecx_n;
				Eq_n SCZO_n = fn1483-1B91(cx_n, (byte) bx, bx, 0x02FC, ds, stackArg0, out ecx_n, out Top_n);
				__cli();
				es->t02FB.u1 = 0x0A0D;
				Eq_n sp_n = (word32) sp_n + 0x02;
				bx = ss->*((word32) sp_n + 0x08);
				word16 cx_n = ss->*((word32) sp_n + 0x0C);
				word16 ax_n = ss->*((word32) sp_n + 0x0E);
				Eq_n di_n = ss->*sp_n;
				si = ss->*((word32) sp_n + 0x02);
				es->*di_n = (byte) ax_n;
				word16 v37_n = Mem110[ds:bx + (di_n + 0x01):word16] + bx;
				ds->*((word32) bx + ((word32) di_n + 0x01)) = v37_n;
				ds->*((word32) di_n + 0x01) = __rcl(ds->*((word32) di_n + 0x01), (byte) cx_n, SLICE(cond(v37_n), bool, 1));
				ax = ax_n - 60602 - SCZO_n;
				bh_n = SLICE(bx, byte, 8);
				ecx_n.u1 = DPB(ecx_n, cx_n, 0);
				sp_n = (word32) sp_n + 0x0010;
				di = (word32) di_n + 0x01;
				al_n = (byte) ax;
			}
			byte al_n = al_n & 0x5C;
			Eq_n sp_n = sp_n - 0x02;
			ss->*sp_n = si;
			Eq_n bx_n = DPB(bx, bh_n, 8);
			Eq_n bx_n = DPB(bx, bh_n, 8);
			union Eq_n Eq_n::* ax_n = DPB(ax, al_n, 0);
			if (al_n != 0x00)
			{
				Eq_n bx_n = DPB(bx, bh_n | ds->*((word32) bx_n + 0x03), 8);
				ss->*(sp_n - 0x02) = es;
				ecxOut = ecx_n;
				dlOut.u0 = <invalid>;
				bxOut = bx_n;
				siOut.u0 = 29289;
				diOut = di;
				esOut = es;
				dsOut.u0 = <invalid>;
				TopOut = Top_n;
				return ax_n - 34302;
			}
			ss->*(sp_n - 0x02) = 25445;
			Eq_n sp_n = ds->*((word32) bx_n + 29290) *s 0x46;
			cx = ss->*((word32) sp_n + 0x0C);
			di = ss->*sp_n;
			si = ss->*((word32) sp_n + 0x02);
			bx = ss->*((word32) sp_n + 0x08);
			dh_n = (byte) *((word32) sp_n + 0x0B);
			cl_n = (byte) cx;
			ecx_n = (word32) DPB(ecx_n, cx, 0);
			al_n = (byte) (ss->*((word32) sp_n + 0x0E));
			sp_n = sp_n + 0x10;
		}
		Eq_n bp_n = ds->*((word32) si + 101) *s 14948;
		Mem188[ss:bp_n + si:byte] = Mem181[ss:bp_n + si:byte] & al_n;
		byte dh_n = dh_n ^ Mem188[ds:bx + di:byte];
		word16 ax_n = __inw(0x0C);
		*((word32) ds + 0x00002CF2) = *((word32) ds + 0x00002CF2) ^ cl_n;
		ds->*di -= dh_n;
		ds->*((word32) di + 59905) = ~(ds->*((word32) di + 59905));
		cu8 al_n = (byte) ax_n;
		Eq_n sp_n = sp_n - 0x02;
		ss->*sp_n = sp_n;
		ds = ss->*((word32) sp_n + 0x02);
		dx = ss->*sp_n;
		Eq_n v34_n = ds->*((word32) di + 2826);
		ds->*((word32) di + 2826) = di;
		__inb(0x41);
		__sti();
		++*((word32) ds + 0x0000FF1F);
		word16 ax_n = DPB(ax_n, al_n - ~0x26, 0);
		bx.u0 = 55561;
		cx = ax_n;
		ecx_n = DPB(ecx_n, ax_n, 0);
		sp_n = (word32) sp_n + 0x04;
		di = v34_n;
		ax = DPB((bool) (al_n < ~0x26) + (DPB(DPB(cx, ~0x50, 8), cl_n, 0) + 0xA587), __inb(dx) - ~0x07 & 0x0A, 0);
		C = false;
	}
}

// 1483:1C50: void fn1483-1C50(Register byte ah, Register mp16 dx)
void fn1483-1C50(byte ah, mp16 dx)
{
	Eq_n ax_n = DPB(ax, __inb(dx), 0);
	ax_n();
}

