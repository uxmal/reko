// space_text.c
// Generated by decompiling space.sav
// using Reko decompiler version 0.11.4.0.

#include "space.h"

Eq_n t0000 = // 0000
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x03C0,
		0x00,
		0x1DAE,
		0x0200,
		0x00,
		0x00,
		23202,
		0x00,
		0x00,
		0x00,
		0x00,
	};
<anonymous> g_t0001 = <code>; // 0001
Eq_n g_t0002 = // 0002
	{
		66,
	};
Eq_n g_t0004 = // 0004
	{
		0x00
	};
Eq_n g_t0005 = // 0005
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0xC000,
		0x03,
		44544,
		0x1D,
	};
Eq_n g_t0007 = // 0007
	{
		0x00,
		0x00,
	};
Eq_n g_t000A = // 000A
	{
		0x4A,
	};
Eq_n g_t000B = // 000B
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0xC0,
		0x1D,
		0x02,
		0x00,
		0xA200,
	};
<anonymous> g_t000D = <code>; // 000D
Eq_n g_t000F = // 000F
	{
		0x00
	};
Eq_n g_t0015 = // 0015
	{
		0x00
	};
Eq_n g_t001B = // 001B
	{
		0x24,
	};
Eq_n g_t0020 = // 0020
	{
		<code>,
		&g_str0200,
		null,
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		0x00,
		0x00,
	};
Eq_n g_t0023 = // 0023
	{
		null,
	};
char g_str0024[] = ""; // 0024
Eq_n g_t0028 = // 0028
	{
		&g_t5AA2,
		0x00,
		?? /* Can't read cui16 at address 0022 */ ,
	};
Eq_n g_t002A = // 002A
	{
		null,
		&g_t5AA2,
	};
Eq_n g_t002C = // 002C
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_n g_t002D = // 002D
	{
		0x69,
	};
<anonymous> g_t0035 = <code>; // 0035
Eq_n g_t003B = // 003B
	{
		0x00
	};
<anonymous> g_t003D = <code>; // 003D
char g_str0042[] = ""; // 0042
Eq_n g_t0047 = // 0047
	{
		null,
	};
Eq_n g_t0050 = // 0050
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		~0x00,
		~0x1B00,
	};
Eq_n g_t0053 = // 0053
	{
		0x00,
		0x00,
	};
Eq_n g_t005A = // 005A
	{
		null,
	};
Eq_n g_t005E = // 005E
	{
		0x00
	};
Eq_n g_t0076 = // 0076
	{
		null,
		0x00,
		?? /* Can't read cui16 at address 0070 */ ,
	};
Eq_n g_t0077 = // 0077
	{
		0x36,
	};
<anonymous> g_t0078 = <code>; // 0078
Eq_n g_t0080 = // 0080
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		&g_tFFFFFFFF,
		&g_tFFFFFFFF,
		~0x00,
		null,
		null,
		0x00,
		0x00,
	};
word16 g_w00A2 = 0x00; // 00A2
Eq_n g_t00B8 = // 00B8
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		0x00,
		0x00,
	};
<anonymous> g_t0106 = <code>; // 0106
word16 g_w0115 = 0x00; // 0115
char g_str011C[] = ""; // 011C
Eq_n g_t0135 = // 0135
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		0x00,
		0x00,
	};
Eq_n g_t014A = // 014A
	{
		0x00
	};
<anonymous> g_t0200 = <code>; // 0200
Eq_n g_t0201 = // 0201
	{
		&g_t201D,
	};
struct Eq_n g_t0202 = // 0202
	{
		&g_t1DC3,
		117,
		?? /* Can't read cui16 at address 01FC */ ,
	};
char g_str0215[] = "\x01\xC1\x15\x01\n\xC0\x1D\x8E\x1B\x01\x03\xC8\t\xC6\x17\""; // 0215
Eq_n g_t021D = // 021D
	{
		<code>,
		&g_strFFFFC803,
		&g_tFFFFC609,
		0x2217,
		37397,
		&g_tFFFFFD05,
		&g_tFFFFC588,
		0x2817,
		&g_t6600,
		&g_strFFFFE60A,
		&g_t0015,
		&g_tFFFF8488,
		&g_t1EF0,
		0x2602,
		0xF700,
		~0x08,
		0x780B,
		0xCE03,
		0x040B,
		
		{
			-0x00003FFD
		},
		0x8015,
		&g_tFFFFC001,
		48149,
		&g_t260A,
		&g_tFFFFE400,
		&g_t000B,
		0x11,
		&g_t6B21,
		&g_tFFFFC483,
		229,
		0xC200,
	};
struct Eq_n g_t0280 = // 0280
	{
		&g_t0106,
		0x1F,
		?? /* Can't read cui16 at address 027A */ ,
	};
Eq_n g_t02F2 = // 02F2
	{
		&g_t15B3,
		~0x4C,
		?? /* Can't read cui16 at address 02EC */ ,
	};
Eq_n g_t0305 = // 0305
	{
		<code>,
		&g_str0C11,
		&g_t0500,
		0x3221,
		3866,
		&g_tFFFFC003,
		&g_tFFFFB815,
		~0x02FC,
		&g_tFFFFC088,
		&g_strFFFFB702,
		&g_tFFFFC823,
		&g_t2021,
		&g_tFFFF8400,
		0x3300,
		0x7A12,
		122,
		0xDF00,
		0x2002,
		0xDF00,
		
		{
			0x0055
		},
		0x2420,
		&g_tFFFFF319,
		30091,
		&g_tFFFF9715,
		&g_tFFFFE903,
		&g_tFFFFDF88,
		~0x2A,
		&g_t7245,
		&g_t2072,
		115,
		29281,
	};
Eq_n g_t030C = // 030C
	{
		&g_tFFFF8332,
		0xB8,
		?? /* Can't read cui16 at address 0306 */ ,
	};
char g_b0380 = '?'; // 0380
char g_b0397 = '?'; // 0397
Eq_n g_t03B8 = // 03B8
	{
		0x1C00,
		0xC0,
		0x1C00,
		0xB6,
		0x1066,
	};
Eq_n g_t03BC = // 03BC
	{
		0x1C00,
		0xB6,
		0x1066,
		0x1D81,
		0x02,
	};
Eq_n g_t03FD = // 03FD
	{
		0x03
	};
word16 g_w0446 = 0x1CC2; // 0446
// 0468: void fn0468(Register (ptr16 byte) r3)
// Called from:
//      fn0472
void fn0468(byte * r3)
{
	while (true)
	{
		++r3;
		int16 r0_n = (int16) *r3;
		if (r0_n == 0x00)
			break;
		do
			;
		while (TTYOUT((char) r0_n));
	}
}

// 0472: void fn0472(Register word16 r1, Stack (ptr16 Eq_n) wArg10)
void fn0472(word16 r1, struct Eq_n * wArg10)
{
	fn0468(&g_b05E4);
	struct Eq_n * r3_n = g_ptr5424;
	struct Eq_n * r0_n = r3_n->ptr007C;
	struct Eq_n * r3_n = r3_n->ptr000E;
	if (r3_n != null)
		r0_n = r3_n->ptr0002;
	fn0528(r0_n);
	struct Eq_n ** sp_n = (struct Eq_n **) <invalid>;
	fn0528(*sp_n);
	fn0468(&g_b05EF);
	ci16 v22_n = *g_ptr5426;
	if (v22_n == 0x00)
	{
		do
			;
		while (TTYOUT('?'));
	}
	else
		fn04FA(v22_n);
	if ((byte) r1 == 0x3D || (byte) r1 == 0x3F)
	{
		fn0468(&g_b0601);
		struct Eq_n * r1_n = wArg10;
		bool C_n = true;
		struct Eq_n * r0_n = &t0000.w0018;
		while (true)
		{
			r1_n = __rcl<word16,byte>(r1_n, 0x01, C_n);
			struct Eq_n * r0_n = __rcl<word16,byte>(r0_n, 0x01, (r1_n & 0x8000) != 0x00);
			do
				;
			while (TTYOUT((char) r0_n));
			r0_n = (struct Eq_n *) (&t0000.w0036 + 40);
			do
			{
				r1_n <<= 1;
				bool C_n = (bool) cond(r1_n);
				if (r1_n == null)
				{
					do
						;
					while (TTYOUT(')'));
					goto l04F2;
				}
				r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
				C_n = (r0_n & 0x80) != 0x00;
				r0_n = r0_n;
			} while ((r0_n & 0x80) != 0x00);
		}
	}
	else
	{
l04F2:
		PRINT(&g_b05E1);
	}
}

// 04FA: void fn04FA(Register ci16 r0)
// Called from:
//      fn0472
//      fn04FA
void fn04FA(ci16 r0)
{
	ci16 wLoc02_n = r0;
	word16 r0_n = 0x00;
	do
	{
		ci16 v11_n = wLoc02_n - 0x0A;
		++r0_n;
		wLoc02_n = v11_n;
	} while (v11_n >= 0x00);
	byte bLoc02_n = (byte) v11_n + 0x3A;
	if (r0_n != 0x01)
		fn04FA(r0_n - 0x01);
	int16 r0_n = (int16) bLoc02_n;
	do
		;
	while (TTYOUT((char) r0_n));
}

Eq_n g_t0500 = // 0500
	{
		0x0A,
		~0x31,
	};
// 051A: Register (ptr16 Eq_n) fn051A(Register (ptr16 Eq_n) r0, Register cup16 r2, Register out (ptr16 Eq_n) r3Out)
// Called from:
//      fn0528
struct Eq_n * fn051A(struct Eq_n * r0, cup16 r2, struct Eq_n & r3Out)
{
	struct Eq_n * r3_n = r0;
	struct Eq_n * r0_n = null;
	while (r2 - r3_n <= 0x00)
	{
		r3_n -= r2;
		r0_n = (struct Eq_n *) ((char *) r0_n + 1);
	}
	r3Out = r3_n;
	return r0_n;
}

// 0528: void fn0528(Register (ptr16 Eq_n) r0)
// Called from:
//      fn0472
void fn0528(struct Eq_n * r0)
{
	struct Eq_n * r3_n;
	word16 r3_n;
	struct Eq_n * r0_n = fn051A(fn051A(r0, 0x28, out r3_n), 0x28, out r3_n);
	word16 r3_n = 0x03;
	while (true)
	{
		int16 r0_n = (int16) r0_n->b05AF;
		do
			;
		while (TTYOUT((char) r0_n));
		--r3_n;
		if (r3_n == 0x00)
			break;
		r0_n = r3_n;
	}
}

// 054C: void fn054C(Register ci16 r0, Register (ptr16 Eq_n) r3)
void fn054C(ci16 r0, struct Eq_n * r3)
{
	r3->b00A0 = (byte) r0;
	r3->b00A1 = r3->b00A2;
	struct Eq_n * r0_n = r3 + (r0 >> 3 & ~0x01) /16 0x00A3;
	ci16 r2_n = r0 & 0x0F;
	struct Eq_n * wLoc02_n = null;
	bool C_n = true;
	do
	{
		struct Eq_n * v18_n = __rcl<word16,byte>(wLoc02_n, 0x01, C_n);
		wLoc02_n = v18_n;
		C_n = (wLoc02_n & 0x8000) != 0x00;
		--r2_n;
	} while (r2_n > 0x00);
	r0_n->w0096 |= v18_n;
}

Eq_n g_t0592 = // 0592
	{
		0x0300,
		0x057A,
		17727,
		0x7272,
		0x3620,
	};
char g_b05E1 = '\r'; // 05E1
byte g_b05E4 = 0x20; // 05E4
byte g_b05EF = 0x22; // 05EF
byte g_b0601 = 0x20; // 0601
// 0608: void fn0608(Stack (ptr16 code) wArg00, Stack (ptr16 Eq_n) wArg02)
void fn0608(<anonymous> * wArg00, struct Eq_n * wArg02)
{
	cui16 wLoc04;
	byte bArg03_n = SLICE(wArg02, byte, 8);
	byte bArg02_n = (byte) wArg02;
	struct Eq_n * r4_n = g_ptr5424;
	r4_n->ptr002A = wArg00;
	struct Eq_n * wArg00_n = null;
	struct Eq_n * r1_n = wArg02;
	if (wArg02 <= null)
	{
		if (wArg02 == null)
			goto l065C;
		r1_n = -wArg02;
	}
	cui16 r2_n = 0x90;
	bool C_n = false;
	while (true)
	{
		r1_n = __rcl<word16,byte>(r1_n, 0x01, C_n);
		C_n = (r1_n & 0x8000) != 0x00;
		if ((r1_n & 0x8000) != 0x00)
			break;
		--r2_n;
	}
	struct Eq_n * r1_n = __swab(SEQ(SLICE(r1_n, byte, 8), 0x00) | r2_n);
	wArg00_n = __rcr<word16,byte>(r1_n, 0x01, (wLoc04 << 0x01 & 0x01) != 0x00);
	wArg02 = SEQ(__rcr<byte,byte>(bArg03_n, 0x01, (r1_n & 0x01) != 0x00), bArg02_n);
l065C:
	r4_n->ptr002A();
}

// 0670: void fn0670(Register (ptr16 Eq_n) r5, Stack (ptr16 code) wArg00, Stack cui16 wArg02, Stack (ptr16 Eq_n) wArg04, Stack cui16 wArg06, Stack (ptr16 Eq_n) wArg08)
void fn0670(struct Eq_n * r5, <anonymous> * wArg00, cui16 wArg02, struct Eq_n * wArg04, cui16 wArg06, struct Eq_n * wArg08)
{
	struct Eq_n * r4_n = g_ptr5424;
	r4_n->ptr002A = wArg00;
	cui16 r2_n = wArg06;
	struct Eq_n * r3_n = wArg08;
	ui32 r0_r1_n = SEQ(wArg02, wArg04);
	if (wArg08 == null)
	{
		r3_n = wArg04;
		r2_n = wArg02;
		r0_r1_n = SEQ(wArg06, wArg08);
	}
	word16 r2_n;
	word16 r3_n;
	ui32 v49_n = r0_r1_n << 0x01;
	struct Eq_n * r1_n = (word16) v49_n;
	struct Eq_n * r0_n = SLICE(v49_n, word16, 16);
	struct Eq_n * r5_n = __rcl<word16,byte>(r5, 0x01, (SLICE(r0_r1_n, word16, 16) & 0x8000) != 0x00);
	if (r0_n == null)
	{
l06B2:
		r2_n = 0x00;
		r3_n = 0x00;
		goto l0738;
	}
	struct Eq_n * r2_n = r2_n << 1;
	if (r2_n == null)
		goto l06B2;
	cui16 r5_n = r5_n + (word16) (r2_n < null);
	wchar_t r4_n = r2_n + SEQ(SLICE(r0_n, byte, 8), 0x00);
	if (r4_n < 0x00)
	{
		if (r4_n <= 0x00)
		{
			__syscall<word16>(0x898A);
			goto l06B2;
		}
	}
	else
	{
		if (r4_n >= 0x00)
			goto l06B0;
		r4_n &= 0x7F00;
		if ((r4_n & 0x7F00) == 0x00)
		{
l06B0:
			__syscall<word16>(0x898B);
			goto l06B2;
		}
	}
	cui16 r4_n = SEQ(SLICE(r4_n, byte, 8), 0x00);
	struct Eq_n * r4_n = __rcr<word16,byte>(r4_n + 0x7F01, 0x01, (r5_n & 0x01) != 0x00);
	struct Eq_n * r2_n = __rcr<word16,byte>(r2_n, 0x01, (r4_n + 0x7F01 & 0x01) != 0x00);
	cui16 r3_n = __swab(r3_n);
	cu16 r2_n = SEQ(SLICE(__swab(r2_n), byte, 8), 0x00) | r3_n;
	struct Eq_n * r3_n = __rcr<word16,byte>(SEQ(SLICE(r3_n, byte, 8), 0x00), 0x01, (r2_n & 0x01) != 0x00);
	cui16 r1_n = __swab(r1_n);
	struct Eq_n * r0_n = SEQ(SLICE(__swab(r0_n), byte, 8), 0x00) | r1_n;
	struct Eq_n * r1_n = SEQ(SLICE(r1_n, byte, 8), 0x00);
	uint32 r4_r5_n = SEQ(r2_n >> 0x01, r3_n);
	uint32 r2_r3_n = SEQ(r2_n >> 0x01, r3_n);
	while (true)
	{
		uint32 r2_r3_n;
		r1_n <<= 1;
		r4_r5_n >>= 1;
		bool C_n = (bool) cond(r1_n);
		if (r1_n == null)
			break;
		r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
		r2_r3_n = r2_r3_n;
		r0_n = r0_n;
		r2_r3_n = r2_r3_n;
		if ((r0_n & 0x8000) == 0x00)
			r2_r3_n = r2_r3_n + r4_r5_n;
	}
	struct Eq_n * r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
	if ((r0_n & 0x8000) == 0x00)
	{
l0700:
		r2_r3_n += r4_r5_n;
	}
	do
	{
		struct Eq_n * r3_n = (word16) r2_r3_n;
		struct Eq_n * r2_n = SLICE(r2_r3_n, word16, 16);
		r4_r5_n >>= 1;
		r0_n <<= 1;
		if (r0_n < null)
			goto l0700;
	} while (r0_n != null);
	struct Eq_n * r4_n = r4_n;
	bool C_n = false;
	if (r2_n < null)
	{
l0724:
		uint32 r2_r3_n = __swab(SEQ(SLICE(__rcl<word16,byte>(r3_n, 0x01, C_n), byte, 8), 0x00) | r2_n) + (uint32) __rcl<word16,byte>(r1_n, 0x01, (r3_n & 0x80) != 0x00);
		r3_n = (word16) r2_r3_n;
		r2_n = SLICE(r2_r3_n, word16, 16);
l0738:
		r4_n->ptr002A();
		return;
	}
	r3_n <<= 0x01;
	r2_n = __rcl<word16,byte>(r2_n, 0x01, (r3_n & 0x8000) != 0x00);
	if ((r4_n & 0x7F80) != 0x00)
	{
		r4_n = (r4_n & 0x7F80) - 0x80;
		C_n = (bool) cond(r4_n);
		goto l0724;
	}
	goto l06B0;
}

Eq_n g_t06F7 = // 06F7
	{
		&g_tFFFFF661,
	};
Eq_n g_t0704 = // 0704
	{
		
		{
			0x02
		},
		&g_w0C84,
		0x0C05,
		3010,
		0x81,
		0x35C4,
		0x7F80,
		0x03C8,
		58820,
	};
// 0754: void fn0754(Stack (ptr16 code) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 Eq_n) wArg04, Stack cui16 wArg06, Stack uint16 wArg08)
void fn0754(<anonymous> * wArg00, struct Eq_n * wArg02, struct Eq_n * wArg04, cui16 wArg06, uint16 wArg08)
{
	struct Eq_n * r0_n;
	struct Eq_n * r2_n;
	struct Eq_n * r4_n = g_ptr5424;
	r4_n->ptr002A = wArg00;
	bool C_n = (bool) cond(wArg02 << 1);
	if (wArg02 << 1 == 0x00)
	{
		__syscall<word16>(0x898C);
		goto l080C;
	}
	struct Eq_n * v24_n = __rcl<word16,byte>(wArg02, 0x01, C_n);
	wArg02 = v24_n;
	if (wArg06 << 1 != 0x00)
	{
		struct Eq_n * v26_n = v24_n + (word16) (wArg06 << 1 < 0x00);
		word16 r2_n = SEQ(SLICE(wArg06 << 1, byte, 8), 0x00);
		word16 r0_n = SEQ(SLICE(wArg02 << 1, byte, 8), 0x00);
		wArg02 = v26_n;
		struct Eq_n * r4_n = wArg06 << 1 & ~r2_n;
		struct Eq_n * r5_n = wArg02 << 1 & ~r0_n;
		wchar_t r2_n = r2_n - r0_n;
		if (r2_n >= 0x00)
		{
			if (r2_n <= 0x00)
			{
				__syscall<word16>(0x898A);
				goto l080A;
			}
l078E:
			ui32 r4_r3_n;
			struct Eq_n * r4_n = __rcr<word16,byte>(r4_n, 0x01, true);
			wArg04 = __rcr<word16,byte>(wArg04, 0x01, (r4_n & 0x01) != 0x00);
			r2_n = __rcr<word16,byte>(r2_n + 0x7F01, 0x01, (v26_n & 0x01) != 0x00);
			struct Eq_n * r5_n = __rcr<word16,byte>(r5_n, 0x01, (r2_n + 0x7F01 & 0x01) != 0x00);
			r0_n = (struct Eq_n *) (&t0000.w0036 + 101);
			cup16 v34_n = r4_n - r5_n;
			if (v34_n > 0x00)
			{
l07AC:
				r4_r3_n = wArg08 - &(r5_n->*wArg04).ptr0000;
				r0_n = (struct Eq_n *) &g_t0202;
				goto l07B6;
			}
			else
			{
				r4_r3_n = (ui32) wArg08;
				if (v34_n >= 0x00)
				{
					uint16 v36_n = wArg08 - wArg04;
					r4_r3_n = (ui32) wArg08;
					if (v36_n >= 0x00)
					{
						if (v36_n == 0x00)
						{
l07E6:
							r2_n += r0_n;
l07E8:
							r0_n = null;
l07FE:
							wArg02->ptr0000();
							return;
						}
						goto l07AC;
					}
				}
l07B6:
				wArg04 = (struct Eq_n *) &g_t07EC;
				ui32 r4_r3_n = r4_r3_n;
				do
				{
					bool C_n;
					ui32 r4_r3_n = r4_r3_n << 0x01;
					uint16 r3_n = (word16) r4_r3_n;
					ui16 r4_n = SLICE(r4_r3_n, word16, 16);
					if ((SLICE(r4_r3_n, word16, 16) & 0x80) == 0x00)
					{
						cu8 v43_n = (byte) (r5_n - r4_n);
						C_n = (bool) cond(v43_n);
						if (v43_n > 0x00)
							goto l07CE;
						if (v43_n != 0x00)
							goto l07C6;
						uint16 v44_n = wArg04 - r3_n;
						C_n = (bool) cond(v44_n);
						if (v44_n > 0x00)
							goto l07CE;
						if (v44_n >= 0x00)
						{
							bool C_n = true;
							do
							{
								r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
								C_n = (r0_n & 0x8000) != 0x00;
								r0_n = r0_n;
							} while ((r0_n & 0x8000) != 0x00);
							if (true)
								goto l07E6;
							goto l07FE;
						}
					}
l07C6:
					r4_r3_n -= &(r5_n->*wArg04).ptr0000;
					C_n = true;
l07CE:
					r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
					r4_r3_n = r4_r3_n;
				} while ((r0_n & 0x8000) != 0x00);
				return;
			}
		}
		if (r2_n <= 0x00)
			goto l078E;
		__syscall<word16>(0x898B);
	}
l080C:
	r2_n = null;
	goto l07E8;
}

word16 g_w07A7 = 0x0620; // 07A7
Eq_n g_t07DD = // 07DD
	{
		<code>,
		&g_strFFFF9786,
		&g_tFFFFF625,
		0x0C07,
		0x090A,
		&g_t0201,
		&g_tFFFFC060,
		0x0115,
		&g_tFFFFF700,
		&g_str440C,
		&g_t40A1,
		&g_tFFFF8B00,
		&g_tFFFF8209,
		0xC200,
		0xA29C,
		0xA2,
		0x00,
		20069,
		0xC800,
		
		{
			0x0055
		},
		63360,
		&g_t0035,
		0x0201,
		&g_tFFFFA28A,
		&g_t3300,
		&g_t720A,
		0x00,
		&g_tFFFFF710,
		&g_t0135,
		0x4B,
		52227,
	};
struct Eq_n g_t07EC = // 07EC
	{
		&g_t6002,
		133,
		?? /* Can't read cui16 at address 07E6 */ ,
	};
// 0818: void fn0818(Register (ptr16 word16) r5)
void fn0818(word16 * r5)
{
	fn11A6(r5 + *r5 + *r5 + 1, r5);
	g_ptr53F0();
}

Eq_n g_t09DE = // 09DE
	{
		
		{
			0x06
		},
		&g_w55CC,
		0x10,
		35266,
		0x35,
		0x0303,
		~0x600B,
		0x4A3A,
		0x10,
	};
Eq_n g_t09F7 = // 09F7
	{
		<code>,
		&g_str104A,
		&g_t5800,
		0xF700,
		0x034A,
		&g_tFFFFF403,
		&g_t361F,
		0x184A,
		&g_t5800,
		&g_str1601,
		&g_t014A,
		&g_t0035,
		&g_t740B,
		0xF700,
		0x0135,
		0x01,
		0xDA00,
		0xC303,
		22665,
		
		{
			-0x0900
		},
		2101,
		&g_tFFFFC303,
		22665,
		&g_t4011,
		&g_t4063,
		&g_tFFFFD063,
		11,
		&g_t5854,
		&g_tFFFFC200,
		0x1F,
		63305,
	};
<anonymous> g_t0A00 = <code>; // 0A00
Eq_n g_t0A15 = // 0A15
	{
		0x01,
		0x03,
	};
// 0A64: void fn0A64(Register (ptr16 word16) r5)
void fn0A64(word16 * r5)
{
	fn11A6(r5 + *r5 + *r5 + 1, r5);
	g_ptr5414();
}

// 0AAE: void fn0AAE(Register (ptr16 Eq_n) r5)
void fn0AAE(struct Eq_n * r5)
{
	struct Eq_n * r4_n = r5->ptr0002;
	word16 v10_n = r4_n->w0002;
	cui16 v12_n = r4_n->w0000;
	int16 r0_n;
	struct Eq_n * r3_n = __rcr<word16,byte>(null, 0x01, (bool) cond(v12_n << 1));
	struct Eq_n * r0_n = __rcr<word16,byte>(v12_n << 1, 0x01, true);
	struct Eq_n * r2_n = SEQ(SLICE(r0_n, byte, 8), 0x00);
	cui16 r0_n = r0_n & ~r2_n;
	wchar_t r2_n = __swab(r2_n);
	if (r2_n <= 0x00)
	{
		int32 r0_r1_n = SEQ(r0_n, v10_n);
		if (r2_n < 0x91)
		{
			do
			{
				while (true)
				{
					r0_n = SLICE(r0_r1_n, word16, 16);
					uint16 r1_n = (word16) r0_r1_n;
					ci16 v32_n = 0x88 - r2_n;
					if (v32_n >= 0x00)
						break;
					r0_r1_n <<= 0x01;
					--r2_n;
				}
				if (v32_n == 0x00)
					break;
				++r2_n;
				r0_n >>= 1;
				r0_r1_n = SEQ(r0_n >> 1, r1_n);
			} while (r0_n >> 1 != 0x00);
			if (r3_n <= null)
				r0_n = -r0_n;
l107E:
			if (r0_n == 0x00)
			{
l1086:
				g_ptr0ABE();
				return;
			}
			r3_n += r0_n;
			if (r3_n >= null)
				goto l1086;
			goto l105E;
		}
l105E:
		__syscall<word16>(0x8981);
	}
	r0_n = 0x00;
	goto l107E;
}

Eq_n g_t0AB7 = // 0AB7
	{
		&g_t021D,
		&g_t2600,
	};
<anonymous> * g_ptr0ABE = &g_t0AC0; // 0ABE
Eq_n g_t0ABF = // 0ABF
	{
		&g_tFFFF800A,
		0x01,
		?? /* Can't read cui16 at address 0AB9 */ ,
	};
<anonymous> g_t0AC0 = <code>; // 0AC0
Eq_n g_t0AC3 = // 0AC3
	{
		
		{
			0x00
		},
		&g_w0115,
		0x0E01,
		0x0815,
		0x08,
		0x0504,
		58881,
		0x0115,
		0x0204,
	};
// 0AC4: void fn0AC4(Register (ptr16 (ptr16 code)) r4, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 code) wArg04)
void fn0AC4(<anonymous> ** r4, struct Eq_n * wArg00, struct Eq_n * wArg02, <anonymous> * wArg04)
{
	fn0AE6(r4, 0x0101, wArg00, wArg02, wArg04);
}

// 0AE2: void fn0AE2(Register (ptr16 (ptr16 code)) r4, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 code) wArg04)
void fn0AE2(<anonymous> ** r4, struct Eq_n * wArg00, struct Eq_n * wArg02, <anonymous> * wArg04)
{
	fn0AE6(r4, 0x0202, wArg00, wArg02, wArg04);
}

// 0AE6: void fn0AE6(Register (ptr16 (ptr16 code)) r4, Stack word16 wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 Eq_n) wArg04, Stack (ptr16 code) wArg06)
// Called from:
//      fn0AC4
//      fn0AE2
void fn0AE6(<anonymous> ** r4, word16 wArg00, struct Eq_n * wArg02, struct Eq_n * wArg04, <anonymous> * wArg06)
{
	cu8 bArg00 = (byte) wArg00;
	cu8 bArg01 = SLICE(wArg00, byte, 8);
	uint16 wLoc04_n;
	struct Eq_n * r3_n = g_ptr5424;
	if (bArg00 != 0x01)
	{
		wLoc04_n = (uint16) bArg00;
		if (bArg00 != 0x08)
			wLoc04_n += 0x03;
	}
	r3_n->w00A4 = wLoc04_n + (word16) (bArg00 - bArg01 < 0x00);
	if (r3_n->b0074 == 0x00)
	{
		r3_n->w0052 = wArg00;
		r3_n->ptr0044 = wArg04;
		wArg06();
	}
	else
	{
		r3_n->w0052 = wArg00;
		r3_n->ptr0044 = wArg02;
		wArg04();
		(*r4)();
	}
}

// 0B3E: void fn0B3E(Register (ptr16 Eq_n) r0, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 word16) ptrArg04)
void fn0B3E(struct Eq_n * r0, struct Eq_n * wArg00, struct Eq_n * wArg02, word16 * ptrArg04)
{
	fn0B60(r0, 0x0202, wArg00, wArg02, ptrArg04);
}

// 0B44: void fn0B44(Register (ptr16 Eq_n) r0, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 word16) ptrArg04)
void fn0B44(struct Eq_n * r0, struct Eq_n * wArg00, struct Eq_n * wArg02, word16 * ptrArg04)
{
	fn0B60(r0, 0x0101, wArg00, wArg02, ptrArg04);
}

// 0B60: void fn0B60(Register (ptr16 Eq_n) r0, Stack word16 wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 Eq_n) wArg04, Stack (ptr16 word16) ptrArg06)
// Called from:
//      fn0B3E
//      fn0B44
void fn0B60(struct Eq_n * r0, word16 wArg00, struct Eq_n * wArg02, struct Eq_n * wArg04, word16 * ptrArg06)
{
	ptr16 fp;
	cu8 bArg00 = (byte) wArg00;
	cu8 bArg01 = SLICE(wArg00, byte, 8);
	uint16 wLoc04_n;
	struct Eq_n * r3_n = g_ptr5424;
	if (bArg00 != 0x01)
	{
		wLoc04_n = (uint16) bArg00;
		if (bArg00 != 0x08)
			wLoc04_n += 0x03;
	}
	word16 * sp_n;
	<anonymous> ** sp_n;
	r3_n->w00A4 = wLoc04_n + (word16) (bArg00 - bArg01 < 0x00);
	if (r3_n->b0074 != 0x00)
	{
		r3_n->w0052 = wArg00;
		r3_n->ptr0044 = wArg02;
		r3_n->w005A = wArg04->t0000;
		r3_n->ptr007E = &g_t0BEC;
		sp_n = fp + 0x06;
l0BC6:
		struct Eq_n * r0_n;
		(*sp_n)();
		struct Eq_n * sp_n = (char *) sp_n + 2;
		sp_n->ptrFFFFFFFE = r3_n;
		sp_n->ptrFFFFFFFC = r0_n;
		struct Eq_n * r3_n = g_ptr5424;
		r3_n->ptr0044 += (int16) r3_n->b0053 /16 166;
		struct Eq_n * v27_n = sp_n->ptrFFFFFFFC;
		word16 v28_n = r3_n->w005A - 0x01;
		r3_n->w005A = v28_n;
		sp_n = sp_n - 0x02;
		r0 = v27_n;
		if (v28_n == 0x00)
		{
			sp_n->ptrFFFFFFFC = sp_n->ptrFFFFFFFE;
			sp_n->ptrFFFFFFFE = r3_n->ptr007E;
			sp_n->ptrFFFFFFFE();
			return;
		}
	}
	else
	{
		r3_n->w0052 = wArg00;
		r3_n->ptr007E = wArg02;
		r3_n->ptr0044 = wArg04;
		r3_n->w005A = *ptrArg06;
		sp_n = fp + 0x06;
	}
	sp_n = sp_n + 1;
	r3_n = *sp_n;
	goto l0BC6;
}

Eq_n g_t0BCE = // 0BCE
	{
		<code>,
		&g_strFFFF9CC0,
		&g_t0053,
		0x6033,
		0x0AF3,
		&g_t005A,
		&g_t02F2,
		5030,
		&g_t1CF6,
		&g_str1583,
		&g_t005E,
		&g_t1581,
		&g_t0305,
		2551,
		0x28,
		0x00,
		772,
		0x10,
		0xA08E,
		
		{
			-32245
		},
		0x0CC1,
		&g_tFFFF8001,
		24642,
		&g_tFFFF8702,
		&g_t6081,
		&g_tFFFF86EE,
		~0x29,
		&g_t0AC0,
		&g_tFFFF800B,
		0xC0,
		0x04,
	};
Eq_n g_t0BEC = // 0BEC
	{
		<code>,
		&g_str15C2,
		&g_t0007,
		0x0102,
		5505,
		&g_t1580,
		&g_t1583,
		0x1066,
		&g_t10A6,
		&g_str0042,
		&g_t03FD,
		&g_t000D,
		&g_t0BCE,
		0x8702,
		0x6081,
		0x60,
		~0x7911,
		177,
		0x4041,
		
		{
			2142
		},
		0x0AC0,
		&g_t0CD6,
		34311,
		&g_t0C01,
		&g_t0C41,
		&g_tFFFF85F2,
		161,
		&g_tFFFFFF80,
		&g_tFFFFE5C2,
		~0x19,
		0x15C1,
	};
char g_str0BF0[] = "\a"; // 0BF0
Eq_n g_t0C01 = // 0C01
	{
		16
	};
char g_str0C11[] = ""; // 0C11
Eq_n g_t0C41 = // 0C41
	{
		
		{
			0x86
		},
		&g_wFFFFB10B,
		0x4100,
		0xD60B,
		0x07,
		0x0180,
		0x010B,
		0x410C,
		0xF20C,
	};
// 0C4A: void fn0C4A(Register ci16 r0, Register (ptr16 Eq_n) r1, Stack cui16 wArg02, Stack (ptr16 code) wArg04)
void fn0C4A(ci16 r0, struct Eq_n * r1, cui16 wArg02, <anonymous> * wArg04)
{
	if (r0 > 0x01)
		return;
	if (wArg02 << 1 < 0x00)
	{
		if (wArg02 << 1 <= 0x00)
			r1 = -r1;
		r1 = __rcl<word16,byte>(r1 >> 0x01, 0x01, (r1 & 0x01) != 0x00);
		if (OVERFLOW<word16>(r1))
		{
			wArg04();
			return;
		}
	}
	wArg04();
}

Eq_n g_t0C80 = // 0C80
	{
		
		{
			66
		},
		&g_w1589,
		6211,
		0x10E6,
		0x15,
		0x8604,
		3013,
		0x0402,
		0x0B05,
	};
char g_str0C81[] = "\x12\x89\x15C\x18I\x11E\x18\t\x11\xC2`\xE6\x10\xC1\x15- \xC0\f\x04\x86\xC5\v\x02\x04\x05\v\xC1"; // 0C81
word16 g_w0C84 = 6211; // 0C84
Eq_n g_t0CD6 = // 0CD6
	{
		&g_t2020,
		&g_t0AC3,
	};
// 0CF4: void fn0CF4(Register (ptr16 Eq_n) r5)
void fn0CF4(struct Eq_n * r5)
{
	Eq_n tLoc08;
	if (r5->b0000 == 0x01)
	{
		struct Eq_n * r0_n = r5->ptr0002;
		tLoc08.ptr0006 = (char *) &tLoc08 + 6;
		tLoc08.ptr0004 = (char *) &tLoc08 + 4;
		tLoc08.ptr0002 = (char *) &tLoc08 + 2;
		tLoc08.w0000 = 0x03;
		fn15CC(&tLoc08);
		struct Eq_n * r1_n = (tLoc08.w0002 << 1) + tLoc08.w0002;
		struct Eq_n * r0_n = fn0D3E(r0_n, tLoc08.ptr0004);
		r0_n->b0000 = 0x2D;
		r0_n->b0001 = r1_n->b0D4F;
		r0_n->b0002 = r1_n->b0D50;
		r0_n->b0003 = r1_n->b0D51;
		r0_n->b0004 = 0x2D;
		struct Eq_n * v36_n = tLoc08.ptr0006;
		fn0D3E(&r0_n->b0004 + 1, v36_n);
	}
	else
		__syscall<word16>(0x8990);
}

<anonymous> g_t0D0A = <code>; // 0D0A
// 0D3E: Register (ptr16 Eq_n) fn0D3E(Register (ptr16 Eq_n) r0, Register (ptr16 Eq_n) r2)
// Called from:
//      fn0CF4
struct Eq_n * fn0D3E(struct Eq_n * r0, struct Eq_n * r2)
{
	ci16 r2_n = __swab(r2);
	do
		r2_n += 0xF601;
	while (r2_n > 0x00);
	r0->b0000 = (byte) r2_n + 0x2F;
	r0->b0001 = (byte) __swab(r2_n + 0x3A2F);
	return &r0->b0001 + 1;
}

// 0D7A: void fn0D7A(Register word16 r0, Stack word16 wArg00, Stack word16 wArg02, Stack word16 wArg04)
void fn0D7A(word16 r0, word16 wArg00, word16 wArg02, word16 wArg04)
{
	g_t0D7E();
}

<anonymous> g_t0D7E = <code>; // 0D7E
// 0DC8: void fn0DC8(Register word16 r0, Stack word16 wArg00, Stack word16 wArg02, Stack word16 wArg04)
void fn0DC8(word16 r0, word16 wArg00, word16 wArg02, word16 wArg04)
{
	g_t0DCC();
}

<anonymous> g_t0DCC = <code>; // 0DCC
Eq_n g_t0E06 = // 0E06
	{
		0x0033
	};
// 0E0E: void fn0E0E(Stack (ptr16 code) wArg00, Stack word16 wArg02, Stack word16 wArg04, Stack word16 wArg06, Stack word16 wArg08)
void fn0E0E(<anonymous> * wArg00, word16 wArg02, word16 wArg04, word16 wArg06, word16 wArg08)
{
	struct Eq_n * r4_n = g_ptr5424;
	r4_n->ptr002A = wArg00;
	cup16 v19_n = wArg06 - wArg02;
	bool v25_n = v19_n >= 0x00;
	if (v19_n == 0x00)
	{
		cup16 v21_n = wArg08 - wArg04;
		v25_n = v21_n >= 0x00;
		if (v21_n == 0x00)
		{
l0E7C:
			r4_n->ptr002A();
			return;
		}
	}
	goto l0E7C;
}

// 0EA8: void fn0EA8(Stack (ptr16 Eq_n) wArg00)
void fn0EA8(struct Eq_n * wArg00)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->ptr0044 = null;
	if (r3_n->b0074 == 0x00)
		r3_n->ptr007E = wArg00;
	wArg00();
	struct Eq_n * r3_n = g_ptr5424;
	if (r3_n->b0074 != 0x00)
	{
		r3_n->ptr0072 = null;
		r3_n->ptr0070 = null;
		r3_n->ptr0014 = null;
		r3_n->w000C = r3_n->w0058;
		r3_n->b00A2 = 0x00;
	}
	else
	{
		r3_n->ptr0072 = null;
		r3_n->ptr0070 = null;
		r3_n->ptr0014 = null;
		r3_n->w000C = r3_n->w0058;
		r3_n->b00A2 = 0x00;
	}
}

Eq_n g_t0EF4 = // 0EF4
	{
		
		{
			0x5C
		},
		&g_w15C1,
		0x0A01,
		40166,
		0x00,
		4838,
		5158,
		5158,
		0x0A0B,
	};
// 0EF8: void fn0EF8(Register (ptr16 Eq_n) r4, Register (ptr16 word16) r5)
// Called from:
//      fn243A
//      fn2B90
//      fn2E20
//      fn2EC4
//      fn3220
//      fn34AC
//      fn395C
//      fn3B3C
//      fn3E12
//      fn3F42
//      fn4030
//      fn4072
//      fn413C
//      fn4180
//      fn4230
//      fn4534
//      fn457C
//      fn45C8
void fn0EF8(struct Eq_n * r4, word16 * r5)
{
	ptr16 fp;
	struct Eq_n * r3_n = g_ptr5424;
	struct Eq_n * v14_n = r4->ptr0000;
	struct Eq_n * v18_n = r3_n->ptr000E;
	Eq_n v19_n = r3_n->t0000;
	byte v17_n = r3_n->b0074;
	byte bLoc04_n = v14_n->b0001;
	r3_n->t0000 = (<anonymous>) 0x00;
	r3_n->ptr000E = fp - 0x07;
	word16 v23_n = *r5;
	byte bLoc03_n = (byte) v19_n;
	byte bLoc01_n = (byte) v18_n;
	byte bLoc02_n = SLICE(v19_n, byte, 8);
	byte bArg00_n = SLICE(v18_n, byte, 8);
	word16 * r0_n = &v14_n->w0004;
	word16 * r5_n = r5 + 1;
	word16 r1_n = v23_n;
	Eq_n wLoc04_n = SEQ(bLoc03_n, bLoc04_n);
	wLoc04_n = SEQ(bLoc03_n, bLoc04_n);
	struct Eq_n * wLoc02_n = SEQ(bLoc01_n, bLoc02_n);
	wLoc02_n = SEQ(bLoc01_n, bLoc02_n);
	if (v23_n != 0x00)
	{
		word16 v24_n = v14_n->w0004;
		r0_n = &v14_n->ptr0006;
		word16 r2_n = v24_n;
		if (v24_n != 0x00)
		{
			r0_n = v14_n->ptr0006;
			do
			{
				*r0_n = *r5_n;
				++r5_n;
				++r0_n;
				--r1_n;
				if (r1_n == 0x00)
					break;
				--r2_n;
			} while (r2_n != 0x00);
		}
	}
	r3_n->b0074 = 0x00;
	word16 wArg00_n = SEQ(v17_n, bArg00_n);
	if (true)
	{
		fn4078();
		struct Eq_n * r4_n = g_ptr5424;
		r4_n->t0000 = (<anonymous>) wLoc04_n;
		r4_n->ptr000E = wLoc02_n;
		r4_n->b0074 = bArg00_n;
	}
	else
		r4->ptr0002();
}

// 0F48: void fn0F48(Register (ptr16 Eq_n) r5)
void fn0F48(struct Eq_n * r5)
{
	if (r5->b0000 == 0x02)
	{
		ui32 r0_r1_n;
		struct Eq_n ** v14_n = r5->ptr0002;
		uint16 * v16_n = r5->ptr0004;
		struct Eq_n * r0_n = *v14_n;
		uint16 r1_n = *v16_n;
		if (r1_n != 0x00)
		{
			r0_r1_n = SEQ(__rcl<word16,byte>(r0_n, 0x01, (bool) cond(r1_n << 1)) + Mem0[v14_n + 0x00:word16], r1_n << 1) + SEQ(Mem0[v16_n + 0x00:word16], Mem0[v16_n + 0x00:word16]);
			uint16 r1_n = (word16) r0_r1_n;
			ci16 r0_n = SLICE(r0_r1_n, word16, 16);
			if (r0_n <= 0x00)
				r0_r1_n = SEQ(r0_n + 0x8000, r1_n);
		}
		else
			r0_r1_n = (ui32) (r0_n + 1 + 3);
		*v14_n = SLICE(r0_r1_n, word16, 16);
		*v16_n = (word16) r0_r1_n;
		ui32 r0_r1_n = r0_r1_n;
		do
			r0_r1_n <<= 0x01;
		while ((SLICE(r0_r1_n, word16, 16) & 0x8000) == 0x00);
	}
	else
		__syscall<word16>(0x8990);
}

// 0F9C: void fn0F9C()
void fn0F9C()
{
	t0000.b002B |= 0x01;
	struct Eq_n * r3_n = g_ptr5424;
	++r3_n->w0066;
	struct Eq_n * r4_n = r3_n->ptr0004;
	while (r4_n - r3_n->ptr0002 < 0x00)
	{
		r4_n = r4_n + 1;
		r4_n = r4_n;
		if ((int16) r4_n->b0000 != 0x00)
		{
			if (r3_n->w0066 == 0x02)
			{
				r4_n->bFFFFFFFF = 0x00;
				--r3_n->w0066;
				--r4_n;
			}
			else
				g_ptr1DAA();
		}
	}
	union Eq_n * r0_n = r3_n->ptr006E;
	if (r0_n == null)
	{
		cui16 v31_n = t0000.w0024 & 0x0800;
		t0000.w0024 = v31_n;
		if (v31_n == 0x00)
			r0_n = (union Eq_n *) ((char *) r0_n + 1);
		EXIT(r0_n);
	}
	else
		r0_n();
}

// 0FA4: void fn0FA4(Register word16 r0, Stack word16 wArg00, Stack (ptr16 Eq_n) wArg02, Stack word16 wArg04, Stack word16 wArg06)
void fn0FA4(word16 r0, word16 wArg00, union Eq_n * wArg02, word16 wArg04, word16 wArg06)
{
	fn0FB2(r0, &g_t1020, wArg00, wArg02, wArg04, wArg06);
}

// 0FAE: void fn0FAE(Register word16 r0, Stack word16 wArg00, Stack (ptr16 Eq_n) wArg02, Stack word16 wArg04, Stack word16 wArg06)
void fn0FAE(word16 r0, word16 wArg00, union Eq_n * wArg02, word16 wArg04, word16 wArg06)
{
	fn0FB2(r0, &g_t101E, wArg00, wArg02, wArg04, wArg06);
}

// 0FB2: void fn0FB2(Register word16 r0, Stack (ptr16 Eq_n) wArg00, Stack word16 wArg02, Stack (ptr16 Eq_n) wArg04, Stack word16 wArg06, Stack word16 wArg08)
// Called from:
//      fn0FA4
//      fn0FAE
void fn0FB2(word16 r0, struct Eq_n * wArg00, word16 wArg02, union Eq_n * wArg04, word16 wArg06, word16 wArg08)
{
	ptr16 fp;
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->ptr0064 = fp + 0x0A;
	if (r3_n->ptr0014 != null)
		__syscall<word16>(0x899A);
	r3_n->ptr0014 = wArg00;
	r3_n->ptr001C = wArg04;
	g_t0FE2();
}

<anonymous> g_t0FE2 = <code>; // 0FE2
Eq_n g_t101E = // 101E
	{
		
		{
			0x00
		},
		&g_wFFFF8000,
		0x1DC4,
		0x0109,
		0x1D,
		0x2A,
		5516,
		5558,
		0x02,
	};
Eq_n g_t1020 = // 1020
	{
		
		{
			0x00
		},
		&g_w1DC4,
		0x4400,
		0x1DC4,
		0x43,
		5516,
		5558,
		0x02,
		5558,
	};
Eq_n g_t1037 = // 1037
	{
		<code>,
		&g_str0215,
		&g_tFFFFB600,
		533,
		0x0315,
		&g_tFFFFC00A,
		&g_t030C,
		0xB10C,
		null,
		&g_strFFFF808A,
		&g_tFFFFC240,
		&g_t0D0A,
		&g_t0080,
		0x5C10,
		0x8000,
		0x80,
		3731,
		0x7F00,
		0x7F7F,
		
		{
			0x007F
		},
		~0x83,
		&g_t7FFF,
		32636,
		&g_t7F7F,
		&g_t7F7F,
		&g_t7F7F,
		0x7F,
		&g_t7F7F,
		&g_t7F7F,
		0x06,
		0x0400,
	};
char g_str104A[] = "\xB1"; // 104A
<anonymous> g_t105D = <code>; // 105D
Eq_n g_t10A6 = // 10A6
	{
		
		{
			0x7F
		},
		&g_w7F7F,
		0x7F7F,
		0x7F7F,
		0x7F,
		0x7F7F,
		0x7F7F,
		0x7F7F,
		0x7F7F,
	};
// 11A6: void fn11A6(Register (ptr16 Eq_n) r0, Register (ptr16 word16) r5)
// Called from:
//      fn0818
//      fn0A64
void fn11A6(struct Eq_n * r0, word16 * r5)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->ptr0064 = r0;
	r3_n->w0058 = r3_n->w000C;
	word16 * r0_n = g_a541C;
	word16 * r1_n = &g_w542C;
	word16 * r2_n = &g_ptr5426;
	word16 ** r5_n = r5 + 1;
	while (true)
	{
		r2_n -= 0x02;
		word16 * r3_n = *r2_n;
		if (r3_n == null)
			break;
		uint16 r4_n = *r0_n;
		r1_n -= 0x02;
		*r1_n = **r5_n;
		uint16 v25_n = *r1_n;
		++r0_n;
		r5_n = (word16 **) ((char *) r5_n + 2);
		uint16 wLoc02_n = v25_n;
		bool v40_n = v25_n == 0x00;
		while (!v40_n)
		{
			uint16 v29_n = wLoc02_n >> 0x01;
			wLoc02_n = v29_n;
			if ((wLoc02_n & 0x01) == 0x00)
			{
				r4_n &= 0x01;
				if (r4_n != 0x00)
				{
					*r3_n = *r5_n;
					r5_n = (word16 **) ((char *) r5_n + 2);
				}
			}
			++r3_n;
			r4_n >>= 0x01;
			v40_n = v29_n == 0x00;
		}
	}
}

<anonymous> g_t11EC = <code>; // 11EC
// 12AC: void fn12AC(Register int16 r2)
void fn12AC(int16 r2)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->b00A2 = (byte) r2;
	if (r3_n->ptr0014 != null)
		__syscall<word16>(0x899A);
	struct Eq_n * r0_n = fn1420(r2, r3_n);
	r3_n->ptr0014 = r0_n;
	r0_n->t0000.u1 = (ci16) (r0_n->t0000.u1 & 0x0800);
}

// 12CA: void fn12CA(Register ptr16 r2, Register (ptr16 Eq_n) r3)
void fn12CA(ptr16 r2, struct Eq_n * r3)
{
	ptr16 fp;
	struct Eq_n * r4_n = r3->ptr0014;
	char * r1_n = r3->ptr001A;
	if (r4_n->t0000.u0 <= 0x00)
	{
		PRINT(&g_b138E);
		r2 = r3->ptr0054;
		r3->ptr0054 = fp - 0x04;
	}
	Eq_n v19_n = r4_n->t0000.u1 & 0x20;
	r4_n->t0000.u1 = (ci16) v19_n;
	int16 r0_n = 0x0A;
	if (v19_n != 0x00)
	{
		int16 r5_n = (int16) *r1_n;
		++r1_n;
		if ((byte) r5_n == 0x31)
		{
			r0_n = 0x0C;
l1326:
			word16 r2_n;
			fn1366(r0_n, r3, r4_n, out r2_n, out r3, out r4_n);
l132A:
			if (r4_n->t0000.u0 <= 0x00)
			{
				if (r1_n - r3->ptr001C < 0x00)
				{
					int16 r5_n = (int16) r3->ptr001C->u0;
					r3->ptr001C->u1 = (ptr16) 0x80;
					PRINT(r1_n);
					r3->ptr001C->u1 = (ptr16) (byte) r5_n;
				}
			}
			else
			{
				while (r1_n - r3->ptr001C < 0x00)
				{
					word16 r2_n;
					fn1370((int16) *r1_n, r3, r4_n, out r2_n, out r3, out r4_n);
					++r1_n;
				}
			}
			return;
		}
		if ((byte) r5_n == 0x2B)
			goto l132A;
		if ((byte) r5_n == 0x24)
		{
			--r3->ptr001C;
			r3->ptr0054 = 0x00;
		}
		else if ((byte) r5_n == 0x30)
			r0_n = fn1366(0x0A, r3, r4_n, out r2, out r3, out r4_n);
	}
	if (r4_n->t0000.u0 <= 0x00 && r2 == 0x00)
		goto l132A;
	goto l1326;
}

Eq_n g_t1360 = // 1360
	{
		0x86,
	};
// 1366: Register int16 fn1366(Register int16 r0, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out ptr16 r2Out, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn12CA
int16 fn1366(int16 r0, struct Eq_n * r3, struct Eq_n * r4, ptr16 & r2Out, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	ptr16 r2;
	if (r4->t0000.u0 > 0x00)
	{
		ptr16 r2_n;
		struct Eq_n * r3_n;
		struct Eq_n * r4_n;
		int16 r0_n = fn1370(r0, r3, r4, out r2_n, out r3_n, out r4_n);
		r2Out = r2_n;
		r3Out = r3_n;
		r4Out = r4_n;
		return r0_n;
	}
	else
	{
		do
			;
		while (TTYOUT((char) r0));
		r2Out = r2;
		r3Out = r3;
		r4Out = r4;
		return r0;
	}
}

// 1370: Register int16 fn1370(Register int16 r0, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out (ptr16 byte) r2Out, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn12CA
//      fn1366
int16 fn1370(int16 r0, struct Eq_n * r3, struct Eq_n * r4, byte & r2Out, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	word16 r2_n = Mem0[r4 + 0x0E:word16] + Mem0[r4 + 0x02:word16];
	*r2_n = (byte) r0;
	r4[7] = (struct Eq_n) ((word16) r4[7].t0000 + 1);
	cui16 v16_n = r4[7] & 0x01FF;
	r4[7] = (struct Eq_n) v16_n;
	if (v16_n != 0x00)
	{
		r2Out = r2_n;
		r3Out = r3;
		r4Out = r4;
		return r0;
	}
	else
	{
		r4[7] = (struct Eq_n) 0x00;
		byte * r2_n;
		struct Eq_n * r3_n;
		struct Eq_n * r4_n;
		int16 r0_n = fn1836(r3, r4, out r2_n, out r3_n, out r4_n);
		r2Out = r2_n;
		r3Out = r3_n;
		r4Out = r4_n;
		return r0_n;
	}
}

char g_b138E = '\x80'; // 138E
Eq_n g_t1396 = // 1396
	{
		&g_t15C4,
		&g_t13F0,
	};
<anonymous> g_t13F0 = <code>; // 13F0
// 13FE: void fn13FE()
// Called from:
//      fn14A8
//      fn45F6
void fn13FE()
{
	WAIT0();
	__syscall<word16>(0x88A1);
	__syscall<word16>(0x88A2);
	__syscall<word16>(0x88A3);
	__syscall<word16>(0x88A4);
	__syscall<word16>(0x88A5);
	__syscall<word16>(0x88A6);
	__syscall<word16>(0x88A7);
	__syscall<word16>(0x88A8);
	__syscall<word16>(0x88A9);
	__syscall<word16>(0x88AA);
	__syscall<word16>(0x88AB);
	__syscall<word16>(0x88AC);
	__syscall<word16>(0x88AD);
	__syscall<word16>(0x88AE);
	__syscall<word16>(0x88AF);
}

// 1420: Register word16 fn1420(Register int16 r2, Register (ptr16 Eq_n) r3)
// Called from:
//      fn12AC
//      fn145E
//      fn14A8
word16 fn1420(int16 r2, struct Eq_n * r3)
{
	if (r2 <= 0x00 || r2 > 99)
		__syscall<word16>(0x8994);
	struct Eq_n * v15_n = r3->ptr0004;
	struct Eq_n * r1_n = v15_n;
	do
	{
		++r1_n;
		if ((byte) r2 - r1_n->b0000 == 0x00)
			goto l144A;
	} while (r1_n - r3->ptr0002 < 0x00);
	r1_n = v15_n;
	do
	{
		++r1_n;
		if (r1_n->b0000 == 0x00)
			goto l144A;
	} while (r1_n - r3->ptr0002 < 0x00);
	__syscall<word16>(0x8995);
l144A:
	byte * r1_n = r1_n - 0x01;
	*r1_n = (byte) r2;
	word16 r0_n = r3->w0006;
	ptr16 r1_n;
	for (r1_n = r1_n - v15_n; r1_n != 0x00; --r1_n)
		r0_n += 0x20;
	return r0_n;
}

// 145E: void fn145E(Register word16 r2, Stack (ptr16 code) wArg00, Stack word16 wArg02, Stack (ptr16 int16) ptrArg04)
void fn145E(word16 r2, <anonymous> * wArg00, word16 wArg02, int16 * ptrArg04)
{
	ptr16 fp;
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->ptr0064 = fp + 22;
	r3_n->b00A2 = (byte) r2;
	if (r3_n->ptr0014 != null)
		__syscall<word16>(0x899A);
	r3_n->w0012 = wArg02;
	int16 v19_n = *ptrArg04;
	struct Eq_n * r0_n = fn1420(v19_n, r3_n);
	r3_n->ptr0014 = r0_n;
	r0_n->t0000.u1 = (ci16) (r0_n->t0000.u1 & 0x0800);
	struct Eq_n * r0_n;
	wArg00();
	ci16 v23_n = r0_n->w0000 & 0x0800;
	r0_n->w0000 = v23_n;
	if (v23_n == 0x00)
		fn45F6(r0_n, v19_n, r3_n);
	r3_n->ptr001A = r3_n->ptr0002;
	r3_n->w0058 = r3_n->w000C;
}

// 14A8: void fn14A8(Register int16 r2, Register uint16 r5)
void fn14A8(int16 r2, uint16 r5)
{
	ptr16 fp;
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->b00A2 = (byte) r2;
	struct Eq_n * r0_n = fn1420(r2, r3_n);
	r3_n->ptr0014 = r0_n;
	cui16 v15_n = r0_n->t0000.u1 & 0x0800;
	r0_n->t0000.u1 = v15_n;
	if (v15_n != 0x00)
	{
		word16 * wLoc08_n;
		if (r0_n->t0000.u0 >= 0x00)
		{
			struct Eq_n * r4_n;
			r3_n = fn1D30(r0_n, r3_n, out r4_n);
			ci16 v22_n = r4_n->t0000.u1 & 0x0200;
			r4_n->t0000.u1 = v22_n;
			if (v22_n != 0x00)
			{
				cu16 v24_n = r4_n[0x0C];
				r4_n[11] = (struct Eq_n) v24_n;
				if (v24_n != 0x00)
				{
					word16 * r2_n = r4_n[1];
					word16 r5_n;
					for (r5_n = 0x0100; r5_n != 0x00; --r5_n)
					{
						*r2_n = 0x00;
						++r2_n;
					}
					ci16 v27_n = r4_n->t0000.u1 & 0x0100;
					r4_n->t0000.u1 = v27_n;
					if (v27_n != 0x00)
					{
						r3_n->ptr0070 = &g_t1520;
						if (r3_n->b0074 != 0x00)
							r3_n->ptr0072 = &g_t151E;
						r3_n->ptr0064 = fp - 0x09;
						while (true)
						{
							word16 r2_n;
							fn1836(r3_n, r4_n, out r2_n, out r3_n, out r4_n);
						}
					}
					while (r4_n[11] - r4_n[0x0D] <= 0x00)
					{
						word16 r2_n;
						fn1836(r3_n, r4_n, out r2_n, out r3_n, out r4_n);
					}
				}
			}
			fn13FE();
			cui16 r5_n = r4_n[2];
			word16 * r2_n = r4_n[1];
			ci16 v49_n = r4_n->t0000.u1 & 0x01;
			r4_n->t0000.u1 = v49_n;
			r5 = r5_n << 1;
			if (v49_n != 0x00)
				r2_n -= 0x0200;
			wLoc08_n = r2_n;
			word16 * r0_n = r2_n + (r5_n << 1);
			do
			{
				*r2_n = *r0_n;
				++r0_n;
				++r2_n;
			} while (r0_n - r3_n->w000C < 0x00);
			r3_n->w000C -= r5_n << 1;
			ci16 v63_n = r4_n->t0000.u1 & 0x04;
			r4_n->t0000.u1 = v63_n;
			int16 r1_n = (int16) r4_n->b0011;
			__syscall<word16>(0x88FC);
			struct Eq_n * r0_n = null;
			bool C_n = true;
			do
			{
				r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
				C_n = (r0_n & 0x8000) != 0x00;
				--r1_n;
			} while (r1_n > 0x00);
			r3_n->ptr0010 &= ~r0_n;
		}
		else
			wLoc08_n = (word16 *) ~0x00;
		r3_n->ptr0072 = null;
		r3_n->ptr0070 = null;
		struct Eq_n * r4_n = r3_n->ptr0004;
		while (r4_n - r3_n->ptr0002 < 0x00)
		{
			++r4_n;
			int16 r2_n = (int16) r4_n->b0000;
			if (r2_n != 0x00)
			{
				struct Eq_n * r0_n = fn1420(r2_n, r3_n);
				if (wLoc08_n - r0_n[1] < 0x00)
					r0_n[1] = (struct Eq_n) (r0_n[1] - r5);
			}
		}
		r0_n = r3_n->ptr0014;
	}
	word16 r4_n;
	for (r4_n = 0x10; r4_n != 0x00; --r4_n)
	{
		r0_n->t0000.u1 = (ci16) 0x00;
		++r0_n;
	}
	struct Eq_n * r0_n = r3_n->ptr0004;
	do
	{
		r0_n = r0_n + 1;
		r0_n = r0_n;
	} while (r0_n->b0000 - (byte) r2 != 0x00);
	r0_n->bFFFFFFFF = 0x00;
	r3_n->ptr0014 = null;
	r3_n->b00A2 = 0x00;
}

Eq_n g_t151E = // 151E
	{
		
		{
			0x20
		},
		&g_wFFFF95B3,
		0xA2,
		0x04,
		0x0C,
		0x35CC,
		0x01,
		770,
		58818,
	};
Eq_n g_t1520 = // 1520
	{
		
		{
			~0x4C
		},
		&g_w00A2,
		5508,
		0x0CC5,
		0x1D,
		0x01,
		770,
		58818,
		0x0200,
	};
Eq_n g_t1580 = // 1580
	{
		&g_t0002,
	};
<anonymous> g_t1581 = <code>; // 1581
Eq_n g_t1583 = // 1583
	{
		&g_t0A00,
		~0x01,
		?? /* Can't read cui16 at address 157D */ ,
	};
word16 g_w1589 = ~0x08FC; // 1589
<anonymous> g_t15B3 = <code>; // 15B3
word16 g_w15C1 = 0x8715; // 15C1
char g_str15C2[] = "\x87"; // 15C2
Eq_n g_t15C4 = // 15C4
	{
		0x1004,
		5606,
	};
Eq_n g_t15C5 = // 15C5
	{
		
		{
			0x10
		},
		&g_wFFFFFF15,
		~0x2B00,
		0x1F89,
		166,
		0x15,
		0xB011,
		0x0211,
		0xFD00,
	};
// 15CC: void fn15CC(Register (ptr16 Eq_n) r5)
// Called from:
//      fn0CF4
void fn15CC(struct Eq_n * r5)
{
	Eq_n tLoc04;
	if (r5->b0000 != 0x03)
		__syscall<word16>(0x8990);
	else
	{
		tLoc04.w0000 = 0x1100;
		tLoc04.w0002 = &tLoc04;
		FnSubfn(&tLoc04);
		__syscall<word16>(0x88FC);
		ptr16 r2_n = 0x0A00;
		if (true)
			r2_n = 0x48;
		r5->ptr0002->u1 = (ptr16) (__swab(&g_t0280) & 0x1F);
		*r5->ptr0004 = 0x10;
		*r5->ptr0006 = r2_n;
	}
}

Eq_n g_t15E6 = // 15E6
	{
		<code>,
		&g_str0A00,
		&g_tFFFF88FC,
		5571,
		0x0303,
		&g_t40C2,
		&g_t65C2,
		0x48,
		&g_t0C80,
		&g_str0C81,
		&g_str0C81,
		&g_t105D,
		&g_tFFFF8000,
		2551,
		65060,
		~0x01,
		0x0202,
		22,
		0x55C8,
		
		{
			-0x00008000
		},
		0x35C8,
		&g_tFFFF89A5,
		2526,
		&g_tFFFF89A6,
		&g_t09DE,
		&g_t1DC3,
		202,
		&g_t09F7,
		&g_t00B8,
		0x87,
		0x0BF3,
	};
Eq_n g_t15F1 = // 15F1
	{
		&g_tFFFFC203,
	};
Eq_n g_t15F7 = // 15F7
	{
		
		{
			101
		},
		&g_wFFFF8000,
		0x800C,
		0xC10C,
		0xC0,
		0x1D25,
		0x5D10,
		0x9D10,
		0x8710,
	};
<anonymous> g_t15FF = <code>; // 15FF
char g_str1601[] = "\f\x81\f\x81\f\xC1@\xC0"; // 1601
char g_str16B4[] = "\x04\x80\xCCU\x02"; // 16B4
// 16DA: void fn16DA(Register int16 r0, Register cui16 r2, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4)
void fn16DA(int16 r0, cui16 r2, struct Eq_n * r3, struct Eq_n * r4)
{
	r4[7] = (struct Eq_n) r2;
	if (r4[11] - r3->w005E != 0x00)
	{
		ci16 v14_n = r4->t0000.u1 & 0x02;
		r4->t0000.u1 = v14_n;
		if (v14_n != 0x00)
		{
			word16 r2_n;
			r0 = fn1836(r3, r4, out r2_n, out r3, out r4);
			r4[0x0C] = (struct Eq_n) 0x00;
			r4->t0000.u1 &= ~0x02;
		}
		r4[11] = (struct Eq_n) r3->w005E;
		if (r4->t0000.u1 > 0x00 || ((r3->t005C).u0 < 0x0200 || r4[7] != 0x00))
		{
			struct Eq_n * r4_n;
			r3 = fn18BE(r0, r3, r4, out r4_n);
			--r4_n->w0016;
		}
	}
	++r3->w005E;
}

// 171E: void fn171E(Register (ptr16 Eq_n) r0, Register (ptr16 Eq_n) r3)
void fn171E(struct Eq_n * r0, struct Eq_n * r3)
{
	ptr16 r2_n = *r3->ptr0012;
	*r0->ptr0012 = r2_n;
	++*r0->ptr0012;
	fn172C(r0, r2_n - 0x01);
}

// 172C: void fn172C(Register (ptr16 Eq_n) r0, Register word16 r2)
// Called from:
//      fn171E
void fn172C(struct Eq_n * r0, word16 r2)
{
	Eq_n r3_n = r0->t0014.u0;
	uint32 r4_r1_n = 0x00;
	uint32 r5_r2_n = (uint32) r2;
	while (true)
	{
		struct Eq_n * r4_n = SLICE(r4_r1_n, word16, 16);
		word16 r1_n = (word16) r4_r1_n;
		r3_n >>= 1;
		if (r3_n >= 0x00)
		{
			if (r3_n == 0x00)
			{
				cui16 r1_n = __swab(SEQ(SLICE(r1_n, byte, 8), 0x00));
				cui16 r4_n = __swab(r4_n);
				if (r4_n != 0x00)
					__syscall<word16>(0x89A8);
				struct Eq_n * r3_n = g_ptr5424;
				r3_n->w005E = r1_n | r4_n;
				r3_n->t005C.u0 = r0->t0014.u0;
				r3_n->t005C.u0 = (int16) (r3_n->t005C.u0 << 1);
				return;
			}
		}
		else
			r4_r1_n += r5_r2_n;
		r5_r2_n <<= 0x01;
	}
}

// 1836: Register word16 fn1836(Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out ptr16 r2Out, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn1370
//      fn14A8
//      fn16DA
//      fn1D30
word16 fn1836(struct Eq_n * r3, struct Eq_n * r4, ptr16 & r2Out, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	r4[0x0C] = r4[11];
	r4[0x0C] = (struct Eq_n) ((word16) r4[0x0C].t0000 + 1);
	if (r4[11] - r4[0x0D] >= 0x00)
		r4[0x0D] = r4[11];
	Eq_n v20_n = r4->t0000.u1 & 0x40;
	r4->t0000.u1 = (ci16) v20_n;
	if (v20_n != 0x00)
	{
		r4->t0000.u1 = (ci16) (r4->t0000.u1 & 0x7FFF);
		r4[0x0C] = (struct Eq_n) 0x00;
		__syscall<word16>(35235);
	}
	struct Eq_n * r3_n;
	struct Eq_n * r4_n;
	ptr16 r2_n = fn1900(r3, r4, out r3_n, out r4_n);
	byte v27_n = r4_n->b0011 | 0x90;
	word16 r0_n;
	SEQ(0x88, v27_n)();
	r2Out = r2_n;
	r3Out = r3_n;
	r4Out = r4_n;
	return r0_n;
}

// 18BE: Register (ptr16 Eq_n) fn18BE(Register int16 r0, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn16DA
struct Eq_n * fn18BE(int16 r0, struct Eq_n * r3, struct Eq_n * r4, struct Eq_n & r4Out)
{
	if (r4[0x0C] == 0x00 || r4[11] - r4[0x0C] < 0x00)
	{
		struct Eq_n * r3_n;
		struct Eq_n * r4_n;
		fn1900(r3, r4, out r3_n, out r4_n);
		byte v19_n = r4_n->b0011 | 0x80;
		SEQ(0x88, v19_n)();
		r4Out = r4_n;
		return r3_n;
	}
	else
	{
		struct Eq_n * r3_n;
		struct Eq_n * r4_n;
		fn1932(r3, r4, out r3_n, out r4_n);
		r4Out = r4_n;
		return r3_n;
	}
}

// 18F6: void fn18F6(Register (ptr16 Eq_n) r4)
// Called from:
//      fn1900
void fn18F6(struct Eq_n * r4)
{
	r4[11] = (struct Eq_n) ((word16) r4[11].t0000 + 1);
	fn18FE();
}

// 18FE: void fn18FE()
// Called from:
//      fn18F6
//      fn1900
void fn18FE()
{
}

// 1900: Register word16 fn1900(Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn1836
//      fn18BE
word16 fn1900(struct Eq_n * r3, struct Eq_n * r4, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	ptr16 fp;
	word16 r2;
	byte NZVC_n;
	(*(fp - 0x04))();
	if ((bool) NZVC_n)
	{
		fn18FE();
		r3Out = r3;
		r4Out = r4;
		return r2;
	}
	else
	{
		r4->t0000.u1 &= 0x7FFD;
		cui16 v13_n = r4->t0000.u1 & 0x4000;
		r4->t0000.u1 = v13_n;
		if (v13_n != 0x00)
			r4[11] = (struct Eq_n) ~0x00;
		if (t0000.b002A == 0x00)
		{
			struct Eq_n * r3_n;
			struct Eq_n * r4_n;
			word16 r2_n = fn1932(r3, r4, out r3_n, out r4_n);
			r3Out = r3_n;
			r4Out = r4_n;
			return r2_n;
		}
		else
		{
			r3->ptr0070 = null;
			struct Eq_n * r4_n = r3->ptr0072;
			if (r4_n != null)
			{
				struct Eq_n * r3_n;
				struct Eq_n * r4_n;
				word16 r2_n = fn1932(r3, r4_n, out r3_n, out r4_n);
				r3Out = r3_n;
				r4Out = r4_n;
				return r2_n;
			}
			else
			{
				__syscall<word16>(35223);
				struct Eq_n * r3_n;
				struct Eq_n * r4_n;
				word16 r2_n = fn1932(r3, r4_n, out r3_n, out r4_n);
				r3Out = r3_n;
				r4Out = r4_n;
				return r2_n;
			}
		}
	}
}

// 1932: Register word16 fn1932(Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn18BE
//      fn1900
word16 fn1932(struct Eq_n * r3, struct Eq_n * r4, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	word16 r2;
	cui16 v5_n = r4[0x0E] & 0x08;
	r4[0x0E] = (struct Eq_n) v5_n;
	if (v5_n != 0x00)
	{
		fn18F6(r4);
		r3Out = r3;
		r4Out = r4;
		return r2_n;
	}
	else
	{
		r4->t0000.u1 |= 0x1000;
		r3->ptr0072 = null;
		struct Eq_n * r4_n = r3->ptr0070;
		if (r4_n == null)
			__syscall<word16>(0x8998);
		struct Eq_n * sp_n = r3->ptr0064;
		sp_n->ptrFFFFFFFE = &g_t0EF4;
		sp_n->ptrFFFFFFFC = r3;
		if (r3->b0074 == 0x00)
			sp_n->ptrFFFFFFFE = r4_n;
		r3->ptr0072 = null;
		r3->ptr0070 = null;
		r3->ptr0014 = null;
		r3->w000C = r3->w0058;
		r3->b00A2 = 0x00;
		r3Out = sp_n->ptrFFFFFFFC;
		r4Out = r4_n;
		return r2;
	}
}

// 194E: void fn194E(Register (ptr16 Eq_n) r3)
void fn194E(struct Eq_n * r3)
{
	++r3->w0012;
}

// 1966: void fn1966(Register int16 r0, Register (ptr16 Eq_n) r3)
// Called from:
//      fn197A
void fn1966(int16 r0, struct Eq_n * r3)
{
	r3->t001C.u1->u1 = (ptr16) (byte) r0;
	fn196A(r3);
}

// 196A: void fn196A(Register (ptr16 Eq_n) r3)
// Called from:
//      fn1966
void fn196A(struct Eq_n * r3)
{
	if (r3->t001C.u0 - r3->w0018 < 0x00)
		r3->t001C.u0 = (cup16) (r3->t001C.u0 + 0x01);
}

// 197A: void fn197A(Register (ptr16 Eq_n) r3)
void fn197A(struct Eq_n * r3)
{
	if (r3->t001C.u0 - (r3->t0046).u0 < 0x00)
		r3->t001C.u0 = r3->t0046.u0;
	r3->t0046.u0 = 0x00;
	if (r3->w0056 != 0x00)
	{
		r3->ptr0060();
		r3->w0056 = 0x00;
		if (*r3->ptr0014 <= 0x00)
			r3->w0054 = 0x00;
	}
	else
	{
		fn1966(0x0D, r3);
		r3->ptr0060();
	}
}

word16 g_w1AE6 = 0x0A82; // 1AE6
Eq_n g_t1CF6 = // 1CF6
	{
		
		{
			~0x15
		},
		&g_w1AE6,
		0x87,
		4646,
		0x18,
		0x1826,
		5584,
		0x1D26,
		4646,
	};
// 1CFA: void fn1CFA()
// Called from:
//      fn1DAE
void fn1CFA()
{
}

// 1CFC: void fn1CFC()
void fn1CFC()
{
}

// 1D30: Register (ptr16 Eq_n) fn1D30(Register (ptr16 Eq_n) r0, Register (ptr16 Eq_n) r3, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn14A8
struct Eq_n * fn1D30(struct Eq_n * r0, struct Eq_n * r3, struct Eq_n & r4Out)
{
	ci16 v8_n = r0->t0000.u1 & 0x4000;
	r0->t0000.u1 = v8_n;
	struct Eq_n * r4_n = r0;
	if (v8_n != 0x00)
	{
		ci16 v10_n = r0->t0000.u1 & 0x02;
		r0->t0000.u1 = v10_n;
		if (v10_n == 0x00)
			goto l1D84;
		r0->t0000.u1 &= ~0x02;
	}
	else
	{
		if (r0->t0000.u1 > 0x00)
			goto l1D84;
		ci16 v16_n = r0->t0000.u1 & 0x0200;
		r0->t0000.u1 = v16_n;
		if (v16_n != 0x00)
		{
			cui16 r2_n = r0[7];
			byte * r2_n = (word16) r0[1].t0000 + r2_n;
			ci16 v22_n = r0->t0000.u1 & 0x2000;
			r0->t0000.u1 = v22_n;
			if (v22_n != 0x00)
				*r2_n = 0x00;
			else
				*r2_n = 0x0A;
			byte * r2_n = (word16) r0[1].t0000 + r2_n + 0x01;
			ci16 r1_n = r2_n - 0x01FF;
			if (r2_n != 0x01FF)
			{
				do
				{
					*r2_n = 0x00;
					++r2_n;
					++r1_n;
				} while (r1_n < 0x00);
			}
		}
		else
		{
			cui16 * r2_n = (word16) r0[1].w001C + 482;
			*r2_n |= 0x8000;
		}
	}
	word16 r2_n;
	fn1836(r3, r0, out r2_n, out r3, out r4_n);
l1D84:
	r4Out = r4_n;
	return r3;
}

<anonymous> * g_ptr1DAA = fn14A8; // 1DAA
// 1DAE: void fn1DAE()
void fn1DAE()
{
	<anonymous> * r0_n = g_ptr1DAA;
	if (r0_n != null)
		r0_n();
	struct Eq_n * sp_n = t0000.w0022;
	sp_n->ptrFFFFFFFE = (struct Eq_n *) &g_t1DB2;
	FnSubfn(&g_t0592);
	struct Eq_n * r5_n = t0000.w0028;
	sp_n->ptrFFFFFFFC = r5_n;
	sp_n->ptrFFFFFFFA = 0x00;
	sp_n->wFFFFFFF8 = 0x1000;
	sp_n->ptrFFFFFFFA = sp_n - 0x18;
	FnSubfn(sp_n - 0x08);
	word16 r4_n = sp_n->wFFFFFFEA;
	if (g_ptr1DAA == null)
	{
		FnSubfn(&g_t03B8);
		if (false)
			t0000.w001E = 0xF000;
		if (true)
		{
			t0000.w0026 = 0x0200;
			if (g_w53EA != 0x00)
			{
				if (sp_n->wFFFFFFE8 != 0x00)
					PRINT(&g_b0380);
				else
				{
					FnSubfn(&g_t03BC);
					t0000.w0026 = 0x00;
					r4_n = 0x03BC;
				}
			}
		}
	}
	SETTOP(r4_n - 0x02);
	struct Eq_n * r4_n = t0000.w0028;
	if (r4_n - (r5_n + 1) > 0x00)
	{
		g_ptr5426 = r4_n - 0xB2;
		cu16 r4_n = r4_n - 0xB2 - g_w53E8;
		sp_n->wFFFFFFE6 = r4_n & ~0x01;
		cui16 r2_n = g_w53EC;
		if (r2_n == 0x00)
			goto l0372;
		cui16 r4_n = (r4_n & ~0x01) - r2_n;
		sp_n->wFFFFFFE4 = r4_n;
		uint16 r4_n = r4_n & ~0x01;
		do
		{
			r4_n -= 0x20;
			--r2_n;
		} while (r2_n != 0x00);
		sp_n->wFFFFFFE2 = r4_n;
		sp_n->wFFFFFFE0 = r4_n - 0x38;
		if (r4_n - 0x38 - (r5_n + 1) > 0x00)
		{
			struct Eq_n * r2_n = r4_n;
			do
			{
				r2_n -= 0x02;
				r2_n->w0000 = 0x00;
			} while (r2_n - (r4_n - 0x38) > 0x00);
			r4_n->bFFFFFFC2 = 0x00;
			r4_n->bFFFFFFC3 = 0x00;
			r4_n->wFFFFFF56 = sp_n->wFFFFFFE0;
			r4_n->wFFFFFF54 = sp_n->wFFFFFFE2;
			r4_n->wFFFFFF52 = sp_n->wFFFFFFE4;
			r4_n->wFFFFFF50 = sp_n->wFFFFFFE6;
			r4_n->wFFFFFFC4 = sp_n->wFFFFFFEA;
			r4_n->wFFFFFFC6 = sp_n->wFFFFFFEC;
			r4_n->wFFFFFF58 = r4_n - 0x38;
			r4_n->wFFFFFF5A = r5_n + 1;
			if (r4_n - 0x38 - (r5_n + 1) > 0x00)
			{
				if (g_ptr1DAA != null)
				{
					FnSubfn(&g_t03B8);
					if (false && (sp_n->wFFFFFFE8 - g_w53EA >= 0x00 && (r4_n - 0x38) - (t0000.w0022 + 0x1000) <= 0x00))
						goto l0372;
				}
				r4_n->wFFFFFF5E = 0x8000;
				r4_n->ptrFFFFFF9E = r4_n - 0xB2;
				r4_n->ptrFFFFFF9E += 0x22;
				r4_n->ptrFFFFFFB8 = sp_n->ptrFFFFFFFC;
				struct Eq_n * v57_n = sp_n->ptrFFFFFFFE;
				r4_n->ptrFFFFFFB6 = v57_n;
				struct Eq_n * v58_n = v57_n->ptr0000;
				r4_n->wFFFFFFCA = v58_n->w0000;
				r4_n->wFFFFFFC8 = v58_n->w0002;
				t0000.w0020 = 0x0202;
				t0000.w0024 |= 0x2000;
				fn1CFA();
				if (r4_n->bFFFFFFC3 == 0x00)
				{
					sp_n->ptrFFFFFFFE = &g_t1396;
					v57_n->ptr0002();
					return;
				}
				else
				{
					v57_n->ptr0002();
					return;
				}
			}
		}
	}
l0372:
	PRINT(&g_b0397);
	t0000.b002B |= 0x08;
	EXIT(&g_b0397);
}

struct Eq_n g_t1DB2 = // 1DB2
	{
		&g_t47FE,
		&g_t15FF,
	};
Eq_n g_t1DC0 = // 1DC0
	{
		0x15,
	};
<anonymous> g_t1DC3 = <code>; // 1DC3
word16 g_w1DC4 = 0x3660; // 1DC4
Eq_n g_t1DF1 = // 1DF1
	{
		&g_tFFFFBC15,
		&g_tFFFFF748,
	};
char g_str1DF7[] = "6\xE6\x15\xA4H\xE6\x15\x10H\xF7\t\xC4\xEF\xE6\x15xX\xF7\t\xD6\xEC\xF7\t\x98\xF0\xBF\n\x126\xE6\x15\xA4H\xE6\x15\x13H\xF7\t\xA8\xEF\xE6\x15\x9EH\xE6\x15zX\xF7\t\x18\xED\xF7\tx\xF0\xFF\x15\x18"; // 1DF7
Eq_n g_t1EB6 = // 1EB6
	{
		<code>,
		&g_str0024,
		&g_t356A,
		0x1DC1,
		0x0CC1,
		&g_t15F1,
		&g_t0001,
		22722,
		&g_t0ABF,
		&g_str3608,
		&g_t0004,
		&g_t5A3E,
		&g_t07DD,
		1999,
		0x0ABF,
		0x0A,
		0x351A,
		18618,
		2551,
		
		{
			0x0000211C
		},
		0x0ABF,
		&g_t0001,
		0x35BA,
		&g_t5464,
		&g_t15FF,
		&g_t002C,
		~0x05,
		&g_t002D,
		&g_t34F0,
		228,
		2551,
	};
Eq_n g_t1EF0 = // 1EF0
	{
		<code>,
		&g_str35E6,
		&g_t2DD7,
		0x35E2,
		0x0AB7,
		&g_t35D8,
		&g_t2DD7,
		0x35D4,
		&g_t0005,
		&g_str351A,
		&g_t15C5,
		&g_t0001,
		&g_t34F0,
		0x48D0,
		2551,
		0x09,
		0x22EA,
		13532,
		0x15C5,
		
		{
			0x000048DA
		},
		2551,
		&g_t34D0,
		0x15C5,
		&g_t0ABF,
		&g_t34C4,
		&g_t15C5,
		~0x11,
		&g_t34B8,
		&g_t15E6,
		~0x08,
		8858,
	};
<anonymous> g_t1F0A = <code>; // 1F0A
Eq_n g_t1F24 = // 1F24
	{
		&g_t5464,
		0x3D,
		?? /* Can't read cui16 at address 1F1E */ ,
	};
Eq_n g_t1F6E = // 1F6E
	{
		
		{
			~0x19
		},
		&g_w4898,
		5606,
		0xF026,
		0x15,
		60252,
		2551,
		~0x10E1,
		0x0ABF,
	};
Eq_n g_t1F7C = // 1F7C
	{
		&g_t54DC,
		&g_t09F7,
	};
word16 g_w1FE6 = 0x15FF; // 1FE6
Eq_n g_t201D = // 201D
	{
		0x02,
	};
Eq_n g_t2020 = // 2020
	{
		<code>,
		&g_str3402,
		&g_t0A15,
		0x15FF,
		0x0AC4,
		&g_t06F7,
		&g_t0ABF,
		0x33F2,
		&g_t15F7,
		&g_t15F7,
		&g_t0002,
		&g_t348C,
		&g_t15FF,
		0x3448,
		0x0CC0,
		0x0C,
		0x0BF0,
		0x0202,
		0x77,
		
		{
			620
		},
		0x15FF,
		&g_t0AB7,
		0x343C,
		&g_t3452,
		&g_t345A,
		&g_t6DF7,
		0x5E,
		&g_t1DC0,
		&g_t3444,
		22,
		0x6FC1,
	};
<anonymous> g_t2021 = <code>; // 2021
Eq_n g_t2037 = // 2037
	{
		0
	};
Eq_n g_t2072 = // 2072
	{
		<code>,
		&g_str0BF0,
		&g_t58C2,
		0x0202,
		0x15FF,
		&g_t0047,
		&g_t33A2,
		0x0AB7,
		&g_t343C,
		&g_str1DF7,
		&g_t3452,
		&g_t1DC0,
		&g_t1037,
		13334,
		0x6FC1,
		111,
		0x33F2,
		7616,
		13342,
		
		{
			4145
		},
		22822,
		&g_t1DF1,
		13332,
		&g_t2037,
		&g_t3404,
		&g_t0704,
		191,
		&g_t15FF,
		&g_t0050,
		0x04,
		0x0ABF,
	};
Eq_n g_t215C = // 215C
	{
		0x09,
	};
Eq_n g_t2254 = // 2254
	{
		
		{
			110
		},
		&g_w0ABF,
		0x31CC,
		0x0ABF,
		0x31,
		2551,
		0x18CE,
		0x0ABF,
		12724,
	};
Eq_n g_t228C = // 228C
	{
		<code>,
		&g_str48BA,
		&g_t09F7,
		0x1B7E,
		0x010D,
		&g_t15FF,
		&g_t0076,
		0x3186,
		&g_t15C5,
		&g_str16B4,
		&g_t0ABF,
		&g_t0078,
		fn3220,
		2551,
		0x0B40,
		11,
		0x0ABF,
		7671,
		12772,
		
		{
			12778
		},
		0x15FF,
		&g_t65F7,
		0x02,
		&g_t31F8,
		&g_t65F7,
		&g_t0002,
		~0x45,
		&g_t0077,
		&g_tFFFFFD58,
		191,
		0x30F4,
	};
Eq_n g_t22B6 = // 22B6
	{
		
		{
			0x78
		},
		&g_w316C,
		0x0ABF,
		0x0312,
		0x15,
		0x15F7,
		0x03,
		0x3220,
		60919,
	};
Eq_n g_t22BA = // 22BA
	{
		&g_t0ABF,
		0x12,
		?? /* Can't read cui16 at address 22B4 */ ,
	};
word16 g_w2402 = 0x0A37; // 2402
Eq_n g_t241E = // 241E
	{
		&g_t1DC0,
		~0x00,
		?? /* Can't read cui16 at address 2418 */ ,
	};
// 243A: void fn243A(Register (ptr16 word16) r5)
void fn243A(word16 * r5)
{
	fn0EF8(&g_t243E, r5);
}

struct Eq_n g_t243E = // 243E
	{
		&g_t4968,
		&g_t15FF,
	};
Eq_n g_t2600 = // 2600
	{
		
		{
			0x77
		},
		&g_w0446,
		0x15FF,
		0x7217,
		0x00,
		0x1002,
		0x0ABF,
		0x2E0A,
		12247,
	};
Eq_n g_t260A = // 260A
	{
		-0x007F
	};
// 2B90: void fn2B90(Register (ptr16 word16) r5)
void fn2B90(word16 * r5)
{
	fn0EF8(&g_t2B94, r5);
}

struct Eq_n g_t2B94 = // 2B94
	{
		&g_t4DAA,
		&g_t15FF,
	};
Eq_n g_t2DD7 = // 2DD7
	{
		55,
		11,
	};
// 2E20: void fn2E20(Register (ptr16 word16) r5)
void fn2E20(word16 * r5)
{
	fn0EF8(&g_t2E24, r5);
}

struct Eq_n g_t2E24 = // 2E24
	{
		&g_t507E,
		&g_t15FF,
	};
// 2EC4: void fn2EC4(Register (ptr16 word16) r5)
void fn2EC4(word16 * r5)
{
	fn0EF8(&g_t2EC8, r5);
}

struct Eq_n g_t2EC8 = // 2EC8
	{
		&g_t50B2,
		&g_t15FF,
	};
word16 g_w316C = 0x44; // 316C
Eq_n g_t31F8 = // 31F8
	{
		-9
	};
// 3220: void fn3220(Register (ptr16 word16) r5)
void fn3220(word16 * r5)
{
	fn0EF8(&g_t3224, r5);
}

struct Eq_n g_t3224 = // 3224
	{
		&g_t512C,
		&g_t15FF,
	};
Eq_n g_t3300 = // 3300
	{
		
		{
			0xC0
		},
		&g_w2402,
		0x0CC0,
		0x2057,
		0x00,
		0x210E,
		0x65F7,
		0x0A,
		0x2558,
	};
Eq_n g_t33A2 = // 33A2
	{
		&g_t59F0,
		~0x00,
		?? /* Can't read cui16 at address 339C */ ,
	};
char g_str3402[] = "\x14#\xC5\x15jQ\xF7\t$\x0E\xBF\n\x16 ?\n\xF6\"\xBF\n\x0E ?\n\xF0\"\xBF\n\x06 ?\n\xE4\"\xBF\n\xFE\x1F7\n\x94$\xBF\n\xF6\x1F7\n\x8E$\xBF\n\xEE\x1F\x12\x01\xFF\x15:"; // 3402
Eq_n g_t3404 = // 3404
	{
		
		{
			0xC5
		},
		&g_w516A,
		2551,
		0x22F6,
		0x0A,
		0x22F0,
		0x0ABF,
		0x2006,
		2623,
	};
Eq_n g_t343C = // 343C
	{
		
		{
			0x3A
		},
		&g_w1FE6,
		0x65F7,
		0x22BE,
		101,
		0x0AB7,
		0x22BA,
		0x2DD7,
		8886,
	};
Eq_n g_t3444 = // 3444
	{
		<code>,
		&g_str65F7,
		&g_t0002,
		0x22BE,
		0x22BA,
		&g_t0AB7,
		&g_t22BA,
		0x2DD7,
		&g_t22B6,
		&g_str15FF,
		&g_t003B,
		&g_t003D,
		&g_t09F7,
		2551,
		0xDA10,
		~0x25,
		0x0ABF,
		0x15C5,
		20852,
		
		{
			2551
		},
		0x0D8C,
		&g_t1F7C,
		0x87,
		&g_str15FF,
		&g_t000B,
		&g_t1F6E,
		~0x08,
		&g_t000A,
		&g_t228C,
		0x3C,
		0x0CC0,
	};
Eq_n g_t3452 = // 3452
	{
		-73
	};
Eq_n g_t345A = // 345A
	{
		
		{
			0x0A
		},
		&g_w07A7,
		0x15FF,
		9228,
		0x03,
		8116,
		0x1DFF,
		0x2400,
		8838,
	};
<anonymous> g_t348C = <code>; // 348C
// 34AC: void fn34AC(Register (ptr16 word16) r5)
void fn34AC(word16 * r5)
{
	fn0EF8(&g_t34B0, r5);
}

struct Eq_n g_t34B0 = // 34B0
	{
		&g_t517E,
		&g_t15FF,
	};
Eq_n g_t34B8 = // 34B8
	{
		0x10,
	};
Eq_n g_t34C4 = // 34C4
	{
		
		{
			~0x08
		},
		&g_w5A2C,
		0x2258,
		0x0C,
		0x1F,
		0x1077,
		8788,
		0x0ABF,
		0x1F44,
	};
Eq_n g_t34D0 = // 34D0
	{
		&g_t518E,
		&g_t2254,
	};
Eq_n g_t34F0 = // 34F0
	{
		<code>,
		&g_str011C,
		&g_t15FF,
		0x0F,
		0x2236,
		&g_t0ABF,
		&g_t1F24,
		0x15F7,
		&g_t0001,
		&g_str5A18,
		&g_t15FF,
		&g_t1F0A,
		&g_t0AB7,
		0x0ABF,
		0x1EE2,
		0x1E,
		3063,
		0x0363,
		0x15FF,
		
		{
			25
		},
		0x1ED6,
		&g_t09F7,
		~0x260F,
		&g_t6666,
		&g_t15E6,
		&g_t4066,
		~0x08,
		&g_t001B,
		&g_t1EB6,
		0x03,
		0x0705,
	};
char g_str351A[] = "\n\x1F\xF7\v\x14\"\x06\x02\xFF\x15\x15"; // 351A
Eq_n g_t356A = // 356A
	{
		0x05,
		~0x00,
	};
Eq_n g_t35D8 = // 35D8
	{
		&g_t215C,
	};
char g_str35E6[] = "<!\xC2\f\xC0\x1DJ!\x80l&Y\xC3\x1D>!\xC3\f3\x10\xEEY\xBF\n&\x1E\xB3\x1C\x8AY\x02Z\xBF\n\x1C\x1E\xF3\x15\xFF\xFF\x16Z\xFF\x15%"; // 35E6
char g_str3608[] = "\x1C\x1E\xF3\x15\xFF\xFF\x16Z\xFF\x15%"; // 3608
Eq_n g_t361F = // 361F
	{
		&g_t0200,
		0x00,
		?? /* Can't read cui16 at address 3619 */ ,
	};
// 395C: void fn395C(Register (ptr16 word16) r5)
void fn395C(word16 * r5)
{
	fn0EF8(&g_t3960, r5);
}

struct Eq_n g_t3960 = // 3960
	{
		&g_t51DC,
		&g_t15FF,
	};
// 3B3C: void fn3B3C(Register (ptr16 word16) r5)
void fn3B3C(word16 * r5)
{
	fn0EF8(&g_t3B40, r5);
}

struct Eq_n g_t3B40 = // 3B40
	{
		&g_t526E,
		&g_t15FF,
	};
// 3E12: void fn3E12(Register (ptr16 word16) r5)
void fn3E12(word16 * r5)
{
	fn0EF8(&g_t3E16, r5);
}

word16 g_w3E15 = 0xE2D0; // 3E15
struct Eq_n g_t3E16 = // 3E16
	{
		&g_t52E2,
		&g_t15FF,
	};
// 3F42: void fn3F42(Register (ptr16 word16) r5)
void fn3F42(word16 * r5)
{
	fn0EF8(&g_t3F46, r5);
}

struct Eq_n g_t3F46 = // 3F46
	{
		&g_t530A,
		&g_t15FF,
	};
Eq_n g_t4011 = // 4011
	{
		90
	};
// 4030: void fn4030(Register (ptr16 word16) r5)
void fn4030(word16 * r5)
{
	fn0EF8(&g_t4034, r5);
}

struct Eq_n g_t4034 = // 4034
	{
		&g_t5330,
		&g_t15FF,
	};
Eq_n g_t4063 = // 4063
	{
		
		{
			0x13
		},
		&g_w3E15,
		63315,
		0x3700,
		0x82,
		0x0315,
		0xA800,
		~0x08EC,
		22047,
	};
Eq_n g_t4066 = // 4066
	{
		
		{
			0x3E
		},
		&g_w09F7,
		1224,
		52866,
		0x53,
		0x13A8,
		0x1FF7,
		0x1756,
		0x175C,
	};
// 4072: void fn4072(Register (ptr16 word16) r5)
void fn4072(word16 * r5)
{
	fn0EF8(&g_t4076, r5);
}

struct Eq_n g_t4076 = // 4076
	{
		&g_t5344,
		&g_t15FF,
	};
// 4078: void fn4078()
// Called from:
//      fn4072
void fn4078()
{
	*g_ptr5426 = 0x03;
	g_t57E0.u0 = g_ptr57DA->u0;
	++*g_ptr5426;
	g_w57E2 = *g_t57DC.u1;
	++*g_ptr5426;
	if (g_t57DE.u0 < 0x00)
	{
		++*g_ptr5426;
		g_t57E0.u0 = 0x00;
	}
	*g_ptr5426 = 0x07;
	if (g_t57E0.u0 < 0x00)
	{
		++*g_ptr5426;
		g_w57E2 = 0x00;
	}
	*g_ptr5426 = 0x09;
	if (g_t57DE.u0 > 0x4F)
	{
		++*g_ptr5426;
		g_t57E0.u0 = 0x4F;
	}
	*g_ptr5426 = 11;
	if (g_t57E0.u0 > 0x17)
	{
		++*g_ptr5426;
		g_w57E2 = 0x17;
	}
	*g_ptr5426 = 0x0D;
	g_ptr57DA = (union Eq_n *) ((char *) g_ptr57DA + 32);
	++*g_ptr5426;
	g_w57E2 = -g_t57E0.u0;
	g_t57DC.u1 = (word16 *) ((char *) g_t57DC.u1 + 55);
	++*g_ptr5426;
	g_t57DC.u0 = 155;
	++*g_ptr5426;
	g_b57DD = 0x59;
	++*g_ptr5426;
	g_t57DE.u1 = g_t57E0.u1;
	++*g_ptr5426;
	g_t57DF.u1 = g_t57DE.u1;
	++*g_ptr5426;
	fn4534(&g_w534E);
	++*g_ptr5426;
}

Eq_n g_t40A1 = // 40A1
	{
		0x15
	};
Eq_n g_t40C2 = // 40C2
	{
		&g_t1360,
	};
// 413C: void fn413C(Register (ptr16 word16) r5)
void fn413C(word16 * r5)
{
	fn0EF8(&g_t4140, r5);
}

struct Eq_n g_t4140 = // 4140
	{
		&g_t5354,
		&g_t15FF,
	};
// 4180: void fn4180(Register (ptr16 word16) r5)
void fn4180(word16 * r5)
{
	fn0EF8(&g_t4184, r5);
}

struct Eq_n g_t4184 = // 4184
	{
		&g_t5368,
		&g_t15FF,
	};
// 4230: void fn4230(Register (ptr16 word16) r5)
void fn4230(word16 * r5)
{
	fn0EF8(&g_t4234, r5);
}

struct Eq_n g_t4234 = // 4234
	{
		&g_t537A,
		&g_t15FF,
	};
char g_str440C[] = "\x16X\xF7\t2\xC7\xF7\t\x92\xCA\xBF\n\f\x10w"; // 440C
// 4534: void fn4534(Register (ptr16 word16) r5)
// Called from:
//      fn4078
void fn4534(word16 * r5)
{
	fn0EF8(&g_t4538, r5);
}

struct Eq_n g_t4538 = // 4538
	{
		&g_t53B0,
		&g_t15FF,
	};
// 457C: void fn457C(Register (ptr16 word16) r5)
void fn457C(word16 * r5)
{
	fn0EF8(&g_t4580, r5);
}

struct Eq_n g_t4580 = // 4580
	{
		&g_t53C0,
		&g_t15FF,
	};
// 45C8: void fn45C8(Register (ptr16 word16) r5)
void fn45C8(word16 * r5)
{
	fn0EF8(&g_t45CC, r5);
}

struct Eq_n g_t45CC = // 45CC
	{
		&g_t53D8,
		&g_t15FF,
	};
// 45F6: void fn45F6(Register (ptr16 Eq_n) r0, Register int16 r2, Register (ptr16 Eq_n) r3)
// Called from:
//      fn145E
void fn45F6(struct Eq_n * r0, int16 r2, struct Eq_n * r3)
{
	ptr16 fp;
	ui16 r4_n = 0x00;
	r2_n = r2;
	while (true)
	{
		int16 r2_n;
		r2_n -= 0x0A;
		if (r2_n < 0x00)
			break;
		++r4_n;
	}
	word16 r2_n = r2_n + 0x0A;
	if (r4_n == 0x00)
	{
l4614:
		r4_n += r2_n;
		r2_n = 65506;
	}
	ui16 r4_n = r4_n + 0x1E;
	r4_n = r4_n * 0x28;
	if (r4_n * 0x28 <= 0x00)
	{
		ui16 r2_n = r0->w0006;
		if (r2_n == 0x00)
		{
			r0->w0006 = r4_n * 0x28;
			struct Eq_n * r1_n = &g_t47E4;
			while (r1_n->w0000 != 0x00 && r1_n->w0000 - r2 != 0x00)
				++r1_n;
			r2_n = r1_n->wFFFFFFFE;
			r0->w0008 = 10414;
			r0->w000A = r4_n * 0x28;
			r0->w000C = 6460;
		}
		if (r0->w0000 >= 0x00)
			r0->w0000 |= 0x0100;
		struct Eq_n * r0_n = r3->ptr0010;
		struct Eq_n * r1_n = null;
		bool C_n = false;
		r0_n = r0_n;
		do
		{
			struct Eq_n * r0_n;
			++r1_n;
			if (OVERFLOW<word16>(r1_n))
			{
				__syscall<word16>(~0x7660);
				__syscall<word16>(0x899B);
				__syscall<word16>(0x899C);
				__syscall<word16>(0x899D);
				r3->ptr0010 = r0_n;
				r1_n[0x0000FFFA] = (struct Eq_n) (r1_n[0x0000FFFA] | 0x80);
				r1_n[0x0A] = (struct Eq_n) 0x00;
				r0->w0018 = 0x00;
				ci16 v55_n = r0->w0000 & 0x18;
				r0->w0000 = v55_n;
				if (v55_n != 0x00)
				{
					ci16 v56_n = r0->w0000 & 0x10;
					r0->w0000 = v56_n;
					if (v56_n != 0x00)
						goto l473C;
				}
				else
				{
					ci16 v57_n = r0->w0000 & 0x0480;
					r0->w0000 = v57_n;
					if (v57_n != 0x00)
					{
l473C:
						r0->w0000 |= 0x20;
					}
				}
				r0->w0000 |= 0x0800;
				return;
			}
			r0_n = __rcr<word16,byte>(r0_n, 0x01, C_n);
			C_n = (r0_n & 0x01) != 0x00;
			r0_n = r0_n;
		} while ((r0_n & 0x01) != 0x00);
		r0->b0011 = (byte) r1_n;
		--r0->b0011;
		bool C_n = true;
		do
		{
			r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
			C_n = (r0_n & 0x8000) != 0x00;
			--r1_n;
		} while (r1_n != null);
		r3->ptr0010 = r0_n;
		fn13FE();
		word16 r4_n = r3->w0050;
		cup16 r5_n = t0000.w0026;
		if (r5_n != 0x00 && r5_n > 14158)
		{
			word16 * r5_n = &g_w47E0;
			if (t0000.w0026 < 0x47E0)
			{
				word16 * sp_n = fp - 0x0E;
				do
				{
					r5_n -= 0x02;
					sp_n -= 0x02;
					*sp_n = *r5_n;
				} while (r5_n > g_a474C);
			}
		}
		// This indirect jump appears to use the range [-1,1], which Reko can't deduce. This is a typical place where a user annotation (indicating the range of valid values) would help.
		ui16 r4_n;
		(*((char *) g_a46C4 + r4_n * 0x02))();
		return;
	}
	goto l4614;
}

<anonymous> * g_a46C4[] = // 46C4
	{
	};
// 474C: Register (ptr16 Eq_n) fn474C(Register (ptr16 Eq_n) r1, Register word16 r2, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out ptr16 r4Out)
// Called from:
//      fn45F6
struct Eq_n * fn474C(struct Eq_n * r1, word16 r2, struct Eq_n * r3, struct Eq_n * r4, ptr16 & r4Out)
{
	ptr16 fp;
	LOCK();
	ptr16 sp_n = fp - 0x02;
	ptr16 r0_n = r3->ptr0008;
	if (r0_n != 0x00)
	{
		QSET(r0_n, 0x04);
		r3->ptr0008 = 0x00;
		sp_n = fp - 0x04;
	}
	struct Eq_n * sp_n = sp_n - 0x02;
	sp_n->ptr0000 = r4;
	struct Eq_n * r0_n = r1;
	if (!DSTAT(sp_n->ptr0000, r1))
	{
		r1->w0000 = r2;
		sp_n->ptrFFFFFFFE = r4;
		sp_n -= 0x02;
		if (DSTAT(sp_n->ptrFFFFFFFE, r1))
			goto l47DC;
	}
	if (r4->b0000 != 0x04)
	{
		word16 v19_n = r4->w0002;
		if (r4->w0004 == 0x00)
		{
			r3->ptr000A -= v19_n;
			if (r3->ptr000A - r3->w000C <= 0x00)
			{
l47D8:
				sp_n->ptr0000 = &sp_n->ptr0000->b0000 + 1;
l47DA:
				sp_n->ptr0000 = &sp_n->ptr0000->b0000 + 1;
l47DC:
				UNLOCK();
				r4Out = 0x00;
				return r0_n;
			}
			sp_n -= 0x02;
			sp_n->ptr0000 = r3->ptr000A;
			if (FETCH(sp_n->ptr0000, r1, out r0_n))
				goto l47DC;
		}
		while (true)
		{
			struct Eq_n * sp_n = sp_n - 0x02;
			sp_n->w0000 = 0x00;
			cui16 v29_n = r1->wFFFA & 0x0100;
			r1->wFFFA = v29_n;
			cui16 r0_n = 0x0100;
			if (v29_n == 0x00)
			{
				sp_n->wFFFFFFFE = r1->w0012;
				sp_n -= 0x02;
				r0_n = 0x0200;
			}
			struct Eq_n * sp_n = sp_n - 0x02;
			sp_n->ptr0000 = r1;
			sp_n->wFFFFFFFE = r0_n | (r1->t000B).u1;
			r0_n = sp_n - 0x02;
			if (FnSubfn(sp_n - 0x02))
				break;
			cui16 v34_n = r1->w0016 & 0x04;
			r1->w0016 = v34_n;
			if (v34_n == 0x00)
				goto l47DA;
			r1->wFFFA &= ~0x0100;
			r1->w0016 &= ~0x04;
		}
		sp_n->ptr0000 = &sp_n->ptr0000->b0000 + 1;
	}
	sp_n->ptr0000 = &sp_n->ptr0000->b0000 + 1;
	goto l47D8;
}

word16 g_w47E0 = 0x87; // 47E0
Eq_n g_a47E2[] = // 47E2
	{
	};
struct Eq_n g_t47E4 = // 47E4
	{
		0x8020,
		0x05,
	};
Eq_n g_t47FE = // 47FE
	{
		0xB109,
		14988,
	};
word16 g_w4898 = 0x05; // 4898
char g_str48BA[] = ""; // 48BA
Eq_n g_t4968 = // 4968
	{
		0x4B,
		0x01,
		&g_w5506,
	};
Eq_n g_t4DAA = // 4DAA
	{
		0x3A,
		0x00,
		&g_w56B2,
	};
Eq_n g_t507E = // 507E
	{
		0x12,
		0x01,
		&g_w56C4,
	};
Eq_n g_t50B2 = // 50B2
	{
		0x0C,
		0x00,
		&g_w56DE,
	};
Eq_n g_t512C = // 512C
	{
		0x46,
		0x01,
		&g_w56FE,
	};
word16 g_w516A = 0x04; // 516A
Eq_n g_t517E = // 517E
	{
		0x0E,
		0x02,
		&g_w571E,
	};
Eq_n g_t518E = // 518E
	{
		<code>,
		&g_str0005,
		&g_t000A,
		0x0F,
		0x1E,
		&g_t0023,
		&g_t0028,
		0x2D,
		null,
		null,
		&g_t4066,
		&g_t0004,
		&g_t51A8,
		0x1900,
		0x00,
		0x00,
		22362,
		0x20,
		0x20,
		
		{
			32
		},
		0x20,
		&g_t002A,
		0x2A,
		&g_t0E06,
		null,
		&g_str0005,
		0x0A,
		&g_t0004,
		&g_t5766,
		~0x15,
		0x04,
	};
Eq_n g_t51A6 = // 51A6
	{
		0x01
	};
Eq_n g_t51A8 = // 51A8
	{
		<code>,
		&g_str4066,
		&g_t6666,
		0x02,
		0x01,
		&g_t574A,
		&g_t0004,
		22330,
		&g_t573C,
		&g_str0001,
		&g_t51A6,
		&g_t51A8,
		&g_t0020,
		0x241E,
		0x0110,
		0x01,
		0x0E06,
		0x05,
		0x0A,
		
		{
			0x0F
		},
		0x01,
		&g_t5766,
		22372,
		&g_t58BA,
		&g_t5768,
		&g_t5206,
		~0x19,
		&g_t5206,
		&g_t51E8,
		118,
		0x5206,
	};
Eq_n g_t51DC = // 51DC
	{
		0x19,
		0x00,
		&g_w575A,
	};
<anonymous> g_t51E4 = <code>; // 51E4
Eq_n g_t51E8 = // 51E8
	{
		<code>,
		&g_str0020,
		&g_str0020,
		0x2A,
		0x2A,
		&g_t002A,
		&g_t241E,
		0x0110,
		&g_t0E06,
		&g_str000A,
		&g_t000F,
		&g_t51E4,
		&g_t5206,
		0x5206,
		20972,
		0x51,
		0x04,
		0x5772,
		0x5206,
		
		{
			0x000051EE
		},
		0x04,
		&g_t5206,
		0x51F0,
		&g_t5206,
		&g_t51F2,
		&g_t0004,
		0x7C,
		&g_t0004,
		&g_t577E,
		0x20,
		0x20,
	};
Eq_n g_t51F2 = // 51F2
	{
		
		{
			0x2A
		},
		&g_w002A,
		0x2A,
		0x05,
		0x00,
		0x05,
		0x04,
		0x5766,
		22372,
	};
Eq_n g_t5206 = // 5206
	{
		
		{
			0x01
		},
		&g_w0005,
		0x04,
		0x04,
		88,
		20966,
		0x04,
		22380,
		22378,
	};
Eq_n g_t526E = // 526E
	{
		0x55,
		0x00,
		&g_w5784,
	};
Eq_n g_t52E2 = // 52E2
	{
		0x78,
		0x00,
		&g_w57AC,
	};
Eq_n g_t530A = // 530A
	{
		0x23,
		0x02,
		&g_w57C0,
	};
Eq_n g_t5330 = // 5330
	{
		0x14,
		0x00,
		&g_w57D4,
	};
Eq_n g_t5344 = // 5344
	{
		0x66,
		0x02,
		&g_w57D8,
	};
word16 g_w534E = 0x02; // 534E
Eq_n g_t5354 = // 5354
	{
		0x2E,
		0x01,
		&g_w57E4,
	};
Eq_n g_t5368 = // 5368
	{
		0x70,
		0x00,
		&g_w57E8,
	};
Eq_n g_t537A = // 537A
	{
		0x66,
		0x04,
		&g_w5808,
	};
Eq_n g_t53B0 = // 53B0
	{
		0x60,
		0x02,
		&g_w5864,
	};
Eq_n g_t53C0 = // 53C0
	{
		0x8C,
		0x00,
		&g_w586E,
	};
Eq_n g_t53D8 = // 53D8
	{
		0x8C,
		0x00,
		&g_w5874,
	};
cup16 g_w53E8 = 22644; // 53E8
cup16 g_w53EA = 0x88; // 53EA
cui16 g_w53EC = 0x00; // 53EC
<anonymous> * g_ptr53F0 = &g_t11EC; // 53F0
<anonymous> * g_ptr5414 = &g_t11EC; // 5414
uint16 g_a541C[] = // 541C
	{
	};
struct Eq_n * g_ptr5424 = &g_t542C; // 5424
ci16 * g_ptr5426 = null; // 5426
word16 g_w542C = 0x00; // 542C
<anonymous> g_t5464 = <code>; // 5464
Eq_n g_t54DC = // 54DC
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		0x00,
		0x00,
	};
word16 g_w5506 = 0x00; // 5506
word16 g_w55CC = 0x00; // 55CC
word16 g_w56B2 = 0x00; // 56B2
word16 g_w56C4 = 0x00; // 56C4
word16 g_w56DE = 0x00; // 56DE
word16 g_w56FE = 0x00; // 56FE
word16 g_w571E = 0x00; // 571E
Eq_n g_t573C = // 573C
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_n g_t574A = // 574A
	{
		null,
	};
word16 g_w575A = 0x00; // 575A
Eq_n g_t5766 = // 5766
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		0x00,
		0x00,
	};
Eq_n g_t5768 = // 5768
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_n g_t577E = // 577E
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		0x00,
		0x00,
	};
word16 g_w5784 = 0x00; // 5784
word16 g_w57AC = 0x00; // 57AC
word16 g_w57C0 = 0x00; // 57C0
word16 g_w57D4 = 0x00; // 57D4
word16 g_w57D8 = 0x00; // 57D8
union Eq_n * g_ptr57DA = null; // 57DA
Eq_n g_t57DC = // 57DC
	{
		0x00
	};
byte g_b57DD = 0x00; // 57DD
Eq_n g_t57DE = // 57DE
	{
		0x00
	};
Eq_n g_t57DF = // 57DF
	{
		0x00
	};
Eq_n g_t57E0 = // 57E0
	{
		0x00
	};
word16 g_w57E2 = 0x00; // 57E2
word16 g_w57E4 = 0x00; // 57E4
word16 g_w57E8 = 0x00; // 57E8
Eq_n g_t5800 = // 5800
	{
		0x00,
		0x00,
	};
word16 g_w5808 = 0x00; // 5808
Eq_n g_t5854 = // 5854
	{
		?? /* Can't read byte at address 5E03 */ ,
	};
word16 g_w5864 = 0x00; // 5864
word16 g_w586E = 0x00; // 586E
word16 g_w5874 = 0x00; // 5874
Eq_n g_t58BA = // 58BA
	{
		0
	};
Eq_n g_t58C2 = // 58C2
	{
		0x00,
		0x00,
	};
<anonymous> g_t59F0 = <code>; // 59F0
char g_str5A18[] = ""; // 5A18
word16 g_w5A2C = 0x00; // 5A2C
<anonymous> g_t5A3E = <code>; // 5A3E
// 5A90: void fn5A90()
void fn5A90()
{
	t0000.w0024 |= 0x5040;
	word16 r0_n;
	TTYIN(out r0_n);
}

<anonymous> g_t5AA2 = <code>; // 5AA2
