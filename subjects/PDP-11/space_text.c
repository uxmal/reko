// space_text.c
// Generated by decompiling space.sav
// using Reko decompiler version 0.10.2.0.

#include "space.h"

Eq_n t0000 = // 0000
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x03C0,
		0x00,
		0x1DAE,
		0x0200,
		0x00,
		0x00,
		23202,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_n g_t0001 = // 0001
	{
		0x41,
	};
Eq_n g_t0002 = // 0002
	{
		0
	};
Eq_n g_t0003 = // 0003
	{
		null,
	};
Eq_n g_t0004 = // 0004
	{
		
		{
			0x00
		},
		0x00,
		0x00,
	};
Eq_n g_t0005 = // 0005
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0xC000,
		0x03,
		44544,
		0x1D,
	};
char g_str0006[] = ""; // 0006
Eq_n g_t0007 = // 0007
	{
		0x00,
		0x00,
	};
Eq_n g_t000A = // 000A
	{
		0x4A,
	};
Eq_n g_t000B = // 000B
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0xC0,
		0x1D,
		0x02,
		0x00,
		0xA200,
	};
<anonymous> g_t000D = <code>; // 000D
Eq_n g_t000F = // 000F
	{
		0
	};
Eq_n g_t0015 = // 0015
	{
		0
	};
Eq_n g_t0016 = // 0016
	{
		
		{
			0x00
		},
		0x00,
		0x00,
	};
Eq_n g_t0019 = // 0019
	{
		
		{
			0x00
		},
		0xC000,
		0x03,
	};
Eq_n g_t001B = // 001B
	{
		0x24,
	};
Eq_n g_t0020 = // 0020
	{
		<code>,
		&g_str0200,
		null,
		0x00,
		23202,
		null,
		0x00,
		null,
		
		{
			0x00
		},
		0x00,
		null,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		
		{
			0
		},
		0x00,
	};
Eq_n g_t0023 = // 0023
	{
		null,
	};
char g_str0024[] = ""; // 0024
Eq_n g_t002A = // 002A
	{
		null,
		&g_t5AA2,
	};
Eq_n g_t002C = // 002C
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_n g_t002D = // 002D
	{
		0x69,
	};
Eq_n g_t002F = // 002F
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_n g_t003B = // 003B
	{
		0
	};
<anonymous> g_t003D = <code>; // 003D
char g_str0042[] = ""; // 0042
Eq_n g_t0047 = // 0047
	{
		null,
	};
Eq_n g_t0050 = // 0050
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		0x00,
		null,
		
		{
			0x00
		},
		0x00,
		null,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		
		{
			-1
		},
		~0x1B00,
	};
Eq_n g_t0053 = // 0053
	{
		0x00,
		0x00,
	};
Eq_n g_t005A = // 005A
	{
		null,
	};
Eq_n g_t005E = // 005E
	{
		0
	};
Eq_n g_t0077 = // 0077
	{
		0x36,
	};
<anonymous> g_t0078 = <code>; // 0078
Eq_n g_t0080 = // 0080
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		0x00,
		null,
		
		{
			0x00
		},
		0x00,
		null,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		&g_tFFFFFFFF,
		&g_tFFFFFFFF,
		~0x00,
		null,
		null,
		
		{
			0
		},
		0x00,
	};
word16 g_w00A2 = 0x00; // 00A2
Eq_n g_t00B8 = // 00B8
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		0x00,
		null,
		
		{
			0x00
		},
		0x00,
		null,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		
		{
			0
		},
		0x00,
	};
word16 g_w0115 = 0x00; // 0115
char g_str011C[] = ""; // 011C
char g_str0200[] = "\xA0"; // 0200
char g_str0215[] = "\x01\xC1\x15\x01\n\xC0\x1D\x8E\x1B\x01\x03\xC8\t\xC6\x17\""; // 0215
Eq_n g_t021D = // 021D
	{
		<code>,
		&g_strFFFFC803,
		&g_tFFFFC609,
		0x2217,
		0x2600,
		&g_tFFFFC011,
		37397,
		&g_tFFFFFD05,
		
		{
			0x88
		},
		0x2817,
		&g_t6600,
		&g_strFFFFE60A,
		&g_t0015,
		&g_tFFFF8488,
		&g_t1EF0,
		&g_t2602,
		0xF700,
		~0x08,
		0x780B,
		0xCE03,
		0x040B,
		
		{
			-0x00003FFD
		},
		0x8015,
		&g_tFFFFC001,
		48149,
		&g_t260A,
		&g_tFFFFE400,
		&g_t000B,
		0x11,
		&g_t6B21,
		&g_tFFFFC483,
		
		{
			8421
		},
		0xC200,
	};
Eq_n g_t026C = // 026C
	{
		
		{
			0x00
		},
		0x26,
		3063,
	};
Eq_n g_t0305 = // 0305
	{
		<code>,
		&g_str0C11,
		&g_t0500,
		0x3221,
		63363,
		&g_tFFFF9A0B,
		3866,
		&g_tFFFFC003,
		
		{
			0x15
		},
		~0x02FC,
		&g_tFFFFC088,
		&g_strFFFFB702,
		&g_tFFFFC823,
		&g_t2021,
		&g_tFFFF8400,
		&g_t3300,
		0x7A12,
		122,
		0xDF00,
		0x2002,
		0xDF00,
		
		{
			0x0055
		},
		0x2420,
		&g_tFFFFF319,
		30091,
		&g_tFFFF9715,
		&g_tFFFFE903,
		&g_tFFFFDF88,
		~0x2A,
		&g_t7245,
		&g_t2072,
		
		{
			0x00007473
		},
		29281,
	};
char g_b0380 = '?'; // 0380
char g_b0397 = '?'; // 0397
char g_b03B8 = '\0'; // 03B8
char g_b03BC = '\0'; // 03BC
Eq_n g_t03FD = // 03FD
	{
		-0x00002DFD
	};
word16 g_w0446 = 0x1CC2; // 0446
// 0468: void fn0468(Register (ptr16 byte) r3)
// Called from:
//      fn0472
void fn0468(byte * r3)
{
	while (true)
	{
		++r3;
		int16 r0_n = (int16) *r3;
		if (r0_n == 0x00)
			break;
		do
			;
		while (TTYOUT((char) r0_n));
	}
}

// 0472: void fn0472(Register Eq_n r1, Stack Eq_n wArg10)
void fn0472(Eq_n r1, Eq_n wArg10)
{
	fn0468(&g_b05E4);
	struct Eq_n * r3_n = g_ptr5424;
	struct Eq_n * r0_n = r3_n->ptr007C;
	struct Eq_n * r3_n = r3_n->ptr000E;
	if (r3_n != null)
		r0_n = r3_n->ptr0002;
	fn0528(r0_n);
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	fn0528(sp_n->ptr0000);
	fn0468(&g_b05EF);
	ci16 v21_n = *g_ptr5426;
	if (v21_n == 0x00)
	{
		do
			;
		while (TTYOUT('?'));
	}
	else
		fn04FA(v21_n);
	if (r1 == 0x3D || r1 == 0x3F)
	{
		fn0468(&g_b0601);
		Eq_n r1_n = wArg10;
		bool C_n = true;
		Eq_n r0_n = 24;
		while (true)
		{
			r1_n = __rcl(r1_n, 1, C_n);
			Eq_n r0_n = __rcl(r0_n, 1, (r1_n & 0x8000) != 0x00);
			do
				;
			while (TTYOUT((char) r0_n));
			r0_n.u0 = 0x0086;
			do
			{
				r1_n <<= 1;
				bool C_n = (bool) cond(r1_n);
				if (r1_n == 0x00)
				{
					do
						;
					while (TTYOUT(')'));
					goto l04F2;
				}
				r0_n = __rcl(r0_n, 1, C_n);
				C_n = (r0_n & 0x80) != 0x00;
				r0_n = r0_n;
			} while ((r0_n & 0x80) != 0x00);
		}
	}
	else
	{
l04F2:
		PRINT(&g_b05E1);
	}
}

// 04FA: void fn04FA(Register ci16 r0)
// Called from:
//      fn0472
//      fn04FA
void fn04FA(ci16 r0)
{
	ci16 wLoc02_n = r0;
	word16 r0_n = 0x00;
	do
	{
		ci16 v10_n = wLoc02_n - 0x0A;
		++r0_n;
		wLoc02_n = v10_n;
	} while (v10_n >= 0x00);
	byte bLoc02_n = (byte) v10_n + 0x3A;
	if (r0_n != 0x01)
		fn04FA(r0_n - 0x01);
	int16 r0_n = (int16) bLoc02_n;
	do
		;
	while (TTYOUT((char) r0_n));
}

Eq_n g_t0500 = // 0500
	{
		0x0A,
		~0x31,
	};
// 051A: Register (ptr16 Eq_n) fn051A(Register (ptr16 Eq_n) r0, Register cup16 r2, Register out (ptr16 Eq_n) r3Out)
// Called from:
//      fn0528
struct Eq_n * fn051A(struct Eq_n * r0, cup16 r2, struct Eq_n & r3Out)
{
	struct Eq_n * r3_n = r0;
	struct Eq_n * r0_n = null;
	while (r3_n - r2 <= 0x00)
	{
		r3_n -= r2;
		r0_n = (struct Eq_n *) ((char *) r0_n + 1);
	}
	r3Out = r3_n;
	return r0_n;
}

// 0528: void fn0528(Register (ptr16 Eq_n) r0)
// Called from:
//      fn0472
void fn0528(struct Eq_n * r0)
{
	struct Eq_n * r3_n;
	word16 r3_n;
	struct Eq_n * r0_n = fn051A(fn051A(r0, 0x28, out r3_n), 0x28, out r3_n);
	word16 r3_n = 0x03;
	while (true)
	{
		int16 r0_n = (int16) r0_n->b05AF;
		do
			;
		while (TTYOUT((char) r0_n));
		--r3_n;
		if (r3_n == 0x00)
			break;
		r0_n = r3_n;
	}
}

// 054C: void fn054C(Register Eq_n r0, Register (ptr16 Eq_n) r3)
void fn054C(Eq_n r0, struct Eq_n * r3)
{
	r3->t00A0 = r0;
	r3->b00A1 = r3->b00A2;
	struct Eq_n * r0_n = r3 + (r0 >> 3 & ~0x01) /16 0x00A3;
	ci16 r2_n = r0 & ~~0x0F;
	Eq_n wLoc02_n = 0x00;
	bool C_n = true;
	do
	{
		Eq_n v16_n = __rcl(wLoc02_n, 1, C_n);
		wLoc02_n = v16_n;
		C_n = (wLoc02_n & 0x8000) != 0x00;
		--r2_n;
	} while (r2_n > 0x00);
	r0_n->w0096 |= v16_n;
}

char g_b0592 = '\0'; // 0592
char g_b05E1 = '\r'; // 05E1
byte g_b05E4 = 0x20; // 05E4
byte g_b05EF = 0x22; // 05EF
byte g_b0601 = 0x20; // 0601
// 0608: void fn0608(Stack (ptr16 code) wArg00, Stack Eq_n wArg02)
void fn0608(<anonymous> * wArg00, Eq_n wArg02)
{
	byte bArg03_n = SLICE(wArg02, byte, 8);
	byte bArg02_n = (byte) wArg02;
	struct Eq_n * r4_n = g_ptr5424;
	r4_n->ptr002A = wArg00;
	Eq_n wArg00_n = 0x00;
	Eq_n r1_n = wArg02;
	if (wArg02 <= 0x00)
	{
		if (wArg02 == 0x00)
			goto l065C;
		r1_n = -wArg02;
	}
	wLoc04 <<= 1;
	cui16 r2_n = 0x90;
	bool C_n = false;
	while (true)
	{
		r1_n = __rcl(r1_n, 1, C_n);
		C_n = (r1_n & 0x8000) != 0x00;
		if ((r1_n & 0x8000) != 0x00)
			break;
		--r2_n;
	}
	Eq_n r1_n = __swab(SEQ(SLICE(r1_n, byte, 8), 0x00) | r2_n);
	wArg00_n = __rcr(r1_n, 1, (wLoc04 << 1 & 0x01) != 0x00);
	wLoc02 >>= 1;
	wArg02 = SEQ(__rcr(bArg03_n, 1, (r1_n & 0x01) != 0x00), bArg02_n);
l065C:
	r4_n->ptr002A();
}

// 0670: void fn0670(Register Eq_n r5, Stack (ptr16 code) wArg00, Stack cui16 wArg02, Stack Eq_n wArg04, Stack cui16 wArg06, Stack Eq_n wArg08)
void fn0670(Eq_n r5, <anonymous> * wArg00, cui16 wArg02, Eq_n wArg04, cui16 wArg06, Eq_n wArg08)
{
	struct Eq_n * r4_n = g_ptr5424;
	r4_n->ptr002A = wArg00;
	cui16 r2_n = wArg06;
	Eq_n r3_n = wArg08;
	ui32 r0_r1_n = SEQ(wArg02, wArg04);
	if (wArg08 == 0x00)
	{
		r3_n = wArg04;
		r2_n = wArg02;
		r0_r1_n = SEQ(wArg06, wArg08);
	}
	word16 r2_n;
	cup16 r3_n;
	ui32 v46_n = r0_r1_n << 0x01;
	Eq_n r1_n = (word16) v46_n;
	Eq_n r0_n = SLICE(v46_n, word16, 16);
	Eq_n r5_n = __rcl(r5, 1, (SLICE(r0_r1_n, word16, 16) & 0x8000) != 0x00);
	if (r0_n == 0x00)
	{
l06B2:
		r2_n = 0x00;
		r3_n = 0x00;
		goto l0738;
	}
	uint16 r2_n = r2_n << 1;
	if (r2_n == 0x00)
		goto l06B2;
	cui16 r5_n = (word16) r5_n + (word16) (r2_n < 0x00);
	wchar_t r4_n = SEQ(SLICE(r0_n, byte, 8), 0x00) + r2_n;
	if (r4_n < 0x00)
	{
		if (r4_n <= 0x00)
		{
			__syscall(0x898A);
			goto l06B2;
		}
	}
	else
	{
		if (r4_n >= 0x00)
			goto l06B0;
		r4_n &= 0x7F00;
		if ((r4_n & 0x7F00) == 0x00)
		{
l06B0:
			__syscall(0x898B);
			goto l06B2;
		}
	}
	cui16 r4_n = SEQ(SLICE(r4_n, byte, 8), 0x00);
	Eq_n r4_n = __rcr(r4_n + 0x7F01, 1, (r5_n & 0x01) != 0x00);
	Eq_n r2_n = __rcr(r2_n, 1, (r4_n + 0x7F01 & 0x01) != 0x00);
	Eq_n r3_n = __swab(r3_n);
	cu16 r2_n = SEQ(SLICE(__swab(r2_n), byte, 8), 0x00) | r3_n;
	Eq_n r3_n = __rcr(SEQ(SLICE(r3_n, byte, 8), 0x00), 1, (r2_n & 0x01) != 0x00);
	Eq_n r1_n = __swab(r1_n);
	Eq_n r2_n = r2_n >> 1;
	Eq_n r0_n = SEQ(SLICE(__swab(r0_n), byte, 8), 0x00) | r1_n;
	Eq_n r1_n = SEQ(SLICE(r1_n, byte, 8), 0x00);
	uint32 r4_r5_n = SEQ(r2_n >> 1, r3_n);
	while (true)
	{
		r4_r5_n >>= 0x01;
		r1_n <<= 1;
		word16 r4_n = SLICE(r4_r5_n, word16, 16);
		word16 r5_n = (word16) r4_r5_n;
		bool C_n = (bool) cond(r1_n);
		if (r1_n == 0x00)
			break;
		r0_n = __rcl(r0_n, 1, C_n);
		r0_n = r0_n;
		if ((r0_n & 0x8000) == 0x00)
		{
			r3_n = (word16) r3_n + r5_n;
			r2_n = (word16) r2_n + (word16) (r3_n < 0x00) + r4_n;
		}
	}
	Eq_n r0_n = __rcl(r0_n, 1, C_n);
	if ((r0_n & 0x8000) == 0x00)
	{
l0700:
		r3_n = (word16) r3_n + (word16) r4_r5_n;
		r2_n = (word16) r2_n + (word16) (r3_n < 0x00) + SLICE(r4_r5_n, word16, 16);
	}
	do
	{
		wArg04 = r4_n;
		r4_r5_n >>= 0x01;
		r0_n <<= 1;
		if (r0_n < 0x00)
			goto l0700;
	} while (r0_n != 0x00);
	Eq_n r4_n = r4_n;
	bool C_n = false;
	if (r2_n < 0x00)
	{
l0724:
		r3_n = __swab(SEQ(SLICE(__rcl(r3_n, 1, C_n), byte, 8), 0x00) | r2_n) + __rcl(r1_n, 1, (r3_n & 0x80) != 0x00);
		r2_n = __swab(SEQ(SLICE(r2_n, byte, 8), 0x00)) + r4_n + CONVERT(r3_n <u 0x00, bool, word16);
l0738:
		r4_n->ptr002A();
		return;
	}
	r3_n <<= 1;
	r2_n = __rcl(r2_n, 1, (r3_n & 0x8000) != 0x00);
	if ((r4_n & 0x7F80) != 0x00)
	{
		r4_n = (r4_n & 0x7F80) - 0x80;
		C_n = (bool) cond(r4_n);
		goto l0724;
	}
	goto l06B0;
}

Eq_n g_t06F7 = // 06F7
	{
		&g_tFFFFF661,
	};
Eq_n g_t0704 = // 0704
	{
		
		{
			0x02
		},
		&g_w0C84,
		0x0C05,
		3010,
		0x81,
		0x35C4,
		0x7F80,
		0x03C8,
		58820,
	};
// 0754: void fn0754(Stack (ptr16 code) wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack cui16 wArg06, Stack word16 wArg08)
void fn0754(<anonymous> * wArg00, Eq_n wArg02, Eq_n wArg04, cui16 wArg06, word16 wArg08)
{
	struct Eq_n * r4_n = g_ptr5424;
	r4_n->ptr002A = wArg00;
	bool C_n = (bool) cond(wArg02 << 1);
	if (wArg02 << 1 == 0x00)
	{
		__syscall(0x898C);
		goto l080C;
	}
	Eq_n v23_n = __rcl(wArg02, 1, C_n);
	wArg02 = v23_n;
	if (wArg06 << 1 != 0x00)
	{
		word16 r2_n = SEQ(SLICE(wArg06 << 1, byte, 8), 0x00);
		word16 r0_n = SEQ(SLICE(wArg02 << 1, byte, 8), 0x00);
		wArg02 = (word16) v23_n + (word16) (wArg06 << 1 < 0x00);
		uint16 r4_n = wArg06 << 1 & ~r2_n;
		uint16 r5_n = wArg02 << 1 & ~r0_n;
		wchar_t r2_n = r2_n - r0_n;
		if (r2_n >= 0x00)
		{
			if (r2_n <= 0x00)
			{
				__syscall(0x898A);
				goto l080A;
			}
l078E:
			ui32 r4_r3_n;
			Eq_n r4_n = __rcr(r4_n, 1, true);
			wArg04 = __rcr(wArg04, 1, (r4_n & 0x01) != 0x00);
			Eq_n r5_n = __rcr(r5_n, 1, (r2_n + 0x7F01 & 0x01) != 0x00);
			Eq_n r0_n = 0x0100;
			Eq_n v33_n = r5_n - r4_n;
			if (v33_n > 0x00)
			{
l07AC:
				cup16 r3_n = wArg08 - wArg04;
				r0_n.u0 = 0x0202;
				r4_r3_n = SEQ(r4_n - (word16) (r3_n < 0x00) - r5_n, r3_n);
				goto l07B6;
			}
			else
			{
				r4_r3_n = SEQ(r4_n, wArg08);
				if (v33_n >= 0x00)
				{
					cup16 v35_n = wArg04 - wArg08;
					r4_r3_n = SEQ(r4_n, wArg08);
					if (v35_n >= 0x00)
					{
						if (v35_n == 0x00)
						{
l07E6:
l07FE:
							(*wArg02)();
							return;
						}
						goto l07AC;
					}
				}
l07B6:
				wArg04.u0 = 2028;
				ui32 r4_r3_n = r4_r3_n;
				do
				{
					bool C_n;
					Eq_n r0_n;
					ui32 r4_r3_n = r4_r3_n << 0x01;
					word16 r3_n = (word16) r4_r3_n;
					word16 r4_n = SLICE(r4_r3_n, word16, 16);
					if ((SLICE(r4_r3_n, word16, 16) & 0x80) == 0x00)
					{
						cup16 v40_n = r4_n - r5_n;
						C_n = (bool) cond(v40_n);
						if (v40_n > 0x00)
							goto l07CE;
						if (v40_n != 0x00)
							goto l07C6;
						cup16 v41_n = r3_n - wArg04;
						C_n = (bool) cond(v41_n);
						if (v41_n > 0x00)
							goto l07CE;
						if (v41_n >= 0x00)
						{
							bool C_n = true;
							do
							{
								r0_n = __rcl(r0_n, 1, C_n);
								C_n = (r0_n & 0x8000) != 0x00;
								r0_n = r0_n;
							} while ((r0_n & 0x8000) != 0x00);
							if (true)
								goto l07E6;
							goto l07FE;
						}
					}
l07C6:
					cup16 r3_n = r3_n - wArg04;
					C_n = true;
					r4_r3_n = SEQ(r4_n - (word16) (r3_n < 0x00) - r5_n, r3_n);
l07CE:
					r0_n = __rcl(r0_n, 1, C_n);
					r4_r3_n = r4_r3_n;
					r0_n = r0_n;
				} while ((r0_n & 0x8000) != 0x00);
				return;
			}
		}
		if (r2_n <= 0x00)
			goto l078E;
		__syscall(0x898B);
	}
l080C:
	goto l07E8;
}

word16 g_w07A7 = 0x0620; // 07A7
Eq_n g_t07CF = // 07CF
	{
		
		{
			0x0C
		},
		0x8786,
		0x4300,
	};
Eq_n g_t07DD = // 07DD
	{
		
		{
			0x0C
		},
		0x9786,
		63013,
	};
// 0818: void fn0818(Register (ptr16 word16) r5)
void fn0818(word16 * r5)
{
	fn11A6(r5 + *r5 + *r5 + 1, r5);
	g_ptr53F0();
}

Eq_n g_t09DE = // 09DE
	{
		
		{
			0x06
		},
		&g_w55CC,
		0x10,
		35266,
		0x35,
		0x0303,
		~0x600B,
		0x4A3A,
		0x10,
	};
Eq_n g_t09F7 = // 09F7
	{
		
		{
			~0x60
		},
		0x104A,
		0x5800,
	};
char g_str0A00[] = ""; // 0A00
Eq_n g_t0A15 = // 0A15
	{
		0x01,
		0x03,
	};
Eq_n g_t0A37 = // 0A37
	{
		
		{
			0x15
		},
		16651,
		0x740B,
	};
// 0A64: void fn0A64(Register (ptr16 word16) r5)
void fn0A64(word16 * r5)
{
	fn11A6(r5 + *r5 + *r5 + 1, r5);
	g_ptr5414();
}

// 0AAE: void fn0AAE(Register (ptr16 Eq_n) r5)
void fn0AAE(struct Eq_n * r5)
{
	struct Eq_n * r4_n = r5->ptr0002;
	word16 v9_n = r4_n->w0002;
	cui16 v11_n = r4_n->w0000;
	int16 r0_n;
	Eq_n r3_n = __rcr(0x00, 1, (bool) cond(v11_n << 1));
	Eq_n r0_n = __rcr(v11_n << 1, 1, true);
	Eq_n r2_n = SEQ(SLICE(r0_n, byte, 8), 0x00);
	cui16 r0_n = r0_n & ~r2_n;
	Eq_n r2_n = __swab(r2_n);
	if (r2_n <= 0x00)
	{
		int32 r0_r1_n = SEQ(r0_n, v9_n);
		if (r2_n > 0x91)
		{
			do
			{
				while (true)
				{
					r0_n = SLICE(r0_r1_n, word16, 16);
					uint16 r1_n = (word16) r0_r1_n;
					wchar_t v31_n = r2_n - 0x88;
					if (v31_n >= 0x00)
						break;
					r0_r1_n <<= 0x01;
					--r2_n;
				}
				if (v31_n == 0x00)
					break;
				r2_n = (word16) r2_n + 1;
				r0_n >>= 1;
				r0_r1_n = SEQ(r0_n >> 1, r1_n);
			} while (r0_n >> 1 != 0x00);
			if (r3_n <= 0x00)
				r0_n = -r0_n;
l107E:
			if (r0_n == 0x00)
			{
l1086:
				g_ptr0ABE();
				return;
			}
			r3_n = (word16) r3_n + r0_n;
			if (r3_n >= 0x00)
				goto l1086;
			goto l105E;
		}
l105E:
		__syscall(0x8981);
	}
	r0_n = 0x00;
	goto l107E;
}

Eq_n g_t0AB7 = // 0AB7
	{
		&g_t021D,
		&g_t2600,
	};
<anonymous> * g_ptr0ABE = &g_t0AC0; // 0ABE
Eq_n g_t0ABF = // 0ABF
	{
		~0x05,
	};
<anonymous> g_t0AC0 = <code>; // 0AC0
Eq_n g_t0AC3 = // 0AC3
	{
		
		{
			0x00
		},
		&g_w0115,
		0x0E01,
		0x0815,
		0x08,
		0x0504,
		58881,
		0x0115,
		0x0204,
	};
// 0AC4: void fn0AC4(Register word16 r3, Register (ptr16 (ptr16 code)) r4, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 code) wArg04)
void fn0AC4(word16 r3, <anonymous> ** r4, struct Eq_n * wArg00, struct Eq_n * wArg02, <anonymous> * wArg04)
{
	fn0AE6(r3, r4, 0x0101, wArg00, wArg02, wArg04);
}

// 0AE2: void fn0AE2(Register word16 r3, Register (ptr16 (ptr16 code)) r4, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 code) wArg04)
void fn0AE2(word16 r3, <anonymous> ** r4, struct Eq_n * wArg00, struct Eq_n * wArg02, <anonymous> * wArg04)
{
	fn0AE6(r3, r4, 0x0202, wArg00, wArg02, wArg04);
}

// 0AE6: void fn0AE6(Register word16 r3, Register (ptr16 (ptr16 code)) r4, Stack word16 wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 Eq_n) wArg04, Stack (ptr16 code) wArg06)
// Called from:
//      fn0AC4
//      fn0AE2
void fn0AE6(word16 r3, <anonymous> ** r4, word16 wArg00, struct Eq_n * wArg02, struct Eq_n * wArg04, <anonymous> * wArg06)
{
	byte bArg00 = (byte) wArg00;
	struct Eq_n * r3_n = g_ptr5424;
	uint16 wLoc04_n = (uint16) bArg00;
	if (bArg00 == 0x01)
		fn0B02(r3_n, r4, wLoc04_n, r3, wArg00, wArg02, wArg04, wArg06);
	else
		fn0AF8(r3_n, r4, wLoc04_n, r3, wArg00, wArg02, wArg04, wArg06);
}

// 0AF8: void fn0AF8(Register (ptr16 Eq_n) r3, Register (ptr16 (ptr16 code)) r4, Stack uint16 wArg00, Stack word16 wArg02, Stack word16 wArg04, Stack (ptr16 Eq_n) wArg06, Stack (ptr16 Eq_n) wArg08, Stack (ptr16 code) wArg0A)
// Called from:
//      fn0AE2
//      fn0AE6
void fn0AF8(struct Eq_n * r3, <anonymous> ** r4, uint16 wArg00, word16 wArg02, word16 wArg04, struct Eq_n * wArg06, struct Eq_n * wArg08, <anonymous> * wArg0A)
{
	byte bArg00 = (byte) wArg00;
	if (bArg00 == 0x08)
		fn0B02(r3, r4, wArg00, wArg02, wArg04, wArg06, wArg08, wArg0A);
	else
		fn0B02(r3, r4, wArg00 + 0x03, wArg02, wArg04, wArg06, wArg08, wArg0A);
}

// 0B02: void fn0B02(Register (ptr16 Eq_n) r3, Register (ptr16 (ptr16 code)) r4, Stack uint16 wArg00, Stack word16 wArg02, Stack word16 wArg04, Stack (ptr16 Eq_n) wArg06, Stack (ptr16 Eq_n) wArg08, Stack (ptr16 code) wArg0A)
// Called from:
//      fn0AE2
//      fn0AE6
void fn0B02(struct Eq_n * r3, <anonymous> ** r4, uint16 wArg00, word16 wArg02, word16 wArg04, struct Eq_n * wArg06, struct Eq_n * wArg08, <anonymous> * wArg0A)
{
	cu8 bArg05 = SLICE(wArg04, byte, 8);
	cu8 bArg04 = (byte) wArg04;
	word16 v6_n = wArg00 + (word16) (bArg05 - bArg04 < 0x00);
	r3->w00A4 = v6_n;
	if (r3->b0074 == 0x00)
	{
		r3->w0052 = wArg04;
		r3->ptr0044 = wArg08;
		wArg0A();
	}
	else
	{
		r3->w0052 = wArg04;
		r3->ptr0044 = wArg06;
		wArg08();
		(*r4)();
	}
}

// 0B3E: void fn0B3E(Register (ptr16 Eq_n) r0, Register (ptr16 word16) r3, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 word16) ptrArg04)
void fn0B3E(struct Eq_n * r0, word16 * r3, struct Eq_n * wArg00, struct Eq_n * wArg02, word16 * ptrArg04)
{
	fn0B60(r0, r3, 0x0202, wArg00, wArg02, ptrArg04);
}

// 0B44: void fn0B44(Register (ptr16 Eq_n) r0, Register (ptr16 word16) r3, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 word16) ptrArg04)
void fn0B44(struct Eq_n * r0, word16 * r3, struct Eq_n * wArg00, struct Eq_n * wArg02, word16 * ptrArg04)
{
	fn0B60(r0, r3, 0x0101, wArg00, wArg02, ptrArg04);
}

// 0B60: void fn0B60(Register (ptr16 Eq_n) r0, Register (ptr16 word16) r3, Stack word16 wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 Eq_n) wArg04, Stack (ptr16 word16) ptrArg06)
// Called from:
//      fn0B3E
//      fn0B44
void fn0B60(struct Eq_n * r0, word16 * r3, word16 wArg00, struct Eq_n * wArg02, struct Eq_n * wArg04, word16 * ptrArg06)
{
	cu8 bArg00 = (byte) wArg00;
	cu8 bArg01 = SLICE(wArg00, byte, 8);
	uint16 wLoc04_n;
	struct Eq_n * r3_n = g_ptr5424;
	if (bArg00 != 0x01)
	{
		wLoc04_n = (uint16) bArg00;
		if (bArg00 != 0x08)
			wLoc04_n += 0x03;
	}
	word16 * sp_n;
	<anonymous> ** sp_n;
	r3_n->w00A4 = wLoc04_n + (word16) (bArg01 - bArg00 < 0x00);
	if (r3_n->b0074 != 0x00)
	{
		r3_n->w0052 = wArg00;
		r3_n->ptr0044 = wArg02;
		r3_n->w005A = wArg04->t0000;
		r3_n->ptr007E = &g_t0BEC;
		sp_n = fp + 0x06;
l0BC6:
		struct Eq_n * r0_n;
		(*sp_n)();
		struct Eq_n * sp_n = (char *) sp_n + 2;
		sp_n->ptrFFFFFFFE = r3_n;
		sp_n->ptrFFFFFFFC = r0_n;
		struct Eq_n * r3_n = g_ptr5424;
		r3_n->ptr0044 += (int16) r3_n->b0053 /16 166;
		struct Eq_n * v36_n = sp_n->ptrFFFFFFFC;
		word16 v38_n = r3_n->w005A - 0x01;
		r3_n->w005A = v38_n;
		sp_n = sp_n - 0x02;
		r0 = v36_n;
		if (v38_n == 0x00)
		{
			sp_n->ptrFFFFFFFC = sp_n->ptrFFFFFFFE;
			sp_n->ptrFFFFFFFE = r3_n->ptr007E;
			sp_n->ptrFFFFFFFE();
			return;
		}
	}
	else
	{
		r3_n->w0052 = wArg00;
		r3_n->ptr007E = wArg02;
		r3_n->ptr0044 = wArg04;
		r3_n->w005A = *ptrArg06;
		ptrArg06 = r3;
		sp_n = fp + 0x06;
	}
	sp_n = sp_n + 1;
	r3_n = *sp_n;
	goto l0BC6;
}

Eq_n g_t0BCE = // 0BCE
	{
		<code>,
		&g_strFFFF9CC0,
		&g_t0053,
		0x6033,
		0x44,
		&g_t1580,
		0x0AF3,
		&g_t005A,
		
		{
			242
		},
		5030,
		&g_t1CF6,
		&g_str1583,
		&g_t005E,
		&g_t1581,
		&g_t0305,
		&g_t09F7,
		0x28,
		0x00,
		772,
		0x10,
		0xA08E,
		
		{
			-32245
		},
		0x0CC1,
		&g_tFFFF8001,
		24642,
		&g_tFFFF8702,
		&g_t6081,
		&g_tFFFF86EE,
		~0x29,
		&g_t0AC0,
		&g_tFFFF800B,
		
		{
			5568
		},
		0x04,
	};
Eq_n g_t0BEC = // 0BEC
	{
		<code>,
		&g_str15C2,
		&g_t0007,
		0x0102,
		5570,
		&g_tFFFF8009,
		5505,
		&g_t1580,
		
		{
			131
		},
		0x1066,
		&g_t10A6,
		&g_str0042,
		&g_t03FD,
		&g_t000D,
		&g_t0BCE,
		&g_tFFFF8702,
		0x6081,
		0x60,
		~0x7911,
		177,
		0x4041,
		
		{
			2142
		},
		0x0AC0,
		&g_t0CD6,
		34311,
		&g_t0C01,
		&g_t0C41,
		&g_tFFFF85F2,
		161,
		&g_tFFFFFF80,
		&g_tFFFFE5C2,
		
		{
			4326
		},
		0x15C1,
	};
char g_str0BF0[] = "\a"; // 0BF0
Eq_n g_t0C01 = // 0C01
	{
		16
	};
char g_str0C11[] = ""; // 0C11
Eq_n g_t0C41 = // 0C41
	{
		
		{
			0x86
		},
		&g_wFFFFB10B,
		0x4100,
		0xD60B,
		0x07,
		0x0180,
		0x010B,
		0x410C,
		0xF20C,
	};
// 0C4A: void fn0C4A(Register ci16 r0, Register Eq_n r1, Stack word16 wArg00, Stack cui16 wArg02, Stack (ptr16 code) wArg04)
void fn0C4A(ci16 r0, Eq_n r1, word16 wArg00, cui16 wArg02, <anonymous> * wArg04)
{
	if (r0 > 0x01)
		return;
	if (wArg02 << 1 < 0x00)
	{
		if (wArg02 << 1 <= 0x00)
			r1 = -r1;
		r1 = __rcl(r1 >> 1, 1, (r1 & 0x01) != 0x00);
		if (OVERFLOW(r1))
		{
			wArg04();
			return;
		}
	}
	wArg04();
}

Eq_n g_t0C80 = // 0C80
	{
		
		{
			66
		},
		&g_w1589,
		6211,
		0x10E6,
		0x15,
		0x8604,
		3013,
		0x0402,
		0x0B05,
	};
char g_str0C81[] = "\x12\x89\x15C\x18I\x11E\x18\t\x11\xC2`\xE6\x10\xC1\x15- \xC0\f\x04\x86\xC5\v\x02\x04\x05\v\xC1"; // 0C81
word16 g_w0C84 = 6211; // 0C84
Eq_n g_t0CD6 = // 0CD6
	{
		&g_t2020,
		&g_t0AC3,
	};
// 0CF4: void fn0CF4(Register (ptr16 Eq_n) r5)
void fn0CF4(struct Eq_n * r5)
{
	if (r5->b0000 == 0x01)
	{
		struct Eq_n * r0_n = r5->ptr0002;
		fn15CC(fp - 0x08);
		struct Eq_n * r0_n = fn0D3E(r0_n, fp - 0x04);
		r0_n->b0000 = 0x2D;
		struct Eq_n * r1_n = (fp - 0x06 << 1) + (fp - 0x06);
		r0_n->b0001 = r1_n->b0D4F;
		r0_n->b0002 = r1_n->b0D50;
		r0_n->b0003 = r1_n->b0D51;
		r0_n->b0004 = 0x2D;
		fn0D3E(&r0_n->b0004 + 1, fp - 0x02);
	}
	else
		__syscall(0x8990);
}

<anonymous> g_t0D0A = <code>; // 0D0A
// 0D3E: Register (ptr16 Eq_n) fn0D3E(Register (ptr16 Eq_n) r0, Register Eq_n r2)
// Called from:
//      fn0CF4
struct Eq_n * fn0D3E(struct Eq_n * r0, Eq_n r2)
{
	Eq_n r2_n = __swab(r2);
	do
		r2_n = (word16) r2_n + 62977;
	while (r2_n > 0x00);
	r0->w0000 = (word16) r2_n + 0x00003A2F;
	r0->t0002 = __swab((word16) r2_n + 0x00003A2F);
	return (char *) &r0->t0002 + 2;
}

// 0D7A: Register word16 fn0D7A(Register word16 r0, Stack word16 wArg00, Stack word16 wArg02, Stack (ptr16 Eq_n) wArg04, Register out ptr16 r3Out)
// Called from:
//      fn2B96
word16 fn0D7A(word16 r0, word16 wArg00, word16 wArg02, struct Eq_n * wArg04, ptr16 & r3Out)
{
	word16 r0_n;
	g_t0D7E();
	r3Out = 3454;
	return r0_n;
}

<anonymous> g_t0D7E = <code>; // 0D7E
// 0DC8: void fn0DC8(Register word16 r0, Stack word16 wArg00, Stack word16 wArg02, Stack word16 wArg04)
void fn0DC8(word16 r0, word16 wArg00, word16 wArg02, word16 wArg04)
{
	g_t0DCC();
}

<anonymous> g_t0DCC = <code>; // 0DCC
Eq_n g_t0E06 = // 0E06
	{
		0x0033
	};
// 0E0E: void fn0E0E(Stack (ptr16 code) wArg00, Stack word16 wArg02, Stack word16 wArg04, Stack word16 wArg06, Stack word16 wArg08)
void fn0E0E(<anonymous> * wArg00, word16 wArg02, word16 wArg04, word16 wArg06, word16 wArg08)
{
	struct Eq_n * r4_n = g_ptr5424;
	r4_n->ptr002A = wArg00;
	cup16 v18_n = wArg02 - wArg06;
	bool v24_n = v18_n >= 0x00;
	if (v18_n == 0x00)
	{
		cup16 v20_n = wArg04 - wArg08;
		v24_n = v20_n >= 0x00;
		if (v20_n == 0x00)
		{
l0E7C:
			r4_n->ptr002A();
			return;
		}
	}
	goto l0E7C;
}

// 0EA8: void fn0EA8(Stack (ptr16 Eq_n) wArg00)
// Called from:
//      fn2B96
void fn0EA8(struct Eq_n * wArg00)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->ptr0044 = null;
	if (r3_n->b0074 == 0x00)
		r3_n->ptr007E = wArg00;
	wArg00();
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->b0074 != 0x00;
	r3_n->ptr0072 = null;
	r3_n->ptr0070 = null;
	r3_n->ptr0014 = null;
	r3_n->w000C = r3_n->w0058;
	r3_n->t00A2.u1 = 0x00;
}

Eq_n g_t0EF4 = // 0EF4
	{
		
		{
			0x5C
		},
		&g_w15C1,
		0x0A01,
		40166,
		0x00,
		4838,
		5158,
		5158,
		0x0A0B,
	};
// 0EF8: void fn0EF8(Register (ptr16 Eq_n) r4, Register (ptr16 word16) r5)
// Called from:
//      fn243A
//      fn2B90
//      fn2E20
//      fn2EC4
//      fn3220
//      fn34AC
//      fn395C
//      fn3B3C
//      fn3E12
//      fn3F42
//      fn4030
//      fn4072
//      fn413C
//      fn4180
//      fn4230
//      fn4534
//      fn457C
//      fn45C8
void fn0EF8(struct Eq_n * r4, word16 * r5)
{
	struct Eq_n * r3_n = g_ptr5424;
	struct Eq_n * v13_n = r4->ptr0000;
	struct Eq_n * v17_n = r3_n->ptr000E;
	word16 v18_n = r3_n->t0000;
	byte v16_n = r3_n->b0074;
	byte bLoc04_n = v13_n->b0001;
	r3_n->t0000 = (<anonymous>) 0x00;
	r3_n->ptr000E = fp - 0x07;
	word16 v22_n = *r5;
	byte bArg00_n = SLICE(v17_n, byte, 8);
	byte bLoc03_n = (byte) v18_n;
	byte bLoc01_n = (byte) v17_n;
	byte bLoc02_n = SLICE(v18_n, byte, 8);
	word16 * r0_n = &v13_n->w0004;
	word16 * r5_n = r5 + 1;
	word16 r1_n = v22_n;
	word16 wArg00_n = SEQ(v16_n, bArg00_n);
	word16 wLoc04_n = SEQ(bLoc03_n, bLoc04_n);
	wLoc04_n = SEQ(bLoc03_n, bLoc04_n);
	struct Eq_n * wLoc02_n = SEQ(bLoc01_n, bLoc02_n);
	wLoc02_n = SEQ(bLoc01_n, bLoc02_n);
	if (v22_n != 0x00)
	{
		word16 v23_n = v13_n->w0004;
		r0_n = &v13_n->ptr0006;
		word16 r2_n = v23_n;
		if (v23_n != 0x00)
		{
			r0_n = v13_n->ptr0006;
			do
			{
				*r0_n = *r5_n;
				++r5_n;
				++r0_n;
				--r1_n;
				if (r1_n == 0x00)
					break;
				--r2_n;
			} while (r2_n != 0x00);
		}
	}
	r3_n->b0074 = 0x00;
	if (true)
	{
		fn2B96(pc);
		struct Eq_n * r4_n = g_ptr5424;
		r4_n->t0000 = (<anonymous>) wLoc04_n;
		r4_n->ptr000E = wLoc02_n;
		r4_n->b0074 = bArg00_n;
	}
	else
		r4->ptr0002();
}

// 0F48: void fn0F48(Register (ptr16 Eq_n) r5)
void fn0F48(struct Eq_n * r5)
{
	if (r5->b0000 == 0x02)
	{
		ui32 r0_r1_n;
		union Eq_n * v13_n = r5->ptr0002;
		cui16 * v15_n = r5->ptr0004;
		Eq_n r0_n = *v13_n;
		cui16 r1_n = *v15_n;
		if (r1_n != 0x00)
		{
			word16 r0_n = __rcl(r0_n, 1, (bool) cond(r1_n << 1)) + Mem0[v13_n + 0x00:word16];
			uint16 r1_n = (r1_n << 1) + *v15_n;
			ci16 r0_n = r0_n + (word16) (r1_n < 0x00) + *v15_n;
			r0_r1_n = SEQ(r0_n, r1_n);
			if (r0_n <= 0x00)
				r0_r1_n = SEQ(r0_n + 0x8000, r1_n);
		}
		else
			r0_r1_n = SEQ((word16) r0_n + 1, 0x03);
		*v13_n = SLICE(r0_r1_n, word16, 16);
		*v15_n = (word16) r0_r1_n;
		ui32 r0_r1_n = r0_r1_n;
		do
			r0_r1_n <<= 0x01;
		while ((SLICE(r0_r1_n, word16, 16) & 0x8000) == 0x00);
	}
	else
		__syscall(0x8990);
}

// 0F9C: void fn0F9C()
void fn0F9C()
{
	t0000.b002B |= 0x01;
	struct Eq_n * r3_n = g_ptr5424;
	++r3_n->w0066;
	struct Eq_n * r4_n = r3_n->ptr0004;
	while (r3_n->ptr0002 - r4_n < 0x00)
	{
		r4_n = r4_n + 1;
		r4_n = r4_n;
		if ((int16) r4_n->b0000 != 0x00)
		{
			if (r3_n->w0066 == 0x02)
			{
				r4_n->bFFFFFFFF = 0x00;
				--r3_n->w0066;
				--r4_n;
			}
			else
				g_ptr1DAA();
		}
	}
	union Eq_n * r0_n = r3_n->ptr006E;
	if (r0_n == null)
	{
		cui16 v30_n = t0000.w0024 & 0x0800;
		t0000.w0024 = v30_n;
		if (v30_n == 0x00)
			r0_n = (union Eq_n *) ((char *) r0_n + 1);
		EXIT(r0_n);
	}
	else
		r0_n();
}

// 0FA4: void fn0FA4(Register word16 r0, Stack word16 wArg00, Stack (ptr16 Eq_n) wArg02, Stack word16 wArg04, Stack word16 wArg06)
void fn0FA4(word16 r0, word16 wArg00, union Eq_n * wArg02, word16 wArg04, word16 wArg06)
{
	fn0FB2(r0, &g_t1020, wArg00, wArg02, wArg04, wArg06);
}

// 0FAE: void fn0FAE(Register word16 r0, Stack word16 wArg00, Stack (ptr16 Eq_n) wArg02, Stack word16 wArg04, Stack word16 wArg06)
void fn0FAE(word16 r0, word16 wArg00, union Eq_n * wArg02, word16 wArg04, word16 wArg06)
{
	fn0FB2(r0, &g_t101E, wArg00, wArg02, wArg04, wArg06);
}

// 0FB2: void fn0FB2(Register word16 r0, Stack (ptr16 Eq_n) wArg00, Stack word16 wArg02, Stack (ptr16 Eq_n) wArg04, Stack word16 wArg06, Stack word16 wArg08)
// Called from:
//      fn0FA4
//      fn0FAE
void fn0FB2(word16 r0, struct Eq_n * wArg00, word16 wArg02, union Eq_n * wArg04, word16 wArg06, word16 wArg08)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->ptr0064 = fp + 0x0A;
	if (r3_n->ptr0014 != null)
		__syscall(0x899A);
	r3_n->ptr0014 = wArg00;
	r3_n->ptr001C = wArg04;
	g_t0FE2();
}

<anonymous> g_t0FE2 = <code>; // 0FE2
Eq_n g_t1002 = // 1002
	{
		
		{
			0x60
		},
		0x15F3,
		0x01,
	};
Eq_n g_t101E = // 101E
	{
		
		{
			0x00
		},
		&g_wFFFF8000,
		0x1DC4,
		0x0109,
		0x1D,
		0x2A,
		5516,
		5558,
		0x02,
	};
Eq_n g_t1020 = // 1020
	{
		
		{
			0x00
		},
		&g_w1DC4,
		0x4400,
		0x1DC4,
		0x43,
		5516,
		5558,
		0x02,
		5558,
	};
Eq_n g_t1037 = // 1037
	{
		<code>,
		&g_str0215,
		&g_tFFFFB600,
		533,
		0x8000,
		&g_tFFFF8115,
		0x0315,
		&g_tFFFFC00A,
		
		{
			0x0C
		},
		0xB10C,
		null,
		&g_strFFFF808A,
		&g_tFFFFC240,
		&g_t0D0A,
		&g_t0080,
		&g_t5C10,
		0x8000,
		0x80,
		3731,
		0x7F00,
		0x7F7F,
		
		{
			0x007F
		},
		~0x83,
		&g_t7FFF,
		32636,
		&g_t7F7F,
		&g_t7F7F,
		&g_t7F7F,
		0x7F,
		&g_t7F7F,
		&g_t7F7F,
		
		{
			0x00003606
		},
		0x0400,
	};
<anonymous> g_t105D = <code>; // 105D
Eq_n g_t10A6 = // 10A6
	{
		
		{
			0x7F
		},
		&g_w7F7F,
		0x7F7F,
		0x7F7F,
		0x7F,
		0x7F7F,
		0x7F7F,
		0x7F7F,
		0x7F7F,
	};
// 11A6: void fn11A6(Register (ptr16 Eq_n) r0, Register (ptr16 word16) r5)
// Called from:
//      fn0818
//      fn0A64
void fn11A6(struct Eq_n * r0, word16 * r5)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->ptr0064 = r0;
	r3_n->w0058 = r3_n->w000C;
	word16 * r0_n = g_a541C;
	word16 * r1_n = &g_w542C;
	word16 * r2_n = &g_ptr5426;
	word16 ** r5_n = r5 + 1;
	while (true)
	{
		r2_n -= 0x02;
		word16 * r3_n = *r2_n;
		if (r3_n == null)
			break;
		uint16 r4_n = *r0_n;
		r1_n -= 0x02;
		*r1_n = **r5_n;
		uint16 v24_n = *r1_n;
		++r0_n;
		r5_n = (word16 **) ((char *) r5_n + 2);
		uint16 wLoc02_n = v24_n;
		bool v39_n = v24_n == 0x00;
		while (!v39_n)
		{
			uint16 v28_n = wLoc02_n >> 1;
			wLoc02_n = v28_n;
			if ((wLoc02_n & 0x01) == 0x00)
			{
				r4_n &= 0x01;
				if (r4_n != 0x00)
				{
					*r3_n = *r5_n;
					r5_n = (word16 **) ((char *) r5_n + 2);
				}
			}
			++r3_n;
			r4_n >>= 1;
			v39_n = v28_n == 0x00;
		}
	}
}

<anonymous> g_t11EC = <code>; // 11EC
// 12AC: void fn12AC(Register Eq_n r2)
void fn12AC(Eq_n r2)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->t00A2 = r2;
	if (r3_n->ptr0014 != null)
		__syscall(0x899A);
	struct Eq_n * r0_n = fn1420(r2, r3_n);
	r3_n->ptr0014 = r0_n;
	r0_n->t0000.u2 = r0_n->t0000 & 0x0800;
}

// 12CA: void fn12CA(Register ptr16 r2, Register (ptr16 Eq_n) r3)
void fn12CA(ptr16 r2, struct Eq_n * r3)
{
	struct Eq_n * r4_n = r3->ptr0014;
	char * r1_n = r3->ptr001A;
	if (r4_n->t0000 <= 0x00)
	{
		PRINT(&g_b138E);
		r2 = r3->ptr0054;
		r3->ptr0054 = fp - 0x04;
	}
	Eq_n v18_n = r4_n->t0000 & 0x20;
	r4_n->t0000.u2 = v18_n;
	int16 r0_n = 0x0A;
	if (v18_n != 0x00)
	{
		++r1_n;
		Eq_n r5_n = (int16) *r1_n;
		if (r5_n == 0x31)
		{
			r0_n = 0x0C;
l1326:
			word16 r2_n;
			fn1366(r0_n, r3, r4_n, out r2_n, out r3, out r4_n);
l132A:
			if (r4_n->t0000 <= 0x00)
			{
				if (r3->ptr001C - r1_n < 0x00)
				{
					Eq_n r5_n = (int16) *r3->ptr001C;
					*r3->ptr001C = (union Eq_n *) 0x80;
					PRINT(r1_n);
					*r3->ptr001C = (union Eq_n *) r5_n;
				}
			}
			else
			{
				while (r3->ptr001C - r1_n < 0x00)
				{
					word16 r2_n;
					fn1370((int16) *r1_n, r3, r4_n, out r2_n, out r3, out r4_n);
					++r1_n;
				}
			}
			return;
		}
		if (r5_n == 0x2B)
			goto l132A;
		if (r5_n == 0x24)
		{
			--r3->ptr001C;
			r3->ptr0054 = 0x00;
		}
		else if (r5_n == 0x30)
			r0_n = fn1366(0x0A, r3, r4_n, out r2, out r3, out r4_n);
	}
	if (r4_n->t0000 <= 0x00 && r2 == 0x00)
		goto l132A;
	goto l1326;
}

Eq_n g_t1360 = // 1360
	{
		0x86,
	};
// 1366: Register int16 fn1366(Register int16 r0, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out ptr16 r2Out, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn12CA
int16 fn1366(int16 r0, struct Eq_n * r3, struct Eq_n * r4, ptr16 & r2Out, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	if (r4->t0000 > 0x00)
	{
		ptr16 r2_n;
		struct Eq_n * r3_n;
		struct Eq_n * r4_n;
		int16 r0_n = fn1370(r0, r3, r4, out r2_n, out r3_n, out r4_n);
		r2Out = r2_n;
		r3Out = r3_n;
		r4Out = r4_n;
		return r0_n;
	}
	else
	{
		do
			;
		while (TTYOUT((char) r0));
		r2Out = r2;
		r3Out = r3;
		r4Out = r4;
		return r0;
	}
}

// 1370: Register int16 fn1370(Register int16 r0, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out (ptr16 int16) r2Out, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn12CA
//      fn1366
int16 fn1370(int16 r0, struct Eq_n * r3, struct Eq_n * r4, int16 & r2Out, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	word16 r2_n = Mem0[r4 + 0x0E:word16] + Mem0[r4 + 0x02:word16];
	*r2_n = r0;
	r4[7] = (struct Eq_n) ((word16) r4[7].t0000 + 1);
	cui16 v14_n = r4[7] & 0x01FF;
	r4[7] = (struct Eq_n) v14_n;
	if (v14_n != 0x00)
	{
		r2Out = r2_n;
		r3Out = r3;
		r4Out = r4;
		return r0;
	}
	else
	{
		r4[7] = (struct Eq_n) 0x00;
		int16 * r2_n;
		struct Eq_n * r3_n;
		struct Eq_n * r4_n;
		int16 r0_n = fn1836(r3, r4, out r2_n, out r3_n, out r4_n);
		r2Out = r2_n;
		r3Out = r3_n;
		r4Out = r4_n;
		return r0_n;
	}
}

char g_b138E = '\x80'; // 138E
Eq_n g_t1396 = // 1396
	{
		&g_t15C4,
		&g_t13F0,
	};
<anonymous> g_t13F0 = <code>; // 13F0
// 13FE: void fn13FE()
// Called from:
//      fn14A8
//      fn45F6
void fn13FE()
{
	__syscall(0x88A0);
	__syscall(0x88A1);
	__syscall(0x88A2);
	__syscall(0x88A3);
	__syscall(0x88A4);
	__syscall(0x88A5);
	__syscall(0x88A6);
	__syscall(0x88A7);
	__syscall(0x88A8);
	__syscall(0x88A9);
	__syscall(0x88AA);
	__syscall(0x88AB);
	__syscall(0x88AC);
	__syscall(0x88AD);
	__syscall(0x88AE);
	__syscall(0x88AF);
}

// 1420: Register word16 fn1420(Register Eq_n r2, Register (ptr16 Eq_n) r3)
// Called from:
//      fn12AC
//      fn145E
//      fn14A8
word16 fn1420(Eq_n r2, struct Eq_n * r3)
{
	if (r2 <= 0x00 || r2 < 99)
		__syscall(0x8994);
	struct Eq_n * v14_n = r3->ptr0004;
	struct Eq_n * r1_n = v14_n;
	do
	{
		++r1_n;
		if (r1_n->b0000 - r2 == 0x00)
			goto l144A;
	} while (r3->ptr0002 - r1_n < 0x00);
	r1_n = v14_n;
	do
	{
		++r1_n;
		if (r1_n->b0000 == 0x00)
			goto l144A;
	} while (r3->ptr0002 - r1_n < 0x00);
	__syscall(0x8995);
l144A:
	union Eq_n * r1_n = r1_n - 0x02;
	*r1_n = (union Eq_n *) r2;
	word16 r0_n = r3->w0006;
	ptr16 r1_n;
	for (r1_n = r1_n - v14_n; r1_n != 0x00; --r1_n)
		r0_n += 0x20;
	return r0_n;
}

// 145E: void fn145E(Register Eq_n r2, Stack (ptr16 code) wArg00, Stack word16 wArg02, Stack (ptr16 Eq_n) ptrArg04)
void fn145E(Eq_n r2, <anonymous> * wArg00, word16 wArg02, union Eq_n * ptrArg04)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->ptr0064 = fp + 22;
	r3_n->t00A2 = r2;
	if (r3_n->ptr0014 != null)
		__syscall(0x899A);
	r3_n->w0012 = wArg02;
	Eq_n v17_n = *ptrArg04;
	struct Eq_n * r0_n = fn1420(v17_n, r3_n);
	r3_n->ptr0014 = r0_n;
	r0_n->t0000.u2 = r0_n->t0000 & 0x0800;
	struct Eq_n * r0_n;
	wArg00();
	ci16 v21_n = r0_n->w0000 & 0x0800;
	r0_n->w0000 = v21_n;
	if (v21_n == 0x00)
		fn45F6(r0_n, v17_n, r3_n);
	r3_n->ptr001A = r3_n->ptr0002;
	r3_n->w0058 = r3_n->w000C;
}

// 14A8: void fn14A8(Register Eq_n r2, Register uint16 r5)
void fn14A8(Eq_n r2, uint16 r5)
{
	struct Eq_n * r3_n = g_ptr5424;
	r3_n->t00A2 = r2;
	struct Eq_n * r0_n = fn1420(r2, r3_n);
	r3_n->ptr0014 = r0_n;
	cui16 v13_n = r0_n->t0000 & 0x0800;
	r0_n->t0000 = v13_n;
	struct Eq_n * sp_n = fp - 0x06;
	if (v13_n != 0x00)
	{
		word16 ** sp_n;
		if (r0_n->t0000 >= 0x00)
		{
			struct Eq_n * r4_n;
			r3_n = fn1D30(r0_n, r3_n, out r4_n);
			ci16 v20_n = r4_n->t0000 & 0x0200;
			r4_n->t0000.u1 = v20_n;
			if (v20_n != 0x00)
			{
				cu16 v22_n = r4_n[0x0C];
				r4_n[11] = (struct Eq_n) v22_n;
				if (v22_n != 0x00)
				{
					word16 * r2_n = r4_n[1];
					word16 r5_n;
					for (r5_n = 0x0100; r5_n != 0x00; --r5_n)
					{
						*r2_n = 0x00;
						++r2_n;
					}
					ci16 v25_n = r4_n->t0000 & 0x0100;
					r4_n->t0000.u1 = v25_n;
					if (v25_n != 0x00)
					{
						r3_n->ptr0070 = &g_t1520;
						if (r3_n->b0074 != 0x00)
							r3_n->ptr0072 = &g_t151E;
						r3_n->ptr0064 = fp - 0x09;
						while (true)
						{
							word16 r2_n;
							fn1836(r3_n, r4_n, out r2_n, out r3_n, out r4_n);
						}
					}
					while (r4_n[0x0D] - r4_n[11] <= 0x00)
					{
						word16 r2_n;
						fn1836(r3_n, r4_n, out r2_n, out r3_n, out r4_n);
						sp_n = (struct Eq_n *) <invalid>;
					}
				}
			}
			fn13FE();
			cui16 r5_n = r4_n[2];
			word16 * r2_n = r4_n[1];
			ci16 v46_n = r4_n->t0000 & 0x01;
			r4_n->t0000.u1 = v46_n;
			r5 = r5_n << 1;
			if (v46_n != 0x00)
				r2_n -= 0x0200;
			sp_n = sp_n - 0x02;
			*sp_n = r2_n;
			word16 * r0_n = r2_n + (r5_n << 1);
			do
			{
				*r2_n = *r0_n;
				++r0_n;
				++r2_n;
			} while (r3_n->w000C - r0_n < 0x00);
			r3_n->w000C -= r5_n << 1;
			ci16 v60_n = r4_n->t0000 & 0x04;
			r4_n->t0000.u1 = v60_n;
			int16 r1_n = (int16) r4_n->b0011;
			__syscall(0x88FC);
			Eq_n r0_n = 0x00;
			bool C_n = true;
			do
			{
				r0_n = __rcl(r0_n, 1, C_n);
				C_n = (r0_n & 0x8000) != 0x00;
				--r1_n;
			} while (r1_n > 0x00);
			r3_n->t0010 &= ~r0_n;
		}
		else
			sp_n = fp - 0x08;
		r3_n->ptr0072 = null;
		r3_n->ptr0070 = null;
		struct Eq_n * r4_n = r3_n->ptr0004;
		while (r3_n->ptr0002 - r4_n < 0x00)
		{
			++r4_n;
			Eq_n r2_n = (int16) r4_n->b0000;
			if (r2_n != 0x00)
			{
				struct Eq_n * r0_n = fn1420(r2_n, r3_n);
				if (r0_n[1] - *sp_n < 0x00)
					r0_n[1] = (struct Eq_n) (r0_n[1] - r5);
			}
		}
		r0_n = r3_n->ptr0014;
	}
	word16 r4_n;
	for (r4_n = 0x10; r4_n != 0x00; --r4_n)
	{
		r0_n->t0000.u0 = 0x00;
		++r0_n;
	}
	struct Eq_n * r0_n = r3_n->ptr0004;
	do
	{
		r0_n = r0_n + 1;
		r0_n = r0_n;
	} while (r2 - r0_n->b0000 != 0x00);
	r0_n->bFFFFFFFF = 0x00;
	r3_n->ptr0014 = null;
	r3_n->t00A2.u1 = 0x00;
}

Eq_n g_t151E = // 151E
	{
		
		{
			0x20
		},
		&g_wFFFF95B3,
		0xA2,
		0x04,
		0x0C,
		0x35CC,
		0x01,
		770,
		58818,
	};
Eq_n g_t1520 = // 1520
	{
		
		{
			~0x4C
		},
		&g_w00A2,
		5508,
		0x0CC5,
		0x1D,
		0x01,
		770,
		58818,
		0x0200,
	};
Eq_n g_t1580 = // 1580
	{
		&g_t0002,
	};
<anonymous> g_t1581 = <code>; // 1581
char g_str1583[] = ""; // 1583
word16 g_w1589 = ~0x08FC; // 1589
word16 g_w15C1 = 0x8715; // 15C1
char g_str15C2[] = "\x87"; // 15C2
Eq_n g_t15C4 = // 15C4
	{
		0x1004,
		5606,
	};
Eq_n g_t15C5 = // 15C5
	{
		
		{
			0x10
		},
		&g_wFFFFFF15,
		~0x2B00,
		0x1F89,
		166,
		0x15,
		0xB011,
		0x0211,
		0xFD00,
	};
// 15CC: void fn15CC(Register (ptr16 Eq_n) r5)
// Called from:
//      fn0CF4
void fn15CC(struct Eq_n * r5)
{
	if (r5->b0000 != 0x03)
		__syscall(0x8990);
	else
	{
		FnSubfn(fp - 0x04);
		__syscall(0x88FC);
		Eq_n r2_n = 0x0A00;
		if (true)
			r2_n = (~~0x1F & 0x0A00) + 0x48;
		*r5->ptr0002 = (union Eq_n *) (__swab(0x0280) & ~~0x1F);
		*r5->ptr0004 = (union Eq_n *) (~~0x1F & 0x50);
		*r5->ptr0006 = (union Eq_n *) r2_n;
	}
}

Eq_n g_t15E6 = // 15E6
	{
		<code>,
		&g_str0A00,
		&g_tFFFF88FC,
		5571,
		~0x1F,
		&g_t1002,
		0x0303,
		&g_t40C2,
		
		{
			0xC2
		},
		0x48,
		&g_t0C80,
		&g_str0C81,
		&g_str0C81,
		&g_t105D,
		&g_tFFFF8000,
		&g_t09F7,
		65060,
		~0x01,
		0x0202,
		22,
		0x55C8,
		
		{
			-0x00008000
		},
		0x35C8,
		&g_tFFFF89A5,
		2526,
		&g_tFFFF89A6,
		&g_t09DE,
		&g_t1DC3,
		202,
		&g_t09F7,
		&g_t00B8,
		
		{
			0x0087
		},
		0x0BF3,
	};
Eq_n g_t15F1 = // 15F1
	{
		&g_tFFFFC203,
	};
Eq_n g_t15F7 = // 15F7
	{
		
		{
			101
		},
		&g_wFFFF8000,
		0x800C,
		0xC10C,
		0xC0,
		0x1D25,
		0x5D10,
		0x9D10,
		0x8710,
	};
<anonymous> g_t15FF = <code>; // 15FF
char g_str16B4[] = "\x04\x80\xCCU\x02"; // 16B4
// 16DA: void fn16DA(Register int16 r0, Register cui16 r2, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4)
void fn16DA(int16 r0, cui16 r2, struct Eq_n * r3, struct Eq_n * r4)
{
	r4[7] = (struct Eq_n) r2;
	if (r3->w005E - r4[11] != 0x00)
	{
		ci16 v13_n = r4->t0000 & 0x02;
		r4->t0000.u1 = v13_n;
		if (v13_n != 0x00)
		{
			word16 r2_n;
			r0 = fn1836(r3, r4, out r2_n, out r3, out r4);
			r4[0x0C] = (struct Eq_n) 0x00;
			r4->t0000.u1 = r4->t0000 & ~0x02;
		}
		r4[11] = (struct Eq_n) r3->w005E;
		if (r4->t0000 > 0x00 || (r3->t005C > 0x0200 || r4[7] != 0x00))
		{
			struct Eq_n * r4_n;
			r3 = fn18BE(r0, r3, r4, out r4_n);
			--r4_n->w0016;
		}
	}
	++r3->w005E;
}

// 171E: void fn171E(Register (ptr16 Eq_n) r0, Register (ptr16 Eq_n) r3)
void fn171E(struct Eq_n * r0, struct Eq_n * r3)
{
	ptr16 r2_n = *r3->ptr0012;
	*r0->ptr0012 = r2_n;
	++*r0->ptr0012;
	fn172C(r0, r2_n - 0x01);
}

// 172C: void fn172C(Register (ptr16 Eq_n) r0, Register word16 r2)
// Called from:
//      fn171E
void fn172C(struct Eq_n * r0, word16 r2)
{
	Eq_n r3_n = r0->t0014;
	cup16 r1_n = 0x00;
	Eq_n r4_n = 0x00;
	uint32 r5_r2_n = (uint32) r2;
	while (true)
	{
		word16 r5_n = SLICE(r5_r2_n, word16, 16);
		word16 r2_n = (word16) r5_r2_n;
		r3_n >>= 1;
		if (r3_n >= 0x00)
		{
			if (r3_n == 0x00)
			{
				Eq_n r1_n = __swab(SEQ(SLICE(r1_n, byte, 8), 0x00));
				Eq_n r4_n = __swab(r4_n);
				if (r4_n != 0x00)
					__syscall(0x89A8);
				struct Eq_n * r3_n = g_ptr5424;
				r3_n->w005E = r1_n | r4_n;
				r3_n->t005C = r0->t0014;
				r3_n->t005C <<= 1;
				return;
			}
		}
		else
		{
			r1_n += r2_n;
			r4_n = (word16) r4_n + (word16) (r1_n < 0x00) + r5_n;
		}
		r5_r2_n <<= 0x01;
	}
}

// 1836: Register word16 fn1836(Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out ptr16 r2Out, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn1370
//      fn14A8
//      fn16DA
//      fn1D30
word16 fn1836(struct Eq_n * r3, struct Eq_n * r4, ptr16 & r2Out, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	r4[0x0C] = r4[11];
	r4[0x0C] = (struct Eq_n) ((word16) r4[0x0C].t0000 + 1);
	if (r4[0x0D] - r4[11] >= 0x00)
		r4[0x0D] = r4[11];
	Eq_n v19_n = r4->t0000 & 0x40;
	r4->t0000.u2 = v19_n;
	if (v19_n != 0x00)
	{
		r4->t0000.u2 = r4->t0000 & ~0x8000;
		r4[0x0C] = (struct Eq_n) 0x00;
		__syscall(35235);
	}
	struct Eq_n * r3_n;
	struct Eq_n * r4_n;
	ptr16 r2_n = fn1900(r3, r4, out r3_n, out r4_n);
	byte v26_n = r4_n->b0011 | 0x90;
	word16 r0_n;
	SEQ(0x88, v26_n)();
	r2Out = r2_n;
	r3Out = r3_n;
	r4Out = r4_n;
	return r0_n;
}

<anonymous> g_t18A6 = <code>; // 18A6
// 18BE: Register (ptr16 Eq_n) fn18BE(Register int16 r0, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn16DA
struct Eq_n * fn18BE(int16 r0, struct Eq_n * r3, struct Eq_n * r4, struct Eq_n & r4Out)
{
	if (r4[0x0C] == 0x00 || r4[0x0C] - r4[11] < 0x00)
	{
		struct Eq_n * r3_n;
		struct Eq_n * r4_n;
		fn1900(r3, r4, out r3_n, out r4_n);
		byte v18_n = r4_n->b0011 | 0x80;
		SEQ(0x88, v18_n)();
		r4Out = r4_n;
		return r3_n;
	}
	else
	{
		struct Eq_n * r3_n;
		struct Eq_n * r4_n;
		fn1932(r3, r4, out r3_n, out r4_n);
		r4Out = r4_n;
		return r3_n;
	}
}

// 1900: Register word16 fn1900(Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out ptr16 r3Out, Register out ptr16 r4Out)
// Called from:
//      fn1836
//      fn18BE
word16 fn1900(struct Eq_n * r3, struct Eq_n * r4, ptr16 & r3Out, ptr16 & r4Out)
{
	byte NZVC_n;
	(fp - 0x04)();
	if ((bool) NZVC_n)
	{
		ptr16 r3_n;
		ptr16 r4_n;
		word16 r2_n = fn1932(r3, r4, out r3_n, out r4_n);
		r3Out = r3_n;
		r4Out = r4_n;
		return r2_n;
	}
	else
	{
		r4->t0000 &= ~0x8002;
		cui16 v12_n = r4->t0000 & 0x4000;
		r4->t0000 = v12_n;
		if (v12_n != 0x00)
			r4[11] = (struct Eq_n) ~0x00;
		if (t0000.b002A == 0x00)
		{
			ptr16 r3_n;
			ptr16 r4_n;
			word16 r2_n = fn1932(r3, r4, out r3_n, out r4_n);
			r3Out = r3_n;
			r4Out = r4_n;
			return r2_n;
		}
		else
		{
			r3->ptr0070 = null;
			struct Eq_n * r4_n = r3->ptr0072;
			if (r4_n != null)
			{
				ptr16 r3_n;
				ptr16 r4_n;
				word16 r2_n = fn1932(r3, r4_n, out r3_n, out r4_n);
				r3Out = r3_n;
				r4Out = r4_n;
				return r2_n;
			}
			else
			{
				__syscall(35223);
				ptr16 r3_n;
				ptr16 r4_n;
				word16 r2_n = fn1932(r3, r4_n, out r3_n, out r4_n);
				r3Out = r3_n;
				r4Out = r4_n;
				return r2_n;
			}
		}
	}
}

// 1932: Register word16 fn1932(Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn18BE
//      fn1900
word16 fn1932(struct Eq_n * r3, struct Eq_n * r4, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	cui16 v4_n = r4[0x0E] & 0x08;
	r4[0x0E] = (struct Eq_n) v4_n;
	if (v4_n != 0x00)
	{
		r4[11] = (struct Eq_n) ((word16) r4[11].t0000 + 1);
		r3Out = r3;
		r4Out = r4;
		return 0x00;
	}
	else
	{
		r4->t0000 |= 0x1000;
		r3->ptr0072 = null;
		struct Eq_n * r4_n = r3->ptr0070;
		if (r4_n == null)
			__syscall(0x8998);
		struct Eq_n * sp_n = r3->ptr0064;
		sp_n->ptrFFFFFFFE = &g_t0EF4;
		sp_n->ptrFFFFFFFC = r3;
		if (r3->b0074 != 0x00)
		{
			r3->ptr0072 = null;
			r3->ptr0070 = null;
			r3->ptr0014 = null;
			r3->w000C = r3->w0058;
			r3->t00A2.u1 = 0x00;
			r3Out = sp_n->ptrFFFFFFFC;
			r4Out = r4_n;
			return r2;
		}
		else
		{
			sp_n->ptrFFFFFFFE = r4_n;
			r3->ptr0072 = null;
			r3->ptr0070 = null;
			r3->ptr0014 = null;
			r3->w000C = r3->w0058;
			r3->t00A2.u1 = 0x00;
			r3Out = sp_n->ptrFFFFFFFC;
			r4Out = r4_n;
			return r2;
		}
	}
}

// 194E: void fn194E(Register (ptr16 Eq_n) r3)
void fn194E(struct Eq_n * r3)
{
	++r3->w0012;
}

// 1966: void fn1966(Register Eq_n r0, Register (ptr16 Eq_n) r3)
// Called from:
//      fn197A
void fn1966(Eq_n r0, struct Eq_n * r3)
{
	*r3->t001C = r0;
	fn196A(r3);
}

// 196A: void fn196A(Register (ptr16 Eq_n) r3)
// Called from:
//      fn1966
void fn196A(struct Eq_n * r3)
{
	if (r3->w0018 - r3->t001C < 0x00)
		r3->t001C = (word16) r3->t001C + 1;
}

// 197A: void fn197A(Register (ptr16 Eq_n) r3)
void fn197A(struct Eq_n * r3)
{
	if (r3->t0046 - r3->t001C < 0x00)
		r3->t001C = r3->t0046;
	r3->t0046.u0 = 0x00;
	if (r3->w0056 != 0x00)
	{
		r3->ptr0060();
		r3->w0056 = 0x00;
		if (*r3->ptr0014 <= 0x00)
			r3->w0054 = 0x00;
	}
	else
	{
		fn1966(0x0D, r3);
		r3->ptr0060();
	}
}

word16 g_w1AE6 = 0x0A82; // 1AE6
Eq_n g_t1CF6 = // 1CF6
	{
		
		{
			~0x15
		},
		&g_w1AE6,
		0x87,
		4646,
		0x18,
		0x1826,
		5584,
		0x1D26,
		4646,
	};
// 1CFA: void fn1CFA()
// Called from:
//      fn1DAE
void fn1CFA()
{
}

// 1CFC: void fn1CFC()
void fn1CFC()
{
}

// 1D30: Register (ptr16 Eq_n) fn1D30(Register (ptr16 Eq_n) r0, Register (ptr16 Eq_n) r3, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn14A8
struct Eq_n * fn1D30(struct Eq_n * r0, struct Eq_n * r3, struct Eq_n & r4Out)
{
	ci16 v7_n = r0->t0000 & 0x4000;
	r0->t0000.u1 = v7_n;
	struct Eq_n * r4_n = r0;
	if (v7_n != 0x00)
	{
		ci16 v9_n = r0->t0000 & 0x02;
		r0->t0000.u1 = v9_n;
		if (v9_n == 0x00)
			goto l1D84;
		r0->t0000.u1 = r0->t0000 & ~0x02;
	}
	else
	{
		if (r0->t0000 > 0x00)
			goto l1D84;
		ci16 v15_n = r0->t0000 & 0x0200;
		r0->t0000.u1 = v15_n;
		if (v15_n != 0x00)
		{
			cui16 r2_n = r0[7];
			byte * r2_n = (word16) r0[1].t0000 + r2_n;
			ci16 v21_n = r0->t0000 & 0x2000;
			r0->t0000.u1 = v21_n;
			if (v21_n != 0x00)
				*r2_n = 0x00;
			else
				*r2_n = 0x0A;
			byte * r2_n = (word16) r0[1].t0000 + r2_n + 0x01;
			ci16 r1_n = r2_n - 0x01FF;
			if (r2_n != 0x01FF)
			{
				do
				{
					*r2_n = 0x00;
					++r2_n;
					++r1_n;
				} while (r1_n < 0x00);
			}
		}
		else
		{
			cui16 * r2_n = (word16) r0[1].w001C + 482;
			*r2_n |= 0x8000;
		}
	}
	word16 r2_n;
	fn1836(r3, r0, out r2_n, out r3, out r4_n);
l1D84:
	r4Out = r4_n;
	return r3;
}

<anonymous> * g_ptr1DAA = fn14A8; // 1DAA
// 1DAE: void fn1DAE()
void fn1DAE()
{
	<anonymous> * r0_n = g_ptr1DAA;
	if (r0_n != null)
		r0_n();
	struct Eq_n * sp_n = t0000.w0022;
	sp_n->ptrFFFFFFFE = (struct Eq_n *) &g_t1DB2;
	FnSubfn(&g_b0592);
	struct Eq_n * r5_n = t0000.w0028;
	sp_n->ptrFFFFFFFC = r5_n;
	sp_n->ptrFFFFFFFA = 0x00;
	sp_n->wFFFFFFF8 = 0x1000;
	sp_n->ptrFFFFFFFA = sp_n - 0x18;
	FnSubfn(sp_n - 0x08);
	word16 r4_n = sp_n->wFFFFFFEA;
	if (g_ptr1DAA == null)
	{
		FnSubfn(&g_b03B8);
		if (false)
			t0000.w001E = 0xF000;
		if (true)
		{
			t0000.w0026 = 0x0200;
			if (g_w53EA != 0x00)
			{
				if (sp_n->wFFFFFFE8 != 0x00)
					PRINT(&g_b0380);
				else
				{
					FnSubfn(&g_b03BC);
					t0000.w0026 = 0x00;
					r4_n = 0x03BC;
				}
			}
		}
	}
	SETTOP(r4_n - 0x02);
	struct Eq_n * r4_n = t0000.w0028;
	if (r5_n + 1 - r4_n > 0x00)
	{
		g_ptr5426 = r4_n - 0xB2;
		cui16 r4_n = r4_n - 0xB2 - g_w53E8 & ~0x01;
		sp_n->wFFFFFFE6 = r4_n;
		cui16 r2_n = g_w53EC;
		if (r2_n == 0x00)
			goto l0372;
		cui16 r4_n = r4_n - r2_n;
		sp_n->wFFFFFFE4 = r4_n;
		cu16 r4_n = r4_n & ~0x01;
		do
		{
			r4_n -= 0x20;
			--r2_n;
		} while (r2_n != 0x00);
		sp_n->wFFFFFFE2 = r4_n;
		sp_n->wFFFFFFE0 = r4_n - 0x38;
		if (r5_n + 1 - (r4_n - 0x38) > 0x00)
		{
			struct Eq_n * r2_n = r4_n;
			do
			{
				r2_n -= 0x02;
				r2_n->w0000 = 0x00;
			} while (r4_n - 0x38 - r2_n > 0x00);
			r4_n->tFFFFFFC2.u1 = 0x00;
			r4_n->tFFFFFFC3.u1 = 0x00;
			r4_n->wFFFFFF56 = sp_n->wFFFFFFE0;
			r4_n->wFFFFFF54 = sp_n->wFFFFFFE2;
			r4_n->wFFFFFF52 = sp_n->wFFFFFFE4;
			r4_n->wFFFFFF50 = sp_n->wFFFFFFE6;
			r4_n->wFFFFFFC4 = sp_n->wFFFFFFEA;
			r4_n->wFFFFFFC6 = sp_n->wFFFFFFEC;
			r4_n->wFFFFFF58 = r4_n - 0x38;
			r4_n->wFFFFFF5A = r5_n + 1;
			if (r5_n + 1 - (r4_n - 0x38) > 0x00)
			{
				if (g_ptr1DAA != null)
				{
					FnSubfn(&g_b03B8);
					if (false && (g_w53EA - sp_n->wFFFFFFE8 >= 0x00 && (t0000.w0022 + 0x1000) - (r4_n - 0x38) <= 0x00))
						goto l0372;
				}
				r4_n->wFFFFFF5E = 0x8000;
				r4_n->ptrFFFFFF9E = r4_n - 0xB2;
				r4_n->ptrFFFFFF9E += 0x22;
				r4_n->ptrFFFFFFB8 = sp_n->ptrFFFFFFFC;
				struct Eq_n * v54_n = sp_n->ptrFFFFFFFE;
				r4_n->ptrFFFFFFB6 = v54_n;
				struct Eq_n * v55_n = v54_n->ptr0000;
				r4_n->wFFFFFFCA = v55_n->w0000;
				r4_n->wFFFFFFC8 = v55_n->w0002;
				t0000.w0020 = 0x0202;
				t0000.w0024 |= 0x2000;
				fn1CFA();
				if (r4_n->tFFFFFFC3 == 0x00)
				{
					sp_n->ptrFFFFFFFE = &g_t1396;
					v54_n->ptr0002();
					return;
				}
				else
				{
					v54_n->ptr0002();
					return;
				}
			}
		}
	}
l0372:
	PRINT(&g_b0397);
	t0000.b002B |= 0x08;
	EXIT(&g_b0397);
}

struct Eq_n g_t1DB2 = // 1DB2
	{
		&g_t47FE,
		&g_t15FF,
	};
Eq_n g_t1DC0 = // 1DC0
	{
		0x15,
	};
Eq_n g_t1DC3 = // 1DC3
	{
		
		{
			0x0A
		},
		&g_w3736,
		44042,
		14134,
		244,
		14134,
		0xEE0A,
		~0x40C9,
		0x440A,
	};
word16 g_w1DC4 = 0x3660; // 1DC4
Eq_n g_t1DF1 = // 1DF1
	{
		&g_tFFFFBC15,
		&g_tFFFFF748,
	};
char g_str1DF7[] = "6\xE6\x15\xA4H\xE6\x15\x10H\xF7\t\xC4\xEF\xE6\x15xX\xF7\t\xD6\xEC\xF7\t\x98\xF0\xBF\n\x126\xE6\x15\xA4H\xE6\x15\x13H\xF7\t\xA8\xEF\xE6\x15\x9EH\xE6\x15zX\xF7\t\x18\xED\xF7\tx\xF0\xFF\x15\x18"; // 1DF7
Eq_n g_t1EB6 = // 1EB6
	{
		<code>,
		&g_str0024,
		&g_t356A,
		0x1DC1,
		13848,
		&g_t6541,
		0x0CC1,
		&g_t15F1,
		
		{
			0x01
		},
		22722,
		&g_t0ABF,
		&g_str3608,
		&g_t0004,
		&g_t5A3E,
		&g_t07DD,
		&g_t07CF,
		0x0ABF,
		0x0A,
		0x351A,
		18618,
		2551,
		
		{
			0x0000211C
		},
		0x0ABF,
		&g_t0001,
		0x35BA,
		&g_t5464,
		&g_t15FF,
		&g_t002C,
		~0x05,
		&g_t002D,
		&g_t34F0,
		
		{
			0x000048E4
		},
		2551,
	};
Eq_n g_t1EF0 = // 1EF0
	{
		<code>,
		&g_str35E6,
		&g_t2DD7,
		0x35E2,
		0x0A,
		&g_t07DD,
		0x0AB7,
		&g_t35D8,
		
		{
			~0x28
		},
		0x35D4,
		&g_t0005,
		&g_str351A,
		&g_t15C5,
		&g_t0001,
		&g_t34F0,
		&g_t48D0,
		2551,
		0x09,
		0x22EA,
		13532,
		0x15C5,
		
		{
			0x000048DA
		},
		2551,
		&g_t34D0,
		0x15C5,
		&g_t0ABF,
		&g_t34C4,
		&g_t15C5,
		~0x11,
		&g_t34B8,
		&g_t15E6,
		
		{
			2551
		},
		8858,
	};
<anonymous> g_t1F0A = <code>; // 1F0A
Eq_n g_t1F6E = // 1F6E
	{
		
		{
			~0x19
		},
		&g_w4898,
		5606,
		0xF026,
		0x15,
		60252,
		2551,
		~0x10E1,
		0x0ABF,
	};
Eq_n g_t1F7C = // 1F7C
	{
		&g_t54DC,
		&g_t09F7,
	};
word16 g_w1FE6 = 0x15FF; // 1FE6
Eq_n g_t2000 = // 2000
	{
		&g_t0ABF,
	};
Eq_n g_t2020 = // 2020
	{
		<code>,
		&g_str3402,
		&g_t0A15,
		0x15FF,
		66,
		&g_t33FA,
		0x0AC4,
		&g_t06F7,
		
		{
			191
		},
		0x33F2,
		&g_t15F7,
		&g_t15F7,
		&g_t0002,
		&g_t348C,
		&g_t15FF,
		&g_t3448,
		0x0CC0,
		0x0C,
		0x0BF0,
		0x0202,
		0x77,
		
		{
			620
		},
		0x15FF,
		&g_t0AB7,
		0x343C,
		&g_t3452,
		&g_t345A,
		&g_t6DF7,
		0x5E,
		&g_t1DC0,
		&g_t3444,
		
		{
			13334
		},
		0x6FC1,
	};
<anonymous> g_t2021 = <code>; // 2021
Eq_n g_t2037 = // 2037
	{
		0
	};
Eq_n g_t203E = // 203E
	{
		13494
	};
Eq_n g_t2061 = // 2061
	{
		200,
	};
Eq_n g_t2072 = // 2072
	{
		<code>,
		&g_str0BF0,
		&g_t58C2,
		0x0202,
		0x77,
		&g_t026C,
		0x15FF,
		&g_t0047,
		
		{
			0xA2
		},
		0x0AB7,
		&g_t343C,
		&g_str1DF7,
		&g_t3452,
		&g_t1DC0,
		&g_t1037,
		&g_t3416,
		0x6FC1,
		111,
		0x33F2,
		7616,
		13342,
		
		{
			4145
		},
		22822,
		&g_t1DF1,
		13332,
		&g_t2037,
		&g_t3404,
		&g_t0704,
		191,
		&g_t15FF,
		&g_t0050,
		
		{
			0x0704
		},
		0x0ABF,
	};
Eq_n g_t215C = // 215C
	{
		0x09,
	};
Eq_n g_t2254 = // 2254
	{
		
		{
			110
		},
		&g_w0ABF,
		0x31CC,
		0x0ABF,
		0x31,
		2551,
		0x18CE,
		0x0ABF,
		12724,
	};
Eq_n g_t228C = // 228C
	{
		<code>,
		&g_str48BA,
		&g_t09F7,
		0x1B7E,
		0x0ABF,
		&g_t318E,
		0x010D,
		&g_t15FF,
		
		{
			118
		},
		0x3186,
		&g_t15C5,
		&g_str16B4,
		&g_t0ABF,
		&g_t0078,
		fn3220,
		&g_t09F7,
		0x0B40,
		11,
		0x0ABF,
		7671,
		12772,
		
		{
			12778
		},
		0x15FF,
		&g_t65F7,
		0x02,
		&g_t31F8,
		&g_t65F7,
		&g_t0002,
		~0x45,
		&g_t0077,
		&g_tFFFFFD58,
		
		{
			0x0ABF
		},
		0x30F4,
	};
Eq_n g_t22B6 = // 22B6
	{
		
		{
			0x78
		},
		&g_w316C,
		0x0ABF,
		0x0312,
		0x15,
		0x15F7,
		0x03,
		0x3220,
		60919,
	};
Eq_n g_t241E = // 241E
	{
		
		{
			0xC0
		},
		0x30A2,
		0x0202,
	};
// 243A: void fn243A(Register (ptr16 word16) r5)
void fn243A(word16 * r5)
{
	fn0EF8(&g_t243E, r5);
}

struct Eq_n g_t243E = // 243E
	{
		&g_t4968,
		&g_t15FF,
	};
Eq_n g_t2600 = // 2600
	{
		
		{
			0x77
		},
		&g_w0446,
		0x15FF,
		0x7217,
		0x00,
		0x1002,
		0x0ABF,
		0x2E0A,
		12247,
	};
Eq_n g_t2602 = // 2602
	{
		
		{
			0x46
		},
		0x15FF,
		0x29,
	};
Eq_n g_t260A = // 260A
	{
		-0x007F
	};
// 2B90: void fn2B90(Register (ptr16 word16) r5)
void fn2B90(word16 * r5)
{
	fn0EF8(&g_t2B94, r5);
}

struct Eq_n g_t2B94 = // 2B94
	{
		&g_t4DAA,
		&g_t15FF,
	};
// 2B96: void fn2B96(Register (ptr16 Eq_n) pc)
// Called from:
//      fn0EF8
void fn2B96(struct Eq_n * pc)
{
	*g_ptr5426 = 0x05;
	fn457C();
	++*g_ptr5426;
	fn4030();
	++*g_ptr5426;
	g_ptr56B8 = (struct Eq_n *) ((char *) &t0000.w0000 + 1);
	ci16 r4_n;
	byte * r5_n = g_a5898;
	for (r4_n = 0x1E; r4_n > 0x00; --r4_n)
	{
		*g_ptr5426 = 0x08;
		*r5_n = 0x20;
		*g_ptr5426 = 0x09;
		++r5_n;
	}
	++*g_ptr5426;
	fn413C();
	++*g_ptr5426;
	word16 r0_n = fn4072();
	++*g_ptr5426;
	word16 r3_n;
	word16 r0_n = fn0D7A(r0_n, wLoc06, 19942, &g_t5006, out r3_n);
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	fn0EA8(sp_n->ptrFFFFFFFE);
	++*g_ptr5426;
	sp_n->ptrFFFFFFFE = &g_t5006;
	sp_n->wFFFFFFFC = 20242;
	word16 r3_n;
	fn0D7A(r0_n, sp_n->wFFFFFFFA, sp_n->wFFFFFFFC, sp_n->ptrFFFFFFFE, out r3_n);
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	fn0EA8(sp_n->ptrFFFFFFFE);
	++*g_ptr5426;
	fn413C();
	++*g_ptr5426;
	word16 r0_n = fn4072();
	++*g_ptr5426;
	sp_n->ptrFFFFFFFE = &g_t5006;
	sp_n->wFFFFFFFC = 0x4FA0;
	word16 r3_n;
	fn0D7A(r0_n, sp_n->wFFFFFFFA, sp_n->wFFFFFFFC, sp_n->ptrFFFFFFFE, out r3_n);
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	fn0EA8(sp_n->ptrFFFFFFFE);
	++*g_ptr5426;
	word16 r0_n = fn4072();
	++*g_ptr5426;
	sp_n->ptrFFFFFFFE = &g_t5006;
	sp_n->wFFFFFFFC = 0x4FBD;
	word16 r3_n;
	fn0D7A(r0_n, sp_n->wFFFFFFFA, sp_n->wFFFFFFFC, sp_n->ptrFFFFFFFE, out r3_n);
	fn0EA8(&g_t5006);
	++*g_ptr5426;
	g_ptr56BA = (struct Eq_n *) ((char *) &t0000.w0000 + 1);
	++*g_ptr5426;
	g_w56BC = 0x02;
	++*g_ptr5426;
	g_w56BE = 0x01;
	++*g_ptr5426;
	g_w56C0 = 0x0A;
	while (true)
	{
		*g_ptr5426 = 0x17;
		if (g_w56BC > 0x00)
		{
			++*g_ptr5426;
			fn4230();
		}
		*g_ptr5426 = 0x19;
		if (g_w56BC < 0x00)
		{
			++*g_ptr5426;
			fn4230();
		}
		*g_ptr5426 = 0x1B;
		if (g_w56BC > 0x00)
		{
			++*g_ptr5426;
			fn4230();
		}
		*g_ptr5426 = 0x1D;
		if (g_w56BC < 0x00)
		{
			++*g_ptr5426;
			fn4230();
		}
		*g_ptr5426 = 0x1F;
		fn413C();
		++*g_ptr5426;
		if (g_w56BC > 0x00)
		{
			++*g_ptr5426;
			fn4230();
		}
		*g_ptr5426 = 0x22;
		if (g_w56BC < 0x00)
		{
			++*g_ptr5426;
			fn4230();
		}
		*g_ptr5426 = 0x24;
		fn413C();
		++*g_ptr5426;
		Eq_n r1_n = (int16) fn5A90();
		g_t56B6 = r1_n;
		*g_ptr5426 = 0x26;
		if (r1_n == 0x0D)
			break;
		*g_ptr5426 = 0x28;
		if (r1_n <= 0x20)
		{
			*g_ptr5426 = 0x2A;
			if (r1_n != 0x7F)
			{
				*g_ptr5426 = 44;
				struct Eq_n * r2_n = g_ptr56B8;
				if (r2_n != (char *) (&t0000.w001E) + 1)
				{
					*g_ptr5426 = 0x2E;
					r2_n->t5897 = r1_n;
					++*g_ptr5426;
					g_ptr56BA = r2_n;
					g_ptr56BA = (struct Eq_n *) ((char *) g_ptr56B8 + 1);
					++*g_ptr5426;
				}
			}
			else
			{
				*g_ptr5426 = 0x31;
				g_ptr56BA = g_ptr56B8 - 0x01;
				++*g_ptr5426;
				if (g_ptr56B8 <= null)
				{
					++*g_ptr5426;
					g_ptr56BA = (struct Eq_n *) ((char *) &t0000.w0000 + 1);
				}
				*g_ptr5426 = 0x34;
				g_ptr56B8->t5897.u0 = 0x20;
			}
		}
		*g_ptr5426 = 0x35;
		fn4230();
		++*g_ptr5426;
		g_w56BE = -g_w56BC;
		++*g_ptr5426;
		pc->w28DC = g_ptr56BA + pc->w28DC /16 0x00005899;
		++*g_ptr5426;
		if (g_w56BE < 0x3C)
		{
			++*g_ptr5426;
			g_w56BC = -g_ptr56BA;
		}
		*g_ptr5426 = 0x3A;
		if (g_w56BE > 0x08)
		{
			++*g_ptr5426;
			g_w56BC = -g_ptr56BA;
		}
		*g_ptr5426 = 0x3C;
	}
	*g_ptr5426 = 0x3D;
}

Eq_n g_t2DD7 = // 2DD7
	{
		55,
		11,
	};
// 2E20: void fn2E20(Register (ptr16 word16) r5)
void fn2E20(word16 * r5)
{
	fn0EF8(&g_t2E24, r5);
}

struct Eq_n g_t2E24 = // 2E24
	{
		&g_t507E,
		&g_t15FF,
	};
// 2EC4: void fn2EC4(Register (ptr16 word16) r5)
void fn2EC4(word16 * r5)
{
	fn0EF8(&g_t2EC8, r5);
}

struct Eq_n g_t2EC8 = // 2EC8
	{
		&g_t50B2,
		&g_t15FF,
	};
word16 g_w316C = 0x44; // 316C
Eq_n g_t318E = // 318E
	{
		
		{
			0xC0
		},
		0x04,
		0x2040,
	};
Eq_n g_t31F8 = // 31F8
	{
		-9
	};
// 3220: void fn3220(Register (ptr16 word16) r5)
void fn3220(word16 * r5)
{
	fn0EF8(&g_t3224, r5);
}

struct Eq_n g_t3224 = // 3224
	{
		&g_t512C,
		&g_t15FF,
	};
Eq_n g_t3300 = // 3300
	{
		
		{
			0xC0
		},
		0x2402,
		0x0CC0,
	};
Eq_n g_t33FA = // 33FA
	{
		
		{
			~0x08
		},
		0x24C2,
		8984,
	};
char g_str3402[] = "\x14#\xC5\x15jQ\xF7\t$\x0E\xBF\n\x16 ?\n\xF6\"\xBF\n\x0E ?\n\xF0\"\xBF\n\x06 ?\n\xE4\"\xBF\n\xFE\x1F7\n\x94$\xBF\n\xF6\x1F7\n\x8E$\xBF\n\xEE\x1F\x12\x01\xFF\x15:"; // 3402
Eq_n g_t3404 = // 3404
	{
		
		{
			0xC5
		},
		&g_w516A,
		2551,
		0x22F6,
		0x0A,
		0x22F0,
		0x0ABF,
		0x2006,
		2623,
	};
Eq_n g_t3416 = // 3416
	{
		
		{
			0x0E
		},
		2623,
		0x22F0,
	};
Eq_n g_t343C = // 343C
	{
		
		{
			0x3A
		},
		&g_w1FE6,
		0x65F7,
		0x22BE,
		101,
		0x0AB7,
		0x22BA,
		0x2DD7,
		8886,
	};
Eq_n g_t3444 = // 3444
	{
		<code>,
		&g_str65F7,
		&g_t0002,
		0x22BE,
		0x65F7,
		&g_t0002,
		0x22BA,
		&g_t0AB7,
		
		{
			~0x45
		},
		0x2DD7,
		&g_t22B6,
		&g_str15FF,
		&g_t003B,
		&g_t003D,
		&g_t09F7,
		&g_t09F7,
		0xDA10,
		~0x25,
		0x0ABF,
		0x15C5,
		20852,
		
		{
			2551
		},
		0x0D8C,
		&g_t1F7C,
		0x87,
		&g_str15FF,
		&g_t000B,
		&g_t1F6E,
		~0x08,
		&g_t000A,
		&g_t228C,
		
		{
			0x0000223C
		},
		0x0CC0,
	};
Eq_n g_t3448 = // 3448
	{
		
		{
			0x02
		},
		0x22BE,
		0x65F7,
	};
Eq_n g_t3452 = // 3452
	{
		-73
	};
Eq_n g_t345A = // 345A
	{
		
		{
			0x0A
		},
		&g_w07A7,
		0x15FF,
		9228,
		0x03,
		8116,
		0x1DFF,
		0x2400,
		8838,
	};
<anonymous> g_t348C = <code>; // 348C
// 34AC: void fn34AC(Register (ptr16 word16) r5)
void fn34AC(word16 * r5)
{
	fn0EF8(&g_t34B0, r5);
}

struct Eq_n g_t34B0 = // 34B0
	{
		&g_t517E,
		&g_t15FF,
	};
Eq_n g_t34B8 = // 34B8
	{
		0x10,
	};
Eq_n g_t34C4 = // 34C4
	{
		
		{
			~0x08
		},
		&g_w5A2C,
		0x2258,
		0x0C,
		0x1F,
		0x1077,
		8788,
		0x0ABF,
		0x1F44,
	};
Eq_n g_t34D0 = // 34D0
	{
		&g_t518E,
		&g_t2254,
	};
Eq_n g_t34F0 = // 34F0
	{
		<code>,
		&g_str011C,
		&g_t15FF,
		0x0F,
		0x1F2C,
		&g_t0A37,
		0x2236,
		&g_t0ABF,
		
		{
			0x24
		},
		0x15F7,
		&g_t0001,
		&g_str5A18,
		&g_t15FF,
		&g_t1F0A,
		&g_t0AB7,
		&g_t0ABF,
		0x1EE2,
		0x1E,
		3063,
		0x0363,
		0x15FF,
		
		{
			25
		},
		0x1ED6,
		&g_t09F7,
		~0x260F,
		&g_t6666,
		&g_t15E6,
		&g_t4066,
		~0x08,
		&g_t001B,
		&g_t1EB6,
		
		{
			3
		},
		0x0705,
	};
char g_str351A[] = "\n\x1F\xF7\v\x14\"\x06\x02\xFF\x15\x15"; // 351A
Eq_n g_t356A = // 356A
	{
		0x05,
		~0x00,
	};
Eq_n g_t35D8 = // 35D8
	{
		&g_t215C,
	};
char g_str35E6[] = "<!\xC2\f\xC0\x1DJ!\x80l&Y\xC3\x1D>!\xC3\f3\x10\xEEY\xBF\n&\x1E\xB3\x1C\x8AY\x02Z\xBF\n\x1C\x1E\xF3\x15\xFF\xFF\x16Z\xFF\x15%"; // 35E6
char g_str3608[] = "\x1C\x1E\xF3\x15\xFF\xFF\x16Z\xFF\x15%"; // 3608
word16 g_w3736 = 0x200A; // 3736
// 395C: void fn395C(Register (ptr16 word16) r5)
void fn395C(word16 * r5)
{
	fn0EF8(&g_t3960, r5);
}

struct Eq_n g_t3960 = // 3960
	{
		&g_t51DC,
		&g_t15FF,
	};
// 3B3C: void fn3B3C(Register (ptr16 word16) r5)
void fn3B3C(word16 * r5)
{
	fn0EF8(&g_t3B40, r5);
}

struct Eq_n g_t3B40 = // 3B40
	{
		&g_t526E,
		&g_t15FF,
	};
char g_str3C3E[] = "J\x1B\x02\x02w"; // 3C3E
// 3E12: void fn3E12(Register (ptr16 word16) r5)
void fn3E12(word16 * r5)
{
	fn0EF8(&g_t3E16, r5);
}

struct Eq_n g_t3E16 = // 3E16
	{
		&g_t52E2,
		&g_t15FF,
	};
// 3F42: void fn3F42(Register (ptr16 word16) r5)
void fn3F42(word16 * r5)
{
	fn0EF8(&g_t3F46, r5);
}

struct Eq_n g_t3F46 = // 3F46
	{
		&g_t530A,
		&g_t15FF,
	};
// 4030: void fn4030()
// Called from:
//      fn2B96
void fn4030()
{
	fn0EF8(&g_t4034, r5);
}

struct Eq_n g_t4034 = // 4034
	{
		&g_t5330,
		&g_t15FF,
	};
Eq_n g_t4066 = // 4066
	{
		
		{
			0x3E
		},
		&g_w09F7,
		1224,
		52866,
		0x53,
		0x13A8,
		0x1FF7,
		0x1756,
		0x175C,
	};
// 4072: Register (ptr16 Eq_n) fn4072()
// Called from:
//      fn2B96
struct Eq_n * fn4072()
{
	fn0EF8(&g_t4076, r5);
	return (struct Eq_n *) <invalid>;
}

struct Eq_n g_t4076 = // 4076
	{
		&g_t5344,
		&g_t15FF,
	};
Eq_n g_t40C2 = // 40C2
	{
		&g_t1360,
	};
// 413C: void fn413C()
// Called from:
//      fn2B96
void fn413C()
{
	fn0EF8(&g_t4140, r5);
}

struct Eq_n g_t4140 = // 4140
	{
		&g_t5354,
		&g_t15FF,
	};
// 4180: void fn4180(Register (ptr16 word16) r5)
void fn4180(word16 * r5)
{
	fn0EF8(&g_t4184, r5);
}

struct Eq_n g_t4184 = // 4184
	{
		&g_t5368,
		&g_t15FF,
	};
// 4230: void fn4230()
// Called from:
//      fn2B96
void fn4230()
{
	fn0EF8(&g_t4234, r5);
}

struct Eq_n g_t4234 = // 4234
	{
		&g_t537A,
		&g_t15FF,
	};
// 4534: void fn4534(Register (ptr16 word16) r5)
void fn4534(word16 * r5)
{
	fn0EF8(&g_t4538, r5);
}

struct Eq_n g_t4538 = // 4538
	{
		&g_t53B0,
		&g_t15FF,
	};
// 457C: void fn457C()
// Called from:
//      fn2B96
void fn457C()
{
	fn0EF8(&g_t4580, r5);
}

struct Eq_n g_t4580 = // 4580
	{
		&g_t53C0,
		&g_t15FF,
	};
// 45C8: void fn45C8(Register (ptr16 word16) r5)
void fn45C8(word16 * r5)
{
	fn0EF8(&g_t45CC, r5);
}

struct Eq_n g_t45CC = // 45CC
	{
		&g_t53D8,
		&g_t15FF,
	};
// 45F6: void fn45F6(Register (ptr16 Eq_n) r0, Register Eq_n r2, Register (ptr16 Eq_n) r3)
// Called from:
//      fn145E
void fn45F6(struct Eq_n * r0, Eq_n r2, struct Eq_n * r3)
{
	ui16 r4_n = 0x00;
	r2_n = r2;
	while (true)
	{
		Eq_n r2_n;
		r2_n -= 0x0A;
		if (r2_n < 0x00)
			break;
		++r4_n;
	}
	word16 r2_n = (word16) r2_n + 0x0A;
	if (r4_n == 0x00)
	{
l4614:
		r4_n += r2_n;
		r2_n = 65506;
	}
	ui16 r4_n = r4_n + 0x1E;
	r4_n = r4_n * 0x28;
	if (r4_n * 0x28 <= 0x00)
	{
		ui16 r2_n = r0->w0006;
		if (r2_n == 0x00)
		{
			r0->w0006 = r4_n * 0x28;
			struct Eq_n * r1_n = &g_t47E4;
			while (r1_n->w0000 != 0x00 && r2 - r1_n->w0000 != 0x00)
				++r1_n;
			r2_n = r1_n->wFFFFFFFE;
			r0->w0008 = 10414;
			r0->w000A = r4_n * 0x28;
			r0->w000C = 6460;
		}
		if (r0->w0000 >= 0x00)
			r0->w0000 |= 0x0100;
		Eq_n r0_n = r3->t0010;
		Eq_n r1_n = 0x00;
		bool C_n = false;
		r0_n = r0_n;
		do
		{
			Eq_n r0_n;
			r1_n = (word16) r1_n + 1;
			if (OVERFLOW(r1_n))
			{
				__syscall(~0x7660);
				__syscall(0x899B);
				__syscall(0x899C);
				__syscall(0x899D);
				r3->t0010 = r0_n;
				*((word16) r1_n + 0x0000FFFA) |= 0x80;
				((word16) r1_n + 0x0A)->u0 = 0x00;
				r0->w0018 = 0x00;
				ci16 v53_n = r0->w0000 & 0x18;
				r0->w0000 = v53_n;
				if (v53_n != 0x00)
				{
					ci16 v54_n = r0->w0000 & 0x10;
					r0->w0000 = v54_n;
					if (v54_n != 0x00)
						goto l473C;
				}
				else
				{
					ci16 v55_n = r0->w0000 & 0x0480;
					r0->w0000 = v55_n;
					if (v55_n != 0x00)
					{
l473C:
						r0->w0000 |= 0x20;
					}
				}
				r0->w0000 |= 0x0800;
				return;
			}
			r0_n = __rcr(r0_n, 1, C_n);
			C_n = (r0_n & 0x01) != 0x00;
			r0_n = r0_n;
		} while ((r0_n & 0x01) != 0x00);
		r0->t0011 = r1_n;
		--r0->t0011;
		bool C_n = true;
		do
		{
			r0_n = __rcl(r0_n, 1, C_n);
			C_n = (r0_n & 0x8000) != 0x00;
			--r1_n;
		} while (r1_n != 0x00);
		r3->t0010 = r0_n;
		fn13FE();
		struct Eq_n * r4_n = r3->ptr0050;
		cup16 r5_n = t0000.w0026;
		if (r5_n != 0x00 && r5_n < 0xC8B2)
		{
			word16 * r5_n = &g_w47E0;
			if (t0000.w0026 > 0x47E0)
			{
				word16 * sp_n = fp - 0x0E;
				do
				{
					r5_n -= 0x02;
					sp_n -= 0x02;
					*sp_n = *r5_n;
				} while (r5_n < g_a474C);
			}
		}
		// This indirect jump appears to use the range [-1,1], which Reko can't deduce. This is a typical place where a user annotation (indicating the range of valid values) would help.
	}
	goto l4614;
}

// 474C: Register (ptr16 Eq_n) fn474C(Register (ptr16 Eq_n) r1, Register ui16 r2, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4)
// Called from:
//      fn45F6
struct Eq_n * fn474C(struct Eq_n * r1, ui16 r2, struct Eq_n * r3, struct Eq_n * r4)
{
	LOCK();
	ptr16 sp_n = fp - 0x02;
	ptr16 r0_n = r3->ptr0008;
	if (r0_n != 0x00)
	{
		QSET(r0_n, 0x04);
		r3->ptr0008 = 0x00;
		sp_n = fp - 0x04;
	}
	struct Eq_n * sp_n = sp_n - 0x02;
	sp_n->ptr0000 = r4;
	if (!DSTAT(sp_n->ptr0000, r1))
	{
		r1->w0000 = r2;
		sp_n->ptrFFFFFFFE = r4;
		sp_n -= 0x02;
		if (DSTAT(sp_n->ptrFFFFFFFE, r1))
			goto l47DC;
	}
	if (r4->t0000 != 0x04)
	{
		word16 v17_n = r4->w0002;
		if (r4->w0004 == 0x00)
		{
			r3->ptr000A -= v17_n;
			if (r3->w000C - r3->ptr000A <= 0x00)
			{
l47D8:
				sp_n->ptr0000 = (struct Eq_n *) ((char *) &sp_n->ptr0000->t0000 + 1);
l47DA:
				sp_n->ptr0000 = (struct Eq_n *) ((char *) &sp_n->ptr0000->t0000 + 1);
l47DC:
				UNLOCK();
				return null;
			}
			sp_n -= 0x02;
			sp_n->ptr0000 = r3->ptr000A;
			word16 r0_n;
			if (FETCH(sp_n->ptr0000, r1, out r0_n))
				goto l47DC;
		}
		while (true)
		{
			struct Eq_n * sp_n = sp_n - 0x02;
			sp_n->w0000 = 0x00;
			cui16 v27_n = r1->wFFFA & 0x0100;
			r1->wFFFA = v27_n;
			cui16 r0_n = 0x0100;
			if (v27_n == 0x00)
			{
				sp_n->wFFFFFFFE = r1->w0012;
				sp_n -= 0x02;
				r0_n = 0x0200;
			}
			struct Eq_n * sp_n = sp_n - 0x02;
			sp_n->ptr0000 = r1;
			sp_n->wFFFFFFFE = r0_n | r1->t000B;
			FnSubfn(sp_n - 0x02);
			if (Test(UGE,false))
				break;
			cui16 v32_n = r1->w0016 & 0x04;
			r1->w0016 = v32_n;
			if (v32_n == 0x00)
				goto l47DA;
			r1->wFFFA &= ~0x0100;
			r1->w0016 &= ~0x04;
		}
		sp_n->ptr0000 = (struct Eq_n *) ((char *) &sp_n->ptr0000->t0000 + 1);
	}
	sp_n->ptr0000 = (struct Eq_n *) ((char *) &sp_n->ptr0000->t0000 + 1);
	goto l47D8;
}

word16 g_w47E0 = 0x87; // 47E0
Eq_n g_a47E2[] = // 47E2
	{
	};
struct Eq_n g_t47E4 = // 47E4
	{
		0x8020,
		0x05,
	};
Eq_n g_t47FE = // 47FE
	{
		0xB109,
		14988,
	};
word16 g_w4898 = 0x05; // 4898
char g_str48BA[] = ""; // 48BA
Eq_n g_t48D0 = // 48D0
	{
		
		{
			0x04
		},
		0x48A8,
		0x48A8,
	};
Eq_n g_t4968 = // 4968
	{
		0x4B,
		0x01,
		&g_w5506,
	};
Eq_n g_t4DAA = // 4DAA
	{
		0x3A,
		0x00,
		&g_w56B2,
	};
Eq_n g_t4DBC = // 4DBC
	{
		<code>,
		&g_str3C3E,
		&g_t2020,
		0x2000,
		0x2020,
		&g_t7B7D,
		0x2020,
		&g_t2000,
		
		{
			0x20
		},
		32123,
		&g_t2020,
		&g_str613C,
		&g_t203E,
		&g_t18A6,
		&g_t6120,
		&g_t2020,
		0x2020,
		0x20,
		0x6120,
		0x6120,
		0x2020,
		
		{
			8289
		},
		8289,
		&g_t6120,
		0x6120,
		&g_t6161,
		&g_t2020,
		&g_t6161,
		0x61,
		&g_t2061,
		&g_t2061,
		
		{
			-23032
		},
		40472,
	};
char g_str5004[] = "\x01"; // 5004
Eq_n g_t5006 = // 5006
	{
		<code>,
		&g_str0006,
		&g_t0007,
		0x1E,
		0x00,
		&g_t0016,
		0x14,
		&g_t0003,
		
		{
			0x0A
		},
		0x08,
		&g_t002F,
		&g_str5004,
		&g_t0002,
		&g_t5014,
		&g_t4DBC,
		&g_t0004,
		22208,
		0x56,
		0x5018,
		19916,
		0x04,
		
		{
			22208
		},
		0x5008,
		&g_t0004,
		22208,
		&g_t0004,
		&g_t501A,
		&g_t5014,
		0x0C,
		&g_t0001,
		&g_t56C4,
		
		{
			20628
		},
		0x5090,
	};
<anonymous> g_t5014 = <code>; // 5014
Eq_n g_t501A = // 501A
	{
		
		{
			0x2F
		},
		null,
		0x01,
		0x01,
		0x50,
		20500,
		0x02,
		0x5006,
		0x5004,
	};
Eq_n g_t507E = // 507E
	{
		0x12,
		0x01,
		&g_w56C4,
	};
Eq_n g_t50B2 = // 50B2
	{
		0x0C,
		0x00,
		&g_w56DE,
	};
Eq_n g_t512C = // 512C
	{
		0x46,
		0x01,
		&g_w56FE,
	};
word16 g_w516A = 0x04; // 516A
Eq_n g_t517E = // 517E
	{
		0x0E,
		0x02,
		&g_w571E,
	};
Eq_n g_t518E = // 518E
	{
		<code>,
		&g_str0005,
		&g_t000A,
		0x0F,
		0x14,
		&g_t0019,
		0x1E,
		&g_t0023,
		
		{
			0x28
		},
		0x2D,
		null,
		null,
		&g_t4066,
		&g_t0004,
		&g_t51A8,
		fn1900,
		0x00,
		0x00,
		22362,
		0x20,
		0x20,
		
		{
			32
		},
		0x20,
		&g_t002A,
		0x2A,
		&g_t0E06,
		null,
		&g_str0005,
		0x0A,
		&g_t0004,
		&g_t5766,
		
		{
			20970
		},
		0x04,
	};
Eq_n g_t51A6 = // 51A6
	{
		1
	};
Eq_n g_t51A8 = // 51A8
	{
		<code>,
		&g_str4066,
		&g_t6666,
		0x02,
		22710,
		&g_t58B8,
		0x01,
		&g_t574A,
		
		{
			0x04
		},
		22330,
		&g_t573C,
		&g_str0001,
		&g_t51A6,
		&g_t51A8,
		&g_t0020,
		&g_t241E,
		0x0110,
		0x01,
		0x0E06,
		0x05,
		0x0A,
		
		{
			0x0F
		},
		0x01,
		&g_t5766,
		22372,
		&g_t58BA,
		&g_t5768,
		&g_t5206,
		~0x19,
		&g_t5206,
		&g_t51E8,
		
		{
			0x00005776
		},
		0x5206,
	};
Eq_n g_t51DC = // 51DC
	{
		0x19,
		0x00,
		&g_w575A,
	};
<anonymous> g_t51E4 = <code>; // 51E4
Eq_n g_t51E8 = // 51E8
	{
		<code>,
		&g_str0020,
		&g_str0020,
		0x2A,
		0x2A,
		&g_t002A,
		0x2A,
		&g_t002A,
		
		{
			0x1E
		},
		0x0110,
		&g_t0E06,
		&g_str000A,
		&g_t000F,
		&g_t51E4,
		&g_t5206,
		&g_t5206,
		20972,
		0x51,
		0x04,
		0x5772,
		0x5206,
		
		{
			0x000051EE
		},
		0x04,
		&g_t5206,
		0x51F0,
		&g_t5206,
		&g_t51F2,
		&g_t0004,
		0x7C,
		&g_t0004,
		&g_t577E,
		
		{
			0x00002020
		},
		0x20,
	};
Eq_n g_t51F2 = // 51F2
	{
		
		{
			0x2A
		},
		&g_w002A,
		0x2A,
		0x05,
		0x00,
		0x05,
		0x04,
		0x5766,
		22372,
	};
Eq_n g_t5206 = // 5206
	{
		
		{
			0x01
		},
		&g_w0005,
		0x04,
		0x04,
		88,
		20966,
		0x04,
		22380,
		22378,
	};
Eq_n g_t526E = // 526E
	{
		0x55,
		0x00,
		&g_w5784,
	};
Eq_n g_t52E2 = // 52E2
	{
		0x78,
		0x00,
		&g_w57AC,
	};
Eq_n g_t530A = // 530A
	{
		0x23,
		0x02,
		&g_w57C0,
	};
Eq_n g_t5330 = // 5330
	{
		0x14,
		0x00,
		&g_w57D4,
	};
Eq_n g_t5344 = // 5344
	{
		0x66,
		0x02,
		&g_w57D8,
	};
Eq_n g_t5354 = // 5354
	{
		0x2E,
		0x01,
		&g_w57E4,
	};
Eq_n g_t5368 = // 5368
	{
		0x70,
		0x00,
		&g_w57E8,
	};
Eq_n g_t537A = // 537A
	{
		0x66,
		0x04,
		&g_w5808,
	};
Eq_n g_t53B0 = // 53B0
	{
		0x60,
		0x02,
		&g_w5864,
	};
Eq_n g_t53C0 = // 53C0
	{
		0x8C,
		0x00,
		&g_w586E,
	};
Eq_n g_t53D8 = // 53D8
	{
		0x8C,
		0x00,
		&g_w5874,
	};
cu16 g_w53E8 = 22644; // 53E8
cup16 g_w53EA = 0x88; // 53EA
cui16 g_w53EC = 0x00; // 53EC
<anonymous> * g_ptr53F0 = &g_t11EC; // 53F0
<anonymous> * g_ptr5414 = &g_t11EC; // 5414
uint16 g_a541C[] = // 541C
	{
	};
struct Eq_n * g_ptr5424 = &g_t542C; // 5424
ci16 * g_ptr5426 = null; // 5426
word16 g_w542C = 0x00; // 542C
Eq_n g_t5464 = // 5464
	{
		0
	};
Eq_n g_t54DC = // 54DC
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		0x00,
		null,
		
		{
			0x00
		},
		0x00,
		null,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		
		{
			0
		},
		0x00,
	};
word16 g_w5506 = 0x00; // 5506
word16 g_w55CC = 0x00; // 55CC
word16 g_w56B2 = 0x00; // 56B2
Eq_n g_t56B6 = // 56B6
	{
		0
	};
struct Eq_n * g_ptr56B8 = null; // 56B8
struct Eq_n * g_ptr56BA = null; // 56BA
ci16 g_w56BC = 0x00; // 56BC
ci16 g_w56BE = 0x00; // 56BE
word16 g_w56C0 = 0x00; // 56C0
Eq_n g_t56C4 = // 56C4
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		0x00,
		null,
		
		{
			0x00
		},
		0x00,
		null,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		
		{
			0
		},
		0x00,
	};
word16 g_w56DE = 0x00; // 56DE
word16 g_w56FE = 0x00; // 56FE
word16 g_w571E = 0x00; // 571E
Eq_n g_t573C = // 573C
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_n g_t574A = // 574A
	{
		null,
	};
word16 g_w575A = 0x00; // 575A
Eq_n g_t5766 = // 5766
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		0x00,
		null,
		
		{
			0x00
		},
		0x00,
		null,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		
		{
			0
		},
		0x00,
	};
Eq_n g_t5768 = // 5768
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_n g_t577E = // 577E
	{
		<code>,
		null,
		null,
		0x00,
		0x00,
		null,
		0x00,
		null,
		
		{
			0x00
		},
		0x00,
		null,
		null,
		null,
		null,
		null,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
		0x00,
		null,
		0x00,
		null,
		null,
		null,
		0x00,
		null,
		null,
		
		{
			0
		},
		0x00,
	};
word16 g_w5784 = 0x00; // 5784
word16 g_w57AC = 0x00; // 57AC
word16 g_w57C0 = 0x00; // 57C0
word16 g_w57D4 = 0x00; // 57D4
word16 g_w57D8 = 0x00; // 57D8
word16 g_w57E4 = 0x00; // 57E4
word16 g_w57E8 = 0x00; // 57E8
word16 g_w5808 = 0x00; // 5808
word16 g_w5864 = 0x00; // 5864
word16 g_w586E = 0x00; // 586E
word16 g_w5874 = 0x00; // 5874
byte g_a5898[] = // 5898
	{
	};
Eq_n g_t58B8 = // 58B8
	{
		
		{
			0x00
		},
		0x00,
		0x00,
	};
Eq_n g_t58BA = // 58BA
	{
		0
	};
Eq_n g_t58C2 = // 58C2
	{
		0x00,
		0x00,
	};
char g_str5A18[] = ""; // 5A18
word16 g_w5A2C = 0x00; // 5A2C
<anonymous> g_t5A3E = <code>; // 5A3E
// 5A90: Register word16 fn5A90()
// Called from:
//      fn2B96
word16 fn5A90()
{
	t0000.w0024 |= 0x5040;
	word16 r0_n;
	TTYIN(out r0_n);
	return r0_n;
}

Eq_n g_t5AA2 = // 5AA2
	{
		
		{
			0x00
		},
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
