// pySample.c
// Generated by decompiling pySample.dll
// using Reko decompiler version 0.8.1.0.

#include "pySample.h"

// 10001000: Register (ptr32 Eq_n) fn10001000(Stack (ptr32 Eq_n) ptrArg04, Stack (ptr32 Eq_n) ptrArg08)
PyObject * fn10001000(PyObject * ptrArg04, PyObject * ptrArg08)
{
	PyObject * eax_n = PyArg_ParseTuple(ptrArg08, "ii:sum", fp - 0x04, fp - 0x08);
	if (eax_n != null)
		return Py_BuildValue("i", dwLoc04 + dwLoc08);
	return eax_n;
}

// 10001050: Register (ptr32 Eq_n) fn10001050(Stack (ptr32 Eq_n) ptrArg04, Stack (ptr32 Eq_n) ptrArg08)
PyObject * fn10001050(PyObject * ptrArg04, PyObject * ptrArg08)
{
	PyObject * eax_n = PyArg_ParseTuple(ptrArg08, "ii:dif", fp - 0x08, fp - 0x04);
	if (eax_n != null)
		return Py_BuildValue("i", dwLoc08 - dwLoc04);
	return eax_n;
}

// 100010A0: Register (ptr32 Eq_n) fn100010A0(Stack (ptr32 Eq_n) ptrArg04, Stack (ptr32 Eq_n) ptrArg08)
PyObject * fn100010A0(PyObject * ptrArg04, PyObject * ptrArg08)
{
	PyObject * eax_n = PyArg_ParseTuple(ptrArg08, "ii:div", fp - 0x08, fp - 0x04);
	if (eax_n != null)
		return Py_BuildValue("i", (int32) ((int64) dwLoc08 / dwLoc04));
	return eax_n;
}

// 100010F0: Register (ptr32 Eq_n) fn100010F0(Stack (ptr32 Eq_n) ptrArg04, Stack (ptr32 Eq_n) ptrArg08)
PyObject * fn100010F0(PyObject * ptrArg04, PyObject * ptrArg08)
{
	PyObject * eax_n = PyArg_ParseTuple(ptrArg08, "ff:fdiv", fp - 0x08, fp - 0x04);
	if (eax_n != null)
		return Py_BuildValue("f", (real64) rLoc08 / rLoc04);
	return eax_n;
}

// 10001140: Register (ptr32 Eq_n) py_unused(Stack (ptr32 Eq_n) self, Stack (ptr32 Eq_n) args)
PyObject * py_unused(PyObject * self, PyObject * args)
{
	PyObject * eax_n = PyArg_ParseTuple(args, ":unused");
	if (eax_n == null)
		return eax_n;
	PyObject * eax_n = &_Py_NoneStruct;
	++eax_n->ob_refcnt;
	return &_Py_NoneStruct;
}

// 10001170: void initpySample()
void initpySample()
{
	Py_InitModule4("pySample", globals->methods, null, null, 1007);
}

// 100011E9: Register word32 fn100011E9(Stack word32 dwArg08)
word32 fn100011E9(word32 dwArg08)
{
	word32 eax_n;
	Eq_n ebp_n = 0x00;
	if (dwArg08 == 0x00)
	{
		if (globals->dw10003070 <= 0x00)
		{
			eax_n = 0x00;
			return eax_n;
		}
		--globals->dw10003070;
	}
	globals->dw100033A4 = *adjust_fdiv;
	if (dwArg08 == 0x01)
	{
		Eq_n edi_n = fs->ptr0018->t0004;
		while (true)
		{
			Eq_n eax_n = InterlockedCompareExchange(&globals->t100033AC, edi_n, 0x00);
			if (eax_n == 0x00)
				break;
			if (eax_n == edi_n)
			{
				ebp_n = 0x01;
				break;
			}
			Sleep(1000);
		}
		if (globals->dw100033A8 != 0x00)
			_amsg_exit(0x1F);
		globals->dw100033A8 = 0x01;
		if (_initterm_e(&globals->t100020A0, &globals->t100020A8) != 0x00)
		{
			eax_n = 0x00;
			return eax_n;
		}
		_initterm(&globals->t10002098, &globals->t1000209C);
		globals->dw100033A8 = 0x02;
		if (ebp_n == 0x00)
			InterlockedExchange(&globals->t100033AC, ebp_n);
		if (globals->ptr100033B8 != null)
		{
			word32 edi_n;
			word32 eax_n = fn10001742(InterlockedCompareExchange, 268448684, 0x02, out edi_n);
			if (eax_n != 0x00)
			{
				*(fp - 0x14) = fp->dw000C;
				*(fp - 0x18) = edi_n;
				*(fp - 0x1C) = fp->dw0004;
				word32 esp_n;
				word32 eax_n;
				word32 ebp_n;
				byte SZO_n;
				bool C_n;
				byte SCZO_n;
				bool Z_n;
				word32 ecx_n;
				word32 ebx_n;
				word32 esi_n;
				word32 edi_n;
				struct Eq_n * fs_n;
				globals->ptr100033B8();
			}
		}
		++globals->dw10003070;
	}
	else if (dwArg08 == 0x00)
	{
		while (InterlockedCompareExchange(&globals->t100033AC, 0x01, 0x00) != 0x00)
			Sleep(1000);
		if (globals->dw100033A8 != 0x02)
			_amsg_exit(0x1F);
		word32 * eax_n = _decode_pointer(globals->ptr100033B4);
		word32 * ebx_n = eax_n;
		ptr32 esp_n = fp - 0x10;
		if (eax_n != null)
		{
			ptr32 esp_n = fp - 0x10;
			word32 * edi_n = _decode_pointer(globals->ptr100033B0);
			while (true)
			{
				edi_n -= 0x04;
				if (edi_n < ebx_n)
					break;
				<anonymous> * eax_n = *edi_n;
				if (eax_n != null)
				{
					word32 eax_n;
					word32 ebp_n;
					byte SZO_n;
					bool C_n;
					byte SCZO_n;
					bool Z_n;
					word32 ecx_n;
					word32 esi_n;
					struct Eq_n * fs_n;
					eax_n();
				}
			}
			word32 ** esp_n = esp_n - 0x04;
			*esp_n = ebx_n;
			free(*esp_n);
			void * eax_n = _encoded_null();
			globals->ptr100033B0 = eax_n;
			globals->ptr100033B4 = eax_n;
			esp_n = (char *) esp_n + 0x04;
		}
		LONG * esp_n = esp_n - 0x04;
		*esp_n = (int32) 0x00;
		*(esp_n - 0x04) = 268448684;
		globals->dw100033A8 = 0x00;
		InterlockedExchange(*(esp_n - 0x04), *esp_n);
	}
	eax_n = 0x01;
	return eax_n;
}

// 10001388: Register word32 fn10001388(Register Eq_n ecx, Register Eq_n edx, Register (ptr32 Eq_n) ebx, Register ptr32 esi, Register word32 edi)
word32 fn10001388(LPVOID ecx, DWORD edx,  * ebx, ptr32 esi, word32 edi)
{
	struct Eq_n * ebp_n = fn100017E8(ebx, esi, edi, dwLoc0C, 0x100021E8, 0x10);
	Eq_n ebx_n = ebp_n->t0008;
	*(ebp_n - 0x1C) = 0x01;
	*(ebp_n - 0x04) = 0x00;
	globals->t10003008 = edx;
	*(ebp_n - 0x04) = 0x01;
	ptr32 esp_n = fp - 0x08;
	Eq_n edi_n = ecx;
	Eq_n esi_n = edx;
	if (edx == 0x00 && globals->dw10003070 == 0x00)
	{
		*(ebp_n - 0x1C) = 0x00;
		goto l1000147A;
	}
	if (edx == 0x01 || edx == 0x02)
	{
		word32 eax_n = globals->dw100020CC;
		if (eax_n != 0x00)
		{
			word32 ecx_n;
			word32 edx_n;
			word32 eax_n;
			byte SZO_n;
			bool C_n;
			byte SCZO_n;
			bool Z_n;
			fn00000000();
			*(ebp_n - 0x1C) = eax_n;
		}
		if (*(ebp_n - 0x1C) == 0x00)
		{
l1000147A:
			*(ebp_n - 0x04) &= 0x00;
			*(ebp_n - 0x04) = ~0x01;
			fn10001493();
			word32 eax_n = *(ebp_n - 0x1C);
			fn1000182D(ebp_n, 0x10, dwArg00, dwArg04, dwArg08, dwArg0C);
			return eax_n;
		}
		LPVOID * esp_n = esp_n - 0x04;
		*esp_n = (LPVOID *) edi_n;
		*(esp_n - 0x04) = (uint32) esi_n;
		*(esp_n - 0x08) = (_onexit_t *) ebx_n;
		ui32 eax_n = fn100011E9(dwArg04);
		*(ebp_n - 0x1C) = eax_n;
		esp_n = (char *) esp_n + 0x04;
		if (eax_n == 0x00)
			goto l1000147A;
	}
	LPVOID * esp_n = esp_n - 0x04;
	*esp_n = (LPVOID *) edi_n;
	*(esp_n - 0x04) = (uint32) esi_n;
	*(esp_n - 0x08) = (_onexit_t *) ebx_n;
	word32 eax_n = fn100017C6(dwArg00, dwArg04);
	*(ebp_n - 0x1C) = eax_n;
	ptr32 esp_n = (char *) esp_n + 0x04;
	if (esi_n == 0x01 && eax_n == 0x00)
	{
		*esp_n = (LPVOID *) edi_n;
		*(esp_n - 0x04) = eax_n;
		*(esp_n - 0x08) = (_onexit_t *) ebx_n;
		fn100017C6(dwArg00, dwArg04);
		*esp_n = (LPVOID *) edi_n;
		*(esp_n - 0x04) = 0x00;
		*(esp_n - 0x08) = (_onexit_t *) ebx_n;
		fn100011E9(dwArg04);
		esp_n = (char *) esp_n + 0x04;
		word32 eax_n = globals->dw100020CC;
		if (eax_n != 0x00)
		{
			*esp_n = (LPVOID *) edi_n;
			*(esp_n - 0x04) = 0x00;
			*(esp_n - 0x08) = (_onexit_t *) ebx_n;
			word32 ecx_n;
			word32 edx_n;
			word32 eax_n;
			byte SZO_n;
			bool C_n;
			byte SCZO_n;
			bool Z_n;
			fn00000000();
		}
	}
	if (esi_n == 0x00 || esi_n == 0x03)
	{
		LPVOID * esp_n = esp_n - 0x04;
		*esp_n = (LPVOID *) edi_n;
		*(esp_n - 0x04) = (uint32) esi_n;
		*(esp_n - 0x08) = (_onexit_t *) ebx_n;
		ui32 eax_n = fn100011E9(dwArg04);
		if (eax_n == 0x00)
			*(ebp_n - 0x1C) &= eax_n;
		if (*(ebp_n - 0x1C) != 0x00)
		{
			word32 eax_n = globals->dw100020CC;
			if (eax_n != 0x00)
			{
				*esp_n = (LPVOID *) edi_n;
				*(esp_n - 0x04) = (uint32) esi_n;
				*(esp_n - 0x08) = (_onexit_t *) ebx_n;
				word32 esp_n;
				word32 edi_n;
				word32 ecx_n;
				word32 esi_n;
				word32 edx_n;
				word32 ebx_n;
				word32 eax_n;
				byte SZO_n;
				bool C_n;
				byte SCZO_n;
				bool Z_n;
				fn00000000();
				*(ebp_n - 0x1C) = eax_n;
			}
		}
	}
	goto l1000147A;
}

// 10001493: void fn10001493()
void fn10001493()
{
	globals->t10003008 = ~0x00;
}

// 1000149E: Register Eq_n DllMain(Stack Eq_n hModule, Stack Eq_n dwReason, Stack Eq_n lpReserved)
BOOL DllMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == 0x01)
		fn10001864();
	return fn10001388(lpReserved, dwReason, ebx, esi, edi);
}

// 100015CF: Register Eq_n fn100015CF(Register (ptr32 Eq_n) ebx, Register ptr32 esi, Register word32 edi)
_onexit_t fn100015CF( * ebx, ptr32 esi, word32 edi)
{
	Eq_n eax_n;
	struct Eq_n * ebp_n = fn100017E8(ebx, esi, edi, dwLoc0C, 0x10002210, 0x14);
	word32 * eax_n = _decode_pointer(globals->ptr100033B4);
	*(ebp_n - 0x1C) = eax_n;
	if (eax_n == (word32 *) ~0x00)
		eax_n = _onexit(ebp_n->t0008);
	else
	{
		word32 esp_n;
		word32 esi_n;
		word32 eax_n;
		word32 ecx_n;
		struct Eq_n * ebp_n;
		byte SCZO_n;
		bool Z_n;
		byte SZO_n;
		bool C_n;
		word32 ebx_n;
		word32 edi_n;
		lock();
		*(ebp_n - 0x04) &= 0x00;
		*(ebp_n - 0x1C) = _decode_pointer(globals->ptr100033B4);
		*(ebp_n - 0x20) = _decode_pointer(globals->ptr100033B0);
		Eq_n eax_n = __dllonexit(ebp_n->t0008, ebp_n - 0x1C, ebp_n - 0x20);
		*(ebp_n - 0x24) = (_onexit_t *) eax_n;
		word32 esp_n;
		word32 esi_n;
		void * eax_n;
		word32 ecx_n;
		word32 ebp_n;
		byte SCZO_n;
		bool Z_n;
		byte SZO_n;
		bool C_n;
		word32 ebx_n;
		word32 edi_n;
		encode_pointer();
		globals->ptr100033B4 = eax_n;
		word32 esp_n;
		word32 esi_n;
		void * eax_n;
		word32 ecx_n;
		byte SCZO_n;
		bool Z_n;
		byte SZO_n;
		bool C_n;
		word32 ebx_n;
		word32 edi_n;
		encode_pointer();
		globals->ptr100033B0 = eax_n;
		*(ebp_n - 0x04) = ~0x01;
		fn10001665();
		eax_n = (Eq_n) *(ebp_n - 0x24);
	}
	fn1000182D(ebp_n, 0x14, dwArg00, dwArg04, dwArg08, dwArg0C);
	return eax_n;
}

// 10001665: void fn10001665()
void fn10001665()
{
	word32 esp_n;
	word32 ecx_n;
	unlock();
}

// 1000166E: void fn1000166E(Register (ptr32 Eq_n) ebx, Register ptr32 esi, Register word32 edi, Stack word32 dwArg04)
void fn1000166E( * ebx, ptr32 esi, word32 edi, word32 dwArg04)
{
	fn100015CF(ebx, esi, edi);
}

// 10001680: void fn10001680()
void fn10001680()
{
	word32 * esi_n = &globals->dw100021D8;
	if (false)
	{
		do
		{
			word32 eax_n = *esi_n;
			if (eax_n != 0x00)
			{
				word32 esp_n;
				word32 edi_n;
				word32 eax_n;
				byte SCZO_n;
				bool C_n;
				byte SZO_n;
				bool Z_n;
				fn00000000();
			}
			++esi_n;
		} while (esi_n < &globals->dw100021D8);
	}
}

// 100016D0: Register word32 fn100016D0(Stack (ptr32 Eq_n) dwArg04)
word32 fn100016D0(Eq_n * dwArg04)
{
	if (dwArg04->w0000 != 23117)
		return 0x00;
	struct Eq_n * eax_n = dwArg04 + dwArg04->dw003C / 0x0040;
	if (eax_n->dw0000 != 0x4550)
		return 0x00;
	return (word32) (eax_n->w0018 == 0x010B);
}

// 10001700: Register (ptr32 Eq_n) fn10001700(Stack (ptr32 Eq_n) dwArg04, Stack uint32 dwArg08)
Eq_n * fn10001700(Eq_n * dwArg04, uint32 dwArg08)
{
	struct Eq_n * ecx_n = dwArg04 + dwArg04->dw003C / 0x0040;
	up32 esi_n = (word32) ecx_n->w0006;
	up32 edx_n = 0x00;
	struct Eq_n * eax_n = ecx_n + ((word32) ecx_n->w0014 + 0x18) / 22;
	if (!DPB(CZ, false, 0))
	{
		do
		{
			uint32 ecx_n = eax_n->dw000C;
			if (dwArg08 >= ecx_n && dwArg08 < eax_n->dw0008 + ecx_n)
				return eax_n;
			++edx_n;
			++eax_n;
		} while (edx_n < esi_n);
	}
	eax_n = null;
	return eax_n;
}

// 10001742: Register ui32 fn10001742(Register (ptr32 Eq_n) ebx, Register ptr32 esi, Register word32 edi, Register out ptr32 ediOut)
ui32 fn10001742( * ebx, ptr32 esi, word32 edi, ptr32 & ediOut)
{
	ui32 eax_n;
	struct Eq_n * ebp_n = fn100017E8(ebx, esi, edi, dwLoc0C, 0x10002230, 0x08);
	*(ebp_n - 0x04) &= 0x00;
	Eq_n dwLoc0C_n = 0x10000000;
	if (fn100016D0(&globals->t10000000) != 0x00)
	{
		Eq_n eax_n = ebp_n->t0008;
		dwLoc0C_n = eax_n - 0x10000000;
		struct Eq_n * eax_n = fn10001700(&globals->t10000000, eax_n - 0x10000000);
		if (eax_n != null)
		{
			eax_n = ~(eax_n->dw0024 >> 0x1F) & 0x01;
			*(ebp_n - 0x04) = ~0x01;
l100017A8:
			word32 edi_n;
			*ediOut = fn1000182D(ebp_n, dwLoc0C_n, &globals->t10002230, 0x08, dwArg00, dwArg04);
			return eax_n;
		}
	}
	*(ebp_n - 0x04) = ~0x01;
	eax_n = 0x00;
	goto l100017A8;
}

// 100017C6: Register word32 fn100017C6(Stack Eq_n dwArg04, Stack word32 dwArg08)
word32 fn100017C6(HMODULE dwArg04, word32 dwArg08)
{
	if (dwArg08 == 0x01 && globals->dw100020CC == 0x00)
		DisableThreadLibraryCalls(dwArg04);
	return 0x01;
}

// 100017E8: Register ptr32 fn100017E8(Register (ptr32 Eq_n) ebx, Register ptr32 esi, Register word32 edi, Stack word32 dwArg00, Stack word32 dwArg04, Stack ui32 dwArg08)
ptr32 fn100017E8( * ebx, ptr32 esi, word32 edi, word32 dwArg00, word32 dwArg04, ui32 dwArg08)
{
	ptr32 esp_n = fp - 0x08 - dwArg08;
	*(esp_n - 0x04) = (Eq_n (**)(LONG *, Eq_n, Eq_n)) ebx;
	*(esp_n - 0x08) = esi;
	*(esp_n - 0x0C) = edi;
	*(esp_n - 0x0010) = globals->dw10003000 ^ fp + 0x08;
	*(esp_n - 0x0014) = dwArg00;
	fs->ptr0000 = fp - 0x08;
	return fp + 0x08;
}

// 1000182D: Register word32 fn1000182D(Register (ptr32 Eq_n) ebp, Stack Eq_n dwArg00, Stack Eq_n dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
word32 fn1000182D(Eq_n * ebp, Eq_n dwArg00, HMODULE dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	fs->dw0000 = *(ebp - 0x10);
	ebp->t0000 = dwArg00;
	return dwArg08;
}

// 10001864: void fn10001864()
void fn10001864()
{
	ui32 eax_n = globals->dw10003000;
	if (eax_n != 0xBB40E64E && (eax_n & 0xFFFF0000) != 0x00)
		globals->dw10003004 = ~eax_n;
	else
	{
		GetSystemTimeAsFileTime(fp - 0x0C);
		ui32 esi_n = dwLoc08 & 0x00 ^ dwLoc0C & 0x00 ^ GetCurrentProcessId() ^ GetCurrentThreadId() ^ GetTickCount();
		QueryPerformanceCounter(fp - 0x14);
		ui32 esi_n = esi_n ^ (dwLoc10 ^ dwLoc14);
		if (esi_n == 0xBB40E64E)
			esi_n = ~0x44BF19B0;
		else if ((esi_n & 0xFFFF0000) == 0x00)
			esi_n |= esi_n << 0x10;
		globals->dw10003000 = esi_n;
		globals->dw10003004 = ~esi_n;
	}
}

