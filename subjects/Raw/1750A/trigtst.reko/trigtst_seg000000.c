// trigtst_seg000000.c
// Generated by decompiling trigtst.ldm
// using Reko decompiler version 0.12.0.0.

#include "trigtst.h"

struct Eq_n g_t0007 = // 0007
	{
		&g_t0316,
	};
// 0100: void fn0100()
void fn0100()
{
	__mov(&g_uFFFF8000, &g_t04C2);
	__mov(&g_uFFFF80E9, (char *) &g_r05B4 + 3);
	fn0111();
	while (true)
		;
}

// 0111: void fn0111()
// Called from:
//      fn0100
void fn0111()
{
	fn04B9(&g_uFFFF8000);
	real48 gp0_gp1_gp2_n = g_rFFFF80CE;
	word16 gp2_n;
	fn04AE(fn01E6((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF800D);
	real48 gp0_gp1_gp2_n = (real48) *((char *) &g_rFFFF80CE + 3);
	word16 gp2_n;
	fn04AE(fn01E6((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF801A);
	real48 gp0_gp1_gp2_n = g_rFFFF80D4;
	word16 gp2_n;
	fn04AE(fn01E6((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF8027);
	real48 gp0_gp1_gp2_n = (real48) *((char *) &g_rFFFF80D4 + 3);
	word16 gp2_n;
	fn04AE(fn01E6((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF8036);
	real48 gp0_gp1_gp2_n = g_rFFFF80DA;
	word16 gp2_n;
	fn04AE(fn032A((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF8042);
	real48 gp0_gp1_gp2_n = (real48) *((char *) &g_rFFFF80DA + 3);
	word16 gp2_n;
	fn04AE(fn032A((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF804F);
	real48 gp0_gp1_gp2_n = g_rFFFF80E0;
	word16 gp2_n;
	fn04AE(fn032A((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF805C);
	real48 gp0_gp1_gp2_n = (real48) *((char *) &g_rFFFF80E0 + 3);
	word16 gp2_n;
	fn04AE(fn032A((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF806B);
	real48 gp0_gp1_gp2_n = g_rFFFF80E6;
	word16 gp2_n;
	fn04AE(fn032A((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF8076);
	real48 gp0_gp1_gp2_n = g_rFFFF80CE;
	word16 gp2_n;
	fn04AE(fn032A((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF8082);
	real48 gp0_gp1_gp2_n = g_rFFFF80DA;
	word16 gp2_n;
	fn04AE(fn034E((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF808E);
	real48 gp0_gp1_gp2_n = (real48) *((char *) &g_rFFFF80DA + 3);
	word16 gp2_n;
	fn04AE(fn034E((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF809B);
	real48 gp0_gp1_gp2_n = g_rFFFF80E0;
	word16 gp2_n;
	fn04AE(fn034E((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF80A8);
	real48 gp0_gp1_gp2_n = (real48) *((char *) &g_rFFFF80E0 + 3);
	word16 gp2_n;
	fn04AE(fn034E((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF80B7);
	real48 gp0_gp1_gp2_n = g_rFFFF80E6;
	word16 gp2_n;
	fn04AE(fn034E((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
	fn04B9(&g_tFFFF80C2);
	real48 gp0_gp1_gp2_n = g_rFFFF80CE;
	word16 gp2_n;
	fn04AE(fn034E((word32) gp0_gp1_gp2_n, (word16) gp0_gp1_gp2_n, out gp2_n), gp2_n);
	fn045A(0x0A);
}

// 01E6: Sequence word32 fn01E6(Sequence word32 gp0_gp1, Register word16 gp2, Register out word16 gp2Out)
// Called from:
//      fn0111
word32 fn01E6(word32 gp0_gp1, word16 gp2, word16 & gp2Out)
{
	word16 gp0 = SLICE(gp0_gp1, word16, 16);
	int16 gp1 = (word16) gp0_gp1;
	real48 gp0_gp1_gp2_n = SEQ(gp0_gp1, gp2);
	if (gp0_gp1_gp2_n != g_r05AB)
	{
		if (gp0_gp1_gp2_n < g_r05AB)
			__bpt();
		Eq_n gp6_n = __xbr(gp1);
		real48 gp0_gp1_gp2_n = SEQ(gp0, gp1 & 0xFF00, gp2) * g_r05AE + g_r05B1;
		real48 gp0_gp1_gp2_n = gp0_gp1_gp2_n + SEQ(gp0, gp1 & 0xFF00, gp2) / gp0_gp1_gp2_n;
		real48 gp0_gp1_gp2_n = SEQ(SLICE(gp0_gp1_gp2_n, word16, 32), SLICE(gp0_gp1_gp2_n, word16, 16) & 0xFF00 | 0xFE, 0xFE) + SEQ(gp0, gp1 & 0xFF00, gp2) / gp0_gp1_gp2_n;
		real48 gp0_gp1_gp2_n = gp0_gp1_gp2_n + SEQ(gp0, gp1 & 0xFF00, gp2) / gp0_gp1_gp2_n;
		Eq_n gp6_n = gp6_n >> 0x08;
		word16 gp0_n = SLICE(gp0_gp1_gp2_n, word16, 32);
		word16 gp2_n = (word16) gp0_gp1_gp2_n;
		int16 gp1_n = SLICE(gp0_gp1_gp2_n, word16, 16) & 0xFF00 | 0xFF;
		if ((gp6_n >> 0x08 & 0x8000) != 0x00)
		{
			real48 gp0_gp1_gp2_n = SEQ(gp0_n, gp1_n, gp2_n) * g_r05B4;
			gp1_n = SLICE(gp0_gp1_gp2_n, word16, 16);
			gp0_n = SLICE(gp0_gp1_gp2_n, word16, 32);
			gp2_n = (word16) gp0_gp1_gp2_n;
			gp6_n = (gp6_n >> 0x08) + 0x01;
		}
		cui16 gp1_n = gp1_n & 0xFF00 | (__xbr(gp1_n) >> 0x08) + gp6_n /16 0x02 & 0xFF;
		gp2Out = gp2_n;
		return SEQ(gp0_n, gp1_n);
	}
	else
	{
		gp2Out = gp2;
		return gp0_gp1;
	}
}

// 02BF: Register word16 fn02BF(Register (ptr16 Eq_n) gp1, Register word16 gp4, Register out word16 gp1Out, Register out word16 gp2Out, Register out ptr16 gp14Out)
// Called from:
//      fn032A
//      fn034E
word16 fn02BF(struct Eq_n * gp1, word16 gp4, word16 & gp1Out, word16 & gp2Out, ptr16 & gp14Out)
{
	struct Eq_n * gp2_n = gp1;
	if (gp1 < null)
		gp2_n = gp1 + &g_t0007;
	struct Eq_n * gp2_n = gp2_n & ~0x07;
	if ((uint32) (gp1 - gp2_n) > 0x07)
	{
		real48 gp3_gp4_gp5_n = g_rFFFF811F;
		gp1Out = (word16) gp3_gp4_gp5_n;
		gp2Out = (word16) gp3_gp4_gp5_n;
		ptr16 fp;
		gp14Out = fp;
		return SLICE(gp3_gp4_gp5_n, word16, 16);
	}
	else
	{
		<anonymous> * gp2_n = (<anonymous> *) gp2_n->ptr02DA;
		gp2_n();
		word16 gp1_n;
		gp1Out = gp1_n;
		word16 gp2_n;
		gp2Out = gp2_n;
		ptr16 gp14_n;
		gp14Out = gp14_n;
		word16 gp0_n;
		return gp0_n;
	}
}

<anonymous> g_t0316 = <code>; // 0316
// 032A: Sequence int32 fn032A(Sequence int32 gp0_gp1, Register word16 gp2, Register out word16 gp2Out)
// Called from:
//      fn0111
int32 fn032A(int32 gp0_gp1, word16 gp2, word16 & gp2Out)
{
	word16 gp14_n;
	word16 gp2_n;
	word16 gp1_n;
	real48 gp5_gp6_gp7_n = SEQ(gp0_gp1, gp2);
	if (gp0_gp1 < 0x00)
	{
		real48 gp2_gp3_gp4_n = (real48) *((char *) &g_rFFFF811F + 3);
		gp5_gp6_gp7_n = SEQ((word32) gp2_gp3_gp4_n, (word16) gp2_gp3_gp4_n) - SEQ(gp0_gp1, gp2);
	}
	real48 gp5_gp6_gp7_n = gp5_gp6_gp7_n * g_rFFFF8125;
	int32 gp0_gp1_n = (int32) gp5_gp6_gp7_n;
	real48 gp5_gp6_gp7_n = gp5_gp6_gp7_n - (real48) gp0_gp1_n;
	word16 gp7_n = (word16) gp5_gp6_gp7_n;
	word16 gp4_n = gp7_n;
	int32 gp0_gp1_n = SEQ(SLICE(gp0_gp1_n, word16, 16), (word16) gp5_gp6_gp7_n);
	if (gp5_gp6_gp7_n < 0.0)
	{
		gp4_n = (word16) (SEQ((word32) gp5_gp6_gp7_n, gp7_n) + *((char *) (&g_rFFFF8125) + 3));
		gp0_gp1_n = gp0_gp1_n + g_dwFFFF812B;
	}
	struct Eq_n * gp1_n = (word16) gp0_gp1_n;
	if (gp0_gp1 < 0x00)
		gp1_n = (struct Eq_n *) ((char *) &(*((char *) &g_dwFFFF812B + 2))->dwFFFF812B + ((word16) gp0_gp1_n + 0x00007ED5));
	word16 gp0_n = fn02BF(gp1_n, gp4_n, out gp1_n, out gp2_n, out gp14_n);
	gp2Out = gp2_n;
	return SEQ(gp0_n, gp1_n);
}

// 034E: Sequence int32 fn034E(Sequence int32 gp0_gp1, Register word16 gp2, Register out word16 gp2Out)
// Called from:
//      fn0111
int32 fn034E(int32 gp0_gp1, word16 gp2, word16 & gp2Out)
{
	word16 gp14_n;
	word16 gp2_n;
	word16 gp1_n;
	real48 gp5_gp6_gp7_n = SEQ(gp0_gp1, gp2);
	if (gp0_gp1 < 0x00)
	{
		real48 gp2_gp3_gp4_n = g_rFFFF812F - SEQ(gp0_gp1, gp2);
		gp5_gp6_gp7_n = SEQ((word32) gp2_gp3_gp4_n, (word16) gp2_gp3_gp4_n);
	}
	real48 gp5_gp6_gp7_n = gp5_gp6_gp7_n * g_rFFFF8132;
	int32 gp0_gp1_n = (int32) gp5_gp6_gp7_n;
	real48 gp5_gp6_gp7_n = gp5_gp6_gp7_n - (real48) gp0_gp1_n;
	word16 gp7_n = (word16) gp5_gp6_gp7_n;
	word16 gp4_n = gp7_n;
	int32 gp0_gp1_n = SEQ(SLICE(gp0_gp1_n, word16, 16), (word16) gp5_gp6_gp7_n);
	if (gp5_gp6_gp7_n < 0.0)
	{
		gp4_n = (word16) (SEQ((word32) gp5_gp6_gp7_n, gp7_n) + *((char *) (&g_rFFFF8132) + 3));
		gp0_gp1_n = gp0_gp1_n + g_dwFFFF8138;
	}
	word16 gp0_n = fn02BF((word16) gp0_gp1_n + g_wFFFF813A, gp4_n, out gp1_n, out gp2_n, out gp14_n);
	gp2Out = gp2_n;
	return SEQ(gp0_n, gp1_n);
}

// 03E0: Register (ptr16 Eq_n) fn03E0(Sequence word32 gp1_gp2, Register (ptr16 Eq_n) gp0, Register word16 gp3, Register out word16 gp14Out)
// Called from:
//      fn04AE
union Eq_n * fn03E0(word32 gp1_gp2, union Eq_n * gp0, word16 gp3, word16 & gp14Out)
{
	union Eq_n * gp1 = SLICE(gp1_gp2, word16, 16);
	(&gp0->u1)[0x0A] = (struct Eq_n) 0x00;
	gp14Out = fn03EC(SEQ(gp1_gp2, gp3), 0x00, 11, gp0);
	return gp1;
}

// 03EC: Register cui16 fn03EC(Sequence Eq_n gp12_gp13_gp14, Register cui16 gp0, Register word16 gp1, Register (ptr16 Eq_n) gp11)
// Called from:
//      fn03E0
cui16 fn03EC(Eq_n gp12_gp13_gp14, cui16 gp0, word16 gp1, union Eq_n * gp11)
{
	cui16 gp12 = SLICE(gp12_gp13_gp14, word16, 32);
	cui16 gp13 = SLICE(gp12_gp13_gp14, word16, 16);
	cui16 gp14 = (word16) gp12_gp13_gp14;
	word16 gp0_n;
	if ((gp12 & 0x01) != 0x00)
	{
		if ((gp12 & 0x02) != 0x00)
		{
			gp0_n = 0x2D20;
			gp12_gp13_gp14 *= g_r0610;
			goto l00000406;
		}
	}
	else if ((gp0 | gp12 | gp13 | gp14) == 0x00 || (gp12 & 0x02) != 0x00)
	{
		gp0_n = 0x2B20;
l00000406:
		gp11->u0 = gp0_n;
		int16 gp2_n = 0x00;
		Eq_n gp12_gp13_n = gp12_gp13_gp14;
		gp12_gp13_n = gp12_gp13_gp14;
		word16 gp14_n;
		word16 gp0_n;
		if ((SLICE(gp12_gp13_gp14, word16, 16) & 0x0100) != 0x00)
		{
			while (true)
			{
				gp14_n = (word16) gp12_gp13_n;
				if (gp12_gp13_n < g_t060A.u1)
					break;
				gp12_gp13_n /= g_t060A.u1;
				++gp2_n;
			}
			gp0_n = 17707;
		}
		else
		{
			while (true)
			{
				gp14_n = (word16) gp12_gp13_n;
				if (gp12_gp13_n >= g_t060D.u1)
					break;
				gp12_gp13_n *= g_t060A.u1;
				++gp2_n;
			}
			gp0_n = 17709;
		}
		if (gp1 != 0x06)
			(&gp11->u1)[8] = (struct Eq_n) gp0_n;
		else
			(&gp11->u1)[5] = (struct Eq_n) gp0_n;
		int16 gp2_n = gp2_n / 0x0A;
		cui16 gp2_n = __xbr(gp2_n) | gp2_n % 0x0A;
		if (gp1 != 0x06)
			(&gp11->u1)[9] = (struct Eq_n) (gp2_n | 0x3030);
		else
			(&gp11->u1)[6] = (struct Eq_n) (gp2_n | 0x3030);
		gp11->u0 = SEQ(SLICE(gp11->u0, byte, 8), (byte) gp14_n + 0x30);
		(&gp11->u1)[1] = (struct Eq_n) SEQ(0x2E, (byte) (&gp11->u1)[1]);
		cui16 gp7_n = 0x00;
		real48 gp12_gp13_gp14_n = SEQ(gp12_gp13_n, gp14_n) - (real48) ((int32) SEQ(gp12_gp13_n, gp14_n));
		do
		{
			real48 gp12_gp13_gp14_n = gp12_gp13_gp14_n * g_t060A.u1;
			word16 gp14_n = (word16) gp12_gp13_gp14_n;
			gp12_gp13_gp14_n = gp12_gp13_gp14_n - (real48) ((int32) SEQ((word32) gp12_gp13_gp14_n, gp14_n));
			gp14 = (word16) gp12_gp13_gp14_n;
			++gp7_n;
			if ((gp7_n & 0x8000) != 0x00)
				(&gp11->u1)[1] = (struct Eq_n) SEQ((byte) gp14_n + 0x30, (byte) (&gp11->u1)[1]);
			else
			{
				(&gp11->u1)[1] = (struct Eq_n) SEQ(SLICE((&gp11->u1)[1], byte, 8), (byte) gp14_n + 0x30);
				gp11 = &gp11->u1 + 1;
			}
			--gp1;
		} while (gp1 != 0x00);
		(&gp11->u1)[1] = (struct Eq_n) 0x2020;
		return gp14;
	}
	__mov(gp11, (char *) &g_r0610 + 3);
	return gp14;
}

// 045A: void fn045A(Register word16 gp0)
// Called from:
//      fn0111
//      fn045D
//      fn04B9
void fn045A(word16 gp0)
{
	__console_output(gp0);
}

// 045D: void fn045D(Register (ptr16 Eq_n) gp0)
// Called from:
//      fn04AE
void fn045D(struct Eq_n * gp0)
{
	struct Eq_n * gp11_n = gp0;
	word16 gp0_n = 0x00;
	while (true)
	{
		word16 gp0_n = SEQ((byte) gp11_n->w0000, (byte) gp0_n);
		if (gp0_n == 0x00)
			break;
		fn045A(gp0_n);
		gp0_n = SEQ((byte) gp11_n->w0000, (byte) gp11_n->w0000);
		if (gp0_n == 0x00)
			return;
		fn045A(gp0_n);
		++gp11_n;
	}
}

// 04AE: Register word16 fn04AE(Sequence word32 gp0_gp1, Register word16 gp2)
// Called from:
//      fn0111
word16 fn04AE(word32 gp0_gp1, word16 gp2)
{
	word16 gp14_n;
	fn045D(fn03E0(gp0_gp1, &g_uFFFF813C, gp2, out gp14_n));
	return gp14_n;
}

// 04B9: void fn04B9(Register (ptr16 Eq_n) gp0)
// Called from:
//      fn0111
void fn04B9(struct Eq_n * gp0)
{
	struct Eq_n * gp1_n = gp0;
	while (true)
	{
		word16 gp0_n = gp1_n->w0000;
		if (gp0_n == 0x00)
			break;
		fn045A(gp0_n);
		++gp1_n;
	}
}

<unknown> g_t04C2 = // 04C2;
real48 g_r05AB = 0.0; // 05AB
real48 g_r05AE = 0.590159880790452; // 05AE
real48 g_r05B1 = 0.4173099999998158; // 05B1
real48 g_r05B4 = 0.7071066619791964; // 05B4
Eq_n g_t060A = // 060A
	{
		10.0F
	};
Eq_n g_t060D = // 060D
	{
		1.0F
	};
real48 g_r0610 = -1.0; // 0610
